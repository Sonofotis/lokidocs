{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Loki Network \u00b6 Quick Navigation \u00b6 About Wallets Private Messenger Service Nodes Lokinet About Loki Which wallet should you use? Session Service Nodes Lokinet See more information on the different aspects of the Loki Network. Learn more about which wallet best suits you and see the guides to help you set one up. Learn more about Session ), our Private messenger. Learn more about Loki Service Nodes and see step by step guides to help you set one up. Learn more about the Lokinet and follow step by step guides to gain access. Information is Important \u00b6 Privacy is having the agency to decide when you reveal personal information. It is a particularly valuable quality today, when the collection and storage of personal data is taking place at unprecedented levels in history. Loki provides the means to transact and communicate privately and anonymously, using the decentralised nature of blockchain technology to create new methods of interacting with the internet. Loki is a privacy cryptocurrency based on Monero. Loki currently offers an incentivised full node layer, instant private transactions, and secure private communications. More information on the project can be found on the website and in the whitepaper . Loki is an open source project, and we encourage contributions from anyone with something to offer. For more information on contributing, please contact team@loki.network If you are unsure where to start check out our \"Getting Started\" page by clicking here Otherwise to begin browsing Loki Docs click here . Community Channels \u00b6 Telegram: t.me/LokiCommunity GitHub: https://github.com/loki-project/loki Discord: https://discord.gg/67GXfD6 Twitter: https://twitter.com/loki_project Youtube: https://www.youtube.com/lokinetwork Reddit: https://www.reddit.com/r/LokiProject/ Mail: team@loki.network Copyright \u00b6 Copyright (c) 2018 The Loki Project. Portions Copyright (c) 2014-2018 The Monero Project. Portions Copyright (c) 2012-2013 The Cryptonote developers.","title":"Home"},{"location":"#loki-network","text":"","title":"Loki Network"},{"location":"#quick-navigation","text":"About Wallets Private Messenger Service Nodes Lokinet About Loki Which wallet should you use? Session Service Nodes Lokinet See more information on the different aspects of the Loki Network. Learn more about which wallet best suits you and see the guides to help you set one up. Learn more about Session ), our Private messenger. Learn more about Loki Service Nodes and see step by step guides to help you set one up. Learn more about the Lokinet and follow step by step guides to gain access.","title":"Quick Navigation"},{"location":"#information-is-important","text":"Privacy is having the agency to decide when you reveal personal information. It is a particularly valuable quality today, when the collection and storage of personal data is taking place at unprecedented levels in history. Loki provides the means to transact and communicate privately and anonymously, using the decentralised nature of blockchain technology to create new methods of interacting with the internet. Loki is a privacy cryptocurrency based on Monero. Loki currently offers an incentivised full node layer, instant private transactions, and secure private communications. More information on the project can be found on the website and in the whitepaper . Loki is an open source project, and we encourage contributions from anyone with something to offer. For more information on contributing, please contact team@loki.network If you are unsure where to start check out our \"Getting Started\" page by clicking here Otherwise to begin browsing Loki Docs click here .","title":"Information is Important"},{"location":"#community-channels","text":"Telegram: t.me/LokiCommunity GitHub: https://github.com/loki-project/loki Discord: https://discord.gg/67GXfD6 Twitter: https://twitter.com/loki_project Youtube: https://www.youtube.com/lokinetwork Reddit: https://www.reddit.com/r/LokiProject/ Mail: team@loki.network","title":"Community Channels"},{"location":"#copyright","text":"Copyright (c) 2018 The Loki Project. Portions Copyright (c) 2014-2018 The Monero Project. Portions Copyright (c) 2012-2013 The Cryptonote developers.","title":"Copyright"},{"location":"FAQ/","text":"Frequently Asked Questions \u00b6 General \u00b6 What is Loki? Is Loki Proof of Work (PoW) or Proof of Service (PoS)? What is the token supply? What do you do differently from Monero? Who would use Loki Network? Is Loki an ERC20 token? Why the name Loki? What is the business model behind this peer-to-peer network? Will you guys commit back to the Monero source code? Can I see details about the premine? Why is there a 5% governance reward? What is the block reward for mining? What is the block generation time? Are there plans to support Loki on the Ledger Nano S hardware wallet? Service Nodes \u00b6 Why are Service Nodes required? Is there a concept of Masternode's in Loki? What is the collateral requirement to run Service Nodes? Can you run multiple service nodes in a single VPS server? Can a pool member request for the stake to be unlocked? Session \u00b6 What is Session? why should I trust Session? What will Session do if compelled by a court to reveal user identities? How do I contact Session? How does Session protect my identity? What is metadata and why does Session need to protect it? What are the differences between Session on mobile and Session on desktop? What is an onion routing network? What is proxy routing, and how is it different from onion routing? How do I know if the person I am talking to is the person I want to talk to? What are channels, and do they protect my privacy in the same way as person-to-person messages? What are private group chats, and how do they compare with channels? If my phone is taken from me, can someone access my messages? Can I share attachments with my contacts? If so, does the app strip metadata from those attachments? Lokinet \u00b6 What is Lokinet? How is Lokinet different from Tor? Is Lokinet more private than Tor? What protocol does Lokinet use? What can I access using Lokinet? Is Lokinet enough to protect my privacy when I\u2019m browsing the internet? How do I use Lokinet? Who develops Lokinet? SNApps \u00b6 Do SNApps run on Service Nodes only? Are SNApps like DApps? Where will SNApps and all of its data be hosted? Loki Services \u00b6 What's Session? General \u00b6 What is Loki? \u00b6 Loki provides users with tools to interact online in an anonymous, decentralised, secure and private way. By combining a private transaction network, the $LOKI cryptocurrency, and economically incentivised Service Nodes , Loki has created a trustless quorum-based onion router called Lokinet . Built into Lokinet is Session \u2014 a decentralised, anonymous and private messaging service. Front end applications, known as Service Node Apps (SNApps) operate on Lokinet, and will allow browser integration and contribution from our open-source community. Is Loki Proof of Work (PoW) or Proof of Service (PoS)? \u00b6 Loki uses a hybrid of Proof of Work and Proof of Service , similar to how DASH is secured by PoW but also has a reward for their masternodes through a Proof of Service. What is the token supply? \u00b6 Like Monero, there is no total token supply. The current supply can be seen at lokiblocks.com . What do you do differently from Monero? \u00b6 Aside from some minor changes in approach to the core currency, we implement a Service Node network that performs a variety of functions, including an anonymous networking layer , trustless quorum-based instant transactions (based on a system called \" Blink \"), and a range of functions that leverage the networking layer for applications like secure private messaging . Compared to Monero, Loki has a fixed ring size with a minimum mixin of 10, governance block reward of 5% which will fund community projects and developments , and emission curve changes . These are base-layer changes that will differentiate us from Monero; however, the main change that is being implemented is the second layer of incentivised Service Nodes , Loki Services , and Lokinet . Who would use Loki Network? \u00b6 Loki provides both private transaction and private communication functionality, making the Loki Network important for users who want the highest level of privacy in their communication channels. As more SNApps are developed we imagine Loki will present it self as the network to run privacy-centric applications on top of. Is Loki an ERC20 token? \u00b6 Loki is not an ERC20 token. Loki is its own coin, running its own mainnet. See lokiblocks.com Why the name Loki? \u00b6 Loki is the Norse god of trickery. This is fitting as we use a lot of digital 'tricks' to obfuscate transactional data. The name is also a play on words, as transactions and communications on the Loki network are very 'Low-Key'. What is the business model behind this peer-to-peer network? \u00b6 Loki operates on an incentives structure provided by the network. Peer-to-peer communications only occurs through the Service Node layer which is already incentivised to run so there is less of an incentive to provide any additional businesses models. The business model post-launch for the Loki Foundation is twofold: first, to continue to build core Loki Services , and second, to aid in the development of 3rd party SNApps which Loki Service Nodes can optionally operate. Will you guys commit back to the Monero source code? \u00b6 Loki plans to push back any useful changes to Monero, such as optimisations, bug fixes, and feature adds. Can I see details about the premine? \u00b6 Yes, see the premine report . Why is there a 10% governance reward? \u00b6 We intended to create a self-funding system so that users can be certain that no external influences can drive the development funding of the network in an undesirable direction. The 10% block reward that is issued to the governance wallet is for this purpose. This is a similar approach to other projects, such as the Zcash Foundation, who for the first 4 years of the network\u2019s operation will receive a 20% block reward, and the DASH project, who receive a 10% block reward from the network. We wanted to keep the governance reward significantly smaller than Zcash and DASH, but we also want to ensure that the amount is enough to sustain the project indefinitely. In the future, the community may decide that this reward is unnecessary, or of too high or too low a proportion, in which case, a hard fork event may change the nature of this block reward split. What is the block reward for mining? \u00b6 The exact block reward can be found at www.lokiblocks.com . This block reward is split as follows: 66% of the block reward goes to service nodes, 24% to miners, and 10% to the governance pool. You can see more details on the block reward split here What is the block generation time? \u00b6 About 120 seconds. Are there plans to support Loki on the Ledger Nano S hardware wallet? \u00b6 Yes, support is in the works. Service Nodes \u00b6 Why are Service Nodes required? \u00b6 Loki Service Nodes form a second-layer network that allows for anonymous networking using a novel garlic routing technology. Service Nodes will route data being passed through our onion router, called Lokinet . SNApps are the front-end user-facing applications enabled by this network of service nodes. SNApps do not run on the blockchain, but rely on the consensus rules of the blockchain to enforce service node behaviour. This also means that SNApps do not impact blockchain scalability. Service nodes don't mine blocks, but they do propagate and validate blocks like regular full nodes. Is there a concept of 'Masternodes' in Loki? \u00b6 Yes, they are called Service Nodes in Loki. What is the collateral requirement to run Service Nodes? \u00b6 The initial requirement is 20K $LOKI, though this will adjust downward over time. Pools are also allowed, and can include up to 4 people. For more information on the collateral requirement click here . Check out the collateral calculator here to see the current requirement. You can either run a single node or join a pooled node. For a single node, you will need to stake the full collateral. For a pooled node, the operator and all but one of the 4 contributors must have at least 25% of the required total collateral. See more details on service nodes in the Service Node Portal . Can you run multiple service nodes in a single VPS server? \u00b6 It is recommended that you run different VPS instances for each service node , however it is not required. Can a pool member request for the stake to be unlocked? \u00b6 In pooled nodes, any contributor that requests the stake be unlocked will schedule the service node for expiration. Session \u00b6 What is Session? \u00b6 Session is a secure messaging app that protects your metadata, encrypts your communications and makes sure your messaging activities leave no digital trail behind. Why should I trust Session? \u00b6 Conversations in Session are end-to-end encrypted, just as in most private messengers. However, when you use Session, the identities of the people communicating are also protected. Session keeps your communication private, secure and anonymous. When using Session Desktop, your messages are sent to their destinations through Lokinet, a decentralised onion routing network similar to Tor (with a few key differences). Lokinet protects user privacy by ensuring that no single server ever knows a message's origin and destination. For more on this, check out What is an onion routing network? While Lokinet is being finished on mobile, Session\u2019s Android and iOS clients use proxy routing to protect IP addresses and maintain anonymity. For more on the difference between desktop and mobile, check out \"What is proxy routing?\" below. Session\u2019s code is open-source and can be independently audited at any time. Session is a project of the Loki Foundation, a not-for-profit organisation whose mission is to provide the world with better access to digital privacy technologies. What will Session do if compelled by a court to reveal user identities? \u00b6 As Session is a project of the Loki Foundation, court orders in situations such as this would be targeted at the Foundation. The Loki Foundation would comply with lawful orders. However, the Loki Foundation could not reveal user identities simply because the Foundation does not have access to the data required to do so. Session account creation does not use or require email addresses or phone numbers. Session IDs (which are public keys) are recorded, but there is no link between a public key and a person's real identity, and due to Session's decentralised network, there's also no way to link a Session ID to a specific IP address. The most the Loki Foundation could provide, if compelled to do so, would be tangential information such as access logs for the getsession.org website or statistics collected by the Apple App Store or Google Play Store. How do I contact Session? \u00b6 Got questions, comments or suggestions? Contact the team behind Session at team@loki.network or reach out to Session on social media. How does Session protect my identity? \u00b6 You don\u2019t need a mobile number or an email to make an account with Session. Your display name can be your real name, an alias, or anything else you like. Session does not collect any geolocation data, metadata or any other data about the device or network you are using. Session Desktop messages are sent over Lokinet, Session's decentralised onion routing solution, so no remote servers are ever able to trace or track your conversations. And on mobile, Session uses secure proxy routing to keep your identity private. For more on Session's secure message routing, check out \"What is an onion routing network?\" and \"What is proxy routing?\" What is metadata and why does Session need to protect it? \u00b6 In messaging apps, metadata is the information created when you send a message \u2014 everything about the message besides the actual contents of the message itself. This can include information like your IP address, the IP addresses of your contacts, who your messages are sent to, and the time and date that messages are sent. It\u2019s impossible for Session to track users\u2019 IP addresses because the app uses onion routing (on desktop) and proxy routing (on mobile) to send messages. Because Session doesn\u2019t use central servers to route messages from person to person, we don\u2019t know when you send messages, or who you send them to. Session lets you send messages \u2014 not metadata. What are the differences between Session on mobile and Session on desktop? \u00b6 As mentioned in \"What is proxy routing\" below, mobile devices use an alternative form of anonymous routing, called proxy routing, to protect user IP addresses. This is a temporary measure which will be replaced by Lokinet when the latter has mobile client functionality. Other than this, mobile and desktop Session clients have feature parity. What is an onion routing network? \u00b6 An onion routing network is a network of nodes over which users can send anonymous encrypted messages. Onion networks encrypt messages with multiple layers of encryption, then send them through a number of nodes. Each node \u2018unwraps\u2019 (decrypts) a layer of encryption, meaning that no single node ever knows both the destination and origin of the message. Session uses onion routing to ensure that a server which receives a message never knows the IP address of the sender. Session uses the Loki Project\u2019s Lokinet onion routing network to send messages securely and anonymously. Lokinet is built on a foundation of Loki Service Nodes, which also power the $LOKI cryptocurrency. Check out Loki.network for more information on the tech behind Session\u2019s onion routing. What is proxy routing, and how is it different from onion routing? \u00b6 Session\u2019s desktop client uses the Lokinet onion routing network to send messages, but due to platform-specific limitations, Lokinet is not yet available on mobile devices. While we work to make Lokinet available on mobile, we have implemented an interim solution: proxy routing. Instead of connecting directly to a Loki Service Node to send or receive messages, mobile devices connect to a service node which then connects to a second service node on behalf of the mobile device. The first service node then sends or requests messages from the second node on behalf of the mobile device. This proxy routing system ensures that the client device\u2019s IP address is never known by the service node which fetches or sends the messages. However, proxy routing does provide weaker privacy than the Lokinet onion routing protocol used by Session\u2019s desktop client. Proxy routing still provides a high level of security for minimising metadata leakage on mobile. The proxy routing system will be replaced by full Lokinet integration when Lokinet clients are ready for mobile devices. How do I know if the person I am talking to is the person I want to talk to? \u00b6 Session's \"Safety Numbers\" feature makes it easy for people in a conversation to verify each other if both parties would like to do so. You can use another channel of communication outside of Session to ask for and verify someone's Session Safety Number, and then check that the Safety Number in the app matches what you've been told. If the Safety Numbers match, you're speaking to the correct person. If they do not, the Session account may be an imposter. What are channels, and do they protect my privacy in the same way as person-to-person messages? \u00b6 The short answer: channels are not as private as person-to-person messages. The long answer: channels are large public channels where Session users can congregate and discuss anything they want. Channels, unlike other services in Session, are self-hosted and thus not fully decentralised. Someone has to run a server which stores the public chat's message history. Additionally, because channel servers can serve thousands of users, messages are only encrypted in transit to the server rather than being fully end-to-end encrypted. For smaller group chats with a higher degree of privacy, users are encouraged to use private group chats. You can find out more about channels and private group chats here . What are private group chats, and how do they compare with channels? \u00b6 Private group chats are fully end-to-end encrypted group chats. Up to 10 people can participate in a private group chat. Private group chat messages are stored on Session's decentralised network, with no central servers used or required. If my phone is taken from me, can someone access my messages? \u00b6 Session allows users to encrypt their local Session database with a PIN code. With this feature turned on, your messages cannot be accessed without knowing your PIN code. Can I share attachments with my contacts? If so, does the app strip metadata from those attachments? \u00b6 Session can send files, images and other attachments up to 10MB in both person-to-person messages and group chats. By default, Session uses the Loki File Server for attachment sending and storage. The Loki File Server is an open-source file server run by the Loki Foundation \u2014 the creators of Session. When you send an attachment, the file is symmetrically encrypted on the device and then sent to the Loki File Server. To send the attachment to a friend, Session sends them an encrypted message containing the link, plus the decryption key for the file. This ensures that the Loki File Server can never see the contents of files being uploaded to it. Additionally, the desktop and mobile versions of Session use onion routing and proxy routing (respectively) to hide users' IP addresses when uploading or downloading attachments from the Loki File Server. In future, you will be able to configure the Session app to use a custom file server, such as a self-hosted server or VPS (Virtual Private Server), if you would prefer not to use a file server hosted by the Loki Foundation. Lokinet \u00b6 What is Lokinet? \u00b6 Lokinet is a decentralised onion router that uses Loki Service Nodes as relays, giving Lokinet the same market-based Sybil attack resistance as the Loki blockchain. Lokinet supports web browsing, onion-routed real-time voice communications, and other applications. How is Lokinet different from Tor? \u00b6 While Tor and Lokinet are both onion routers, they are very different at both the protocol and infrastructure levels. Tor relies on a network of volunteer-operated relays and a set of central directory authorities, and this infrastructure introduces a number of weaknesses and limitations. Because Tor\u2019s circuit moderation is bandwidth-weighted, you are much more likely to use high-bandwidth nodes than low-bandwidth ones, meaning that a large percentage of Tor\u2019s 7000+ nodes go mostly unutilised due to having insufficient bandwidth. Additionally, Tor\u2019s reliance on a limited set of directory authorities means that if these directory authorities were compromised, the stability of the entire Tor network would suffer. Instead of relying on volunteers, Lokinet leverages the economically incentivised Loki Service Node network. Because Loki Service Node operators are required to provide high-quality nodes \u2014 and are actively incentivised to do so \u2014 Lokinet\u2019s relay network is consistent and reliable. Lokinet also inherits the market-based Sybil attack resistance of the Loki blockchain, giving Lokinet a high level of security against such attacks. Instead of Tor\u2019s system of central directory authorities, Lokinet distributes address records over the network. This makes Lokinet significantly more decentralised than Tor. Lokinet is also significantly more versatile than Tor \u2014 while Tor operates on the transport layer and is only able to carry TCP traffic, Lokinet operates on the network layer, meaning it can onion-route any IP-based protocol: TCP, UDP, ICMP, etc. Is Lokinet more private than Tor? \u00b6 No \u2014 but it could be in the future. In its current experimental state, Lokinet has a more limited anonymity set due to having far fewer active users than Tor. However, Lokinet does have some important advantages over Tor, specifically in terms of Sybil attack resistance and decentralisation, which do make Lokinet more private in some circumstances. Sybil attack resistance \u00b6 The Tor network relies on volunteer-operated relays, with very little barrier to entry for operating a relay. As a result, the network is vulnerable to something called a Sybil attack, where an attacker initialises a large number of malicious nodes, eventually controlling enough nodes to give them control of the guard and exit nodes for a given target\u2019s circuit. This allows the attacker to conduct granular traffic analysis, de-anonymising the user and any other circuits in which the exit and guard are owned by the attacker. Decentralisation \u00b6 One of Tor\u2019s most well-documented weaknesses is its reliance on a relatively small set of central directory authority servers that allow clients to find nodes in the Tor network. If these directory authorities are compromised, it would endanger the stability of the entire Tor network. Instead of relying on central directory authorities, Lokinet uses the Loki blockchain as a form of decentralised directory authority, meaning that Lokinet isn\u2019t reliant on any kind of central server \u2014 the network is fully decentralised. What protocol does Lokinet use? \u00b6 Lokinet is the reference implementation of LLARP (Low-Latency Anonymous Routing Protocol), a next-generation onion routing protocol that aims to address issues with Tor and I2P. You can read more about LLARP here . What can I access using Lokinet? \u00b6 Currently, Lokinet enables access to SNApps \u2014 applications hosted on Loki Service Nodes. SNApps are analogous to Tor\u2019s hidden services, and typically appear in the form of internet addresses ending in \u2018.loki\u2019. When you access a SNApp through Lokinet, your connection is protected by Lokinet\u2019s onion routing protocol. Exit node support, which is on the Lokinet road map, will enable users to access clearnet websites over Lokinet, helping to anonymise normal internet browsing as well as enabling access to SNApps. Is Lokinet enough to protect my privacy when I\u2019m browsing the internet? \u00b6 In its current form, Lokinet does not have full exit node support. This means that if you use the internet with Lokinet enabled, normal (clearnet) traffic \u2014 traffic to or from servers outside of Lokinet itself \u2014 will not be onion routed, and you will not have the same privacy protections as when accessing SNApps over Lokinet. Once Lokinet implements full exit node support, all internet traffic from your computer can be onion-routed over Lokinet. Full exit node support is on the Lokinet roadmap, but until it\u2019s implemented, we recommend using Tor to browse the clearnet anonymously. How do I use Lokinet? \u00b6 You can use Lokinet on Windows, macOS, and Linux \u2014 and it\u2019s easy to get up and running. Just go here , download the Lokinet client for your platform, and follow the easy steps to enable Lokinet. You can then start accessing SNApps securely, privately, and anonymously. If you prefer to build the Lokinet client from source directly, you can find the source code on the Lokinet GitHub . Who develops Lokinet? \u00b6 Lokinet is developed by the Loki Foundation, Australia\u2019s first privacy tech not-for-profit organisation. Lokinet is part of the Loki Foundation\u2019s suite of blockchain-based privacy tools that also includes the encrypted messaging app Session, and the Loki cryptocurrency itself. SNapps \u00b6 Do SNApps run on Service Nodes only? \u00b6 When accessing a SNApp your data is obfuscated by being routed through multiple service nodes. However, the SNApp you are accessing is hosted on servers, similar to hidden services in Tor, and is computed client-side. Are SNApps like DApps? \u00b6 In the sense that their core function is 'decentralised,' yes. However, unlike most DApps, SNApps do not rely on on-chain execution or computation. All Loki SNApps are computed client-side, and the networking is handled offchain by the service node network. Where will SNApps and all of their data be hosted? \u00b6 SNApps are similar to hidden services in Tor; they are hosted on servers by users. Loki Services \u00b6 What is Session? \u00b6 Session is a decentralised, end-to-end encrypted private messaging service. Many other encrypted private messengers rely on central servers to route traffic. Session leverages the power of public-private key cryptography and the Loki Service Node architecture on the Loki network to create a service similar to the secure messaging application Signal, but with the added benefit of decentralisation and network anonymity.","title":"FAQ"},{"location":"FAQ/#frequently-asked-questions","text":"","title":"Frequently Asked Questions"},{"location":"FAQ/#general","text":"What is Loki? Is Loki Proof of Work (PoW) or Proof of Service (PoS)? What is the token supply? What do you do differently from Monero? Who would use Loki Network? Is Loki an ERC20 token? Why the name Loki? What is the business model behind this peer-to-peer network? Will you guys commit back to the Monero source code? Can I see details about the premine? Why is there a 5% governance reward? What is the block reward for mining? What is the block generation time? Are there plans to support Loki on the Ledger Nano S hardware wallet?","title":"General"},{"location":"FAQ/#service-nodes","text":"Why are Service Nodes required? Is there a concept of Masternode's in Loki? What is the collateral requirement to run Service Nodes? Can you run multiple service nodes in a single VPS server? Can a pool member request for the stake to be unlocked?","title":"Service Nodes"},{"location":"FAQ/#session","text":"What is Session? why should I trust Session? What will Session do if compelled by a court to reveal user identities? How do I contact Session? How does Session protect my identity? What is metadata and why does Session need to protect it? What are the differences between Session on mobile and Session on desktop? What is an onion routing network? What is proxy routing, and how is it different from onion routing? How do I know if the person I am talking to is the person I want to talk to? What are channels, and do they protect my privacy in the same way as person-to-person messages? What are private group chats, and how do they compare with channels? If my phone is taken from me, can someone access my messages? Can I share attachments with my contacts? If so, does the app strip metadata from those attachments?","title":"Session"},{"location":"FAQ/#lokinet","text":"What is Lokinet? How is Lokinet different from Tor? Is Lokinet more private than Tor? What protocol does Lokinet use? What can I access using Lokinet? Is Lokinet enough to protect my privacy when I\u2019m browsing the internet? How do I use Lokinet? Who develops Lokinet?","title":"Lokinet"},{"location":"FAQ/#snapps","text":"Do SNApps run on Service Nodes only? Are SNApps like DApps? Where will SNApps and all of its data be hosted?","title":"SNApps"},{"location":"FAQ/#loki-services","text":"What's Session?","title":"Loki Services"},{"location":"FAQ/#general_1","text":"","title":"General"},{"location":"FAQ/#what-is-loki","text":"Loki provides users with tools to interact online in an anonymous, decentralised, secure and private way. By combining a private transaction network, the $LOKI cryptocurrency, and economically incentivised Service Nodes , Loki has created a trustless quorum-based onion router called Lokinet . Built into Lokinet is Session \u2014 a decentralised, anonymous and private messaging service. Front end applications, known as Service Node Apps (SNApps) operate on Lokinet, and will allow browser integration and contribution from our open-source community.","title":"What is Loki?"},{"location":"FAQ/#is-loki-proof-of-work-pow-or-proof-of-service-pos","text":"Loki uses a hybrid of Proof of Work and Proof of Service , similar to how DASH is secured by PoW but also has a reward for their masternodes through a Proof of Service.","title":"Is Loki Proof of Work (PoW) or Proof of Service (PoS)?"},{"location":"FAQ/#what-is-the-token-supply","text":"Like Monero, there is no total token supply. The current supply can be seen at lokiblocks.com .","title":"What is the token supply?"},{"location":"FAQ/#what-do-you-do-differently-from-monero","text":"Aside from some minor changes in approach to the core currency, we implement a Service Node network that performs a variety of functions, including an anonymous networking layer , trustless quorum-based instant transactions (based on a system called \" Blink \"), and a range of functions that leverage the networking layer for applications like secure private messaging . Compared to Monero, Loki has a fixed ring size with a minimum mixin of 10, governance block reward of 5% which will fund community projects and developments , and emission curve changes . These are base-layer changes that will differentiate us from Monero; however, the main change that is being implemented is the second layer of incentivised Service Nodes , Loki Services , and Lokinet .","title":"What do you do differently from Monero?"},{"location":"FAQ/#who-would-use-loki-network","text":"Loki provides both private transaction and private communication functionality, making the Loki Network important for users who want the highest level of privacy in their communication channels. As more SNApps are developed we imagine Loki will present it self as the network to run privacy-centric applications on top of.","title":"Who would use Loki Network?"},{"location":"FAQ/#is-loki-an-erc20-token","text":"Loki is not an ERC20 token. Loki is its own coin, running its own mainnet. See lokiblocks.com","title":"Is Loki an ERC20 token?"},{"location":"FAQ/#why-the-name-loki","text":"Loki is the Norse god of trickery. This is fitting as we use a lot of digital 'tricks' to obfuscate transactional data. The name is also a play on words, as transactions and communications on the Loki network are very 'Low-Key'.","title":"Why the name Loki?"},{"location":"FAQ/#what-is-the-business-model-behind-this-peer-to-peer-network","text":"Loki operates on an incentives structure provided by the network. Peer-to-peer communications only occurs through the Service Node layer which is already incentivised to run so there is less of an incentive to provide any additional businesses models. The business model post-launch for the Loki Foundation is twofold: first, to continue to build core Loki Services , and second, to aid in the development of 3rd party SNApps which Loki Service Nodes can optionally operate.","title":"What is the business model behind this peer-to-peer network?"},{"location":"FAQ/#will-you-guys-commit-back-to-the-monero-source-code","text":"Loki plans to push back any useful changes to Monero, such as optimisations, bug fixes, and feature adds.","title":"Will you guys commit back to the Monero source code?"},{"location":"FAQ/#can-i-see-details-about-the-premine","text":"Yes, see the premine report .","title":"Can I see details about the premine?"},{"location":"FAQ/#why-is-there-a-10-governance-reward","text":"We intended to create a self-funding system so that users can be certain that no external influences can drive the development funding of the network in an undesirable direction. The 10% block reward that is issued to the governance wallet is for this purpose. This is a similar approach to other projects, such as the Zcash Foundation, who for the first 4 years of the network\u2019s operation will receive a 20% block reward, and the DASH project, who receive a 10% block reward from the network. We wanted to keep the governance reward significantly smaller than Zcash and DASH, but we also want to ensure that the amount is enough to sustain the project indefinitely. In the future, the community may decide that this reward is unnecessary, or of too high or too low a proportion, in which case, a hard fork event may change the nature of this block reward split.","title":"Why is there a 10% governance reward?"},{"location":"FAQ/#what-is-the-block-reward-for-mining","text":"The exact block reward can be found at www.lokiblocks.com . This block reward is split as follows: 66% of the block reward goes to service nodes, 24% to miners, and 10% to the governance pool. You can see more details on the block reward split here","title":"What is the block reward for mining?"},{"location":"FAQ/#what-is-the-block-generation-time","text":"About 120 seconds.","title":"What is the block generation time?"},{"location":"FAQ/#are-there-plans-to-support-loki-on-the-ledger-nano-s-hardware-wallet","text":"Yes, support is in the works.","title":"Are there plans to support Loki on the Ledger Nano S hardware wallet?"},{"location":"FAQ/#service-nodes_1","text":"","title":"Service Nodes"},{"location":"FAQ/#why-are-service-nodes-required","text":"Loki Service Nodes form a second-layer network that allows for anonymous networking using a novel garlic routing technology. Service Nodes will route data being passed through our onion router, called Lokinet . SNApps are the front-end user-facing applications enabled by this network of service nodes. SNApps do not run on the blockchain, but rely on the consensus rules of the blockchain to enforce service node behaviour. This also means that SNApps do not impact blockchain scalability. Service nodes don't mine blocks, but they do propagate and validate blocks like regular full nodes.","title":"Why are Service Nodes required?"},{"location":"FAQ/#is-there-a-concept-of-masternodes-in-loki","text":"Yes, they are called Service Nodes in Loki.","title":"Is there a concept of 'Masternodes' in Loki?"},{"location":"FAQ/#what-is-the-collateral-requirement-to-run-service-nodes","text":"The initial requirement is 20K $LOKI, though this will adjust downward over time. Pools are also allowed, and can include up to 4 people. For more information on the collateral requirement click here . Check out the collateral calculator here to see the current requirement. You can either run a single node or join a pooled node. For a single node, you will need to stake the full collateral. For a pooled node, the operator and all but one of the 4 contributors must have at least 25% of the required total collateral. See more details on service nodes in the Service Node Portal .","title":"What is the collateral requirement to run Service Nodes?"},{"location":"FAQ/#can-you-run-multiple-service-nodes-in-a-single-vps-server","text":"It is recommended that you run different VPS instances for each service node , however it is not required.","title":"Can you run multiple service nodes in a single VPS server?"},{"location":"FAQ/#can-a-pool-member-request-for-the-stake-to-be-unlocked","text":"In pooled nodes, any contributor that requests the stake be unlocked will schedule the service node for expiration.","title":"Can a pool member request for the stake to be unlocked?"},{"location":"FAQ/#session_1","text":"","title":"Session"},{"location":"FAQ/#what-is-session","text":"Session is a secure messaging app that protects your metadata, encrypts your communications and makes sure your messaging activities leave no digital trail behind.","title":"What is Session?"},{"location":"FAQ/#why-should-i-trust-session","text":"Conversations in Session are end-to-end encrypted, just as in most private messengers. However, when you use Session, the identities of the people communicating are also protected. Session keeps your communication private, secure and anonymous. When using Session Desktop, your messages are sent to their destinations through Lokinet, a decentralised onion routing network similar to Tor (with a few key differences). Lokinet protects user privacy by ensuring that no single server ever knows a message's origin and destination. For more on this, check out What is an onion routing network? While Lokinet is being finished on mobile, Session\u2019s Android and iOS clients use proxy routing to protect IP addresses and maintain anonymity. For more on the difference between desktop and mobile, check out \"What is proxy routing?\" below. Session\u2019s code is open-source and can be independently audited at any time. Session is a project of the Loki Foundation, a not-for-profit organisation whose mission is to provide the world with better access to digital privacy technologies.","title":"Why should I trust Session?"},{"location":"FAQ/#what-will-session-do-if-compelled-by-a-court-to-reveal-user-identities","text":"As Session is a project of the Loki Foundation, court orders in situations such as this would be targeted at the Foundation. The Loki Foundation would comply with lawful orders. However, the Loki Foundation could not reveal user identities simply because the Foundation does not have access to the data required to do so. Session account creation does not use or require email addresses or phone numbers. Session IDs (which are public keys) are recorded, but there is no link between a public key and a person's real identity, and due to Session's decentralised network, there's also no way to link a Session ID to a specific IP address. The most the Loki Foundation could provide, if compelled to do so, would be tangential information such as access logs for the getsession.org website or statistics collected by the Apple App Store or Google Play Store.","title":"What will Session do if compelled by a court to reveal user identities?"},{"location":"FAQ/#how-do-i-contact-session","text":"Got questions, comments or suggestions? Contact the team behind Session at team@loki.network or reach out to Session on social media.","title":"How do I contact Session?"},{"location":"FAQ/#how-does-session-protect-my-identity","text":"You don\u2019t need a mobile number or an email to make an account with Session. Your display name can be your real name, an alias, or anything else you like. Session does not collect any geolocation data, metadata or any other data about the device or network you are using. Session Desktop messages are sent over Lokinet, Session's decentralised onion routing solution, so no remote servers are ever able to trace or track your conversations. And on mobile, Session uses secure proxy routing to keep your identity private. For more on Session's secure message routing, check out \"What is an onion routing network?\" and \"What is proxy routing?\"","title":"How does Session protect my identity?"},{"location":"FAQ/#what-is-metadata-and-why-does-session-need-to-protect-it","text":"In messaging apps, metadata is the information created when you send a message \u2014 everything about the message besides the actual contents of the message itself. This can include information like your IP address, the IP addresses of your contacts, who your messages are sent to, and the time and date that messages are sent. It\u2019s impossible for Session to track users\u2019 IP addresses because the app uses onion routing (on desktop) and proxy routing (on mobile) to send messages. Because Session doesn\u2019t use central servers to route messages from person to person, we don\u2019t know when you send messages, or who you send them to. Session lets you send messages \u2014 not metadata.","title":"What is metadata and why does Session need to protect it?"},{"location":"FAQ/#what-are-the-differences-between-session-on-mobile-and-session-on-desktop","text":"As mentioned in \"What is proxy routing\" below, mobile devices use an alternative form of anonymous routing, called proxy routing, to protect user IP addresses. This is a temporary measure which will be replaced by Lokinet when the latter has mobile client functionality. Other than this, mobile and desktop Session clients have feature parity.","title":"What are the differences between Session on mobile and Session on desktop?"},{"location":"FAQ/#what-is-an-onion-routing-network","text":"An onion routing network is a network of nodes over which users can send anonymous encrypted messages. Onion networks encrypt messages with multiple layers of encryption, then send them through a number of nodes. Each node \u2018unwraps\u2019 (decrypts) a layer of encryption, meaning that no single node ever knows both the destination and origin of the message. Session uses onion routing to ensure that a server which receives a message never knows the IP address of the sender. Session uses the Loki Project\u2019s Lokinet onion routing network to send messages securely and anonymously. Lokinet is built on a foundation of Loki Service Nodes, which also power the $LOKI cryptocurrency. Check out Loki.network for more information on the tech behind Session\u2019s onion routing.","title":"What is an onion routing network?"},{"location":"FAQ/#what-is-proxy-routing-and-how-is-it-different-from-onion-routing","text":"Session\u2019s desktop client uses the Lokinet onion routing network to send messages, but due to platform-specific limitations, Lokinet is not yet available on mobile devices. While we work to make Lokinet available on mobile, we have implemented an interim solution: proxy routing. Instead of connecting directly to a Loki Service Node to send or receive messages, mobile devices connect to a service node which then connects to a second service node on behalf of the mobile device. The first service node then sends or requests messages from the second node on behalf of the mobile device. This proxy routing system ensures that the client device\u2019s IP address is never known by the service node which fetches or sends the messages. However, proxy routing does provide weaker privacy than the Lokinet onion routing protocol used by Session\u2019s desktop client. Proxy routing still provides a high level of security for minimising metadata leakage on mobile. The proxy routing system will be replaced by full Lokinet integration when Lokinet clients are ready for mobile devices.","title":"What is proxy routing, and how is it different from onion routing?"},{"location":"FAQ/#how-do-i-know-if-the-person-i-am-talking-to-is-the-person-i-want-to-talk-to","text":"Session's \"Safety Numbers\" feature makes it easy for people in a conversation to verify each other if both parties would like to do so. You can use another channel of communication outside of Session to ask for and verify someone's Session Safety Number, and then check that the Safety Number in the app matches what you've been told. If the Safety Numbers match, you're speaking to the correct person. If they do not, the Session account may be an imposter.","title":"How do I know if the person I am talking to is the person I want to talk to?"},{"location":"FAQ/#what-are-channels-and-do-they-protect-my-privacy-in-the-same-way-as-person-to-person-messages","text":"The short answer: channels are not as private as person-to-person messages. The long answer: channels are large public channels where Session users can congregate and discuss anything they want. Channels, unlike other services in Session, are self-hosted and thus not fully decentralised. Someone has to run a server which stores the public chat's message history. Additionally, because channel servers can serve thousands of users, messages are only encrypted in transit to the server rather than being fully end-to-end encrypted. For smaller group chats with a higher degree of privacy, users are encouraged to use private group chats. You can find out more about channels and private group chats here .","title":"What are channels, and do they protect my privacy in the same way as person-to-person messages?"},{"location":"FAQ/#what-are-private-group-chats-and-how-do-they-compare-with-channels","text":"Private group chats are fully end-to-end encrypted group chats. Up to 10 people can participate in a private group chat. Private group chat messages are stored on Session's decentralised network, with no central servers used or required.","title":"What are private group chats, and how do they compare with channels?"},{"location":"FAQ/#if-my-phone-is-taken-from-me-can-someone-access-my-messages","text":"Session allows users to encrypt their local Session database with a PIN code. With this feature turned on, your messages cannot be accessed without knowing your PIN code.","title":"If my phone is taken from me, can someone access my messages?"},{"location":"FAQ/#can-i-share-attachments-with-my-contacts-if-so-does-the-app-strip-metadata-from-those-attachments","text":"Session can send files, images and other attachments up to 10MB in both person-to-person messages and group chats. By default, Session uses the Loki File Server for attachment sending and storage. The Loki File Server is an open-source file server run by the Loki Foundation \u2014 the creators of Session. When you send an attachment, the file is symmetrically encrypted on the device and then sent to the Loki File Server. To send the attachment to a friend, Session sends them an encrypted message containing the link, plus the decryption key for the file. This ensures that the Loki File Server can never see the contents of files being uploaded to it. Additionally, the desktop and mobile versions of Session use onion routing and proxy routing (respectively) to hide users' IP addresses when uploading or downloading attachments from the Loki File Server. In future, you will be able to configure the Session app to use a custom file server, such as a self-hosted server or VPS (Virtual Private Server), if you would prefer not to use a file server hosted by the Loki Foundation.","title":"Can I share attachments with my contacts? If so, does the app strip metadata from those attachments?"},{"location":"FAQ/#lokinet_1","text":"","title":"Lokinet"},{"location":"FAQ/#what-is-lokinet","text":"Lokinet is a decentralised onion router that uses Loki Service Nodes as relays, giving Lokinet the same market-based Sybil attack resistance as the Loki blockchain. Lokinet supports web browsing, onion-routed real-time voice communications, and other applications.","title":"What is Lokinet?"},{"location":"FAQ/#how-is-lokinet-different-from-tor","text":"While Tor and Lokinet are both onion routers, they are very different at both the protocol and infrastructure levels. Tor relies on a network of volunteer-operated relays and a set of central directory authorities, and this infrastructure introduces a number of weaknesses and limitations. Because Tor\u2019s circuit moderation is bandwidth-weighted, you are much more likely to use high-bandwidth nodes than low-bandwidth ones, meaning that a large percentage of Tor\u2019s 7000+ nodes go mostly unutilised due to having insufficient bandwidth. Additionally, Tor\u2019s reliance on a limited set of directory authorities means that if these directory authorities were compromised, the stability of the entire Tor network would suffer. Instead of relying on volunteers, Lokinet leverages the economically incentivised Loki Service Node network. Because Loki Service Node operators are required to provide high-quality nodes \u2014 and are actively incentivised to do so \u2014 Lokinet\u2019s relay network is consistent and reliable. Lokinet also inherits the market-based Sybil attack resistance of the Loki blockchain, giving Lokinet a high level of security against such attacks. Instead of Tor\u2019s system of central directory authorities, Lokinet distributes address records over the network. This makes Lokinet significantly more decentralised than Tor. Lokinet is also significantly more versatile than Tor \u2014 while Tor operates on the transport layer and is only able to carry TCP traffic, Lokinet operates on the network layer, meaning it can onion-route any IP-based protocol: TCP, UDP, ICMP, etc.","title":"How is Lokinet different from Tor?"},{"location":"FAQ/#is-lokinet-more-private-than-tor","text":"No \u2014 but it could be in the future. In its current experimental state, Lokinet has a more limited anonymity set due to having far fewer active users than Tor. However, Lokinet does have some important advantages over Tor, specifically in terms of Sybil attack resistance and decentralisation, which do make Lokinet more private in some circumstances.","title":"Is Lokinet more private than Tor?"},{"location":"FAQ/#sybil-attack-resistance","text":"The Tor network relies on volunteer-operated relays, with very little barrier to entry for operating a relay. As a result, the network is vulnerable to something called a Sybil attack, where an attacker initialises a large number of malicious nodes, eventually controlling enough nodes to give them control of the guard and exit nodes for a given target\u2019s circuit. This allows the attacker to conduct granular traffic analysis, de-anonymising the user and any other circuits in which the exit and guard are owned by the attacker.","title":"Sybil attack resistance"},{"location":"FAQ/#decentralisation","text":"One of Tor\u2019s most well-documented weaknesses is its reliance on a relatively small set of central directory authority servers that allow clients to find nodes in the Tor network. If these directory authorities are compromised, it would endanger the stability of the entire Tor network. Instead of relying on central directory authorities, Lokinet uses the Loki blockchain as a form of decentralised directory authority, meaning that Lokinet isn\u2019t reliant on any kind of central server \u2014 the network is fully decentralised.","title":"Decentralisation"},{"location":"FAQ/#what-protocol-does-lokinet-use","text":"Lokinet is the reference implementation of LLARP (Low-Latency Anonymous Routing Protocol), a next-generation onion routing protocol that aims to address issues with Tor and I2P. You can read more about LLARP here .","title":"What protocol does Lokinet use?"},{"location":"FAQ/#what-can-i-access-using-lokinet","text":"Currently, Lokinet enables access to SNApps \u2014 applications hosted on Loki Service Nodes. SNApps are analogous to Tor\u2019s hidden services, and typically appear in the form of internet addresses ending in \u2018.loki\u2019. When you access a SNApp through Lokinet, your connection is protected by Lokinet\u2019s onion routing protocol. Exit node support, which is on the Lokinet road map, will enable users to access clearnet websites over Lokinet, helping to anonymise normal internet browsing as well as enabling access to SNApps.","title":"What can I access using Lokinet?"},{"location":"FAQ/#is-lokinet-enough-to-protect-my-privacy-when-im-browsing-the-internet","text":"In its current form, Lokinet does not have full exit node support. This means that if you use the internet with Lokinet enabled, normal (clearnet) traffic \u2014 traffic to or from servers outside of Lokinet itself \u2014 will not be onion routed, and you will not have the same privacy protections as when accessing SNApps over Lokinet. Once Lokinet implements full exit node support, all internet traffic from your computer can be onion-routed over Lokinet. Full exit node support is on the Lokinet roadmap, but until it\u2019s implemented, we recommend using Tor to browse the clearnet anonymously.","title":"Is Lokinet enough to protect my privacy when I\u2019m browsing the internet?"},{"location":"FAQ/#how-do-i-use-lokinet","text":"You can use Lokinet on Windows, macOS, and Linux \u2014 and it\u2019s easy to get up and running. Just go here , download the Lokinet client for your platform, and follow the easy steps to enable Lokinet. You can then start accessing SNApps securely, privately, and anonymously. If you prefer to build the Lokinet client from source directly, you can find the source code on the Lokinet GitHub .","title":"How do I use Lokinet?"},{"location":"FAQ/#who-develops-lokinet","text":"Lokinet is developed by the Loki Foundation, Australia\u2019s first privacy tech not-for-profit organisation. Lokinet is part of the Loki Foundation\u2019s suite of blockchain-based privacy tools that also includes the encrypted messaging app Session, and the Loki cryptocurrency itself.","title":"Who develops Lokinet?"},{"location":"FAQ/#snapps_1","text":"","title":"SNapps"},{"location":"FAQ/#do-snapps-run-on-service-nodes-only","text":"When accessing a SNApp your data is obfuscated by being routed through multiple service nodes. However, the SNApp you are accessing is hosted on servers, similar to hidden services in Tor, and is computed client-side.","title":"Do SNApps run on Service Nodes only?"},{"location":"FAQ/#are-snapps-like-dapps","text":"In the sense that their core function is 'decentralised,' yes. However, unlike most DApps, SNApps do not rely on on-chain execution or computation. All Loki SNApps are computed client-side, and the networking is handled offchain by the service node network.","title":"Are SNApps like DApps?"},{"location":"FAQ/#where-will-snapps-and-all-of-their-data-be-hosted","text":"SNApps are similar to hidden services in Tor; they are hosted on servers by users.","title":"Where will SNApps and all of their data be hosted?"},{"location":"FAQ/#loki-services_1","text":"","title":"Loki Services"},{"location":"FAQ/#what-is-session_1","text":"Session is a decentralised, end-to-end encrypted private messaging service. Many other encrypted private messengers rely on central servers to route traffic. Session leverages the power of public-private key cryptography and the Loki Service Node architecture on the Loki network to create a service similar to the secure messaging application Signal, but with the added benefit of decentralisation and network anonymity.","title":"What is Session?"},{"location":"Advanced/AcceptingLoki/","text":"Accepting Loki \u00b6 Instructions for the Command-Line Interface \u00b6 The Basics \u00b6 Loki works a little differently to what you may have become accustomed to from other cryptocurrencies. In the case of a digital currency like Bitcoin and its many derivatives merchant payment systems will usually create a new recipient address for each payment or user. However, because Loki has stealth addresses there is no need to have separate recipient addresses for each payment or user, and a single account address can be published. Instead, when receiving payments a merchant will provide the person paying with a payment ID . A payment ID is a hexadecimal string that is 64 characters long, and is normally randomly created by the merchant. An example of a payment ID is: 326d381588ae509bcf35fc8ae05abd31ba1ef885ced2e5c1f2180f28845d1f6f To generate a payment ID in loki-wallet-cli run the command: payment_id Checking for a Payment in loki-wallet-cli \u00b6 If you want to check for a payment using loki-wallet-cli you can use the payments command followed by the payment ID or payment IDs you want to check: payments <PID_1> [<PID_2> ... <PID_N>] For example: [wallet L6k67F]: payments 4c746dff9f666d6275a60eb6ecbe5078970d5207bc104032f5afa4878eb414e6 payment transaction height amount unlock time addr index <4c746dff9f666d6275a60eb6ecbe5078970d5207bc104032f5afa4878eb414e6> <3fc266d4167060613fba401c65e22e7f01e00045070009b99dd15134b60b47e9> 191878 1.000000000 0 0 [wallet L6k67F]: If you need to check for payments programmatically, then follow the next section . Receiving a Payment Step-by-Step \u00b6 Generate a random 64 character hexadecimal string for the payment Communicate the payment ID and Loki address to the individual who is making payment Check for the payment using the \"payments\" command in loki-wallet-cli Checking for a Payment Programmatically \u00b6 In order to check for a payment programmatically you can use the get_payments or get_bulk_payments JSON RPC API calls. get_payments : this requires a payment_id parameter with a single payment ID. get_bulk_payments : this is the preferred method, and requires two parameters, payment_ids - a JSON array of payment IDs - and an optional min_block_height - the block height to scan from. get_payments \u00b6 Get a list of incoming payments using a given payment id. Alias : None. Inputs : payment_id - string; Payment ID used to find the payments (16 characters hex). Outputs : payments - list of: payment_id - string; Payment ID matching the input parameter. tx_hash - string; Transaction hash used as the transaction ID. amount - unsigned int; Amount for this payment. block_height - unsigned int; Height of the block that first confirmed this payment. unlock_time - unsigned int; Time (in block height) until this payment is safe to spend. subaddr_index - subaddress index: major - unsigned int; Account index for the subaddress. minor - unsigned int; Index of the subaddress in the account. address - string; Address receiving the payment; Base58 representation of the public keys. Example : $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_payments\",\"params\":{\"payment_id\":\"4c746dff9f666d6275a60eb6ecbe5078970d5207bc104032f5afa4878eb414e6\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"payments\": [{ \"address\": \"LTyHcisBFCGQ6nU3D8wtMj5nr9yZfVBqE5pzrKQak5abBPFMx21r5V57UT33hzzzyLA8yaJFyrcj7iJwiQ8Z1zPeK1a7tpo\", \"amount\": 1000000000000, \"block_height\": 127606, \"payment_id\": \"4c746dff9f666d6275a60eb6ecbe5078970d5207bc104032f5afa4878eb414e6\", \"subaddr_index\": { \"major\": 0, \"minor\": 0 }, \"tx_hash\": \"3fc266d4167060613fba401c65e22e7f01e00045070009b99dd15134b60b47e9\", \"unlock_time\": 0 }] } } get_bulk_payments \u00b6 Get a list of incoming payments using a given payment id, or a list of payments ids, from a given height. This method is the preferred method over get_payments because it has the same functionality but is more extendable. Either is fine for looking up transactions by a single payment ID. Alias : None. Inputs : payment_ids - array of: string; Payment IDs used to find the payments (16 characters hex). min_block_height - unsigned int; The block height at which to start looking for payments. Outputs : payments - list of: payment_id - string; Payment ID matching one of the input IDs. tx_hash - string; Transaction hash used as the transaction ID. amount - unsigned int; Amount for this payment. block_height - unsigned int; Height of the block that first confirmed this payment. unlock_time - unsigned int; Time (in block height) until this payment is safe to spend. subaddr_index - subaddress index: major - unsigned int; Account index for the subaddress. minor - unsigned int; Index of the subaddress in the account. address - string; Address receiving the payment; Base58 representation of the public keys. Example : $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_bulk_payments\",\"params\":{\"payment_ids\":[\"60900e5603bf96e3\"],\"min_block_height\":\"120000\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"payments\": [{ \"address\": \"LTyHcisBFCGQ6nU3D8wtMj5nr9yZfVBqE5pzrKQak5abBPFMx21r5V57UT33hzzzyLA8yaJFyrcj7iJwiQ8Z1zPeK1a7tpo\", \"amount\": 1000000000000, \"block_height\": 127606, \"payment_id\": \"4c746dff9f666d6275a60eb6ecbe5078970d5207bc104032f5afa4878eb414e6\", \"subaddr_index\": { \"major\": 0, \"minor\": 0 }, \"tx_hash\": \"3fc266d4167060613fba401c65e22e7f01e00045070009b99dd15134b60b47e9\", \"unlock_time\": 0 }] } } It is important to note that the amounts returned are in base Loki units and not in the display units normally used in end-user applications. Also, since a transaction will typically have multiple outputs that add up to the total required for the payment, the amounts should be grouped by the tx_hash or the payment_id and added together. Additionally, as multiple outputs can have the same amount, it is imperative not to try and filter out the returned data from a single get_bulk_payments call. Before scanning for payments it is useful to check against the daemon RPC API (the get_info RPC call) to see if additional blocks have been received. Typically you would want to then scan only from that received block on by specifying it as the min_block_height to get_bulk_payments . Programatically Scanning for Payments \u00b6 Get the current block height from the daemon, only proceed if it has increased since our last scan. Call the get_bulk_payments RPC API call with our last scanned height and the list of all payment IDs in our system Store the current block height as our last scanned height Remove duplicates based on transaction hashes we have already received and processed Sources \u00b6 https://ww.getmonero.org/get-started/accepting/ https://src.getmonero.org/resources/developer-guides/wallet-rpc.html","title":"Accepting Loki for Merchants and Exchanges"},{"location":"Advanced/AcceptingLoki/#accepting-loki","text":"","title":"Accepting Loki"},{"location":"Advanced/AcceptingLoki/#instructions-for-the-command-line-interface","text":"","title":"Instructions for the Command-Line Interface"},{"location":"Advanced/AcceptingLoki/#the-basics","text":"Loki works a little differently to what you may have become accustomed to from other cryptocurrencies. In the case of a digital currency like Bitcoin and its many derivatives merchant payment systems will usually create a new recipient address for each payment or user. However, because Loki has stealth addresses there is no need to have separate recipient addresses for each payment or user, and a single account address can be published. Instead, when receiving payments a merchant will provide the person paying with a payment ID . A payment ID is a hexadecimal string that is 64 characters long, and is normally randomly created by the merchant. An example of a payment ID is: 326d381588ae509bcf35fc8ae05abd31ba1ef885ced2e5c1f2180f28845d1f6f To generate a payment ID in loki-wallet-cli run the command: payment_id","title":"The Basics"},{"location":"Advanced/AcceptingLoki/#checking-for-a-payment-in-loki-wallet-cli","text":"If you want to check for a payment using loki-wallet-cli you can use the payments command followed by the payment ID or payment IDs you want to check: payments <PID_1> [<PID_2> ... <PID_N>] For example: [wallet L6k67F]: payments 4c746dff9f666d6275a60eb6ecbe5078970d5207bc104032f5afa4878eb414e6 payment transaction height amount unlock time addr index <4c746dff9f666d6275a60eb6ecbe5078970d5207bc104032f5afa4878eb414e6> <3fc266d4167060613fba401c65e22e7f01e00045070009b99dd15134b60b47e9> 191878 1.000000000 0 0 [wallet L6k67F]: If you need to check for payments programmatically, then follow the next section .","title":"Checking for a Payment in loki-wallet-cli"},{"location":"Advanced/AcceptingLoki/#receiving-a-payment-step-by-step","text":"Generate a random 64 character hexadecimal string for the payment Communicate the payment ID and Loki address to the individual who is making payment Check for the payment using the \"payments\" command in loki-wallet-cli","title":"Receiving a Payment Step-by-Step"},{"location":"Advanced/AcceptingLoki/#checking-for-a-payment-programmatically","text":"In order to check for a payment programmatically you can use the get_payments or get_bulk_payments JSON RPC API calls. get_payments : this requires a payment_id parameter with a single payment ID. get_bulk_payments : this is the preferred method, and requires two parameters, payment_ids - a JSON array of payment IDs - and an optional min_block_height - the block height to scan from.","title":"Checking for a Payment Programmatically"},{"location":"Advanced/AcceptingLoki/#get_payments","text":"Get a list of incoming payments using a given payment id. Alias : None. Inputs : payment_id - string; Payment ID used to find the payments (16 characters hex). Outputs : payments - list of: payment_id - string; Payment ID matching the input parameter. tx_hash - string; Transaction hash used as the transaction ID. amount - unsigned int; Amount for this payment. block_height - unsigned int; Height of the block that first confirmed this payment. unlock_time - unsigned int; Time (in block height) until this payment is safe to spend. subaddr_index - subaddress index: major - unsigned int; Account index for the subaddress. minor - unsigned int; Index of the subaddress in the account. address - string; Address receiving the payment; Base58 representation of the public keys. Example : $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_payments\",\"params\":{\"payment_id\":\"4c746dff9f666d6275a60eb6ecbe5078970d5207bc104032f5afa4878eb414e6\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"payments\": [{ \"address\": \"LTyHcisBFCGQ6nU3D8wtMj5nr9yZfVBqE5pzrKQak5abBPFMx21r5V57UT33hzzzyLA8yaJFyrcj7iJwiQ8Z1zPeK1a7tpo\", \"amount\": 1000000000000, \"block_height\": 127606, \"payment_id\": \"4c746dff9f666d6275a60eb6ecbe5078970d5207bc104032f5afa4878eb414e6\", \"subaddr_index\": { \"major\": 0, \"minor\": 0 }, \"tx_hash\": \"3fc266d4167060613fba401c65e22e7f01e00045070009b99dd15134b60b47e9\", \"unlock_time\": 0 }] } }","title":"get_payments"},{"location":"Advanced/AcceptingLoki/#get_bulk_payments","text":"Get a list of incoming payments using a given payment id, or a list of payments ids, from a given height. This method is the preferred method over get_payments because it has the same functionality but is more extendable. Either is fine for looking up transactions by a single payment ID. Alias : None. Inputs : payment_ids - array of: string; Payment IDs used to find the payments (16 characters hex). min_block_height - unsigned int; The block height at which to start looking for payments. Outputs : payments - list of: payment_id - string; Payment ID matching one of the input IDs. tx_hash - string; Transaction hash used as the transaction ID. amount - unsigned int; Amount for this payment. block_height - unsigned int; Height of the block that first confirmed this payment. unlock_time - unsigned int; Time (in block height) until this payment is safe to spend. subaddr_index - subaddress index: major - unsigned int; Account index for the subaddress. minor - unsigned int; Index of the subaddress in the account. address - string; Address receiving the payment; Base58 representation of the public keys. Example : $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_bulk_payments\",\"params\":{\"payment_ids\":[\"60900e5603bf96e3\"],\"min_block_height\":\"120000\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"payments\": [{ \"address\": \"LTyHcisBFCGQ6nU3D8wtMj5nr9yZfVBqE5pzrKQak5abBPFMx21r5V57UT33hzzzyLA8yaJFyrcj7iJwiQ8Z1zPeK1a7tpo\", \"amount\": 1000000000000, \"block_height\": 127606, \"payment_id\": \"4c746dff9f666d6275a60eb6ecbe5078970d5207bc104032f5afa4878eb414e6\", \"subaddr_index\": { \"major\": 0, \"minor\": 0 }, \"tx_hash\": \"3fc266d4167060613fba401c65e22e7f01e00045070009b99dd15134b60b47e9\", \"unlock_time\": 0 }] } } It is important to note that the amounts returned are in base Loki units and not in the display units normally used in end-user applications. Also, since a transaction will typically have multiple outputs that add up to the total required for the payment, the amounts should be grouped by the tx_hash or the payment_id and added together. Additionally, as multiple outputs can have the same amount, it is imperative not to try and filter out the returned data from a single get_bulk_payments call. Before scanning for payments it is useful to check against the daemon RPC API (the get_info RPC call) to see if additional blocks have been received. Typically you would want to then scan only from that received block on by specifying it as the min_block_height to get_bulk_payments .","title":"get_bulk_payments"},{"location":"Advanced/AcceptingLoki/#programatically-scanning-for-payments","text":"Get the current block height from the daemon, only proceed if it has increased since our last scan. Call the get_bulk_payments RPC API call with our last scanned height and the list of all payment IDs in our system Store the current block height as our last scanned height Remove duplicates based on transaction hashes we have already received and processed","title":"Programatically Scanning for Payments"},{"location":"Advanced/AcceptingLoki/#sources","text":"https://ww.getmonero.org/get-started/accepting/ https://src.getmonero.org/resources/developer-guides/wallet-rpc.html","title":"Sources"},{"location":"Advanced/CheckpointingLip3/","text":"Service Node Checkpointing \u00b6 Metadata LIP Number: 3 Title: Service Node Checkpointing [Foundation Vote] Author/s: Kee Jefferys, Jason Rhinelander Status: Final Type: (Core) Created: date (2018-11-30) 1 Simple Summary \u00b6 Consensus via Proof of Work in Loki presents a significant risk of 51% attack. To mitigate this risk and increase security, Loki should leverage the existing Service Node network and integrate Service Nodes more closely into our consensus mechanism. This proposal, if passed, would allow Service Nodes to validate the existing PoW chain to prevent reorganisations of the blockchain greater than N blocks. 2 Abstract \u00b6 Loki currently only uses Proof of Work to come to consensus on the state of the blockchain. Although the introduction of Service Nodes has removed a portion of the block reward from miners, Service Nodes do not create, verify or submit blocks to the network. Proof of Work is a well studied system for forming decentralised consensus, but a number of issues persist, especially for coins with lower market capitalisations. These issues include but are not limited to: Roaming hashrate attacks, Monopooling, and rented hashrate attacks. This proposal presents novel attacks on Loki\u2019s Proof of Work consensus system and proposes Service Node block validation to prevent this. 3 Motivation \u00b6 Proof of Work\u2019s intrinsic value in a blockchain system is derived from its ability to fairly choose who can update the blockchain. Each block requires proof that the block creator has spent some resource that is external to the blockchain itself. Although Proof of Work does well to satisfy the above claims, it also has some major drawbacks. The most pressing for Loki is that of a 51% attack, which would seek to perform a double spend by producing a chain with more proof of work than a canonical chain. Typically when referring to 51% attacks they are strictly theoretical, either requiring unreasonable amounts of money or large amounts of economically disincentivised social collusion. However there are a number of factors which make lower market cap coins like Loki particularly susceptible to 51% attacks. The first being the \u2018roaming hashrate phenomenon,\u2019 which refers to the propensity for miners to quickly move hashrate across networks seeking the most profitable coins, this can create large fluctuations in hashrate which are difficult to control for. Secondly, there are \u2018rented hash power attacks,\u2019 a relatively new phenomena which have seen wide proliferation through services like NiceHash and MiningRigRentals. These services allow users to temporarily rent hashing power for a number of popular hashing algorithms[1][2]. Rented hash attacks become a significant threat when the hashrate available on these services exceeds the hashrate of the minable coin. Finally there is \u2018monopooling,\u2019 which is a complex problem where a large number of miners tend to mine only to the largest pool regardless of the fee structure of that pool. This is often a symptom of the roaming hashrate phoneomenon. If a monopool reaches more than 51% of the network hashrate then it becomes a risk factor for general 51% attacks occurring. These attacks will now be discussed in further detail. 3.1 PoW Disadvantages \u00b6 3.1.1 Roaming Hashrate Phenomenon \u00b6 To understand this phenomenon, it is best to imagine a portion of the \u201cglobal GPU hashrate\u201d as liquid in nature. This hashrate moves between coins based on their short term profitability. This means coins which have a spike in price or a large reduction in difficulty are often mined for short periods of time by this type of miner. The roaming hashrate phenomenon has increased in scale with the adoption of websites which allow miners to easily analyse the profitability of every minable coin live depending on their hardware, and make recommendations on the most profitable coin to mine[3][4][5]. Additionally, developers have created open source utilities which allow a miner\u2019s hashrate to automatically switch between different coins depending on profitability, entirely without user interaction[6]. Figure 1: CryptonightProfitSwitcher CLI utility that automatically targets mining rigs to most profitable CryptoNight coin. Although these miners are not necessarily intending to negatively impact coins, they can further exacerbate deep cycles of hashrate fluctuation when they switch between networks. These deep cycles can be exploited by attackers, either by controlling pools that these miners automatically switch to, or using rented hashing power attacks when profit seeking miners switch off creating a temporary drop in the network hashrate. If done programmatically, the roaming hashrate phenomenon can also contribute to the monopooling phenomenon. 3.1.2 Rented Hashrate Attacks \u00b6 Although the phenomenon of the roaming hashrate would generally be considered as benign and lacking malicious intent, rented hashrate attacks often carry a much greater negative stigma. There have been numerous examples of attackers using rented hashrate to perform a wide variety of attacks, including timestamp forging, difficulty jamming and double spend attacks[7][8][9]. Figure 2 : example of a hashrate attack causing difficulty jamming on the Karbowanec network The proliferation of services like NiceHash and MiningRigRentals make the renting of hashrate easy to even the most basic of attacker. Although the same 51% attacks have always been possible, attackers previously would either have to permanently purchase hardware totaling 51% of the network hashrate, or convince miners to use their malicious pool. These options typically involved large setup costs in hardware, time, or social efforts (and often all three). Miners can now spontaneously set up a private pool with modified malicious software, then rent the needed hashrate to perform a double spend with relative ease. Although this specific issue has not directly affected Loki, there have been notable attacks on a number of Cryptonote coins. This attack becomes easier as the hashing algorithm becomes more available and liquid on NiceHash relative to a coin network\u2019s actual hashrate. This comes as a particular concern for Loki as we have repeatedly lowered rewards for miners which has reduced the network hashrate and led to a significant amount of hashrate moving to more profitable coins. Any plans to increase rewards for Service Nodes further may continue this effect, further reducing the Loki hashrate. This trend is illustrated in figure 3, which shows a trend of growing convergence between Nicehash available hashing power and Loki\u2019s global hashrate. Figure 3: Available NiceHash CryptoNight heavy hashing power versus the Global hashing power of at Loki. 3.1.3 Monopooling \u00b6 We will use the term \u2018monopooling,\u2019 which refers to single pools which dominate more than 51% of the hashrate of a coin\u2019s network. This is a phenomenon which mostly affects small, GPU-mineable coins. The monopools themselves are not necessarily malicious, although provided the right incentive from an attacker they can exert their hashrate over a coin network. Monopooling seems to be the culmination of many of the above phenomenon, being particularly endemic in coins that have issues with roaming hashrate. If we consider a miner who switches between profitable coins using the CryptoNight hashing algorithm, they might switch networks multiple times a day. The most profitable strategy for this miner is not always to seek the pool with the lowest fees, but to join a pool which will will produce more blocks and yield a higher payout in the short time that they are mining. This reduces the variance during the time that they do mine, ensuring that hashes are seldom wasted. If these pools reach over 50% of the hashrate they can also offer advantages to miners. For example in the event of a hard fork, the community and developers of a coin may seek to legitimise the longest chain as the the legitimate chain meaning profits are unlikely to be lost in a split. On a number of coins this leads to large monopools. By measuring the percentage hashrate of the largest pools of 18 small GPU-mineable coins the results indicated that on average these coins had a single pool that represented 53% of their hashrate. Figure 4: Shows the % network hashrate of the largest pool on a number of GPU mineable coins as of 01/12/2018 Although these pools are primarily benign, they still pose a threat due to the control they have over the network. It would be feasible for an attacker to bribe or hack a pool operator to perform a double spend. 4 Specification \u00b6 4.1 Block Validation \u00b6 As a result of the above problems, I propose that Loki utilise Service Nodes to validate the existing Proof of Work chain after N blocks. 4.2 Reorganisation Limits \u00b6 \u2018Checkpoints\u2019 are one way to prevent reorganisations greater than N blocks. Adding a checkpoint to a blockchain dictates that once the checkpoint is reached, the normal rules of Proof of Work are ignored. This means that when a checkpoint is set, block reorganisations past the checkpoint are invalid, even if the proposed candidate for reorganisation contains a longer chain with higher difficulty targets. The other, more naive approach is to simply cap reorganisations greater than P blocks. However there are serious problems with this approach, if an attacker can produce a chain of length P +1 and submit it to a different edge of the network as the non attacking chain is being checkpointed, then the network will diverge and will be unable to merge back into a single chain, effectively permanently forking the chain. This attack could, for example, deliberately target an exchange to put the exchange on a fork controlled by the attacker but distinct from the main network until manual maintenance is undertaken by the exchange to re-sync to the proper network chain. This kind of attack is prevented by Service Node checkpointing, as the attacker would need their two chains to be signed by the quorum to create a conflict. 4.3 Checkpointing Rules \u00b6 Already implemented in Loki are Service Node quorums , which dictate that each block 10 random Service Nodes are selected based on the hash of the 10th previous block to assess the uptime proofs of other Service Nodes. To validate the blockchain every N blocks a new class of Service Node quorums should be selected and be given an additional task, which is to add a checkpoint to the blockchain each time a period N is reached. A Service Node checkpoint should consist of a blockhash, a block height and the signature of a super majority (66%) of the Service Nodes in the relevant quorum. To avoid miners colluding to ignore checkpoints and reorg past the hard limits, the checkpoint should not be included as a transaction in the blockchain. Rather, the checkpoint data should be appended to the \u2018top\u2019 of the block after the fact. All data inside of blocks will maintain immutability, but clients will append the Service Node data outside of the hashed data. Figure 5: example of a Checkpointed block Choosing Chains \u00b6 A Service Node quorum is prevented from checkpointing more than one chain at any time, so behaviour must be written for what should occur when the quorum disagrees on which chain should be checkpointed. First, before any decision is made, each node should share their candidate checkpoint chain with all other nodes in the quorum. Some conditions should be established beyond normal block validation: The proposed chain must be built from one of the last two checkpoints C1 or C2 ; Nodes shall not accept more than ( N *3) - 1 blocks since the last checkpoint (Where N is the reorg limit); If two chains of proof of work are produced with the same cumulative difficulty, Service Nodes should choose the chain based on the lowest hamming distance of the chain tip\u2019s blockhash to 0, and; The latest checkpoint C3 can invalidate two checkpoints back to C1 . Once Service Nodes internally agree on the correct chain, they should all produce a signed copy of the block which should then be submitted to the network. If valid (containing a super majority of Service Node signatures) then the extra Service Node data should be appended to the relevant checkpointed block in all client databases. Why Have More Than One Checkpoint? \u00b6 Adding additional checkpoints to the chain before finalisation adds a high degree of redundancy: in the rare case that a quorum is unable to come to consensus and misses a checkpoint, the chain can continue uninterrupted. The network will then rely on either of the next two quorums which can sign and continue the chain. Service Node Data \u00b6 As discussed, each checkpoint requires that data be appended to the top of blocks. This data should include a couple of things: The blockhash of one of the last two checkpointed blocks; The Service Node data hash of one of the last two checkpointed blocks, and; A super majority of the selected quorum signatures singing the blockhash of the new block to be checkpointed. Practical Issues with Checkpointing \u00b6 When checkpointing or setting reorganisation limits, the question must always be asked: can the blockchain self repair, and in what situation could the blockchain become stuck or permanently forked? If we imagine a protocol bug that causes the blockchain to stop after a reorganisation point or an invalid block is checkpointed, then there is no way to continue the chain, since the longer chain can never reorganise past the first checkpoint on chain 1 as shown in figure 6. Figure 6: Blockchain with unrepairable checkpoints, N = 4 The only way to overcome this issue is to allow Service Nodes to simultaneously sign multiple chains. Clients must measure the dominant chain as the one with the most Service Node signatures. However, this reintroduces the risk of a double spend as Service Nodes can now authorise duplicate chains outside of N . Figure 7: Blockchain as measured by signature weight This leads us to the conclusion that chain reparability and double spend protection are mutually exclusive, since any transactions that were accepted in chain 1 (figure 7) could be reversed in chain 2. 4.4 Proposed Checkpointing in Loki \u00b6 After assessing the above issues I believe Loki should value double spend protection over absolute chain repariablity for a couple of reasons: Chain reparability is already a problem present in Loki\u2019s current PoW. If a chain of blocks is mined and then there is a bug encountered, then that bug is likely to cause an issue for all miners, in this case the Loki team or a third party would have to release new software which would allow miners and clients to sync past the faulty block. This would be the same scenario if an invalid block was to be checkpointed. Thus the introduction of checkpoints doesn\u2019t significantly impact the potential consequences of a bug that causes a chain pause. An active double spend on the Loki network is likely to cause more damage to the ecosystem than a temporary chain pause. Double spends can shake confidence and erode the trust of users and merchants which accept and exchange Loki, a chain pause may be a lower impact event, since no funds are lost and merchants/exchanges can resume normally after the pause. 4.5 Rewards and Consequences \u00b6 This LIP does not seek to increase the Service Node block reward, however it would add additional conditions to a Service Node receiving its normal portion of the block rewards. The primary things we want to prevent Service Nodes from doing are: Checkpointing more than one chain; Checkpointing a chain that defies the consensus of the Service Node quorum, and; Failing to sign any chain despite being in a selected Service Node quorum. The first and second rules can be easily detected by allowing Service Nodes to submit any Service Node\u2019s signature as evidence for a deregistration transaction if the signature conflicts with an existing onchain checkpoint. Rule 3 can be solved by investigating each checkpoint for all Service Node signatures. Because Service Node quorum selection is deterministic, if any checkpoint is missing a Service Node signature more than once, the next quorum should have the ability to vote that non-voting Service Node off the network through a deregistration transaction. 4.6 Setting N \u00b6 N is the depth of the chain before checkpointing occurs. The appropriate N should consider the propensity of natural reorganisations in the Loki blockchain, which happen to occur at a rate of approximately 20 per 10,000 blocks and at an average reorg height of 1.3 blocks. We should also consider the time it will take for a Service Node to actually checkpoint the chain. Currently, processing votes for deregistration takes approximately 1-2 blocks. Taking this into account I propose we set N = 4. In the future we should consider lowering this time if we have good reason to do so. 4.7 DDoS Protection \u00b6 Because Service Node quorums are deterministically selected before checkpointing blocks and Service Node IP addresses are publicly stored on a DHT in Lokinet, it is important to consider an attacker who would seek to disrupt consensus communications. Without protections an attacker could carry out a DDoS attack as Service Nodes were checkpointing the chain in an attempt to disrupt communications and prevent the chain from successfully being checkpointed. Because a super majority of quorum signatures is required to sign a block and the quorum size is 20, the attack would only need to prevent communication of 18 nodes over the course of two consecutive checkpoints to freeze the blockchain. The novel protection for this attack is Service Nodes having the ability to whitelist other nodes inside of their own active quorum when Service Nodes detects an attack. Practically speaking, Service Nodes would turn on this protection automatically when the previous quorum has failed to sign a block. This method allows nodes to communicate and come to consensus on the correct chain to sign, without accepting connections from unknown IP addresses potentially attempting DDoS attacks. Once finished checkpointing the quorum should again regain normal functionality. 4.8 Considerations for Merchants and Exchanges \u00b6 An RPC call should be added to the Loki daemon to indicate the state of the current chain\u2019s checkpoints. This RPC call will indicate the height of the last four blocks which were checkpointed. Merchants can with an extremely high degree of certainty accept any chain with more than two checkpoints and with a high degree of certainty accept a chain that has received a single checkpoint from a Service Node quorum. Any block deeper than 12 blocks in the chain that has more than three checkpoints should then be considered final and cannot be reorganised. If two checkpoints have been missed in a row, this RPC call should indicate that there may be a serious error on the network and the merchant/exchange should disable withdrawals deposits temporarily while investigating the state of the chain. Backwards Capability \u00b6 The Switch \u00b6 This proposal is not backwards compatible and will require a hard fork to enact. As stated, this change introduces a significant alteration to the way we will measure consensus on the Loki chain. Before making this change we should thoroughly discuss the potential consequences and recognise opposing opinions. Implementation \u00b6 This LIP will be opened for public discussion prior to a Foundation vote. If the vote is successful, the code will be written and submitted as a pull request which will be open to community review. These developments shall be linked here as they occur. LIP-3 Has been approved by the Loki Foundation, we will be moving forward with progress over the coming months, progress will be reflected in our weekly dev updates References \u00b6 \"NiceHash.\" https://www.nicehash.com/ . \"Mining Rig Rentals.\" https://www.miningrigrentals.com/ . \"CryptUnit.\" https://www.cryptunit.com/ . \"WhatToMine.\" https://whattomine.com/ . \"Comparing mining profitability of CryptoNight coins.\" https://minecryptonight.net/ . \"GitHub - cryptoprofitswitcher/CryptonightProfitSwitcher: Extensible ....\" https://github.com/cryptoprofitswitcher/CryptonightProfitSwitcher . \"Let's Do the Time Warp Again: The Verge Hack, Part Deux.\" 5 Jun. 2018, https://blog.theabacus.io/lets-do-the-time-warp-again-the-verge-hack-part-deux-c6396ab36ecb . \"GRAFT Network Major Update 1.1.2 at Block 64445 - Graft Blockchain.\" 17 Apr. 2018, https://www.graft.network/2018/04/17/graft-network-node-update-1-1-2-block-64445/ . \"Double Spend Attacks on Exchanges - Announcements and Site ....\" 18 May. 2018, https://forum.bitcoingold.org/t/double-spend-attacks-on-exchanges/1362 .","title":"Checkpointing LIP"},{"location":"Advanced/CheckpointingLip3/#service-node-checkpointing","text":"Metadata LIP Number: 3 Title: Service Node Checkpointing [Foundation Vote] Author/s: Kee Jefferys, Jason Rhinelander Status: Final Type: (Core) Created: date (2018-11-30)","title":"Service Node Checkpointing"},{"location":"Advanced/CheckpointingLip3/#1-simple-summary","text":"Consensus via Proof of Work in Loki presents a significant risk of 51% attack. To mitigate this risk and increase security, Loki should leverage the existing Service Node network and integrate Service Nodes more closely into our consensus mechanism. This proposal, if passed, would allow Service Nodes to validate the existing PoW chain to prevent reorganisations of the blockchain greater than N blocks.","title":"1 Simple Summary"},{"location":"Advanced/CheckpointingLip3/#2-abstract","text":"Loki currently only uses Proof of Work to come to consensus on the state of the blockchain. Although the introduction of Service Nodes has removed a portion of the block reward from miners, Service Nodes do not create, verify or submit blocks to the network. Proof of Work is a well studied system for forming decentralised consensus, but a number of issues persist, especially for coins with lower market capitalisations. These issues include but are not limited to: Roaming hashrate attacks, Monopooling, and rented hashrate attacks. This proposal presents novel attacks on Loki\u2019s Proof of Work consensus system and proposes Service Node block validation to prevent this.","title":"2 Abstract"},{"location":"Advanced/CheckpointingLip3/#3-motivation","text":"Proof of Work\u2019s intrinsic value in a blockchain system is derived from its ability to fairly choose who can update the blockchain. Each block requires proof that the block creator has spent some resource that is external to the blockchain itself. Although Proof of Work does well to satisfy the above claims, it also has some major drawbacks. The most pressing for Loki is that of a 51% attack, which would seek to perform a double spend by producing a chain with more proof of work than a canonical chain. Typically when referring to 51% attacks they are strictly theoretical, either requiring unreasonable amounts of money or large amounts of economically disincentivised social collusion. However there are a number of factors which make lower market cap coins like Loki particularly susceptible to 51% attacks. The first being the \u2018roaming hashrate phenomenon,\u2019 which refers to the propensity for miners to quickly move hashrate across networks seeking the most profitable coins, this can create large fluctuations in hashrate which are difficult to control for. Secondly, there are \u2018rented hash power attacks,\u2019 a relatively new phenomena which have seen wide proliferation through services like NiceHash and MiningRigRentals. These services allow users to temporarily rent hashing power for a number of popular hashing algorithms[1][2]. Rented hash attacks become a significant threat when the hashrate available on these services exceeds the hashrate of the minable coin. Finally there is \u2018monopooling,\u2019 which is a complex problem where a large number of miners tend to mine only to the largest pool regardless of the fee structure of that pool. This is often a symptom of the roaming hashrate phoneomenon. If a monopool reaches more than 51% of the network hashrate then it becomes a risk factor for general 51% attacks occurring. These attacks will now be discussed in further detail.","title":"3 Motivation"},{"location":"Advanced/CheckpointingLip3/#31-pow-disadvantages","text":"","title":"3.1 PoW Disadvantages"},{"location":"Advanced/CheckpointingLip3/#311-roaming-hashrate-phenomenon","text":"To understand this phenomenon, it is best to imagine a portion of the \u201cglobal GPU hashrate\u201d as liquid in nature. This hashrate moves between coins based on their short term profitability. This means coins which have a spike in price or a large reduction in difficulty are often mined for short periods of time by this type of miner. The roaming hashrate phenomenon has increased in scale with the adoption of websites which allow miners to easily analyse the profitability of every minable coin live depending on their hardware, and make recommendations on the most profitable coin to mine[3][4][5]. Additionally, developers have created open source utilities which allow a miner\u2019s hashrate to automatically switch between different coins depending on profitability, entirely without user interaction[6]. Figure 1: CryptonightProfitSwitcher CLI utility that automatically targets mining rigs to most profitable CryptoNight coin. Although these miners are not necessarily intending to negatively impact coins, they can further exacerbate deep cycles of hashrate fluctuation when they switch between networks. These deep cycles can be exploited by attackers, either by controlling pools that these miners automatically switch to, or using rented hashing power attacks when profit seeking miners switch off creating a temporary drop in the network hashrate. If done programmatically, the roaming hashrate phenomenon can also contribute to the monopooling phenomenon.","title":"3.1.1 Roaming Hashrate Phenomenon"},{"location":"Advanced/CheckpointingLip3/#312-rented-hashrate-attacks","text":"Although the phenomenon of the roaming hashrate would generally be considered as benign and lacking malicious intent, rented hashrate attacks often carry a much greater negative stigma. There have been numerous examples of attackers using rented hashrate to perform a wide variety of attacks, including timestamp forging, difficulty jamming and double spend attacks[7][8][9]. Figure 2 : example of a hashrate attack causing difficulty jamming on the Karbowanec network The proliferation of services like NiceHash and MiningRigRentals make the renting of hashrate easy to even the most basic of attacker. Although the same 51% attacks have always been possible, attackers previously would either have to permanently purchase hardware totaling 51% of the network hashrate, or convince miners to use their malicious pool. These options typically involved large setup costs in hardware, time, or social efforts (and often all three). Miners can now spontaneously set up a private pool with modified malicious software, then rent the needed hashrate to perform a double spend with relative ease. Although this specific issue has not directly affected Loki, there have been notable attacks on a number of Cryptonote coins. This attack becomes easier as the hashing algorithm becomes more available and liquid on NiceHash relative to a coin network\u2019s actual hashrate. This comes as a particular concern for Loki as we have repeatedly lowered rewards for miners which has reduced the network hashrate and led to a significant amount of hashrate moving to more profitable coins. Any plans to increase rewards for Service Nodes further may continue this effect, further reducing the Loki hashrate. This trend is illustrated in figure 3, which shows a trend of growing convergence between Nicehash available hashing power and Loki\u2019s global hashrate. Figure 3: Available NiceHash CryptoNight heavy hashing power versus the Global hashing power of at Loki.","title":"3.1.2 Rented Hashrate Attacks"},{"location":"Advanced/CheckpointingLip3/#313-monopooling","text":"We will use the term \u2018monopooling,\u2019 which refers to single pools which dominate more than 51% of the hashrate of a coin\u2019s network. This is a phenomenon which mostly affects small, GPU-mineable coins. The monopools themselves are not necessarily malicious, although provided the right incentive from an attacker they can exert their hashrate over a coin network. Monopooling seems to be the culmination of many of the above phenomenon, being particularly endemic in coins that have issues with roaming hashrate. If we consider a miner who switches between profitable coins using the CryptoNight hashing algorithm, they might switch networks multiple times a day. The most profitable strategy for this miner is not always to seek the pool with the lowest fees, but to join a pool which will will produce more blocks and yield a higher payout in the short time that they are mining. This reduces the variance during the time that they do mine, ensuring that hashes are seldom wasted. If these pools reach over 50% of the hashrate they can also offer advantages to miners. For example in the event of a hard fork, the community and developers of a coin may seek to legitimise the longest chain as the the legitimate chain meaning profits are unlikely to be lost in a split. On a number of coins this leads to large monopools. By measuring the percentage hashrate of the largest pools of 18 small GPU-mineable coins the results indicated that on average these coins had a single pool that represented 53% of their hashrate. Figure 4: Shows the % network hashrate of the largest pool on a number of GPU mineable coins as of 01/12/2018 Although these pools are primarily benign, they still pose a threat due to the control they have over the network. It would be feasible for an attacker to bribe or hack a pool operator to perform a double spend.","title":"3.1.3 Monopooling"},{"location":"Advanced/CheckpointingLip3/#4-specification","text":"","title":"4 Specification"},{"location":"Advanced/CheckpointingLip3/#41-block-validation","text":"As a result of the above problems, I propose that Loki utilise Service Nodes to validate the existing Proof of Work chain after N blocks.","title":"4.1 Block Validation"},{"location":"Advanced/CheckpointingLip3/#42-reorganisation-limits","text":"\u2018Checkpoints\u2019 are one way to prevent reorganisations greater than N blocks. Adding a checkpoint to a blockchain dictates that once the checkpoint is reached, the normal rules of Proof of Work are ignored. This means that when a checkpoint is set, block reorganisations past the checkpoint are invalid, even if the proposed candidate for reorganisation contains a longer chain with higher difficulty targets. The other, more naive approach is to simply cap reorganisations greater than P blocks. However there are serious problems with this approach, if an attacker can produce a chain of length P +1 and submit it to a different edge of the network as the non attacking chain is being checkpointed, then the network will diverge and will be unable to merge back into a single chain, effectively permanently forking the chain. This attack could, for example, deliberately target an exchange to put the exchange on a fork controlled by the attacker but distinct from the main network until manual maintenance is undertaken by the exchange to re-sync to the proper network chain. This kind of attack is prevented by Service Node checkpointing, as the attacker would need their two chains to be signed by the quorum to create a conflict.","title":"4.2 Reorganisation Limits"},{"location":"Advanced/CheckpointingLip3/#43-checkpointing-rules","text":"Already implemented in Loki are Service Node quorums , which dictate that each block 10 random Service Nodes are selected based on the hash of the 10th previous block to assess the uptime proofs of other Service Nodes. To validate the blockchain every N blocks a new class of Service Node quorums should be selected and be given an additional task, which is to add a checkpoint to the blockchain each time a period N is reached. A Service Node checkpoint should consist of a blockhash, a block height and the signature of a super majority (66%) of the Service Nodes in the relevant quorum. To avoid miners colluding to ignore checkpoints and reorg past the hard limits, the checkpoint should not be included as a transaction in the blockchain. Rather, the checkpoint data should be appended to the \u2018top\u2019 of the block after the fact. All data inside of blocks will maintain immutability, but clients will append the Service Node data outside of the hashed data. Figure 5: example of a Checkpointed block","title":"4.3 Checkpointing Rules"},{"location":"Advanced/CheckpointingLip3/#choosing-chains","text":"A Service Node quorum is prevented from checkpointing more than one chain at any time, so behaviour must be written for what should occur when the quorum disagrees on which chain should be checkpointed. First, before any decision is made, each node should share their candidate checkpoint chain with all other nodes in the quorum. Some conditions should be established beyond normal block validation: The proposed chain must be built from one of the last two checkpoints C1 or C2 ; Nodes shall not accept more than ( N *3) - 1 blocks since the last checkpoint (Where N is the reorg limit); If two chains of proof of work are produced with the same cumulative difficulty, Service Nodes should choose the chain based on the lowest hamming distance of the chain tip\u2019s blockhash to 0, and; The latest checkpoint C3 can invalidate two checkpoints back to C1 . Once Service Nodes internally agree on the correct chain, they should all produce a signed copy of the block which should then be submitted to the network. If valid (containing a super majority of Service Node signatures) then the extra Service Node data should be appended to the relevant checkpointed block in all client databases.","title":"Choosing Chains"},{"location":"Advanced/CheckpointingLip3/#why-have-more-than-one-checkpoint","text":"Adding additional checkpoints to the chain before finalisation adds a high degree of redundancy: in the rare case that a quorum is unable to come to consensus and misses a checkpoint, the chain can continue uninterrupted. The network will then rely on either of the next two quorums which can sign and continue the chain.","title":"Why Have More Than One Checkpoint?"},{"location":"Advanced/CheckpointingLip3/#service-node-data","text":"As discussed, each checkpoint requires that data be appended to the top of blocks. This data should include a couple of things: The blockhash of one of the last two checkpointed blocks; The Service Node data hash of one of the last two checkpointed blocks, and; A super majority of the selected quorum signatures singing the blockhash of the new block to be checkpointed.","title":"Service Node Data"},{"location":"Advanced/CheckpointingLip3/#practical-issues-with-checkpointing","text":"When checkpointing or setting reorganisation limits, the question must always be asked: can the blockchain self repair, and in what situation could the blockchain become stuck or permanently forked? If we imagine a protocol bug that causes the blockchain to stop after a reorganisation point or an invalid block is checkpointed, then there is no way to continue the chain, since the longer chain can never reorganise past the first checkpoint on chain 1 as shown in figure 6. Figure 6: Blockchain with unrepairable checkpoints, N = 4 The only way to overcome this issue is to allow Service Nodes to simultaneously sign multiple chains. Clients must measure the dominant chain as the one with the most Service Node signatures. However, this reintroduces the risk of a double spend as Service Nodes can now authorise duplicate chains outside of N . Figure 7: Blockchain as measured by signature weight This leads us to the conclusion that chain reparability and double spend protection are mutually exclusive, since any transactions that were accepted in chain 1 (figure 7) could be reversed in chain 2.","title":"Practical Issues with Checkpointing"},{"location":"Advanced/CheckpointingLip3/#44-proposed-checkpointing-in-loki","text":"After assessing the above issues I believe Loki should value double spend protection over absolute chain repariablity for a couple of reasons: Chain reparability is already a problem present in Loki\u2019s current PoW. If a chain of blocks is mined and then there is a bug encountered, then that bug is likely to cause an issue for all miners, in this case the Loki team or a third party would have to release new software which would allow miners and clients to sync past the faulty block. This would be the same scenario if an invalid block was to be checkpointed. Thus the introduction of checkpoints doesn\u2019t significantly impact the potential consequences of a bug that causes a chain pause. An active double spend on the Loki network is likely to cause more damage to the ecosystem than a temporary chain pause. Double spends can shake confidence and erode the trust of users and merchants which accept and exchange Loki, a chain pause may be a lower impact event, since no funds are lost and merchants/exchanges can resume normally after the pause.","title":"4.4 Proposed Checkpointing in Loki"},{"location":"Advanced/CheckpointingLip3/#45-rewards-and-consequences","text":"This LIP does not seek to increase the Service Node block reward, however it would add additional conditions to a Service Node receiving its normal portion of the block rewards. The primary things we want to prevent Service Nodes from doing are: Checkpointing more than one chain; Checkpointing a chain that defies the consensus of the Service Node quorum, and; Failing to sign any chain despite being in a selected Service Node quorum. The first and second rules can be easily detected by allowing Service Nodes to submit any Service Node\u2019s signature as evidence for a deregistration transaction if the signature conflicts with an existing onchain checkpoint. Rule 3 can be solved by investigating each checkpoint for all Service Node signatures. Because Service Node quorum selection is deterministic, if any checkpoint is missing a Service Node signature more than once, the next quorum should have the ability to vote that non-voting Service Node off the network through a deregistration transaction.","title":"4.5 Rewards and Consequences"},{"location":"Advanced/CheckpointingLip3/#46-setting-n","text":"N is the depth of the chain before checkpointing occurs. The appropriate N should consider the propensity of natural reorganisations in the Loki blockchain, which happen to occur at a rate of approximately 20 per 10,000 blocks and at an average reorg height of 1.3 blocks. We should also consider the time it will take for a Service Node to actually checkpoint the chain. Currently, processing votes for deregistration takes approximately 1-2 blocks. Taking this into account I propose we set N = 4. In the future we should consider lowering this time if we have good reason to do so.","title":"4.6 Setting N"},{"location":"Advanced/CheckpointingLip3/#47-ddos-protection","text":"Because Service Node quorums are deterministically selected before checkpointing blocks and Service Node IP addresses are publicly stored on a DHT in Lokinet, it is important to consider an attacker who would seek to disrupt consensus communications. Without protections an attacker could carry out a DDoS attack as Service Nodes were checkpointing the chain in an attempt to disrupt communications and prevent the chain from successfully being checkpointed. Because a super majority of quorum signatures is required to sign a block and the quorum size is 20, the attack would only need to prevent communication of 18 nodes over the course of two consecutive checkpoints to freeze the blockchain. The novel protection for this attack is Service Nodes having the ability to whitelist other nodes inside of their own active quorum when Service Nodes detects an attack. Practically speaking, Service Nodes would turn on this protection automatically when the previous quorum has failed to sign a block. This method allows nodes to communicate and come to consensus on the correct chain to sign, without accepting connections from unknown IP addresses potentially attempting DDoS attacks. Once finished checkpointing the quorum should again regain normal functionality.","title":"4.7 DDoS Protection"},{"location":"Advanced/CheckpointingLip3/#48-considerations-for-merchants-and-exchanges","text":"An RPC call should be added to the Loki daemon to indicate the state of the current chain\u2019s checkpoints. This RPC call will indicate the height of the last four blocks which were checkpointed. Merchants can with an extremely high degree of certainty accept any chain with more than two checkpoints and with a high degree of certainty accept a chain that has received a single checkpoint from a Service Node quorum. Any block deeper than 12 blocks in the chain that has more than three checkpoints should then be considered final and cannot be reorganised. If two checkpoints have been missed in a row, this RPC call should indicate that there may be a serious error on the network and the merchant/exchange should disable withdrawals deposits temporarily while investigating the state of the chain.","title":"4.8 Considerations for Merchants and Exchanges"},{"location":"Advanced/CheckpointingLip3/#backwards-capability","text":"","title":"Backwards Capability"},{"location":"Advanced/CheckpointingLip3/#the-switch","text":"This proposal is not backwards compatible and will require a hard fork to enact. As stated, this change introduces a significant alteration to the way we will measure consensus on the Loki chain. Before making this change we should thoroughly discuss the potential consequences and recognise opposing opinions.","title":"The Switch"},{"location":"Advanced/CheckpointingLip3/#implementation","text":"This LIP will be opened for public discussion prior to a Foundation vote. If the vote is successful, the code will be written and submitted as a pull request which will be open to community review. These developments shall be linked here as they occur. LIP-3 Has been approved by the Loki Foundation, we will be moving forward with progress over the coming months, progress will be reflected in our weekly dev updates","title":"Implementation"},{"location":"Advanced/CheckpointingLip3/#references","text":"\"NiceHash.\" https://www.nicehash.com/ . \"Mining Rig Rentals.\" https://www.miningrigrentals.com/ . \"CryptUnit.\" https://www.cryptunit.com/ . \"WhatToMine.\" https://whattomine.com/ . \"Comparing mining profitability of CryptoNight coins.\" https://minecryptonight.net/ . \"GitHub - cryptoprofitswitcher/CryptonightProfitSwitcher: Extensible ....\" https://github.com/cryptoprofitswitcher/CryptonightProfitSwitcher . \"Let's Do the Time Warp Again: The Verge Hack, Part Deux.\" 5 Jun. 2018, https://blog.theabacus.io/lets-do-the-time-warp-again-the-verge-hack-part-deux-c6396ab36ecb . \"GRAFT Network Major Update 1.1.2 at Block 64445 - Graft Blockchain.\" 17 Apr. 2018, https://www.graft.network/2018/04/17/graft-network-node-update-1-1-2-block-64445/ . \"Double Spend Attacks on Exchanges - Announcements and Site ....\" 18 May. 2018, https://forum.bitcoingold.org/t/double-spend-attacks-on-exchanges/1362 .","title":"References"},{"location":"Advanced/CheckpointingUpdate/","text":"Safely Receiving Loki \u00b6 In v5.1.2, the Daemon and Wallet have new fields added to indicate if a transaction is backed by a checkpoint. This means that the transaction has atleast 2 consecutive Service Node checkpoints proceeding it, meaning, effectively the transaction can not be reorganised and hence can not be double spent - once checkpointed. Changes \u00b6 For lokid in get_info we return a new field: - immutable_height - uint64 : The latest height in the blockchain that can not be reorganized from (backed by atleast 2 Service Node, or 1 hardcoded checkpoint, 0 if N/A). { \"status\": \"OK\", \"height\": 234767, \"target_height\": 123, \"immutable_height\": 123, ... } For loki-wallet-rpc in get_transfers we return a new field: - checkpointed - uint64 : If transfer is backed by atleast 2 Service Node Checkpoints, 0 if it is not, see immutable_height in the daemon rpc call get_info For example, if you were requesting for incoming payments- the checkpointed field would look like below. \"in\": [{ \"txid\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"payment_id\": \"f378710e54eeeb8d\", \"height\": 234767, \"timestamp\": 123, \"amount\": 123, \"fee\": 123, \"note\": \"User assigned note describing something\", \"destinations\": [{ \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"amount\": 123 }], \"type\": \"in\", \"unlock_time\": 123, \"subaddr_index\": { \"major\": 2130706433, \"minor\": 2130706433 }, \"subaddr_indices\": [{ \"major\": 2130706433, \"minor\": 2130706433 }], \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"double_spend_seen\": true, \"confirmations\": 123, \"suggested_confirmations_threshold\": 123, \"checkpointed\": 1 }], Command Line Interface \u00b6 This new information is also exposed in the CLI wallet as well: With show_transfers : 132272 miner locked checkpointed 2019-10-02 07:34 23.533008373 67192cb1c75968511d2c888a1e9007a7b54da873eb6edfbb430b27559c6c3cb0 0000000000000000 0.000000000 - 0 - 132282 miner locked no 2019-10-02 07:52 23.531838962 7bc31379ba626ea73f105603689c0e2dc2d42934f2fca6f6277dc8296637bc41 0000000000000000 0.000000000 - 0 - With show_transfer 67192cb1c75968511d2c888a1e9007a7b54da873eb6edfbb430b27559c6c3cb0 : Incoming transaction found txid: <67192cb1c75968511d2c888a1e9007a7b54da873eb6edfbb430b27559c6c3cb0> Height: 132272 Timestamp: 2019-10-02 07:34:33 Amount: 23.533008373 Payment ID: 0000000000000000 Locked: 23 blocks to unlock Checkpointed: Yes Address index: 0 Note: In export_transfers : block, type, lock, checkpointed, timestamp, amount, running balance, hash, payment ID, fee, destination, amount,index,note 1, miner,unlocked, checkpointed,2019-03-07 09:14, 116.603178672, 116.603178672,f8c621b85c86fc4e1f3c0f93954cd28a941ebe1ae5998d0bf0198ccf504c47ab,0000000000000000, 0.000000000, -, ,\"0\", 2, miner,unlocked, checkpointed,2019-03-07 09:14, 121.597967646, 238.201146318,dd4dd84f255c457bcf937e4a146193043f9e1318dabe00cd1cde60d8929f493b,0000000000000000, 0.000000000, -, ,\"0\", The changes to RPC are formally documented in our Loki Documentation website (it is currently being updated and will be shortly available). - WalletRPCBeta - DaemonRPCBeta The commit that introduced these changes, which also has some more ad-hoc documentation (whilst Loki Documentation is being updated) is available here https://github.com/loki-project/loki/pull/866","title":"Safely Receiving Loki"},{"location":"Advanced/CheckpointingUpdate/#safely-receiving-loki","text":"In v5.1.2, the Daemon and Wallet have new fields added to indicate if a transaction is backed by a checkpoint. This means that the transaction has atleast 2 consecutive Service Node checkpoints proceeding it, meaning, effectively the transaction can not be reorganised and hence can not be double spent - once checkpointed.","title":"Safely Receiving Loki"},{"location":"Advanced/CheckpointingUpdate/#changes","text":"For lokid in get_info we return a new field: - immutable_height - uint64 : The latest height in the blockchain that can not be reorganized from (backed by atleast 2 Service Node, or 1 hardcoded checkpoint, 0 if N/A). { \"status\": \"OK\", \"height\": 234767, \"target_height\": 123, \"immutable_height\": 123, ... } For loki-wallet-rpc in get_transfers we return a new field: - checkpointed - uint64 : If transfer is backed by atleast 2 Service Node Checkpoints, 0 if it is not, see immutable_height in the daemon rpc call get_info For example, if you were requesting for incoming payments- the checkpointed field would look like below. \"in\": [{ \"txid\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"payment_id\": \"f378710e54eeeb8d\", \"height\": 234767, \"timestamp\": 123, \"amount\": 123, \"fee\": 123, \"note\": \"User assigned note describing something\", \"destinations\": [{ \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"amount\": 123 }], \"type\": \"in\", \"unlock_time\": 123, \"subaddr_index\": { \"major\": 2130706433, \"minor\": 2130706433 }, \"subaddr_indices\": [{ \"major\": 2130706433, \"minor\": 2130706433 }], \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"double_spend_seen\": true, \"confirmations\": 123, \"suggested_confirmations_threshold\": 123, \"checkpointed\": 1 }],","title":"Changes"},{"location":"Advanced/CheckpointingUpdate/#command-line-interface","text":"This new information is also exposed in the CLI wallet as well: With show_transfers : 132272 miner locked checkpointed 2019-10-02 07:34 23.533008373 67192cb1c75968511d2c888a1e9007a7b54da873eb6edfbb430b27559c6c3cb0 0000000000000000 0.000000000 - 0 - 132282 miner locked no 2019-10-02 07:52 23.531838962 7bc31379ba626ea73f105603689c0e2dc2d42934f2fca6f6277dc8296637bc41 0000000000000000 0.000000000 - 0 - With show_transfer 67192cb1c75968511d2c888a1e9007a7b54da873eb6edfbb430b27559c6c3cb0 : Incoming transaction found txid: <67192cb1c75968511d2c888a1e9007a7b54da873eb6edfbb430b27559c6c3cb0> Height: 132272 Timestamp: 2019-10-02 07:34:33 Amount: 23.533008373 Payment ID: 0000000000000000 Locked: 23 blocks to unlock Checkpointed: Yes Address index: 0 Note: In export_transfers : block, type, lock, checkpointed, timestamp, amount, running balance, hash, payment ID, fee, destination, amount,index,note 1, miner,unlocked, checkpointed,2019-03-07 09:14, 116.603178672, 116.603178672,f8c621b85c86fc4e1f3c0f93954cd28a941ebe1ae5998d0bf0198ccf504c47ab,0000000000000000, 0.000000000, -, ,\"0\", 2, miner,unlocked, checkpointed,2019-03-07 09:14, 121.597967646, 238.201146318,dd4dd84f255c457bcf937e4a146193043f9e1318dabe00cd1cde60d8929f493b,0000000000000000, 0.000000000, -, ,\"0\", The changes to RPC are formally documented in our Loki Documentation website (it is currently being updated and will be shortly available). - WalletRPCBeta - DaemonRPCBeta The commit that introduced these changes, which also has some more ad-hoc documentation (whilst Loki Documentation is being updated) is available here https://github.com/loki-project/loki/pull/866","title":"Command Line Interface"},{"location":"Advanced/CryptoNoteElements/","text":"CryptoNote Elements \u00b6 Loki uses the Monero source code because of the high level of privacy it affords to transactions. Monero is an evolution on the CryptoNote protocol , which uses ring signatures , stealth addresses , and RingCT , giving users the ability to sign transactions and obfuscate amounts while maintaining plausible deniability. Ring Signatures \u00b6 Ring signatures work by constructing a ring of possible signers to a transaction where only one of the signers is the actual sender. Loki makes use of ring signatures to obfuscate the true history of transaction outputs. Ring signatures will be mandatory for all Loki transactions (excluding block reward transactions), and uniquely, a fixed ring-size of ten is enforced on the Loki blockchain. This means that each input will spend from one of ten possible outputs, including the true output. Ring Signature Size \u00b6 The size of a ring signature refers to how many mixins are used to construct the ring. Monero currently has an enforced minimum ring signature size of seven, with six mixins used alongside the real unspent output in a transaction. The effect of larger ring-sizes has been sparsely studied, however, in paper 0001 (published by the Monero Research Lab), the effect of differing ring-sizes was analysed versus an attacker who owned a large number of outputs on the blockchain . It was found that higher ring-sizes reduce the timeframe in which a malicious attacker who owned a large number of unspent outputs would be able to perform effective analysis of transactions. Mandating larger ring-sizes also protects against a theoretical attack known as an EABE/Knacc attack , where a third-party (i.e. an exchange) can perform limited temporal analysis on transactions between two users. Additionally, Monero has no maximum ring-size enforced by network consensus rules. Many wallets like the Monero GUI wallet cap the ring-size at 26. However, a user is free to manually create a transaction with whatever ring-size they wish, as long as it is above a ring-size of seven. This is problematic since most wallets have a default ring-size of seven. Increasing a transactions ring-size above seven makes it stand out. Further, if an individuals transactions were to always use a non-standard ring-size in Monero (ten for example), a passive third-party could analyse the blockchain and infer patterns using temporal analysis. transaction hash ring size tx size[kB] 3feaff3f48de0bc4c92ec027236165337b64df404aca098e212c1215e9456697 7 13.47 39d484f7c0a2e8f3823a514056d7cb0bf269171cb4582e05955d4c5ee995cad0 7 13.47 e08f5a937e725011bedd44075334ae98dcca32749da231c56da1278d49c0a231 7 13.50 ab35e69d9cca39219c90df8b2b7aab4a54c82127fb1fbaae65d76357f8f76387 7 13.5 6d8ccd56dc2d3eb7de03ba767f0dbf4d5f42ae91e67f4c28f16d6f8b0229c272 10 13.87 Loki Static Ring Size \u00b6 Loki improves on both of these problems by statically enforcing ring-sizes, and setting the ring-size to ten. Statically setting the maximum ring-size protects users who construct rings with more than nine mixins and setting the ring-size minimum to ten more effectively prevents an attacker who owns a large number of outputs from discerning the true outputs spent in a ring signature. Larger ring-sizes also increase the default churning effectiveness non-linearly, becoming more effective as ring-sizes grow. In the current transaction scheme, increasing the ring-size to 10 would lead to a 2.6% increase in the size of the transaction. However, when Bulletproofs are implemented it will account for about a 8 - 13% increase in the size of a transaction. This is because of the overall reduction in transaction size caused by Bulletproofs. Increasing the minimum ring-size may present a problem on a network that lacks architecture to support larger sized transactions, due to the increased overhead. With Loki however, this burden can be carried by Service Nodes that are incentivised to operate and provide sufficient bandwidth. Stealth Addresses \u00b6 Loki makes use of stealth addresses to ensure that the true public key of the receiver is never linked to their transaction. Every time a Loki transaction is sent, a one-time stealth address is created and the funds are sent to this address. Using a Diffie-Hellman key exchange, the receiver of the transaction is able to calculate a private spend key for this stealth address, thereby taking ownership of the funds without having to reveal their true public address. Stealth addresses provide protection to receivers of transactions and are a core privacy feature in Loki. RingCT \u00b6 RingCT was first proposed by the Monero Research Lab as a way to obfuscate transaction amounts. Current deployments of RingCT use range proofs, which leverage Pedersen commitments to prove that the amount of a transaction being sent is between 0 and 2 64 . This range ensures that only non-negative amounts of currency are sent, without revealing the actual amount sent in the transaction. Recently a number of cryptocurrencies have proposed implementing bulletproofs as a replacement to traditional range proofs in RingCT because of the significant reduction in transaction size. Loki will utilise bulletproofs, reducing the information that nodes are required to store and relay, thereby improving scalability.","title":"CryptoNote Elements"},{"location":"Advanced/CryptoNoteElements/#cryptonote-elements","text":"Loki uses the Monero source code because of the high level of privacy it affords to transactions. Monero is an evolution on the CryptoNote protocol , which uses ring signatures , stealth addresses , and RingCT , giving users the ability to sign transactions and obfuscate amounts while maintaining plausible deniability.","title":"CryptoNote Elements"},{"location":"Advanced/CryptoNoteElements/#ring-signatures","text":"Ring signatures work by constructing a ring of possible signers to a transaction where only one of the signers is the actual sender. Loki makes use of ring signatures to obfuscate the true history of transaction outputs. Ring signatures will be mandatory for all Loki transactions (excluding block reward transactions), and uniquely, a fixed ring-size of ten is enforced on the Loki blockchain. This means that each input will spend from one of ten possible outputs, including the true output.","title":"Ring Signatures"},{"location":"Advanced/CryptoNoteElements/#ring-signature-size","text":"The size of a ring signature refers to how many mixins are used to construct the ring. Monero currently has an enforced minimum ring signature size of seven, with six mixins used alongside the real unspent output in a transaction. The effect of larger ring-sizes has been sparsely studied, however, in paper 0001 (published by the Monero Research Lab), the effect of differing ring-sizes was analysed versus an attacker who owned a large number of outputs on the blockchain . It was found that higher ring-sizes reduce the timeframe in which a malicious attacker who owned a large number of unspent outputs would be able to perform effective analysis of transactions. Mandating larger ring-sizes also protects against a theoretical attack known as an EABE/Knacc attack , where a third-party (i.e. an exchange) can perform limited temporal analysis on transactions between two users. Additionally, Monero has no maximum ring-size enforced by network consensus rules. Many wallets like the Monero GUI wallet cap the ring-size at 26. However, a user is free to manually create a transaction with whatever ring-size they wish, as long as it is above a ring-size of seven. This is problematic since most wallets have a default ring-size of seven. Increasing a transactions ring-size above seven makes it stand out. Further, if an individuals transactions were to always use a non-standard ring-size in Monero (ten for example), a passive third-party could analyse the blockchain and infer patterns using temporal analysis. transaction hash ring size tx size[kB] 3feaff3f48de0bc4c92ec027236165337b64df404aca098e212c1215e9456697 7 13.47 39d484f7c0a2e8f3823a514056d7cb0bf269171cb4582e05955d4c5ee995cad0 7 13.47 e08f5a937e725011bedd44075334ae98dcca32749da231c56da1278d49c0a231 7 13.50 ab35e69d9cca39219c90df8b2b7aab4a54c82127fb1fbaae65d76357f8f76387 7 13.5 6d8ccd56dc2d3eb7de03ba767f0dbf4d5f42ae91e67f4c28f16d6f8b0229c272 10 13.87","title":"Ring Signature Size"},{"location":"Advanced/CryptoNoteElements/#loki-static-ring-size","text":"Loki improves on both of these problems by statically enforcing ring-sizes, and setting the ring-size to ten. Statically setting the maximum ring-size protects users who construct rings with more than nine mixins and setting the ring-size minimum to ten more effectively prevents an attacker who owns a large number of outputs from discerning the true outputs spent in a ring signature. Larger ring-sizes also increase the default churning effectiveness non-linearly, becoming more effective as ring-sizes grow. In the current transaction scheme, increasing the ring-size to 10 would lead to a 2.6% increase in the size of the transaction. However, when Bulletproofs are implemented it will account for about a 8 - 13% increase in the size of a transaction. This is because of the overall reduction in transaction size caused by Bulletproofs. Increasing the minimum ring-size may present a problem on a network that lacks architecture to support larger sized transactions, due to the increased overhead. With Loki however, this burden can be carried by Service Nodes that are incentivised to operate and provide sufficient bandwidth.","title":"Loki Static Ring Size"},{"location":"Advanced/CryptoNoteElements/#stealth-addresses","text":"Loki makes use of stealth addresses to ensure that the true public key of the receiver is never linked to their transaction. Every time a Loki transaction is sent, a one-time stealth address is created and the funds are sent to this address. Using a Diffie-Hellman key exchange, the receiver of the transaction is able to calculate a private spend key for this stealth address, thereby taking ownership of the funds without having to reveal their true public address. Stealth addresses provide protection to receivers of transactions and are a core privacy feature in Loki.","title":"Stealth Addresses"},{"location":"Advanced/CryptoNoteElements/#ringct","text":"RingCT was first proposed by the Monero Research Lab as a way to obfuscate transaction amounts. Current deployments of RingCT use range proofs, which leverage Pedersen commitments to prove that the amount of a transaction being sent is between 0 and 2 64 . This range ensures that only non-negative amounts of currency are sent, without revealing the actual amount sent in the transaction. Recently a number of cryptocurrencies have proposed implementing bulletproofs as a replacement to traditional range proofs in RingCT because of the significant reduction in transaction size. Loki will utilise bulletproofs, reducing the information that nodes are required to store and relay, thereby improving scalability.","title":"RingCT"},{"location":"Advanced/Cryptoeconomics/","text":"Cryptoeconomics \u00b6 Loki is a Blockchain network oriented toward the provision of privacy-preserving services over a network of Service Nodes . The salient cryptoeconomic problem is how to incentivise actors in the Loki network to operate Service Nodes in a manner compatible with the objectives of the Loki network, in particular decentralisation and privacy. To solve this problem the Loki Project team commissioned two Economic papers: Cryptoeconomics of the Loki Network : This Economic Report was commissioned to characterise the game theory behind incentivising Service Node operators. Loki Cryptoeconomics : This Report was commissioned to apply the game theory specific to the Loki Networks economics. These 2 papers analysed the Block Reward , Block Reward Split , Inflation , Circulating Supply and the amount of potential Service Nodes on the network to develop a cryptoeconomic solution to incentivise Service Node Operators. Block Rewards \u00b6 A block reward is the reward created when a new block has been generated. The reward is distributed to the peers in the network that helped facilitate the generation of the block. In most cases, the miners are the individuals who receive this reward as they collect and write transactions into blocks. Loki Block Reward \u00b6 The Loki Block Reward is generated in a similar manner to most proof-of-work cryptocurrencies. Miners use proof-of-work to generate a block and then a reward is released to the network. The reward is then distributed not only distributed to the Miner but to a Service Node Operator and the Governance pool. The amount of Loki rewarded BR to the network at each block height h follows the following equation: This block reward formula is a result of Loki's Cryptoeconomic study , on the 30th of July, 2018, at block 64324, the Loki block reward went from being calculated in terms of the circulating supply with an emission speed factor of 20, to be derived from the block height. Block Reward Split \u00b6 As Service Node's went live on 20th of September, 2018, at block 101250, the addition of a Block Reward split was required to financially incentivise Service Node Operators to maintain and run Service Nodes. At HF15, the Block Reward was hard coded to split the reward as follows: Party Percent of Reward Service Nodes 66% Miners 24% Governance 10% And once Pulse comes at HF16, the block reward will be hard coded to split the reward as follows. Party Percent of Reward Service Nodes 90% Governance 10% Discussion and Pull Request Mining Reward \u00b6 As well as collecting transactions fees, 45% of the block reward is awarded to the miner that constructs the block. Service Node Reward \u00b6 The second output in each block (50% of total reward) goes to a Service Node , or two Service Nodes if a relay is selected. Service Nodes are rewarded based on the time since they last received a reward (or time since they registered), with a preference for nodes that have been waiting longer. Each time a Service Node registers with the network it assumes the last position in the queue. If the Service Node maintains good service and is not ejected from the queue by a swarm flag , it slowly migrates to the higher positions in the queue. Nodes at or near the front of the queue are eligible for a reward, and once awarded, the node again drops to the last position in the queue and begins slowly working its way back up. Governance Reward \u00b6 The final 5% portion of the block reward is distributed towards governance operations ; Inflation \u00b6 Click to expand data Year BH Circulating supply Inflation 0 0 22500000 77.12% 1 262800 39852116.29 19.79% 2 525600 47738927.03 15.48% 3 788400 55129105.11 13.35% 4 1051200 62489416.22 11.78% 5 1314000 69847931.15 10.53% 6 1576800 77206338.06 9.53% 7 1839600 84564738.47 8.70% 8 2102400 91923138.5 8.00% 9 2365200 99281538.5 7.41% 10 2628000 106639938.5 6.90% 11 2890800 113998338.5 6.45% 12 3153600 121356738.5 6.06% 13 3416400 128715138.5 5.72% 14 3679200 136073538.5 5.41% 15 3942000 143431938.5 5.13% Circulating Supply \u00b6 The Circulating Supply is the total amount of $Loki in circulation. The below table \"Circulating Supply Distribution\" shows the predicted circulating supply and the overall amount of Loki the Premine, Governance, Miners and Service Nodes have received. Circulating Supply Data \u00b6 Click to expand data Months BH Circulating supply Premine Governance Miners Service Nodes 0 0 22500000 22500000 1 21600 25124173.21 22500000 131208.66 2492964.552 2 43200 27695047.09 22500000 259752.35 4935294.732 3 64800 30195981.57 22500000 384799.08 7311182.49 4 86400 31765098.95 22500000 463254.95 8801843.998 5 108000 33135278.15 22500000 531763.91 9898775.969 204738.28 6 129600 34347560.03 22500000 592378.00 10444302.82 810879.22 7 151200 35434518.72 22500000 646725.94 10933434.22 1354358.56 8 172800 36422008.33 22500000 696100.42 11377804.55 1848103.36 9 194400 37330549.27 22500000 741527.46 11786647.97 2302373.83 10 216000 38176428.61 22500000 783821.43 12167293.67 2725313.51 11 237600 38972573.41 22500000 823628.67 12525558.84 3123385.91 12 259200 39729243.88 22500000 861462.19 12866060.55 3501721.14 13 280800 40454583.56 22500000 897729.18 13192463.4 3864390.98 14 302400 41155055.96 22500000 932752.80 13507675.98 4214627.18 15 324000 41835791.19 22500000 966789.56 13814006.84 4554994.80 16 345600 42500861.03 22500000 1000043.05 14113288.26 4887529.71 17 367200 43153497.23 22500000 1032674.86 14406974.55 5213847.82 18 388800 43796264.85 22500000 1064813.24 14696219.98 5535231.62 19 410400 44431199.76 22500000 1096559.99 14981940.69 5852699.08 20 432000 45059917.87 22500000 1127995.89 15264863.84 6167058.13 21 453600 45683701.67 22500000 1159185.08 15545566.55 6478950.04 22 475200 46303569.13 22500000 1190178.46 15824506.91 6788883.77 23 496800 46920328.18 22500000 1221016.41 16102048.48 7097263.29 24 518400 47534620.09 22500000 1251731.00 16378479.84 7404409.24 25 540000 48146953.82 22500000 1282347.69 16654030.02 7710576.11 26 561600 48757733.34 22500000 1312886.67 16928880.8 8015965.87 27 583200 49367279.29 22500000 1343363.96 17203176.48 8320738.85 28 604800 49975846.16 22500000 1373792.31 17477031.57 8625022.28 29 626400 50583635.92 22500000 1404181.80 17750536.96 8928917.16 30 648000 51190808.9 22500000 1434540.44 18023764.8 9232503.65 31 669600 51797492.33 22500000 1464874.62 18296772.35 9535845.37 32 691200 52403787.21 22500000 1495189.36 18569605.04 9838992.81 33 712800 53009773.7 22500000 1525488.68 18842298.96 10141986.05 34 734400 53615515.42 22500000 1555775.77 19114882.74 10444856.91 35 756000 54221062.86 22500000 1586053.14 19387379.08 10747630.63 36 777600 54826456.1 22500000 1616322.81 19659806.04 11050327.25 37 799200 55431726.96 22500000 1646586.35 19932177.93 11352962.68 38 820800 56036900.68 22500000 1676845.03 20204506.1 11655549.54 39 842400 56641997.3 22500000 1707099.87 20476799.58 11958097.85 40 864000 57247032.73 22500000 1737351.64 20749065.53 12260615.57 41 885600 57852019.59 22500000 1767600.98 21021309.61 12563109.00 42 907200 58456967.9 22500000 1797848.40 21293536.35 12865583.15 43 928800 59061885.62 22500000 1828094.28 21565749.33 13168042.01 44 950400 59666779.05 22500000 1858338.95 21837951.37 13470488.72 45 972000 60271653.2 22500000 1888582.66 22110144.74 13772925.80 46 993600 60876512.06 22500000 1918825.60 22382331.23 14075355.23 47 1015200 61481358.77 22500000 1949067.94 22654512.25 14377778.59 48 1036800 62086195.85 22500000 1979309.79 22926688.93 14680197.13 49 1058400 62691025.28 22500000 2009551.26 23198862.18 14982611.84 50 1080000 63295848.64 22500000 2039792.43 23471032.69 15285023.52 51 1101600 63900667.18 22500000 2070033.36 23743201.03 15587432.79 52 1123200 64505481.89 22500000 2100274.09 24015367.65 15889840.15 53 1144800 65110293.57 22500000 2130514.68 24287532.91 16192245.99 54 1166400 65715102.84 22500000 2160755.14 24559697.08 16494650.62 55 1188000 66319910.2 22500000 2190995.51 24831860.39 16797054.30 56 1209600 66924716.04 22500000 2221235.80 25104023.02 17099457.22 57 1231200 67529520.67 22500000 2251476.03 25376185.1 17401859.54 58 1252800 68134324.35 22500000 2281716.22 25648346.76 17704261.37 59 1274400 68739127.27 22500000 2311956.36 25920508.07 18006662.83 60 1296000 69343929.59 22500000 2342196.48 26192669.11 18309063.99 61 1317600 69948731.42 22500000 2372436.57 26464829.94 18611464.91 62 1339200 70553532.88 22500000 2402676.64 26736990.6 18913865.64 63 1360800 71158334.04 22500000 2432916.70 27009151.12 19216266.22 64 1382400 71763134.96 22500000 2463156.75 27281311.53 19518666.68 65 1404000 72367935.69 22500000 2493396.78 27553471.86 19821067.05 66 1425600 72972736.27 22500000 2523636.81 27825632.12 20123467.34 67 1447200 73577536.73 22500000 2553876.84 28097792.33 20425867.57 68 1468800 74182337.1 22500000 2584116.85 28369952.49 20728267.75 69 1490400 74787137.39 22500000 2614356.87 28642112.62 21030667.89 70 1512000 75391937.62 22500000 2644596.88 28914272.73 21333068.01 71 1533600 75996737.8 22500000 2674836.89 29186432.81 21635468.10 72 1555200 76601537.94 22500000 2705076.90 29458592.87 21937868.17 73 1576800 77206338.06 22500000 2735316.90 29730752.93 22240268.23 74 1598400 77811138.15 22500000 2765556.91 30002912.97 22542668.28 75 1620000 78415938.22 22500000 2795796.91 30275073 22845068.31 76 1641600 79020738.28 22500000 2826036.91 30547233.03 23147468.34 77 1663200 79625538.33 22500000 2856276.92 30819393.05 23449868.36 78 1684800 80230338.36 22500000 2886516.92 31091553.06 23752268.38 79 1706400 80835138.39 22500000 2916756.92 31363713.08 24054668.40 80 1728000 81439938.41 22500000 2946996.92 31635873.09 24357068.41 81 1749600 82044738.43 22500000 2977236.92 31908033.09 24659468.42 82 1771200 82649538.45 22500000 3007476.92 32180193.1 24961868.42 83 1792800 83254338.46 22500000 3037716.92 32452353.11 25264268.43 84 1814400 83859138.47 22500000 3067956.92 32724513.11 25566668.43 85 1836000 84463938.47 22500000 3098196.92 32996673.11 25869068.44 86 1857600 85068738.48 22500000 3128436.92 33268833.12 26171468.44 87 1879200 85673538.48 22500000 3158676.92 33540993.12 26473868.44 88 1900800 86278338.49 22500000 3188916.92 33813153.12 26776268.44 89 1922400 86883138.49 22500000 3219156.92 34085313.12 27078668.45 90 1944000 87487938.49 22500000 3249396.92 34357473.12 27381068.45 91 1965600 88092738.49 22500000 3279636.92 34629633.12 27683468.45 92 1987200 88697538.5 22500000 3309876.92 34901793.12 27985868.45 93 2008800 89302338.5 22500000 3340116.92 35173953.12 28288268.45 94 2030400 89907138.5 22500000 3370356.92 35446113.12 28590668.45 95 2052000 90511938.5 22500000 3400596.92 35718273.12 28893068.45 96 2073600 91116738.5 22500000 3430836.92 35990433.12 29195468.45 97 2095200 91721538.5 22500000 3461076.92 36262593.12 29497868.45 98 2116800 92326338.5 22500000 3491316.92 36534753.12 29800268.45 99 2138400 92931138.5 22500000 3521556.93 36806913.12 30102668.45 100 2160000 93535938.5 22500000 3551796.93 37079073.12 30405068.45 101 2181600 94140738.5 22500000 3582036.93 37351233.12 30707468.45 102 2203200 94745538.5 22500000 3612276.93 37623393.12 31009868.45 103 2224800 95350338.5 22500000 3642516.93 37895553.12 31312268.45 104 2246400 95955138.5 22500000 3672756.93 38167713.12 31614668.45 105 2268000 96559938.5 22500000 3702996.93 38439873.12 31917068.45 106 2289600 97164738.5 22500000 3733236.93 38712033.12 32219468.45 107 2311200 97769538.5 22500000 3763476.93 38984193.12 32521868.45 108 2332800 98374338.5 22500000 3793716.93 39256353.12 32824268.45 109 2354400 98979138.5 22500000 3823956.93 39528513.12 33126668.45 110 2376000 99583938.5 22500000 3854196.93 39800673.12 33429068.45 111 2397600 100188738.5 22500000 3884436.93 40072833.12 33731468.45 112 2419200 100793538.5 22500000 3914676.93 40344993.12 34033868.45 113 2440800 101398338.5 22500000 3944916.93 40617153.12 34336268.45 114 2462400 102003138.5 22500000 3975156.93 40889313.12 34638668.45 115 2484000 102607938.5 22500000 4005396.93 41161473.12 34941068.45 116 2505600 103212738.5 22500000 4035636.93 41433633.12 35243468.45 117 2527200 103817538.5 22500000 4065876.93 41705793.12 35545868.45 118 2548800 104422338.5 22500000 4096116.93 41977953.12 35848268.45 119 2570400 105027138.5 22500000 4126356.93 42250113.12 36150668.45 120 2592000 105631938.5 22500000 4156596.93 42522273.12 36453068.45","title":"Cryptoeconomics"},{"location":"Advanced/Cryptoeconomics/#cryptoeconomics","text":"Loki is a Blockchain network oriented toward the provision of privacy-preserving services over a network of Service Nodes . The salient cryptoeconomic problem is how to incentivise actors in the Loki network to operate Service Nodes in a manner compatible with the objectives of the Loki network, in particular decentralisation and privacy. To solve this problem the Loki Project team commissioned two Economic papers: Cryptoeconomics of the Loki Network : This Economic Report was commissioned to characterise the game theory behind incentivising Service Node operators. Loki Cryptoeconomics : This Report was commissioned to apply the game theory specific to the Loki Networks economics. These 2 papers analysed the Block Reward , Block Reward Split , Inflation , Circulating Supply and the amount of potential Service Nodes on the network to develop a cryptoeconomic solution to incentivise Service Node Operators.","title":"Cryptoeconomics"},{"location":"Advanced/Cryptoeconomics/#block-rewards","text":"A block reward is the reward created when a new block has been generated. The reward is distributed to the peers in the network that helped facilitate the generation of the block. In most cases, the miners are the individuals who receive this reward as they collect and write transactions into blocks.","title":"Block Rewards"},{"location":"Advanced/Cryptoeconomics/#loki-block-reward","text":"The Loki Block Reward is generated in a similar manner to most proof-of-work cryptocurrencies. Miners use proof-of-work to generate a block and then a reward is released to the network. The reward is then distributed not only distributed to the Miner but to a Service Node Operator and the Governance pool. The amount of Loki rewarded BR to the network at each block height h follows the following equation: This block reward formula is a result of Loki's Cryptoeconomic study , on the 30th of July, 2018, at block 64324, the Loki block reward went from being calculated in terms of the circulating supply with an emission speed factor of 20, to be derived from the block height.","title":"Loki Block Reward"},{"location":"Advanced/Cryptoeconomics/#block-reward-split","text":"As Service Node's went live on 20th of September, 2018, at block 101250, the addition of a Block Reward split was required to financially incentivise Service Node Operators to maintain and run Service Nodes. At HF15, the Block Reward was hard coded to split the reward as follows: Party Percent of Reward Service Nodes 66% Miners 24% Governance 10% And once Pulse comes at HF16, the block reward will be hard coded to split the reward as follows. Party Percent of Reward Service Nodes 90% Governance 10% Discussion and Pull Request","title":"Block Reward Split"},{"location":"Advanced/Cryptoeconomics/#mining-reward","text":"As well as collecting transactions fees, 45% of the block reward is awarded to the miner that constructs the block.","title":"Mining Reward"},{"location":"Advanced/Cryptoeconomics/#service-node-reward","text":"The second output in each block (50% of total reward) goes to a Service Node , or two Service Nodes if a relay is selected. Service Nodes are rewarded based on the time since they last received a reward (or time since they registered), with a preference for nodes that have been waiting longer. Each time a Service Node registers with the network it assumes the last position in the queue. If the Service Node maintains good service and is not ejected from the queue by a swarm flag , it slowly migrates to the higher positions in the queue. Nodes at or near the front of the queue are eligible for a reward, and once awarded, the node again drops to the last position in the queue and begins slowly working its way back up.","title":"Service Node Reward"},{"location":"Advanced/Cryptoeconomics/#governance-reward","text":"The final 5% portion of the block reward is distributed towards governance operations ;","title":"Governance Reward"},{"location":"Advanced/Cryptoeconomics/#inflation","text":"Click to expand data Year BH Circulating supply Inflation 0 0 22500000 77.12% 1 262800 39852116.29 19.79% 2 525600 47738927.03 15.48% 3 788400 55129105.11 13.35% 4 1051200 62489416.22 11.78% 5 1314000 69847931.15 10.53% 6 1576800 77206338.06 9.53% 7 1839600 84564738.47 8.70% 8 2102400 91923138.5 8.00% 9 2365200 99281538.5 7.41% 10 2628000 106639938.5 6.90% 11 2890800 113998338.5 6.45% 12 3153600 121356738.5 6.06% 13 3416400 128715138.5 5.72% 14 3679200 136073538.5 5.41% 15 3942000 143431938.5 5.13%","title":"Inflation"},{"location":"Advanced/Cryptoeconomics/#circulating-supply","text":"The Circulating Supply is the total amount of $Loki in circulation. The below table \"Circulating Supply Distribution\" shows the predicted circulating supply and the overall amount of Loki the Premine, Governance, Miners and Service Nodes have received.","title":"Circulating Supply"},{"location":"Advanced/Cryptoeconomics/#circulating-supply-data","text":"Click to expand data Months BH Circulating supply Premine Governance Miners Service Nodes 0 0 22500000 22500000 1 21600 25124173.21 22500000 131208.66 2492964.552 2 43200 27695047.09 22500000 259752.35 4935294.732 3 64800 30195981.57 22500000 384799.08 7311182.49 4 86400 31765098.95 22500000 463254.95 8801843.998 5 108000 33135278.15 22500000 531763.91 9898775.969 204738.28 6 129600 34347560.03 22500000 592378.00 10444302.82 810879.22 7 151200 35434518.72 22500000 646725.94 10933434.22 1354358.56 8 172800 36422008.33 22500000 696100.42 11377804.55 1848103.36 9 194400 37330549.27 22500000 741527.46 11786647.97 2302373.83 10 216000 38176428.61 22500000 783821.43 12167293.67 2725313.51 11 237600 38972573.41 22500000 823628.67 12525558.84 3123385.91 12 259200 39729243.88 22500000 861462.19 12866060.55 3501721.14 13 280800 40454583.56 22500000 897729.18 13192463.4 3864390.98 14 302400 41155055.96 22500000 932752.80 13507675.98 4214627.18 15 324000 41835791.19 22500000 966789.56 13814006.84 4554994.80 16 345600 42500861.03 22500000 1000043.05 14113288.26 4887529.71 17 367200 43153497.23 22500000 1032674.86 14406974.55 5213847.82 18 388800 43796264.85 22500000 1064813.24 14696219.98 5535231.62 19 410400 44431199.76 22500000 1096559.99 14981940.69 5852699.08 20 432000 45059917.87 22500000 1127995.89 15264863.84 6167058.13 21 453600 45683701.67 22500000 1159185.08 15545566.55 6478950.04 22 475200 46303569.13 22500000 1190178.46 15824506.91 6788883.77 23 496800 46920328.18 22500000 1221016.41 16102048.48 7097263.29 24 518400 47534620.09 22500000 1251731.00 16378479.84 7404409.24 25 540000 48146953.82 22500000 1282347.69 16654030.02 7710576.11 26 561600 48757733.34 22500000 1312886.67 16928880.8 8015965.87 27 583200 49367279.29 22500000 1343363.96 17203176.48 8320738.85 28 604800 49975846.16 22500000 1373792.31 17477031.57 8625022.28 29 626400 50583635.92 22500000 1404181.80 17750536.96 8928917.16 30 648000 51190808.9 22500000 1434540.44 18023764.8 9232503.65 31 669600 51797492.33 22500000 1464874.62 18296772.35 9535845.37 32 691200 52403787.21 22500000 1495189.36 18569605.04 9838992.81 33 712800 53009773.7 22500000 1525488.68 18842298.96 10141986.05 34 734400 53615515.42 22500000 1555775.77 19114882.74 10444856.91 35 756000 54221062.86 22500000 1586053.14 19387379.08 10747630.63 36 777600 54826456.1 22500000 1616322.81 19659806.04 11050327.25 37 799200 55431726.96 22500000 1646586.35 19932177.93 11352962.68 38 820800 56036900.68 22500000 1676845.03 20204506.1 11655549.54 39 842400 56641997.3 22500000 1707099.87 20476799.58 11958097.85 40 864000 57247032.73 22500000 1737351.64 20749065.53 12260615.57 41 885600 57852019.59 22500000 1767600.98 21021309.61 12563109.00 42 907200 58456967.9 22500000 1797848.40 21293536.35 12865583.15 43 928800 59061885.62 22500000 1828094.28 21565749.33 13168042.01 44 950400 59666779.05 22500000 1858338.95 21837951.37 13470488.72 45 972000 60271653.2 22500000 1888582.66 22110144.74 13772925.80 46 993600 60876512.06 22500000 1918825.60 22382331.23 14075355.23 47 1015200 61481358.77 22500000 1949067.94 22654512.25 14377778.59 48 1036800 62086195.85 22500000 1979309.79 22926688.93 14680197.13 49 1058400 62691025.28 22500000 2009551.26 23198862.18 14982611.84 50 1080000 63295848.64 22500000 2039792.43 23471032.69 15285023.52 51 1101600 63900667.18 22500000 2070033.36 23743201.03 15587432.79 52 1123200 64505481.89 22500000 2100274.09 24015367.65 15889840.15 53 1144800 65110293.57 22500000 2130514.68 24287532.91 16192245.99 54 1166400 65715102.84 22500000 2160755.14 24559697.08 16494650.62 55 1188000 66319910.2 22500000 2190995.51 24831860.39 16797054.30 56 1209600 66924716.04 22500000 2221235.80 25104023.02 17099457.22 57 1231200 67529520.67 22500000 2251476.03 25376185.1 17401859.54 58 1252800 68134324.35 22500000 2281716.22 25648346.76 17704261.37 59 1274400 68739127.27 22500000 2311956.36 25920508.07 18006662.83 60 1296000 69343929.59 22500000 2342196.48 26192669.11 18309063.99 61 1317600 69948731.42 22500000 2372436.57 26464829.94 18611464.91 62 1339200 70553532.88 22500000 2402676.64 26736990.6 18913865.64 63 1360800 71158334.04 22500000 2432916.70 27009151.12 19216266.22 64 1382400 71763134.96 22500000 2463156.75 27281311.53 19518666.68 65 1404000 72367935.69 22500000 2493396.78 27553471.86 19821067.05 66 1425600 72972736.27 22500000 2523636.81 27825632.12 20123467.34 67 1447200 73577536.73 22500000 2553876.84 28097792.33 20425867.57 68 1468800 74182337.1 22500000 2584116.85 28369952.49 20728267.75 69 1490400 74787137.39 22500000 2614356.87 28642112.62 21030667.89 70 1512000 75391937.62 22500000 2644596.88 28914272.73 21333068.01 71 1533600 75996737.8 22500000 2674836.89 29186432.81 21635468.10 72 1555200 76601537.94 22500000 2705076.90 29458592.87 21937868.17 73 1576800 77206338.06 22500000 2735316.90 29730752.93 22240268.23 74 1598400 77811138.15 22500000 2765556.91 30002912.97 22542668.28 75 1620000 78415938.22 22500000 2795796.91 30275073 22845068.31 76 1641600 79020738.28 22500000 2826036.91 30547233.03 23147468.34 77 1663200 79625538.33 22500000 2856276.92 30819393.05 23449868.36 78 1684800 80230338.36 22500000 2886516.92 31091553.06 23752268.38 79 1706400 80835138.39 22500000 2916756.92 31363713.08 24054668.40 80 1728000 81439938.41 22500000 2946996.92 31635873.09 24357068.41 81 1749600 82044738.43 22500000 2977236.92 31908033.09 24659468.42 82 1771200 82649538.45 22500000 3007476.92 32180193.1 24961868.42 83 1792800 83254338.46 22500000 3037716.92 32452353.11 25264268.43 84 1814400 83859138.47 22500000 3067956.92 32724513.11 25566668.43 85 1836000 84463938.47 22500000 3098196.92 32996673.11 25869068.44 86 1857600 85068738.48 22500000 3128436.92 33268833.12 26171468.44 87 1879200 85673538.48 22500000 3158676.92 33540993.12 26473868.44 88 1900800 86278338.49 22500000 3188916.92 33813153.12 26776268.44 89 1922400 86883138.49 22500000 3219156.92 34085313.12 27078668.45 90 1944000 87487938.49 22500000 3249396.92 34357473.12 27381068.45 91 1965600 88092738.49 22500000 3279636.92 34629633.12 27683468.45 92 1987200 88697538.5 22500000 3309876.92 34901793.12 27985868.45 93 2008800 89302338.5 22500000 3340116.92 35173953.12 28288268.45 94 2030400 89907138.5 22500000 3370356.92 35446113.12 28590668.45 95 2052000 90511938.5 22500000 3400596.92 35718273.12 28893068.45 96 2073600 91116738.5 22500000 3430836.92 35990433.12 29195468.45 97 2095200 91721538.5 22500000 3461076.92 36262593.12 29497868.45 98 2116800 92326338.5 22500000 3491316.92 36534753.12 29800268.45 99 2138400 92931138.5 22500000 3521556.93 36806913.12 30102668.45 100 2160000 93535938.5 22500000 3551796.93 37079073.12 30405068.45 101 2181600 94140738.5 22500000 3582036.93 37351233.12 30707468.45 102 2203200 94745538.5 22500000 3612276.93 37623393.12 31009868.45 103 2224800 95350338.5 22500000 3642516.93 37895553.12 31312268.45 104 2246400 95955138.5 22500000 3672756.93 38167713.12 31614668.45 105 2268000 96559938.5 22500000 3702996.93 38439873.12 31917068.45 106 2289600 97164738.5 22500000 3733236.93 38712033.12 32219468.45 107 2311200 97769538.5 22500000 3763476.93 38984193.12 32521868.45 108 2332800 98374338.5 22500000 3793716.93 39256353.12 32824268.45 109 2354400 98979138.5 22500000 3823956.93 39528513.12 33126668.45 110 2376000 99583938.5 22500000 3854196.93 39800673.12 33429068.45 111 2397600 100188738.5 22500000 3884436.93 40072833.12 33731468.45 112 2419200 100793538.5 22500000 3914676.93 40344993.12 34033868.45 113 2440800 101398338.5 22500000 3944916.93 40617153.12 34336268.45 114 2462400 102003138.5 22500000 3975156.93 40889313.12 34638668.45 115 2484000 102607938.5 22500000 4005396.93 41161473.12 34941068.45 116 2505600 103212738.5 22500000 4035636.93 41433633.12 35243468.45 117 2527200 103817538.5 22500000 4065876.93 41705793.12 35545868.45 118 2548800 104422338.5 22500000 4096116.93 41977953.12 35848268.45 119 2570400 105027138.5 22500000 4126356.93 42250113.12 36150668.45 120 2592000 105631938.5 22500000 4156596.93 42522273.12 36453068.45","title":"Circulating Supply Data"},{"location":"Advanced/Debugging/","text":"Debugging \u00b6 This section contains general instructions for debugging failed installs or problems encountered with Loki. First ensure you are running the latest version built from the Github repo. Obtaining stack traces and core dumps on Unix systems \u00b6 We generally use the tool gdb (GNU debugger) to provide stack trace functionality, and ulimit to provide core dumps in builds which crash or segfault. To use gdb in order to obtain a stack trace for a build that has stalled: Run the build. Once it stalls, enter the following command: gdb /path/to/lokid `pidof lokid` Type thread apply all bt within gdb in order to obtain the stack trace If however the core dumps or segfaults: Enter ulimit -c unlimited on the command line to enable unlimited filesizes for core dumps Enter echo core | sudo tee /proc/sys/kernel/core_pattern to stop cores from being hijacked by other tools Run the build. When it terminates with an output along the lines of \"Segmentation fault (core dumped)\", there should be a core dump file in the same directory as lokid. It may be named just core , or core.xxxx with numbers appended. You can now analyse this core dump with gdb as follows: gdb /path/to/lokid /path/to/dumpfile Print the stack trace with bt To run loki within gdb: Type gdb /path/to/lokid Pass command-line options with --args followed by the relevant arguments Type run to run lokid Analysing memory corruption \u00b6 We use the tool valgrind for this. Run with valgrind /path/to/lokid . It will be slow. LMDB \u00b6 Instructions for debugging suspected blockchain corruption as per @HYC There is an mdb_stat command in the LMDB source that can print statistics about the database but it's not routinely built. This can be built with the following command: cd ~/loki/external/db_drivers/liblmdb && make The output of mdb_stat -ea <path to blockchain dir> will indicate inconsistencies in the blocks, block_heights and block_info table. The output of mdb_dump -s blocks <path to blockchain dir> and mdb_dump -s block_info <path to blockchain dir> is useful for indicating whether blocks and block_info contain the same keys. These records are dumped as hex data, where the first line is the key and the second line is the data.","title":"Debugging"},{"location":"Advanced/Debugging/#debugging","text":"This section contains general instructions for debugging failed installs or problems encountered with Loki. First ensure you are running the latest version built from the Github repo.","title":"Debugging"},{"location":"Advanced/Debugging/#obtaining-stack-traces-and-core-dumps-on-unix-systems","text":"We generally use the tool gdb (GNU debugger) to provide stack trace functionality, and ulimit to provide core dumps in builds which crash or segfault. To use gdb in order to obtain a stack trace for a build that has stalled: Run the build. Once it stalls, enter the following command: gdb /path/to/lokid `pidof lokid` Type thread apply all bt within gdb in order to obtain the stack trace If however the core dumps or segfaults: Enter ulimit -c unlimited on the command line to enable unlimited filesizes for core dumps Enter echo core | sudo tee /proc/sys/kernel/core_pattern to stop cores from being hijacked by other tools Run the build. When it terminates with an output along the lines of \"Segmentation fault (core dumped)\", there should be a core dump file in the same directory as lokid. It may be named just core , or core.xxxx with numbers appended. You can now analyse this core dump with gdb as follows: gdb /path/to/lokid /path/to/dumpfile Print the stack trace with bt To run loki within gdb: Type gdb /path/to/lokid Pass command-line options with --args followed by the relevant arguments Type run to run lokid","title":"Obtaining stack traces and core dumps on Unix systems"},{"location":"Advanced/Debugging/#analysing-memory-corruption","text":"We use the tool valgrind for this. Run with valgrind /path/to/lokid . It will be slow.","title":"Analysing memory corruption"},{"location":"Advanced/Debugging/#lmdb","text":"Instructions for debugging suspected blockchain corruption as per @HYC There is an mdb_stat command in the LMDB source that can print statistics about the database but it's not routinely built. This can be built with the following command: cd ~/loki/external/db_drivers/liblmdb && make The output of mdb_stat -ea <path to blockchain dir> will indicate inconsistencies in the blocks, block_heights and block_info table. The output of mdb_dump -s blocks <path to blockchain dir> and mdb_dump -s block_info <path to blockchain dir> is useful for indicating whether blocks and block_info contain the same keys. These records are dumped as hex data, where the first line is the key and the second line is the data.","title":"LMDB"},{"location":"Advanced/DenialofServiceAttacks/","text":"Denial of Service Attacks \u00b6 Users of decentralised blockchains are not required to provide digital or physical identifiers. This can be beneficial to users who lack identity or are being persecuted because of it. However, systems that do not require identification render themselves vulnerable to Sybil attacks , where a malicious actor produces numerous false identities (in Loki\u2019s case, numerous public-private key pairs) and uses these identities to spam the network with requests. Many cryptocurrencies have struggled with this problem, and are forced to implement either a fee-for-service model or a proof-of-work model. In fee-for-service models such as Siacoin, users pay for the services that they use. In Siacoins case, the cost is determined per TB of storage per month. Fee-for-service models are effective at reducing Sybil attacks, however, they drive many users away from the system especially when similar services are available for free (such as Google Drive and Onedrive in the case of Siacoin). Proof-of-work systems such as those used in Hashcash and Nano require users to calculate a small proof-of-work before sending a message or transaction. These small proof-of-work systems are arguably more egalitarian than the fee-for-service model but can fall prey to attackers who possess large amounts of computing power. Loki proposes a modified proof-of-work scheme to address the two largest Sybil attack surfaces in the Loki system; offline messages and path creation. Offline messages present a potential target because each message must be stored by a swarm of nine nodes. Potential abuse could arise where a malicious user overloads a particular swarm with a high volume of 15 messages that it would have to store. In path creation attacks, the attacker seeks to engage in the path creation process with as many nodes as possible, taking up bandwidth resources and denying service to users who create paths through the network for legitimate purposes. To prevent both attacks, the Loki network requires that a short proof-of-work be attached when both messages and paths are created. For messages, this proof-of-work is calculated as a Blake2b hash of the message. For path creation, the proof-of-work is sent along with the request for a node to be included in the path building process. To ensure scalability and accessibility for mobile users, the proof-of-work difficulty requirement is fixed based on the Time-to-live (TTL) of the message or the path, and not based on global network activity.","title":"Denial of Service Attacks"},{"location":"Advanced/DenialofServiceAttacks/#denial-of-service-attacks","text":"Users of decentralised blockchains are not required to provide digital or physical identifiers. This can be beneficial to users who lack identity or are being persecuted because of it. However, systems that do not require identification render themselves vulnerable to Sybil attacks , where a malicious actor produces numerous false identities (in Loki\u2019s case, numerous public-private key pairs) and uses these identities to spam the network with requests. Many cryptocurrencies have struggled with this problem, and are forced to implement either a fee-for-service model or a proof-of-work model. In fee-for-service models such as Siacoin, users pay for the services that they use. In Siacoins case, the cost is determined per TB of storage per month. Fee-for-service models are effective at reducing Sybil attacks, however, they drive many users away from the system especially when similar services are available for free (such as Google Drive and Onedrive in the case of Siacoin). Proof-of-work systems such as those used in Hashcash and Nano require users to calculate a small proof-of-work before sending a message or transaction. These small proof-of-work systems are arguably more egalitarian than the fee-for-service model but can fall prey to attackers who possess large amounts of computing power. Loki proposes a modified proof-of-work scheme to address the two largest Sybil attack surfaces in the Loki system; offline messages and path creation. Offline messages present a potential target because each message must be stored by a swarm of nine nodes. Potential abuse could arise where a malicious user overloads a particular swarm with a high volume of 15 messages that it would have to store. In path creation attacks, the attacker seeks to engage in the path creation process with as many nodes as possible, taking up bandwidth resources and denying service to users who create paths through the network for legitimate purposes. To prevent both attacks, the Loki network requires that a short proof-of-work be attached when both messages and paths are created. For messages, this proof-of-work is calculated as a Blake2b hash of the message. For path creation, the proof-of-work is sent along with the request for a node to be included in the path building process. To ensure scalability and accessibility for mobile users, the proof-of-work difficulty requirement is fixed based on the Time-to-live (TTL) of the message or the path, and not based on global network activity.","title":"Denial of Service Attacks"},{"location":"Advanced/DynamicBlockSize/","text":"Dynamic Block Size \u00b6 Like other CryptoNote coins, Loki does not have a fixed block size. Instead, the block size changes over time, growing to include more transactions as the network reaches higher transaction throughput. The Loki block size scales by observing the median block size over the last 100 blocks and slowly retargets the maximum size of any new blocks accordingly. The long-term concern in other cryptocurrencies is that large block sizes burden the nodes that store and verify transactions. As block sizes grow, nodes that run on lower grade hardware are unable to process and propagate new blocks, leading to centralisation of the node network among those with a commercial interest in maintaining nodes. This can be concerning because distributing the blockchain across many nodes allows for the state of the chain to be confirmed among many different parties, adding to its validity and censorship resistance. In Loki, a portion of the block reward is given to Service Nodes that process and propagate blocks as full nodes. Because Service Nodes with insufficient bandwidth and performance are dropped from the Service Node network, the reward pool self-enforces a minimum performance requirement. This incentive structure not only ensures that the node count remains high , but that the said nodes are of a sufficient performance level to successfully share blockchain data across the network, irrespective of how large the blockchain grows or how demanding the bandwidth requirements are. Even so, transaction size optimisations are still required to ensure that the network scales efficiently so as to keep the Service Node operating costs down so that a high node count can be sustained in the long term.","title":"Dynamic Block Size"},{"location":"Advanced/DynamicBlockSize/#dynamic-block-size","text":"Like other CryptoNote coins, Loki does not have a fixed block size. Instead, the block size changes over time, growing to include more transactions as the network reaches higher transaction throughput. The Loki block size scales by observing the median block size over the last 100 blocks and slowly retargets the maximum size of any new blocks accordingly. The long-term concern in other cryptocurrencies is that large block sizes burden the nodes that store and verify transactions. As block sizes grow, nodes that run on lower grade hardware are unable to process and propagate new blocks, leading to centralisation of the node network among those with a commercial interest in maintaining nodes. This can be concerning because distributing the blockchain across many nodes allows for the state of the chain to be confirmed among many different parties, adding to its validity and censorship resistance. In Loki, a portion of the block reward is given to Service Nodes that process and propagate blocks as full nodes. Because Service Nodes with insufficient bandwidth and performance are dropped from the Service Node network, the reward pool self-enforces a minimum performance requirement. This incentive structure not only ensures that the node count remains high , but that the said nodes are of a sufficient performance level to successfully share blockchain data across the network, irrespective of how large the blockchain grows or how demanding the bandwidth requirements are. Even so, transaction size optimisations are still required to ensure that the network scales efficiently so as to keep the Service Node operating costs down so that a high node count can be sustained in the long term.","title":"Dynamic Block Size"},{"location":"Advanced/IPandPacketBlocking/","text":"IP and Packet Blocking \u00b6 Although the Service Node network has no central points of failure, two significant censorship threats face the network; namely harvesting attacks and deep packet inspection . Harvesting attacks would seek to gather the IP addresses of all operating Service Nodes on the network and use ISP level firewalls to block connections to those particular addresses. This type of censorship is regularly performed on the Tor network in China . Deep packet inspection (DPI), aims to investigate the structuring of each individual packet that passes through a firewall, and selectively drop or block packets that appear to relate to a particular service. Again, DPI has been used extensively by state-level actors. Much work has been done to design systems which evade DPI. Users can leverage types of pluggable transports which alter the signature of each packet aiming to appear as normal unblocked traffic. IP blocking is generally avoided by running domain fronting bridges which will encrypt traffic as HTTPS requests to unblocked services like Azure or Cloudflare. Once they reach the unblocked service, the bridge will forward the request to the desired location. In the case of domain fronting, it becomes difficult for a state level actor to prevent the flow of all traffic to popular bridges without causing significant disruption to the general usage of the internet. Governance mechanisms built into Loki can be used to operate domain fronting bridges so that users can access Loki services in countries where large-scale internet censorship policies are at play. Additionally, OBFS4 pluggable transport support will be bundled with the Service Node release of the Loki wallet to help further protect against DPI.","title":"IP and Packet Blocking"},{"location":"Advanced/IPandPacketBlocking/#ip-and-packet-blocking","text":"Although the Service Node network has no central points of failure, two significant censorship threats face the network; namely harvesting attacks and deep packet inspection . Harvesting attacks would seek to gather the IP addresses of all operating Service Nodes on the network and use ISP level firewalls to block connections to those particular addresses. This type of censorship is regularly performed on the Tor network in China . Deep packet inspection (DPI), aims to investigate the structuring of each individual packet that passes through a firewall, and selectively drop or block packets that appear to relate to a particular service. Again, DPI has been used extensively by state-level actors. Much work has been done to design systems which evade DPI. Users can leverage types of pluggable transports which alter the signature of each packet aiming to appear as normal unblocked traffic. IP blocking is generally avoided by running domain fronting bridges which will encrypt traffic as HTTPS requests to unblocked services like Azure or Cloudflare. Once they reach the unblocked service, the bridge will forward the request to the desired location. In the case of domain fronting, it becomes difficult for a state level actor to prevent the flow of all traffic to popular bridges without causing significant disruption to the general usage of the internet. Governance mechanisms built into Loki can be used to operate domain fronting bridges so that users can access Loki services in countries where large-scale internet censorship policies are at play. Additionally, OBFS4 pluggable transport support will be bundled with the Service Node release of the Loki wallet to help further protect against DPI.","title":"IP and Packet Blocking"},{"location":"Advanced/PulseLip5/","text":"Loki Proof of Stake Mechanism: Pulse \u00b6 Metadata LIP Number: 5 Title: Pulse [Foundation Vote] [Not Yet Voted] Author/s: Kee Jefferys Status: Final Type: Core Created: date (2019-09-17) Introduction \u00b6 As Loki moves closer to enabling Service Node checkpointing on the mainnet, the role miners play in the Loki ecosystem has come under question. Historically, Loki miners have secured the blockchain with Proof of Work (PoW), produced blocks, and organised transactions. However Service Node checkpointing will provide security to the blockchain, diminishing a miner\u2019s role to that of only producing blocks and organising transactions. This naturally raises questions about whether miners can, or should be, removed in favour of a system where Service Nodes directly produce blocks, order transactions and secure the chain. The following Loki Improvement Proposal (LIP) will discuss this idea, with the view that a Proof of Stake (PoS) scheme should be adopted. This LIP will also outline how this could be achieved in Loki with a new PoS scheme called \u201cPulse\u201d. The Case for PoS \u00b6 There are several clear arguments that can be made for the adoption of PoS for Loki which I will elaborate on. Increases the Investment That Is Needed to Attack Loki \u00b6 To double spend a transaction, an attacker needs to produce an alternate blockchain with more cumulative difficulty in secret, which reverses a previously spent transaction. Assuming the malicious miner is not using advanced strategies (selfish mining, cartels), this requires the miner obtain 51% of the hashing power. Using RandomXL, Loki\u2019s current mining algorithm which is optimized for CPU performance, a Ryzen 1700 is able to produce about 4500 hashes per second. The total hashrate for Loki is currently about 17 Megahashes. Let's assume every miner is using a Ryzen 1700. This would equate to about 3,691 Ryzen 1700 chips on the Loki Network. If we estimate the hardware cost (including peripherals) of a malicious attacker, each of these miners could conservatively cost 400$ USD[1]. This means that for 51% of the hashrate to be obtained, an attacker would have to buy about 730,000$ USD worth of hardware to successfully attack the network. Keep in mind this uses very conservative estimates with consumer level pricing. It's likely that an attacker would be able to decrease their cost per unit well below 400$ USD, or the attacker could rent the equivalent hashing power, further reducing the cost of an attack. Compromising Masternode PoS would require that the malicious party or consortium own or rent control over 51% of the staked supply. As of the time of writing,, Loki has 620 staked Service Nodes and each stake is approximately 22,000 Loki. This means the malicious operators would need to gain control of about 13.6 million Loki, and with the current cost of Loki at ~0.15$ USD, this equates to about 2 million USD. This scenario ignores the fact that attempting to obtain such a large amount of Loki from the open market would inevitably lead to an increase in price (as with lower supply, and fixed demand, price increases) which would further inflate the cost. It Presents an Increased Sunken Cost for an Attacker \u00b6 RandomXL is designed to provide increased performance on hardware similar to general purpose CPUs, which means that hardware used in any attack is not a sunk cost as it can be recovered by selling or repurposing hardware used in the attack. In a Proof of Stake system where attackers have to buy into the network, performing an attack is likely to reduce users trust in the security of the network, making users likely to sell coins and devalue the attackers own stake. This makes it harder for the attacker to recoup their costs when selling their stake back to the network. Reduced Environmental Impact \u00b6 Proof of Work by its nature requires thousands of miners compete against each other to solve computationally hard mathematical problems. Many people are concerned about the environmental impact of mining, as it uses a massive amount of electricity. Proof of Stake, as implemented in Pulse does not require these energy intensive calculations: instead, it relies on the cooperation of Loki Service Nodes \u2014 which use comparatively small amounts of electricity. Pulse Overview \u00b6 Every 120 seconds, a leader is chosen from the top of the Service Node list. This leader creates a candidate block which they send to 11 randomly chosen Service Node validators. The validators ensure the block is valid, then perform a group ceremony to create a random value. Once the ceremony is finished, each validator includes the final random value in the candidate block, which they sign and send to their validator peers. Once a candidate block has more than 7 signatures, it can be published to the network as a valid block. The process is then repeated to create the next block. Pulse Specifics \u00b6 Proposal Round \u00b6 A single leader chosen sequentially from the Service Node list, plus a group of 11 validators chosen deterministically from the random value included in the last block. The leader scans the transaction pool and collects valid transactions into a block. With this information, the leader creates a candidate block which contains a coinbase transaction. The leader is rewarded according to the Service Node coinbase formula, and receives any transaction tx fees included in the block. The leader signs this candidate block and sends it to all of the validators, who each send it to 3 others until all validators successfully receive the candidate block. Every validator should now wait {candidate_wait}. Commit Round \u00b6 After waiting {candidate_wait}, every validator now generates a 128 bit integer, and commits to that integer by sending the hash of that integer to all other validators. Validators now wait {commit_wait}. Reveal Round \u00b6 After waiting {commit_wait}, validators may reveal the pre-image of the hash \u2014 which in this case is the random integer they committed to. They then send the pre-image of their committed hash to all validating peers. Validators now wait {reveal_wait}. After waiting {reveal_wait}, all validators should now have a subset of the revealed values, which they can combine locally to produce the final random value. Validators can add this to the candidate block and sign the resultant block. This signature is then sent to all other validators. Block Submission \u00b6 All validators now wait {submit_wait}. Once {submit_wait} has elapsed, validators check the validity of the other validator\u2019s signatures, ensuring they are signing the same candidate block and signing the same final random integer. Once signatures are validated, any validator in the quorum may submit a block to the network which includes at least 7 signatures from the group of validators. Proposed Times \u00b6 {candidate_wait} = 30 seconds {commit wait} = 20 seconds {reveal_wait} = 30 seconds {submit_wait} = 40 seconds Properties of Pulse \u00b6 Partially synchronous with reasonable timeouts Produces an unpredictable value that cannot be significantly biased by members of the quorum The scheme tolerates failure of up to ~45% of Service Nodes assuming a quorum size of 11 Targets a blocktime of 120 seconds Prerequisites and Presumptions \u00b6 Block Reward Restructure \u00b6 To implement Pulse, we assume miners have been completely removed from the network, and that mining rewards are either being reallocated to Service Nodes or not created at all. The current logic of sequentially rewarding each Service Node in a sorted list would be preserved, however for a Service Node to win this reward they must act honestly as a leader by producing a valid candidate block. Time Synchronicity \u00b6 We assume that Service Nodes maintain relative synchronicity (within the boundary of the enforced timeouts), which means that when an event like a creation of a new block is triggered, all Service Nodes should react to this event within a reasonable amount of time. Service Nodes \u00b6 We assume that a large and diverse network of staked Service Nodes exist; and that these Service Nodes will act as validators and leaders in the scheme. Because of their significant stake they may be punished by having their stake locked for a period of time (currently 30 days) using a deregistration transaction. Fault Tolerance \u00b6 Failures \u00b6 To make the first implementation of Pulse fairly straightforward, there will only ever be one way in which it can fail: a timeout. Initially this will sacrifice some speed \u2014 especially when recovering offline validators or leaders \u2014 however, this process can be sped up significantly once we have assessed the stability of the protocol in a live environment. Timeouts and Swap Blocks \u00b6 A timeout occurs when a valid block is not produced after max_timeout, which is the sum of all of the wait periods \u2014 effectively 120 seconds. As soon as the leader of the next quorum detects a timeout, they may immediately begin building and distributing a candidate block with a \u201cswap\u201d tag to their validators. If this block is signed by the validators, the swap tag will indicate that there was a quorum failure to newly syncing nodes, and nodes who have been offline. The next leader can always be calculated by XOR\u2019ing the last randomly produced value by a counter which iterates every time a block isn\u2019t created [2]. Demerits and Deregistrations \u00b6 Validators in a quorum can submit intent to demerit messages at any stage for a leader (or any other validator in their quorum) if they feel they have not followed the protocol. For example, if a leader never publishes a candidate block, any validator in the quorum may send an intent to demerit message to their other peers. If this message is signed by the majority of other validators it may be submitted to the network as a demerit point message. This message is not a transaction, and simply propagates through the p2p layer. When obligation quorums are created, each node selected for that obligation quorum checks their local log for demerit points, and if more than a predefined amount of demerit points have been seen in a period of time then a deregistration or decommission transaction with the relevant signed demerit points can be submitted to the network. Common Failure Cases \u00b6 To get a better understanding of Pulse, it is worth discussing what happens in some common failure cases. A leader does not submit a candidate block Not enough validators participate in the commit or reveal rounds Validators sign two different blocks Validators are unable to submit a block due to differences in revealed values Leader Does Not Submit a Candidate Block \u00b6 If a leader fails to construct and send a candidate block, the validators will be triggered to submit an intent to demerit message. If this message is signed by a simple majority of the quorum, a demerit point can be applied to the leader. The next leader will trigger the creation of a new block when max_timeout has elapsed. Not Enough Validators Participate in the Commit or Reveal Rounds \u00b6 Although all Service Nodes are incentivised to cooperate during the commit and reveal phases of the protocol to avoid demerit points, some participants may act maliciously or go offline during the process. The protocol should be able to tolerate the failure of 6 of 11 nodes during the commit reveal stage. As above, any validator that does not participate in a commit or reveal round, or reveals a different value from their commitment, can be flagged by other validators with an intent to demerit message. If this message is signed by a majority of nodes, this message can be submitted to the network as evidence of a node\u2019s non-performance in a block creation quorum. If more than 6 of 11 nodes do not participate in the commit or reveal round, the quorum will not be able to create a block \u2014 which means the next quorum can take over block creation when max_timeout is reached. Validators Are Unable to Submit a Block Due to Differences in Revealed Values \u00b6 There may be a number of cases where not all of the Service Nodes correctly receive all of the committed or revealed values. This will lead to the final random value that a validator calculates not matching the rest of the validators values. As with other errors the scheme will progress normally as long as the revealed values for 7 of the 11 validators match. Nodes with invalid revealed values can query the other validators in their quorum again to receive any values they missed during the two rounds. If more than 7 nodes disagree on the final revealed value, then the scheme will fail after max_timeout and the next leader may begin the process of producing a new block. Validator Signs Two Different Blocks \u00b6 Any Service Node, including a validator or leader, may submit a deregistration transaction if they can produce signatures from any other Service Node that signs multiple blocks which compete for the same height, or signs a competing chain once more than two checkpoints have been applied. This means that any node that signs blocks indiscriminately in block creation quorums will be immediately removed from the network with their funds locked. Traditional PoS Attacks \u00b6 Stake grind attacks \u00b6 Stake grinding usually refers to a class of attacks where a validator or leader can iterate values to bias the selection of the next chosen validator. Since validators are chosen by using a collaboratively generated random integer in each block, it is possible to bias the results of the scheme. However the only way to do this effectively is for a validator to choose not to reveal a value that they previously committed. In the context of Service Node selection for the next quorum, this biasing is extremely weak, and the action of committing but failing to reveal a value leads to a demerit message being submitted for the validator who performs such an action, making this attack infeasible. Long Range Attacks \u00b6 Long range attacks are attacks where nodes that are syncing the chain, or that are offline for a period of time, can be convinced of an alternate state of the chain. This occurs because old Service Nodes can use previously held Service Node keys to resign blocks that appear as alternate chains. Online Nodes \u00b6 The Loki blockchain already provides a solution for online nodes with Service Node checkpointing. This prevents Service Nodes from altering blocks that have received more than 2 checkpoints[3]. However, tackling the problem of nodes that go offline and miss more than two checkpoints in a row or nodes who are syncing for the first time is more difficult. Syncing Nodes or Partially Offline Nodes \u00b6 When a node has no previous state of the blockchain, or has been offline long enough to miss enough checkpoints that it is infeasible for it to validate the non alteration of blocks, it must use an external trusted source to correctly identify the main chain. This is usually referred to as weak subjectivity [4]. The easiest way to solve this issue is to allow syncing Service Nodes, and Service Nodes that have been offline to refer to the seed nodes to ascertain what is the true chain. This is already the case in Proof of Work blockchains, since seed nodes provide the initial list of peers to sync from. To implement weak subjectivity in Loki, seed nodes should additionally provide a list of the latest checkpoints, so that when a client is syncing they can ensure they are syncing to the correct chain \u2014 and not being segmented onto a network with valid but altered signatures. Nothing at Stake \u00b6 The \u2018nothing at stake\u2019 problem references a validator\u2019s tendency to sign or authorise multiple competing blocks in a Proof of Stake system. They are incentivised to do this because they can\u2019t be sure which chain will become the true chain in the long term, thereby they should sign competing blocks to ensure they don't miss rewards. With Pulse, the \u2018nothing at stake\u2019 problem is prevented by allowing nodes in the network to submit evidence of double signed blocks. If this evidence can be validated, the offending node can be deregistered from the network, providing a punishment for nodes who do not effectively choose a single block to sign. DDOS attacks \u00b6 All Service Nodes in the Loki network maintain a public IP address so they are reachable by other Service Nodes and Lokinet / Session users. These IP addresses are held in a distributed list that anyone can access. This opens the Service Node network and especially block producing quorums to DDoS attacks. For example, an attacker could wait for a block to be successfully published and immediately identify the members of the next quorum who will produce a block. With this information, they could launch a DDoS attack aimed to interrupt the communication between validators, or between the leader and validators. If successful, they would prevent a new block from being produced and could continue this attack on successive quorums. Although individual Service Nodes have incentives to prevent DDoS attacks (so they can earn rewards and avoid demerit points), there are some protections we can offer in the Loki software suite which can be deployed in the case that the previous block has failed to be produced. The most trivial protection is that after a failure in block creation, Service Nodes in the next selected quorum should ignore any connections from IP addresses which do not belong to another Service Node. This limits the scope of the attacker\u2019s DDoS to only Service Nodes \u2014 which are costly to operate and far less numerous than a botnet-like DDoS attack. Service Node operators could also reasonably rate limit other Service Nodes on a per key basis, choosing not to respond to Service Nodes who put undue strain on their own networks. Considerations \u00b6 Safety of Commit Reveal schemes \u00b6 Collaborative commit reveal schemes for generating random values are well studied, and limitations on such schemes are well known [5][6][7]. The primary downside to using this type of scheme is that although committed values cannot be changed after they have been committed, a contributor to the scheme may bias the results by not revealing their committed value at all. For example, say a block creation quorum produces a value between 0 and 10 each block, and Alice wants to run an online casino which uses this random integer to flip a coin, with bets being placed on heads or tails. Alice\u2019s casino algorithm reads the random integer from the blockchain and if the random value is between 0-4 then the coin is tails, and if it's between 5-10 it\u2019s heads. A possible attack on this application would be for a Service Node operator, let\u2019s call her \u201cMallory\u201d, to wait to become a validator in a quorum, act honestly, and commit to a random value. Once she has committed to the scheme, she waits for the other validators to reveal their original integers. She can now calculate the shared random result for those validators that have revealed. Let\u2019s suppose their combined final value will be 3. Using this information and whatever deterministic algorithm that is used to combine each validators contribution, Mallory can now decide whether or not she wants to reveal her result and add her contribution to this data. If Mallory bets on tails and realises revealing her commitment would change the overall result to heads, then she should not reveal her commitment. If her commitment (when combined with the other commitments) still selects a number under 3, then she can reveal her committed value. Of course, the cost of not revealing a commitment is demerit points being applied to Mallory\u2019s Service Node which will lead to deregistration in the event that Mallory has not revealed her commitments consistently. However, as long as Mallory\u2019s winnings are more than the cost of being deregistered from the Service Node network, her dishonest actions are financially incentivised. It should be clear from this example that Service Nodes can significantly bias the results of decisions which have few available outcomes, like a coin toss. So applications should not use the random integer we are creating for these type of use cases! The Loki blockchain, however, does not use the source of randomness in this way. We use the randomness to choose Service Nodes in a Service Node list, where biasing the results has an insignificant effect as the possible outcomes are far more numerous. With Pulse, the randomness seeds an algorithm that chooses a combination of 11 nodes out of currently about 620 nodes. Mallory, in this case, would be able to choose between two (and only two) different random samples of 11 nodes from the selection of 620, but this single extra choice is highly unlikely to provide a notable benefit in terms of opportunistic selection. Blocktimes \u00b6 In Loki, a block is created on average every 120 seconds, however block production is distributed on an exponential distribution, meaning blocks will often be created earlier or later than expected. This effect is exacerbated during large hashrate fluctuations, and this unpredictability can be frustrating for users waiting for transactions to confirm. Blocktime in Pulse is controlled through mandatory wait periods that are added at each stage of block creation. Conservative estimates have been taken for the first implementation of the proposed scheme, allowing for nodes who maintain relative synchronicity to successfully participate in the scheme. It's likely that after testing we can reduce or eliminate some of these mandatory wait periods thereby reducing the blocktime. However, in the first implementation, we target a predictable block time of 120 seconds \u2014 excluding the rare case where block creation fails. In this case, a block would be created in the subsequent 120 seconds. This means that in a majority of cases users won't be left wondering when the next block is coming, since blocks will be predictability created every 120 seconds. Conclusion \u00b6 Pulse is a robust yet simple scheme which provides a clear vision for the future of block creation and transaction ordering in the Loki Network. Pulse does this while also increasing security and decreasing the need to use energy intensive proof of work. Additionally, it better aligns existing incentive structures to reward those who do the most work to create order, and secure the network. [1]\"PC part picker Ryzen 1700 build\" https://pcpartpicker.com/list/wGVPyX. [2]\"Exclusive or - Wikipedia.\" https://en.wikipedia.org/wiki/Exclusive_or. [3]\"loki-improvement-proposals/LIP-3.md at master \u00b7 loki-project ... - GitHub.\" https://github.com/loki-project/loki-improvement-proposals/blob/master/LIPS/LIP-3.md. [4]\"Weak Subjectivity - Definition | Binance Academy.\" https://www.binance.vision/glossary/weak-subjectivity. [5]\"RANDAO beacon exploitability analysis, round 2 - Casper - Ethereum ....\" https://ethresear.ch/t/randao-beacon-exploitability-analysis-round-2/1980. [6] \"RNG exploitability analysis assuming pure RANDAO-based main chain.\" https://ethresear.ch/t/rng-exploitability-analysis-assuming-pure-randao-based-main-chain/1825. [7] \"Statistical Model Checking of RANDAO's ... - Semantic Scholar.\" https://pdfs.semanticscholar.org/c267/d8b8383c0dd9103f9920e1e7c448cb063376.pdf. Special thanks to Jason Rhinelander, for helping me proofread and refine some of the concepts in this LIP.","title":"Loki Documentation | Loki Proof of Stake | Pulse"},{"location":"Advanced/PulseLip5/#loki-proof-of-stake-mechanism-pulse","text":"Metadata LIP Number: 5 Title: Pulse [Foundation Vote] [Not Yet Voted] Author/s: Kee Jefferys Status: Final Type: Core Created: date (2019-09-17)","title":"Loki Proof of Stake Mechanism: Pulse"},{"location":"Advanced/PulseLip5/#introduction","text":"As Loki moves closer to enabling Service Node checkpointing on the mainnet, the role miners play in the Loki ecosystem has come under question. Historically, Loki miners have secured the blockchain with Proof of Work (PoW), produced blocks, and organised transactions. However Service Node checkpointing will provide security to the blockchain, diminishing a miner\u2019s role to that of only producing blocks and organising transactions. This naturally raises questions about whether miners can, or should be, removed in favour of a system where Service Nodes directly produce blocks, order transactions and secure the chain. The following Loki Improvement Proposal (LIP) will discuss this idea, with the view that a Proof of Stake (PoS) scheme should be adopted. This LIP will also outline how this could be achieved in Loki with a new PoS scheme called \u201cPulse\u201d.","title":"Introduction"},{"location":"Advanced/PulseLip5/#the-case-for-pos","text":"There are several clear arguments that can be made for the adoption of PoS for Loki which I will elaborate on.","title":"The Case for PoS"},{"location":"Advanced/PulseLip5/#increases-the-investment-that-is-needed-to-attack-loki","text":"To double spend a transaction, an attacker needs to produce an alternate blockchain with more cumulative difficulty in secret, which reverses a previously spent transaction. Assuming the malicious miner is not using advanced strategies (selfish mining, cartels), this requires the miner obtain 51% of the hashing power. Using RandomXL, Loki\u2019s current mining algorithm which is optimized for CPU performance, a Ryzen 1700 is able to produce about 4500 hashes per second. The total hashrate for Loki is currently about 17 Megahashes. Let's assume every miner is using a Ryzen 1700. This would equate to about 3,691 Ryzen 1700 chips on the Loki Network. If we estimate the hardware cost (including peripherals) of a malicious attacker, each of these miners could conservatively cost 400$ USD[1]. This means that for 51% of the hashrate to be obtained, an attacker would have to buy about 730,000$ USD worth of hardware to successfully attack the network. Keep in mind this uses very conservative estimates with consumer level pricing. It's likely that an attacker would be able to decrease their cost per unit well below 400$ USD, or the attacker could rent the equivalent hashing power, further reducing the cost of an attack. Compromising Masternode PoS would require that the malicious party or consortium own or rent control over 51% of the staked supply. As of the time of writing,, Loki has 620 staked Service Nodes and each stake is approximately 22,000 Loki. This means the malicious operators would need to gain control of about 13.6 million Loki, and with the current cost of Loki at ~0.15$ USD, this equates to about 2 million USD. This scenario ignores the fact that attempting to obtain such a large amount of Loki from the open market would inevitably lead to an increase in price (as with lower supply, and fixed demand, price increases) which would further inflate the cost.","title":"Increases the Investment That Is Needed to Attack Loki"},{"location":"Advanced/PulseLip5/#it-presents-an-increased-sunken-cost-for-an-attacker","text":"RandomXL is designed to provide increased performance on hardware similar to general purpose CPUs, which means that hardware used in any attack is not a sunk cost as it can be recovered by selling or repurposing hardware used in the attack. In a Proof of Stake system where attackers have to buy into the network, performing an attack is likely to reduce users trust in the security of the network, making users likely to sell coins and devalue the attackers own stake. This makes it harder for the attacker to recoup their costs when selling their stake back to the network.","title":"It Presents an Increased Sunken Cost for an Attacker"},{"location":"Advanced/PulseLip5/#reduced-environmental-impact","text":"Proof of Work by its nature requires thousands of miners compete against each other to solve computationally hard mathematical problems. Many people are concerned about the environmental impact of mining, as it uses a massive amount of electricity. Proof of Stake, as implemented in Pulse does not require these energy intensive calculations: instead, it relies on the cooperation of Loki Service Nodes \u2014 which use comparatively small amounts of electricity.","title":"Reduced Environmental Impact"},{"location":"Advanced/PulseLip5/#pulse-overview","text":"Every 120 seconds, a leader is chosen from the top of the Service Node list. This leader creates a candidate block which they send to 11 randomly chosen Service Node validators. The validators ensure the block is valid, then perform a group ceremony to create a random value. Once the ceremony is finished, each validator includes the final random value in the candidate block, which they sign and send to their validator peers. Once a candidate block has more than 7 signatures, it can be published to the network as a valid block. The process is then repeated to create the next block.","title":"Pulse Overview"},{"location":"Advanced/PulseLip5/#pulse-specifics","text":"","title":"Pulse Specifics"},{"location":"Advanced/PulseLip5/#proposal-round","text":"A single leader chosen sequentially from the Service Node list, plus a group of 11 validators chosen deterministically from the random value included in the last block. The leader scans the transaction pool and collects valid transactions into a block. With this information, the leader creates a candidate block which contains a coinbase transaction. The leader is rewarded according to the Service Node coinbase formula, and receives any transaction tx fees included in the block. The leader signs this candidate block and sends it to all of the validators, who each send it to 3 others until all validators successfully receive the candidate block. Every validator should now wait {candidate_wait}.","title":"Proposal Round"},{"location":"Advanced/PulseLip5/#commit-round","text":"After waiting {candidate_wait}, every validator now generates a 128 bit integer, and commits to that integer by sending the hash of that integer to all other validators. Validators now wait {commit_wait}.","title":"Commit Round"},{"location":"Advanced/PulseLip5/#reveal-round","text":"After waiting {commit_wait}, validators may reveal the pre-image of the hash \u2014 which in this case is the random integer they committed to. They then send the pre-image of their committed hash to all validating peers. Validators now wait {reveal_wait}. After waiting {reveal_wait}, all validators should now have a subset of the revealed values, which they can combine locally to produce the final random value. Validators can add this to the candidate block and sign the resultant block. This signature is then sent to all other validators.","title":"Reveal Round"},{"location":"Advanced/PulseLip5/#block-submission","text":"All validators now wait {submit_wait}. Once {submit_wait} has elapsed, validators check the validity of the other validator\u2019s signatures, ensuring they are signing the same candidate block and signing the same final random integer. Once signatures are validated, any validator in the quorum may submit a block to the network which includes at least 7 signatures from the group of validators.","title":"Block Submission"},{"location":"Advanced/PulseLip5/#proposed-times","text":"{candidate_wait} = 30 seconds {commit wait} = 20 seconds {reveal_wait} = 30 seconds {submit_wait} = 40 seconds","title":"Proposed Times"},{"location":"Advanced/PulseLip5/#properties-of-pulse","text":"Partially synchronous with reasonable timeouts Produces an unpredictable value that cannot be significantly biased by members of the quorum The scheme tolerates failure of up to ~45% of Service Nodes assuming a quorum size of 11 Targets a blocktime of 120 seconds","title":"Properties of Pulse"},{"location":"Advanced/PulseLip5/#prerequisites-and-presumptions","text":"","title":"Prerequisites and Presumptions"},{"location":"Advanced/PulseLip5/#block-reward-restructure","text":"To implement Pulse, we assume miners have been completely removed from the network, and that mining rewards are either being reallocated to Service Nodes or not created at all. The current logic of sequentially rewarding each Service Node in a sorted list would be preserved, however for a Service Node to win this reward they must act honestly as a leader by producing a valid candidate block.","title":"Block Reward Restructure"},{"location":"Advanced/PulseLip5/#time-synchronicity","text":"We assume that Service Nodes maintain relative synchronicity (within the boundary of the enforced timeouts), which means that when an event like a creation of a new block is triggered, all Service Nodes should react to this event within a reasonable amount of time.","title":"Time Synchronicity"},{"location":"Advanced/PulseLip5/#service-nodes","text":"We assume that a large and diverse network of staked Service Nodes exist; and that these Service Nodes will act as validators and leaders in the scheme. Because of their significant stake they may be punished by having their stake locked for a period of time (currently 30 days) using a deregistration transaction.","title":"Service Nodes"},{"location":"Advanced/PulseLip5/#fault-tolerance","text":"","title":"Fault Tolerance"},{"location":"Advanced/PulseLip5/#failures","text":"To make the first implementation of Pulse fairly straightforward, there will only ever be one way in which it can fail: a timeout. Initially this will sacrifice some speed \u2014 especially when recovering offline validators or leaders \u2014 however, this process can be sped up significantly once we have assessed the stability of the protocol in a live environment.","title":"Failures"},{"location":"Advanced/PulseLip5/#timeouts-and-swap-blocks","text":"A timeout occurs when a valid block is not produced after max_timeout, which is the sum of all of the wait periods \u2014 effectively 120 seconds. As soon as the leader of the next quorum detects a timeout, they may immediately begin building and distributing a candidate block with a \u201cswap\u201d tag to their validators. If this block is signed by the validators, the swap tag will indicate that there was a quorum failure to newly syncing nodes, and nodes who have been offline. The next leader can always be calculated by XOR\u2019ing the last randomly produced value by a counter which iterates every time a block isn\u2019t created [2].","title":"Timeouts and Swap Blocks"},{"location":"Advanced/PulseLip5/#demerits-and-deregistrations","text":"Validators in a quorum can submit intent to demerit messages at any stage for a leader (or any other validator in their quorum) if they feel they have not followed the protocol. For example, if a leader never publishes a candidate block, any validator in the quorum may send an intent to demerit message to their other peers. If this message is signed by the majority of other validators it may be submitted to the network as a demerit point message. This message is not a transaction, and simply propagates through the p2p layer. When obligation quorums are created, each node selected for that obligation quorum checks their local log for demerit points, and if more than a predefined amount of demerit points have been seen in a period of time then a deregistration or decommission transaction with the relevant signed demerit points can be submitted to the network.","title":"Demerits and Deregistrations"},{"location":"Advanced/PulseLip5/#common-failure-cases","text":"To get a better understanding of Pulse, it is worth discussing what happens in some common failure cases. A leader does not submit a candidate block Not enough validators participate in the commit or reveal rounds Validators sign two different blocks Validators are unable to submit a block due to differences in revealed values","title":"Common Failure Cases"},{"location":"Advanced/PulseLip5/#leader-does-not-submit-a-candidate-block","text":"If a leader fails to construct and send a candidate block, the validators will be triggered to submit an intent to demerit message. If this message is signed by a simple majority of the quorum, a demerit point can be applied to the leader. The next leader will trigger the creation of a new block when max_timeout has elapsed.","title":"Leader Does Not Submit a Candidate Block"},{"location":"Advanced/PulseLip5/#not-enough-validators-participate-in-the-commit-or-reveal-rounds","text":"Although all Service Nodes are incentivised to cooperate during the commit and reveal phases of the protocol to avoid demerit points, some participants may act maliciously or go offline during the process. The protocol should be able to tolerate the failure of 6 of 11 nodes during the commit reveal stage. As above, any validator that does not participate in a commit or reveal round, or reveals a different value from their commitment, can be flagged by other validators with an intent to demerit message. If this message is signed by a majority of nodes, this message can be submitted to the network as evidence of a node\u2019s non-performance in a block creation quorum. If more than 6 of 11 nodes do not participate in the commit or reveal round, the quorum will not be able to create a block \u2014 which means the next quorum can take over block creation when max_timeout is reached.","title":"Not Enough Validators Participate in the Commit or Reveal Rounds"},{"location":"Advanced/PulseLip5/#validators-are-unable-to-submit-a-block-due-to-differences-in-revealed-values","text":"There may be a number of cases where not all of the Service Nodes correctly receive all of the committed or revealed values. This will lead to the final random value that a validator calculates not matching the rest of the validators values. As with other errors the scheme will progress normally as long as the revealed values for 7 of the 11 validators match. Nodes with invalid revealed values can query the other validators in their quorum again to receive any values they missed during the two rounds. If more than 7 nodes disagree on the final revealed value, then the scheme will fail after max_timeout and the next leader may begin the process of producing a new block.","title":"Validators Are Unable to Submit a Block Due to Differences in Revealed Values"},{"location":"Advanced/PulseLip5/#validator-signs-two-different-blocks","text":"Any Service Node, including a validator or leader, may submit a deregistration transaction if they can produce signatures from any other Service Node that signs multiple blocks which compete for the same height, or signs a competing chain once more than two checkpoints have been applied. This means that any node that signs blocks indiscriminately in block creation quorums will be immediately removed from the network with their funds locked.","title":"Validator Signs Two Different Blocks"},{"location":"Advanced/PulseLip5/#traditional-pos-attacks","text":"","title":"Traditional PoS Attacks"},{"location":"Advanced/PulseLip5/#stake-grind-attacks","text":"Stake grinding usually refers to a class of attacks where a validator or leader can iterate values to bias the selection of the next chosen validator. Since validators are chosen by using a collaboratively generated random integer in each block, it is possible to bias the results of the scheme. However the only way to do this effectively is for a validator to choose not to reveal a value that they previously committed. In the context of Service Node selection for the next quorum, this biasing is extremely weak, and the action of committing but failing to reveal a value leads to a demerit message being submitted for the validator who performs such an action, making this attack infeasible.","title":"Stake grind attacks"},{"location":"Advanced/PulseLip5/#long-range-attacks","text":"Long range attacks are attacks where nodes that are syncing the chain, or that are offline for a period of time, can be convinced of an alternate state of the chain. This occurs because old Service Nodes can use previously held Service Node keys to resign blocks that appear as alternate chains.","title":"Long Range Attacks"},{"location":"Advanced/PulseLip5/#online-nodes","text":"The Loki blockchain already provides a solution for online nodes with Service Node checkpointing. This prevents Service Nodes from altering blocks that have received more than 2 checkpoints[3]. However, tackling the problem of nodes that go offline and miss more than two checkpoints in a row or nodes who are syncing for the first time is more difficult.","title":"Online Nodes"},{"location":"Advanced/PulseLip5/#syncing-nodes-or-partially-offline-nodes","text":"When a node has no previous state of the blockchain, or has been offline long enough to miss enough checkpoints that it is infeasible for it to validate the non alteration of blocks, it must use an external trusted source to correctly identify the main chain. This is usually referred to as weak subjectivity [4]. The easiest way to solve this issue is to allow syncing Service Nodes, and Service Nodes that have been offline to refer to the seed nodes to ascertain what is the true chain. This is already the case in Proof of Work blockchains, since seed nodes provide the initial list of peers to sync from. To implement weak subjectivity in Loki, seed nodes should additionally provide a list of the latest checkpoints, so that when a client is syncing they can ensure they are syncing to the correct chain \u2014 and not being segmented onto a network with valid but altered signatures.","title":"Syncing Nodes or Partially Offline Nodes"},{"location":"Advanced/PulseLip5/#nothing-at-stake","text":"The \u2018nothing at stake\u2019 problem references a validator\u2019s tendency to sign or authorise multiple competing blocks in a Proof of Stake system. They are incentivised to do this because they can\u2019t be sure which chain will become the true chain in the long term, thereby they should sign competing blocks to ensure they don't miss rewards. With Pulse, the \u2018nothing at stake\u2019 problem is prevented by allowing nodes in the network to submit evidence of double signed blocks. If this evidence can be validated, the offending node can be deregistered from the network, providing a punishment for nodes who do not effectively choose a single block to sign.","title":"Nothing at Stake"},{"location":"Advanced/PulseLip5/#ddos-attacks","text":"All Service Nodes in the Loki network maintain a public IP address so they are reachable by other Service Nodes and Lokinet / Session users. These IP addresses are held in a distributed list that anyone can access. This opens the Service Node network and especially block producing quorums to DDoS attacks. For example, an attacker could wait for a block to be successfully published and immediately identify the members of the next quorum who will produce a block. With this information, they could launch a DDoS attack aimed to interrupt the communication between validators, or between the leader and validators. If successful, they would prevent a new block from being produced and could continue this attack on successive quorums. Although individual Service Nodes have incentives to prevent DDoS attacks (so they can earn rewards and avoid demerit points), there are some protections we can offer in the Loki software suite which can be deployed in the case that the previous block has failed to be produced. The most trivial protection is that after a failure in block creation, Service Nodes in the next selected quorum should ignore any connections from IP addresses which do not belong to another Service Node. This limits the scope of the attacker\u2019s DDoS to only Service Nodes \u2014 which are costly to operate and far less numerous than a botnet-like DDoS attack. Service Node operators could also reasonably rate limit other Service Nodes on a per key basis, choosing not to respond to Service Nodes who put undue strain on their own networks.","title":"DDOS attacks"},{"location":"Advanced/PulseLip5/#considerations","text":"","title":"Considerations"},{"location":"Advanced/PulseLip5/#safety-of-commit-reveal-schemes","text":"Collaborative commit reveal schemes for generating random values are well studied, and limitations on such schemes are well known [5][6][7]. The primary downside to using this type of scheme is that although committed values cannot be changed after they have been committed, a contributor to the scheme may bias the results by not revealing their committed value at all. For example, say a block creation quorum produces a value between 0 and 10 each block, and Alice wants to run an online casino which uses this random integer to flip a coin, with bets being placed on heads or tails. Alice\u2019s casino algorithm reads the random integer from the blockchain and if the random value is between 0-4 then the coin is tails, and if it's between 5-10 it\u2019s heads. A possible attack on this application would be for a Service Node operator, let\u2019s call her \u201cMallory\u201d, to wait to become a validator in a quorum, act honestly, and commit to a random value. Once she has committed to the scheme, she waits for the other validators to reveal their original integers. She can now calculate the shared random result for those validators that have revealed. Let\u2019s suppose their combined final value will be 3. Using this information and whatever deterministic algorithm that is used to combine each validators contribution, Mallory can now decide whether or not she wants to reveal her result and add her contribution to this data. If Mallory bets on tails and realises revealing her commitment would change the overall result to heads, then she should not reveal her commitment. If her commitment (when combined with the other commitments) still selects a number under 3, then she can reveal her committed value. Of course, the cost of not revealing a commitment is demerit points being applied to Mallory\u2019s Service Node which will lead to deregistration in the event that Mallory has not revealed her commitments consistently. However, as long as Mallory\u2019s winnings are more than the cost of being deregistered from the Service Node network, her dishonest actions are financially incentivised. It should be clear from this example that Service Nodes can significantly bias the results of decisions which have few available outcomes, like a coin toss. So applications should not use the random integer we are creating for these type of use cases! The Loki blockchain, however, does not use the source of randomness in this way. We use the randomness to choose Service Nodes in a Service Node list, where biasing the results has an insignificant effect as the possible outcomes are far more numerous. With Pulse, the randomness seeds an algorithm that chooses a combination of 11 nodes out of currently about 620 nodes. Mallory, in this case, would be able to choose between two (and only two) different random samples of 11 nodes from the selection of 620, but this single extra choice is highly unlikely to provide a notable benefit in terms of opportunistic selection.","title":"Safety of Commit Reveal schemes"},{"location":"Advanced/PulseLip5/#blocktimes","text":"In Loki, a block is created on average every 120 seconds, however block production is distributed on an exponential distribution, meaning blocks will often be created earlier or later than expected. This effect is exacerbated during large hashrate fluctuations, and this unpredictability can be frustrating for users waiting for transactions to confirm. Blocktime in Pulse is controlled through mandatory wait periods that are added at each stage of block creation. Conservative estimates have been taken for the first implementation of the proposed scheme, allowing for nodes who maintain relative synchronicity to successfully participate in the scheme. It's likely that after testing we can reduce or eliminate some of these mandatory wait periods thereby reducing the blocktime. However, in the first implementation, we target a predictable block time of 120 seconds \u2014 excluding the rare case where block creation fails. In this case, a block would be created in the subsequent 120 seconds. This means that in a majority of cases users won't be left wondering when the next block is coming, since blocks will be predictability created every 120 seconds.","title":"Blocktimes"},{"location":"Advanced/PulseLip5/#conclusion","text":"Pulse is a robust yet simple scheme which provides a clear vision for the future of block creation and transaction ordering in the Loki Network. Pulse does this while also increasing security and decreasing the need to use energy intensive proof of work. Additionally, it better aligns existing incentive structures to reward those who do the most work to create order, and secure the network. [1]\"PC part picker Ryzen 1700 build\" https://pcpartpicker.com/list/wGVPyX. [2]\"Exclusive or - Wikipedia.\" https://en.wikipedia.org/wiki/Exclusive_or. [3]\"loki-improvement-proposals/LIP-3.md at master \u00b7 loki-project ... - GitHub.\" https://github.com/loki-project/loki-improvement-proposals/blob/master/LIPS/LIP-3.md. [4]\"Weak Subjectivity - Definition | Binance Academy.\" https://www.binance.vision/glossary/weak-subjectivity. [5]\"RANDAO beacon exploitability analysis, round 2 - Casper - Ethereum ....\" https://ethresear.ch/t/randao-beacon-exploitability-analysis-round-2/1980. [6] \"RNG exploitability analysis assuming pure RANDAO-based main chain.\" https://ethresear.ch/t/rng-exploitability-analysis-assuming-pure-randao-based-main-chain/1825. [7] \"Statistical Model Checking of RANDAO's ... - Semantic Scholar.\" https://pdfs.semanticscholar.org/c267/d8b8383c0dd9103f9920e1e7c448cb063376.pdf. Special thanks to Jason Rhinelander, for helping me proofread and refine some of the concepts in this LIP.","title":"Conclusion"},{"location":"Advanced/SwarmFlagging/","text":"Swarm Flagging \u00b6 When nodes operate in a trustless environment without a centralised leader enforcing over arching rules, maintaining proper node behaviour on the network becomes difficult. Although Service Nodes in Loki must hold the correct collateral requirement , they may choose to not route traffic or store data in their memory pools. Because this option is financially beneficial (using less bandwidth/CPU cycles/storage), a system of distributed flagging must be proposed to remove underperforming nodes. For Loki, such distributed flagging faces major implementation issues. Fundamentally, every Service Nodes is financially incentivised to flag every other Service Node as a bad actor. This is because when a Service Node is flagged it will face removal from the staking pool and thereby increase the flaggers chance at winning a reward. One potential method of distributed flagging is one in which evidence is provided when a flagging event occurs, however, this solution falls prey to nodes fabricating evidence in their favour. Conversely, flagging without restrictions allows either single nodes or groups of collaborating nodes to intentionally flag honest nodes in order to improve their chances of winning block rewards . To circumvent these issues, Loki proposes swarm flagging. Swarm flagging works by using existing swarms to choose members that will participate in each testing round. Each Service Node holds a copy of the blockchain, and each block created by a miner will deterministically select a number of test swarms. Every block, 1% of the networks swarms are selected for participation in a testing swarm. To calculate participating swarms, the hash of the five previous blocks is used to seed a Mersenne Twister function which then selects swarms by order of their position in the deterministic list. When a swarm has been selected to participate, each node in that swarm is expected to conduct a number of tests on every other node in the swarm. These are not active tests; rather each node stores historical information about its interactions with every other nodenwithin its swarm. Information about bandwidth, message storage , blockchain requests, and exit node functionality are collected and retained over time. New swarm entrants that have yet to gather this information can query Service Nodes outside of their immediate swarm so as to gather data on each of the Service Nodes they test. Each Service Nodes decides how to vote on each of the other swarm members. Once it has made its decision based on the aforementioned tests, it collects and broadcasts its votes to the swarm. Each node in the swarm can now check the votes for all members. If any single node in the swarm has over 50% of the nodes voting against it, any swarm member has the required information to construct a deregistration transaction. Once this transaction is validated and included in a block, all Service Nodes update their DHT, purging any nodes that were voted off. Testing Suite \u00b6 In order to allow the network to self-enforce performance standards, Service Nodes must be equipped with the required tools so as to test other Service Nodes. These tests should cover the scope of all functionality provided by Service Nodes to prevent lazy masternode attacks . In this initial design, four fundamental tests are proposed. Further tests may be added to the test suite as the function of Services Nodes expands. When an operator first runs the Service Nodes software, an empty file with a predetermined size is allocated on disk to ensure that space is present for tasks that require storage. Next, a simple bandwidth test is conducted between the Service Node and a geographically distributed set of testing servers run by the Loki Foundation . These checks are optional, and Service Nodes are allowed to skip, ignore or fail them, and join the pool of untrusted Service Nodes. However, running and passing these tests provides a good indicator to any would-be Service Node operator as to whether they should risk locking collateral in a node that may not meet minimum requirements. Once a Service Node joins the untrusted Service Node pool, their collateral is locked and they are tested by the next chosen swarm. Swarm tests are enforced via consensus and new entrants to the Service Node network cannot evade these tests. If a node passes all swarm tests, they are awarded the trusted node flag and can begin routing packets. Failing this, they are removed from the network and their collateral remains locked for 30 days. Bandwidth Test \u00b6 The bandwidth test forms the backbone of the Loki network test suite. If a node passes this test then it is assumed to be honestly routing packets above the minimum threshold. Each time a node interacts with another Service Node, it will make and retain a record of the incoming bandwidth provided. Over time, nodes will be included in thousands of paths and route millions of messages . These interactions will form the basis of each nodes bandwidth tables. From this table, a node can respond to bandwidth tests about Service Nodes inside its swarm. All nodes are also expected to respond to queries of their own bandwidth tables from other nodes. This means that even nodes who have recently joined the network can query the wider network for information about any specific node in their swarm. Message Storage Test \u00b6 Message storage is essential for offline messaging functionality for users of Session . Service Nodes must be tested for their ability to cache messages and serve them to users over the course of the message\u2019s Time-to-live (TTL). Users sending offline messages randomly select a Service Node within the destination users swarm. This node must distribute a copy of the message amongst the rest of the swarm. Depending on the proof-of-work attached to the header of the message, Service Nodes that receive a copy will store the data for the TTL. As the TTL on the original message reaches finality, the distributing node sends a nonce to all other members of the swarm. The swarm uses the nonce adding it to the message then hashing the result and then finally sending it back to the distributing node. This test ensures that Service Nodes hold messages until TTL finality, and face eviction if they are unable to produce the correct message digest. As the sampling of the distributing node is random, over time each Service Node will be able to collect performance data on their swarm peers. Blockchain Storage Test \u00b6 Service Nodes are expected to hold a full copy of the Loki blockchain. By holding a full copy of the blockchain, Service Nodes can perform a number of tasks that are essential to users of the network including acting as a remote node , validating transactions, and locking transactions in Blink . As honest nodes also hold a copy of the blockchain, a dishonest node could avoid holding a full copy by simply requesting blocks from an honest node when tested. To avoid this outcome, the blockchain storage test is designed so that honest nodes that hold a copy of the blockchain can pass this test, while dishonest nodes cannot. To achieve this, the testing node requests each tested node to make a selection of K random transactions within the history of the blockchain which are then concatenated and hashed. This hash is then returned to the testing node. By measuring the latency of this request, the testing node can compare the latency with the expected return time T . The exact value for T will be set to accurately differentiate expected latency between loading from disk and downloading blocks from the network. For any attacker, it should be infeasible to download and hash K blocks within T , and thus piggybacking attacks become difficult. Exit Node Test \u00b6 Service Nodes that opt to act as exit nodes receive additional rewards, and so functional tests are required to ensure this extra reward is not abused. For functional exit testing to occur, a Service Node must be able to emulate the natural search behaviour of a human. If a Service Node can detect that it is being tested, it can respond only to tests and discard legitimate user requests. Emulating natural page request behaviour is difficult, however, exit tests can be designed in such a way so as to make the overhead of sorting between legitimate requests and tests sufficiently difficult so that the difference in bandwidth cost between running a legitimate node and a malicious node is negligible. Service Nodes use a list of search engines, held locally, combined with a dictionary so as to construct pseudorandom natural search terms. The search terms are then fed into the search engines and web pages are randomly chosen from the results. The Service node can now build a path with random nodes acting as relays and the node being tested as the exit node. From this exit, the Service Node requests the webpage result generated from its pseudorandom search. If the result returned by the exit node matches the result as generated by the Service Node, then the exit node is deemed to have passed the test.","title":"Swarm Flagging"},{"location":"Advanced/SwarmFlagging/#swarm-flagging","text":"When nodes operate in a trustless environment without a centralised leader enforcing over arching rules, maintaining proper node behaviour on the network becomes difficult. Although Service Nodes in Loki must hold the correct collateral requirement , they may choose to not route traffic or store data in their memory pools. Because this option is financially beneficial (using less bandwidth/CPU cycles/storage), a system of distributed flagging must be proposed to remove underperforming nodes. For Loki, such distributed flagging faces major implementation issues. Fundamentally, every Service Nodes is financially incentivised to flag every other Service Node as a bad actor. This is because when a Service Node is flagged it will face removal from the staking pool and thereby increase the flaggers chance at winning a reward. One potential method of distributed flagging is one in which evidence is provided when a flagging event occurs, however, this solution falls prey to nodes fabricating evidence in their favour. Conversely, flagging without restrictions allows either single nodes or groups of collaborating nodes to intentionally flag honest nodes in order to improve their chances of winning block rewards . To circumvent these issues, Loki proposes swarm flagging. Swarm flagging works by using existing swarms to choose members that will participate in each testing round. Each Service Node holds a copy of the blockchain, and each block created by a miner will deterministically select a number of test swarms. Every block, 1% of the networks swarms are selected for participation in a testing swarm. To calculate participating swarms, the hash of the five previous blocks is used to seed a Mersenne Twister function which then selects swarms by order of their position in the deterministic list. When a swarm has been selected to participate, each node in that swarm is expected to conduct a number of tests on every other node in the swarm. These are not active tests; rather each node stores historical information about its interactions with every other nodenwithin its swarm. Information about bandwidth, message storage , blockchain requests, and exit node functionality are collected and retained over time. New swarm entrants that have yet to gather this information can query Service Nodes outside of their immediate swarm so as to gather data on each of the Service Nodes they test. Each Service Nodes decides how to vote on each of the other swarm members. Once it has made its decision based on the aforementioned tests, it collects and broadcasts its votes to the swarm. Each node in the swarm can now check the votes for all members. If any single node in the swarm has over 50% of the nodes voting against it, any swarm member has the required information to construct a deregistration transaction. Once this transaction is validated and included in a block, all Service Nodes update their DHT, purging any nodes that were voted off.","title":"Swarm Flagging"},{"location":"Advanced/SwarmFlagging/#testing-suite","text":"In order to allow the network to self-enforce performance standards, Service Nodes must be equipped with the required tools so as to test other Service Nodes. These tests should cover the scope of all functionality provided by Service Nodes to prevent lazy masternode attacks . In this initial design, four fundamental tests are proposed. Further tests may be added to the test suite as the function of Services Nodes expands. When an operator first runs the Service Nodes software, an empty file with a predetermined size is allocated on disk to ensure that space is present for tasks that require storage. Next, a simple bandwidth test is conducted between the Service Node and a geographically distributed set of testing servers run by the Loki Foundation . These checks are optional, and Service Nodes are allowed to skip, ignore or fail them, and join the pool of untrusted Service Nodes. However, running and passing these tests provides a good indicator to any would-be Service Node operator as to whether they should risk locking collateral in a node that may not meet minimum requirements. Once a Service Node joins the untrusted Service Node pool, their collateral is locked and they are tested by the next chosen swarm. Swarm tests are enforced via consensus and new entrants to the Service Node network cannot evade these tests. If a node passes all swarm tests, they are awarded the trusted node flag and can begin routing packets. Failing this, they are removed from the network and their collateral remains locked for 30 days.","title":"Testing Suite"},{"location":"Advanced/SwarmFlagging/#bandwidth-test","text":"The bandwidth test forms the backbone of the Loki network test suite. If a node passes this test then it is assumed to be honestly routing packets above the minimum threshold. Each time a node interacts with another Service Node, it will make and retain a record of the incoming bandwidth provided. Over time, nodes will be included in thousands of paths and route millions of messages . These interactions will form the basis of each nodes bandwidth tables. From this table, a node can respond to bandwidth tests about Service Nodes inside its swarm. All nodes are also expected to respond to queries of their own bandwidth tables from other nodes. This means that even nodes who have recently joined the network can query the wider network for information about any specific node in their swarm.","title":"Bandwidth Test"},{"location":"Advanced/SwarmFlagging/#message-storage-test","text":"Message storage is essential for offline messaging functionality for users of Session . Service Nodes must be tested for their ability to cache messages and serve them to users over the course of the message\u2019s Time-to-live (TTL). Users sending offline messages randomly select a Service Node within the destination users swarm. This node must distribute a copy of the message amongst the rest of the swarm. Depending on the proof-of-work attached to the header of the message, Service Nodes that receive a copy will store the data for the TTL. As the TTL on the original message reaches finality, the distributing node sends a nonce to all other members of the swarm. The swarm uses the nonce adding it to the message then hashing the result and then finally sending it back to the distributing node. This test ensures that Service Nodes hold messages until TTL finality, and face eviction if they are unable to produce the correct message digest. As the sampling of the distributing node is random, over time each Service Node will be able to collect performance data on their swarm peers.","title":"Message Storage Test"},{"location":"Advanced/SwarmFlagging/#blockchain-storage-test","text":"Service Nodes are expected to hold a full copy of the Loki blockchain. By holding a full copy of the blockchain, Service Nodes can perform a number of tasks that are essential to users of the network including acting as a remote node , validating transactions, and locking transactions in Blink . As honest nodes also hold a copy of the blockchain, a dishonest node could avoid holding a full copy by simply requesting blocks from an honest node when tested. To avoid this outcome, the blockchain storage test is designed so that honest nodes that hold a copy of the blockchain can pass this test, while dishonest nodes cannot. To achieve this, the testing node requests each tested node to make a selection of K random transactions within the history of the blockchain which are then concatenated and hashed. This hash is then returned to the testing node. By measuring the latency of this request, the testing node can compare the latency with the expected return time T . The exact value for T will be set to accurately differentiate expected latency between loading from disk and downloading blocks from the network. For any attacker, it should be infeasible to download and hash K blocks within T , and thus piggybacking attacks become difficult.","title":"Blockchain Storage Test"},{"location":"Advanced/SwarmFlagging/#exit-node-test","text":"Service Nodes that opt to act as exit nodes receive additional rewards, and so functional tests are required to ensure this extra reward is not abused. For functional exit testing to occur, a Service Node must be able to emulate the natural search behaviour of a human. If a Service Node can detect that it is being tested, it can respond only to tests and discard legitimate user requests. Emulating natural page request behaviour is difficult, however, exit tests can be designed in such a way so as to make the overhead of sorting between legitimate requests and tests sufficiently difficult so that the difference in bandwidth cost between running a legitimate node and a malicious node is negligible. Service Nodes use a list of search engines, held locally, combined with a dictionary so as to construct pseudorandom natural search terms. The search terms are then fed into the search engines and web pages are randomly chosen from the results. The Service node can now build a path with random nodes acting as relays and the node being tested as the exit node. From this exit, the Service Node requests the webpage result generated from its pseudorandom search. If the result returned by the exit node matches the result as generated by the Service Node, then the exit node is deemed to have passed the test.","title":"Exit Node Test"},{"location":"Advanced/SybilResistance/","text":"Sybil Resistance \u00b6 One of the most important features of the Loki network is its built-in market-based Sybil resistance. We defined a successful Sybil attack as one where a single actor controls over 30% of the network\u2019s nodes. At this level of dominance, an actor could conduct effective network wide temporal analysis. Forcing nodes to have a stake in the network greatly increases the cost of performing a Sybil attack. Towler proved the effectiveness of this protection in his game theory model . However, this protection is not guaranteed. Brendan Towler's Game Theoretical Model \u00b6 Using game theory, we were able to model the behaviour of rational economic actors, and built a picture of what the net state of all Service Nodes at any given time should be, given a set of economic conditions. Using this, we were able to assess the potential difficulty and cost of executing a successful Sybil attack on the network under varying conditions. In an economic scenario where only 5% of the circulating supply is locked up in Service Nodes, an attacker would only have to purchase 2.15% of the circulating supply in order to begin conducting effective temporal analysis on the network. Although this attack would be costly, the attacker would be unlikely to experience any compounding effect of the attack cost as a result of their attack. True Market-based Sybil resistance \u00b6 True market-based Sybil resistance only starts to materialise when a greater percentage of the circulating supply is locked up in Service Nodes. In a scenario where 90% of the circulating supply is locked, actors would struggle to purchase enough Loki to perform an effective temporal analysis. However, a 90% lockup is unlikely to occur as Loki aimed to set its equilibrium Service Node lock up to 50% of the circulating supply. In this scenario, an attacker would have to purchase ~21.5% of the circulating supply to begin performing serious network wide temporal analysis. Purchasing ~21.5% of the circulating supply to accomplish this level of saturation will cause liquidity to rapidly decline in the markets, driving up the price of each coin as the accumulation continues. Thus, we would see a compounding effect on the cost of such an attack. Of course, this accumulation can happen over time; depending on the patience of the attacker. Assuming they stake the Loki as they accumulate it, this would dilute the rewards that all Service Nodes receive , including the attacker\u2019s. Towler\u2019s game theoretic model showed that this would start to cause other Service Nodes to drop off the network, but it would also come at an enormous opportunity cost to the attacker. They would suffer a negative Return of Investment (ROI) in dollar terms for all of their nodes as long as the node count remains above the natural equilibrium point derived from a positive $ROI. The Cost of a Sybil Attack on Loki \u00b6 The cost of this Sybil attack is based on the market price and liquidity of Loki over the course of the attack, but assuming low estimates of Loki\u2019s price, this attack would easily run into the tens or hundreds of millions of dollars. If an attacker could sustain these costs, they would eventually achieve dominance over the Service Node network and hold at least 30% of the nodes on the network. Other actors would be forced out, depending on their profitability tolerance, and the attacker could potentially start to return a net positive income from this attack. What happens next would then depend on the intentions of the attacker. If the attacker chose to use their dominance to passively perform analysis on the network, the users of Loki may have not noticed that an attack is occurring until follow-on effects of that analysis arise, at which point the value of the network is likely to decline, further hurting the attacker financially. If the attacker where to start using their dominance to undermine the network entirely by manipulating swarm tests , they could initiate the complete collapse of the Service Node network. This would likely have a catastrophic effect on the value of Loki as Service Nodes leave the network and operators attempt to sell their coins. While the network would have been destroyed, the attacker would now own a very large amount of worthless assets - a cost they cannot recover. High Lockup Ratio \u00b6 Through this analysis we can see that the level of Sybil resistance is derived from the attack cost, which is not only affected by the price of Loki, but also by the fact that a higher lockup ratio of the circulating supply has a compounding effect on the cost. Thus, we surmised that having an economic condition where a large percentage of the circulating supply becomes locked is desirable for the Loki Network\u2019s Sybil resistance to remain effective. Although the lockup selection is somewhat arbitrary, for the purposes of modelling, Loki placed this percentage target at 50%. Effective Dollar Return on Capital Input ($ROI) \u00b6 A high lockup ratio (LR) is achieved when the dollar term return on capital input ($ROI) had attracted enough Service Nodes to operate in favour of other forms of investment. The LR was taken to be the midpoint in an equilibrium, where the number of nodes joining the network drove the rate of return down to the lowest tolerable $ROI compared to other forms of investment, and conversely, nodes leaving the network increased the $ROI for the remaining nodes up to the lowest tolerable $ROI. $ROI is calculated by a combination of the following: the dollar value of the Loki required to purchase the staking requirement ($SR) the expected return on that in terms of Loki (LROI)(as the block reward grants the operator Loki, not dollars) the real-world operating cost of running the Service Node (Operating Expenses, $OE) the dollar value of the LROI. From these variables we deduced the actual $ROI. The exact mathematics are discussed extensively in Towler\u2019s Paper: Cryptoeconomics of The Loki Network . The LROI is directly proportional to the number of Service Nodes operating on the network, and the emission curve (the defined Loki inflation rate) embedded into the software. With the emission curve being the one variable we could hard-code, we ensured that it suited the remaining economic conditions we considered desirable. Operating Expenses ($OE) \u00b6 The introduction of the $OE presented a new problem. The cost of operating the Service Node can only be reflected in dollar terms, the dollar return rate of a Service Node directly affected the viability of the investment. The staking requirement must be set high enough so that the $OE are reasonably negligible compared to the $ROI. That being said, it is also important for the scalability of the network that as many Service Nodes as possible are incentivised to operate within this model, which means the staking requirement had to be set at an amount that balances $ROI and the node count (#N). Max Node Count \u00b6 The relationship between staking requirement (SR) and the circulating supply (A) causes a hard limit on #N(Z). For example: If the circulating supply is 50,000,000 and the staking requirement is 50,000, only 1000 nodes can possibly operate. In reality, #N will be the circulating supply divided by the LR, which if we assume our target of 50%, would mean 500 nodes should operate in the right economic conditions. Desirable Economic Properties \u00b6 To design the economic conditions to target a high LR, the $ROI needed to be consistently attractive overtime to raise the LR to our target of 50% or higher. Considering opportunity cost, rational actors would only deploy a Service Node if the $ROI exceeds that of other forms of investment. Using the long running average of stock market performance, we assumed that an 8% per annum $ROI would be near to the lowest tolerable $ROI for rational actors. Of course, this is difficult to define accurately, as the price of Loki is likely to fluctuate, making any long-term assessment of this profitability near impossible without speculating. However, something we could redefine was the emission curve, which directly influences LROI through time. LROI will be proportional to the LR, but as the same amount of Loki will be rewarded each block regardless of the LR, it is one variable we could analyse closely. In summary, we aimed to design the emission curve so that at a target LR of 50%, the rate of return did not fall below 8% $ROI for as long as possible to allow for a market-based Sybil Resistance.","title":"Sybil Resistance"},{"location":"Advanced/SybilResistance/#sybil-resistance","text":"One of the most important features of the Loki network is its built-in market-based Sybil resistance. We defined a successful Sybil attack as one where a single actor controls over 30% of the network\u2019s nodes. At this level of dominance, an actor could conduct effective network wide temporal analysis. Forcing nodes to have a stake in the network greatly increases the cost of performing a Sybil attack. Towler proved the effectiveness of this protection in his game theory model . However, this protection is not guaranteed.","title":"Sybil Resistance"},{"location":"Advanced/SybilResistance/#brendan-towlers-game-theoretical-model","text":"Using game theory, we were able to model the behaviour of rational economic actors, and built a picture of what the net state of all Service Nodes at any given time should be, given a set of economic conditions. Using this, we were able to assess the potential difficulty and cost of executing a successful Sybil attack on the network under varying conditions. In an economic scenario where only 5% of the circulating supply is locked up in Service Nodes, an attacker would only have to purchase 2.15% of the circulating supply in order to begin conducting effective temporal analysis on the network. Although this attack would be costly, the attacker would be unlikely to experience any compounding effect of the attack cost as a result of their attack.","title":"Brendan Towler's Game Theoretical Model"},{"location":"Advanced/SybilResistance/#true-market-based-sybil-resistance","text":"True market-based Sybil resistance only starts to materialise when a greater percentage of the circulating supply is locked up in Service Nodes. In a scenario where 90% of the circulating supply is locked, actors would struggle to purchase enough Loki to perform an effective temporal analysis. However, a 90% lockup is unlikely to occur as Loki aimed to set its equilibrium Service Node lock up to 50% of the circulating supply. In this scenario, an attacker would have to purchase ~21.5% of the circulating supply to begin performing serious network wide temporal analysis. Purchasing ~21.5% of the circulating supply to accomplish this level of saturation will cause liquidity to rapidly decline in the markets, driving up the price of each coin as the accumulation continues. Thus, we would see a compounding effect on the cost of such an attack. Of course, this accumulation can happen over time; depending on the patience of the attacker. Assuming they stake the Loki as they accumulate it, this would dilute the rewards that all Service Nodes receive , including the attacker\u2019s. Towler\u2019s game theoretic model showed that this would start to cause other Service Nodes to drop off the network, but it would also come at an enormous opportunity cost to the attacker. They would suffer a negative Return of Investment (ROI) in dollar terms for all of their nodes as long as the node count remains above the natural equilibrium point derived from a positive $ROI.","title":"True Market-based Sybil resistance"},{"location":"Advanced/SybilResistance/#the-cost-of-a-sybil-attack-on-loki","text":"The cost of this Sybil attack is based on the market price and liquidity of Loki over the course of the attack, but assuming low estimates of Loki\u2019s price, this attack would easily run into the tens or hundreds of millions of dollars. If an attacker could sustain these costs, they would eventually achieve dominance over the Service Node network and hold at least 30% of the nodes on the network. Other actors would be forced out, depending on their profitability tolerance, and the attacker could potentially start to return a net positive income from this attack. What happens next would then depend on the intentions of the attacker. If the attacker chose to use their dominance to passively perform analysis on the network, the users of Loki may have not noticed that an attack is occurring until follow-on effects of that analysis arise, at which point the value of the network is likely to decline, further hurting the attacker financially. If the attacker where to start using their dominance to undermine the network entirely by manipulating swarm tests , they could initiate the complete collapse of the Service Node network. This would likely have a catastrophic effect on the value of Loki as Service Nodes leave the network and operators attempt to sell their coins. While the network would have been destroyed, the attacker would now own a very large amount of worthless assets - a cost they cannot recover.","title":"The Cost of a Sybil Attack on Loki"},{"location":"Advanced/SybilResistance/#high-lockup-ratio","text":"Through this analysis we can see that the level of Sybil resistance is derived from the attack cost, which is not only affected by the price of Loki, but also by the fact that a higher lockup ratio of the circulating supply has a compounding effect on the cost. Thus, we surmised that having an economic condition where a large percentage of the circulating supply becomes locked is desirable for the Loki Network\u2019s Sybil resistance to remain effective. Although the lockup selection is somewhat arbitrary, for the purposes of modelling, Loki placed this percentage target at 50%.","title":"High Lockup Ratio"},{"location":"Advanced/SybilResistance/#effective-dollar-return-on-capital-input-roi","text":"A high lockup ratio (LR) is achieved when the dollar term return on capital input ($ROI) had attracted enough Service Nodes to operate in favour of other forms of investment. The LR was taken to be the midpoint in an equilibrium, where the number of nodes joining the network drove the rate of return down to the lowest tolerable $ROI compared to other forms of investment, and conversely, nodes leaving the network increased the $ROI for the remaining nodes up to the lowest tolerable $ROI. $ROI is calculated by a combination of the following: the dollar value of the Loki required to purchase the staking requirement ($SR) the expected return on that in terms of Loki (LROI)(as the block reward grants the operator Loki, not dollars) the real-world operating cost of running the Service Node (Operating Expenses, $OE) the dollar value of the LROI. From these variables we deduced the actual $ROI. The exact mathematics are discussed extensively in Towler\u2019s Paper: Cryptoeconomics of The Loki Network . The LROI is directly proportional to the number of Service Nodes operating on the network, and the emission curve (the defined Loki inflation rate) embedded into the software. With the emission curve being the one variable we could hard-code, we ensured that it suited the remaining economic conditions we considered desirable.","title":"Effective Dollar Return on Capital Input ($ROI)"},{"location":"Advanced/SybilResistance/#operating-expenses-oe","text":"The introduction of the $OE presented a new problem. The cost of operating the Service Node can only be reflected in dollar terms, the dollar return rate of a Service Node directly affected the viability of the investment. The staking requirement must be set high enough so that the $OE are reasonably negligible compared to the $ROI. That being said, it is also important for the scalability of the network that as many Service Nodes as possible are incentivised to operate within this model, which means the staking requirement had to be set at an amount that balances $ROI and the node count (#N).","title":"Operating Expenses ($OE)"},{"location":"Advanced/SybilResistance/#max-node-count","text":"The relationship between staking requirement (SR) and the circulating supply (A) causes a hard limit on #N(Z). For example: If the circulating supply is 50,000,000 and the staking requirement is 50,000, only 1000 nodes can possibly operate. In reality, #N will be the circulating supply divided by the LR, which if we assume our target of 50%, would mean 500 nodes should operate in the right economic conditions.","title":"Max Node Count"},{"location":"Advanced/SybilResistance/#desirable-economic-properties","text":"To design the economic conditions to target a high LR, the $ROI needed to be consistently attractive overtime to raise the LR to our target of 50% or higher. Considering opportunity cost, rational actors would only deploy a Service Node if the $ROI exceeds that of other forms of investment. Using the long running average of stock market performance, we assumed that an 8% per annum $ROI would be near to the lowest tolerable $ROI for rational actors. Of course, this is difficult to define accurately, as the price of Loki is likely to fluctuate, making any long-term assessment of this profitability near impossible without speculating. However, something we could redefine was the emission curve, which directly influences LROI through time. LROI will be proportional to the LR, but as the same amount of Loki will be rewarded each block regardless of the LR, it is one variable we could analyse closely. In summary, we aimed to design the emission curve so that at a target LR of 50%, the rate of return did not fall below 8% $ROI for as long as possible to allow for a market-based Sybil Resistance.","title":"Desirable Economic Properties"},{"location":"Advanced/TechnicalSpecs/","text":"Loki Parameters \u00b6 Item Details Loki Difficulty Target (Block Generation Time) 120 Seconds Difficulty Algorithm ZAWY LWMA Hashing algorithm RandomXL Elliptic Curve Curve25519","title":"Technical Specs"},{"location":"Advanced/TechnicalSpecs/#loki-parameters","text":"Item Details Loki Difficulty Target (Block Generation Time) 120 Seconds Difficulty Algorithm ZAWY LWMA Hashing algorithm RandomXL Elliptic Curve Curve25519","title":"Loki Parameters"},{"location":"Advanced/UsingLokinet/","text":"Using LokiNET \u00b6 // TODO: overview for lokinet cli guide --no-igd on the command line or no-igd=1 in lokid.conf to disable IGD (UPnP port forwarding negotiation). --p2p-bind-ifname=lokitun0 to bind to just the lokinet tun interface // TODO: note which version of lokid has --p2p-bind-ifname option Example command line to start lokid for JUST lokinet traffic lokid --no-igd --p2p-bind-ifname=lokitun0","title":"Using LokiNET"},{"location":"Advanced/UsingLokinet/#using-lokinet","text":"// TODO: overview for lokinet cli guide --no-igd on the command line or no-igd=1 in lokid.conf to disable IGD (UPnP port forwarding negotiation). --p2p-bind-ifname=lokitun0 to bind to just the lokinet tun interface // TODO: note which version of lokid has --p2p-bind-ifname option Example command line to start lokid for JUST lokinet traffic lokid --no-igd --p2p-bind-ifname=lokitun0","title":"Using LokiNET"},{"location":"Advanced/UsingTor/","text":"Using Tor \u00b6 While Loki isn't made to integrate with Tor, it can be used wrapped with torsocks, by setting the following configuration parameters and environment variables: --p2p-bind-ip 127.0.0.1 on the command line or p2p-bind-ip=127.0.0.1 in lokid.conf to disable listening for connections on external interfaces. --no-igd on the command line or no-igd=1 in lokid.conf to disable IGD (UPnP port forwarding negotiation), which is pointless with Tor. DNS_PUBLIC=tcp or DNS_PUBLIC=tcp://x.x.x.x where x.x.x.x is the IP of the desired DNS server, for DNS requests to go over TCP, so that they are routed through Tor. When IP is not specified, lokid uses the default list of servers defined in src/common/dns_utils.cpp . TORSOCKS_ALLOW_INBOUND=1 to tell torsocks to allow lokid to bind to interfaces to accept connections from the wallet. On some Linux systems, torsocks allows binding to localhost by default, so setting this variable is only necessary to allow binding to local LAN/VPN interfaces to allow wallets to connect from remote hosts. On other systems, it may be needed for local wallets as well. Do NOT pass --detach when running through torsocks with systemd, (see utils/systemd/lokid.service for details). Example command line to start lokid through Tor: DNS_PUBLIC=tcp torsocks lokid --p2p-bind-ip 127.0.0.1 --no-igd Using Tor on Tails \u00b6 TAILS ships with a very restrictive set of firewall rules. Therefore, you need to add a rule to allow this connection too, in addition to telling torsocks to allow inbound connections. Full example: sudo iptables -I OUTPUT 2 -p tcp -d 127.0.0.1 -m tcp --dport 18081 -j ACCEPT DNS_PUBLIC=tcp torsocks ./lokid --p2p-bind-ip 127.0.0.1 --no-igd --rpc-bind-ip 127.0.0.1 \\ --data-dir /home/amnesia/Persistent/your/directory/to/the/blockchain","title":"Using Tor"},{"location":"Advanced/UsingTor/#using-tor","text":"While Loki isn't made to integrate with Tor, it can be used wrapped with torsocks, by setting the following configuration parameters and environment variables: --p2p-bind-ip 127.0.0.1 on the command line or p2p-bind-ip=127.0.0.1 in lokid.conf to disable listening for connections on external interfaces. --no-igd on the command line or no-igd=1 in lokid.conf to disable IGD (UPnP port forwarding negotiation), which is pointless with Tor. DNS_PUBLIC=tcp or DNS_PUBLIC=tcp://x.x.x.x where x.x.x.x is the IP of the desired DNS server, for DNS requests to go over TCP, so that they are routed through Tor. When IP is not specified, lokid uses the default list of servers defined in src/common/dns_utils.cpp . TORSOCKS_ALLOW_INBOUND=1 to tell torsocks to allow lokid to bind to interfaces to accept connections from the wallet. On some Linux systems, torsocks allows binding to localhost by default, so setting this variable is only necessary to allow binding to local LAN/VPN interfaces to allow wallets to connect from remote hosts. On other systems, it may be needed for local wallets as well. Do NOT pass --detach when running through torsocks with systemd, (see utils/systemd/lokid.service for details). Example command line to start lokid through Tor: DNS_PUBLIC=tcp torsocks lokid --p2p-bind-ip 127.0.0.1 --no-igd","title":"Using Tor"},{"location":"Advanced/UsingTor/#using-tor-on-tails","text":"TAILS ships with a very restrictive set of firewall rules. Therefore, you need to add a rule to allow this connection too, in addition to telling torsocks to allow inbound connections. Full example: sudo iptables -I OUTPUT 2 -p tcp -d 127.0.0.1 -m tcp --dport 18081 -j ACCEPT DNS_PUBLIC=tcp torsocks ./lokid --p2p-bind-ip 127.0.0.1 --no-igd --rpc-bind-ip 127.0.0.1 \\ --data-dir /home/amnesia/Persistent/your/directory/to/the/blockchain","title":"Using Tor on Tails"},{"location":"Advanced/lokid/","text":"lokid - Reference \u00b6 Overview \u00b6 Connects you to Loki network \u00b6 The Loki daemon lokid keeps your computer synced up with the Loki network. It downloads and validates the blockchain from the p2p network. Not aware of your private keys \u00b6 lokid is entirely decoupled from your wallet. lokid does not access your private keys - it is not aware of your transactions and balance. This allows you to run lokid on a separate computer or in the cloud. In fact, you can connect to a remote lokid instance provided by a semi-trusted 3rd party. Such 3rd party will not be able to steal your funds. This is very handy for learning and experimentation. However, there are privacy and reliability implications to using a remote, untrusted node. For any real business you should be running your own full node . Syntax \u00b6 ./lokid [options] [command] Options define how the daemon should be working. Their names follow the --option-name pattern. Commands give access to specific services provided by the daemon. Commands are executed against the running daemon. Their names follow the command_name pattern. Running \u00b6 Go to directory where you unpacked Loki. The stagenet is what your should be using for learning and experimentation. ./lokid --stagenet --detach # run as a daemon in background tail -f ~/.loki/stagenet/loki.log # watch the logs ./lokid --stagenet exit # ask daemon to exit gracefully The mainnnet is when you want to deal with the real $LOKI. ./lokid --detach # run as a daemon in background tail -f ~/.loki/loki.log # watch the logs ./lokid exit # ask daemon to exit gracefully Options \u00b6 Options define how the daemon should be working. Their names follow the --option-name pattern. The following groups are only to make reference easier to follow. The daemon itself does not group options in any way. Help and version \u00b6 Option Description --help Enlist available options. --version Show lokid version to stdout. Example: Loki 'Festive Freya' (v2.0.2-68397db6) --os-version Show build timestamp and target operating system. Example output: OS: Linux #46-Ubuntu SMP Thu Dec 6 14:45:28 UTC 2018 4.15.0-43-generic . Pick network \u00b6 Option Description (missing) By default lokid assumes mainnet --stagenet Run on stagenet. Remember to run your wallet with --stagenet as well. --testnet Run on testnet. Remember to run your wallet with --testnet as well. Logging \u00b6 Option Description --log-file Full path to the log file. Example (mind file permissions): ./lokid --log-file=/var/log/loki/mainnet/lokid.log --log-level 0-4 with 0 being minimal logging and 4 being full tracing. Defaults to 0 . These are general presets and do not directly map to severity levels. For example, even with minimal 0 , you may see some most important INFO entries. Temporarily changing to 1 allows for much better understanding of how the full node operates. Example: ./lokid --log-level=1 --max-log-file-size Soft limit in bytes for the log file (=104850000 by default, which is just under 100MB). Once log file grows past that limit, lokid creates the next log file with a UTC timestamp postfix -YYYY-MM-DD-HH-MM-SS . In production deployments, you would probably prefer to use established solutions like logrotate instead. In that case, set --max-log-file-size=0 to prevent lokid from managing the log files. --max-log-files Limit on the number of log files (=50 by default). The oldest log files are removed. In production deployments, you would probably prefer to use established solutions like logrotate instead. Server \u00b6 lokid defaults are adjusted for running it occasionally on the same computer as your Loki wallet. The following options will be helpful if you intend to have an always running node \u2014 most likely on a remote server or your own separate PC. Option Description --config-file Full path to the configuration file. By default loki looks for loki.conf in Loki data directory. --data-dir Full path to data directory. This is where the blockchain, log files, and p2p network memory are stored. For defaults and details see data directory. --pidfile Full path to the PID file. Works only with --detach . Example: ./lokid --detach --pidfile=/run/loki/lokid.pid --detach Go to background (decouple from the terminal). This is useful for long-running / server scenarios. Typically, you will also want to manage lokid daemon with systemd or similar. By default lokid runs in a foreground. --non-interactive Do not require tty in a foreground mode. Helpful when running in a container. By default lokid runs in a foreground and opens stdin for reading. This breaks containerization because no tty gets assigned and lokid process crashes. You can make it run in a background with --detach but this is inconvenient in a containerized environment because the canonical usage is that the container waits on the main process to exist (forking makes things more complicated). --no-igd Disable UPnP port mapping on the router (\"Internet Gateway Device\"). Add this option to improve security if you are not behind a NAT (you can bind directly to public IP or you run through Tor). --max-txpool-weight Set maximum transactions pool size in bytes. By default 648000000 (~618MB). These are transactions pending for confirmations (not included in any block). P2P network \u00b6 The following options define how your node participates in Loki peer-to-peer network. This is for node-to-node communication. The following options do not affect wallet-to-node interface. The node and peer words are used interchangeably. Option Description --p2p-bind-ip Network interface to bind to for p2p network protocol. Default value 0.0.0.0 binds to all network interfaces. This is typically what you want. You must change this if you want to constrain binding, for example to configure connection through Tor via torsocks: DNS_PUBLIC=tcp://1.1.1.1 TORSOCKS_ALLOW_INBOUND=1 torsocks ./lokid --p2p-bind-ip 127.0.0.1\u200a--no-igd\u200a--hide-my-port --p2p-bind-port TCP port to listen for p2p network connections. Defaults to 22022 for mainnet, 38156 for testnet, and 38153 for stagenet. You normally wouldn't change that. This is helpful to run several nodes on your machine to simulate private Loki p2p network (likely using private Testnet). Example: ./lokid --p2p-bind-port=48080 --p2p-bind-port-ipv6 TCP port to listen for p2p network connections. Defaults to 22022 for mainnet, 38156 for testnet, and 38153 for stagenet. --p2p-bind-ipv6-address Interface for p2p network protocol. --p2p-use-ipv6 Enable IPv6 for p2p. --p2p-external-port TCP port to listen for p2p network connections on your router. Relevant if you are behind a NAT and still want to accept incoming connections. You must then set this to relevant port on your router. This is to let lokid know what to advertise on the network. Default is 0 . --hide-my-port lokid will still open and listen on the p2p port. However, it will not announce itself as a peer list candidate. Technically, it will return port 0 in a response to p2p handshake ( node_data.my_port = 0 in get_local_node_data function). In effect nodes you connect to won't spread your IP to other nodes. To sum up, it is not really hiding, it is more like \"do not advertise\". --seed-node Connect to a node to retrieve other nodes' addresses, and disconnect. If not specified, lokid will use hardcoded seed nodes on the first run, and peers cached on disk on subsequent runs. --add-peer Manually add node to local peer list. --add-priority-node Specify list of nodes to connect to and then attempt to keep the connection open. To add multiple nodes use the option several times. Example: ./lokid --add-priority-node=178.128.192.138:18081 --add-priority-node=144.76.202.167:18081 --add-exclusive-node Specify list of nodes to connect to only. If this option is given the options --add-priority-node and --seed-node are ignored. To add multiple nodes use the option several times. Example: ./lokid --add-exclusive-node=178.128.192.138:18081 --add-exclusive-node=144.76.202.167:18081 --out-peers Set max number of outgoing connections to other nodes. By default 8. Value -1 represents the code default. --in-peers Set max number of incoming connections (nodes actively connecting to you). By default unlimited. Value -1 represents the code default. --limit-rate-up Set outgoing data transfer limit [kB/s]. By default 2048 kB/s. Value -1 represents the code default. --limit-rate-down Set incoming data transfer limit [kB/s]. By default 8192 kB/s. Value -1 represents the code default. --limit-rate Set the same limit value for incoming and outgoing data transfer. By default ( -1 ) the individual up/down default limits will be used. It is better to use --limit-rate-up and --limit-rate-down instead to avoid confusion. --offline Do not listen for peers, nor connect to any. Useful for working with a local, archival blockchain. --allow-local-ip Allow adding local IP to peer list. Useful mostly for debug purposes when you may want to have multiple nodes on a single machine. --service-node Generate a Service Node pubkey that identifies your Node to the network. This flag allows the ability to stake Loki Node RPC API \u00b6 lokid node offers powerful API. It serves 3 purposes: provides network data (stats, blocks, transactions, ...) provides local node information (peer list, hash rate if mining, ...) provides interface for wallets (send transactions, ...) This API is typically referred to as \"RPC\" because it is mostly based on JSON/RPC standard. The following options define how the API behaves. Option Description --rpc-bind-ip IP to listen on. By default 127.0.0.1 because API gives full administrative capabilities over the node. Set it to 0.0.0.0 to listen on all interfaces - but only in connection with one of *-restricted-* options and --confirm-external-bind . --rpc-bind-port TCP port to listen on. By default 22023 (mainnet), 38157 (testnet), 38154 (stagenet). --rpc-restricted-bind-port TCP port to listen on with the limited version of API. The limited API can be made public to create an Open Node. At the same time, you may firewall the full API port to still enjoy local querying and administration. --confirm-external-bind Confirm you consciously set --rpc-bind-ip to non-localhost IP and you understand the consequences. --restricted-rpc Restrict API to view only commands and do not return privacy sensitive data. Note this does not make sense with --rpc-restricted-bind-port because you would end up with two restricted APIs. --rpc-login Specify username[:password] required to connect to API. Practical usage seems limited because API communication is in plain text over HTTP. --rpc-access-control-origins Specify a comma separated list of origins to allow cross origin resource sharing. This is useful if you want to use lokid API directly from a web browser via JavaScript (say in a pure-fronted web appp scenario). With this option lokid will put proper HTTP CORS headers to its responses. You will also need to set --rpc-login if you use this option. Normally though, the API is used by backend app and this option isn't necessary. --rpc-bind-ipv6-address Specify IPv6 address to bind RPC server --rpc-use-ipv6 Allow IPv6 for RPC Accepting Loki \u00b6 Option Description --block-notify Run a program for each new block. The argument must be a full path . If the argument contains %s it will be replaced by the block hash. Example: ./lokid --block-notify=\"/usr/bin/echo %s\" Couple of notes: 1) Block notifications are good for immediate reaction. However, you should always assume you will miss some block notifications and you should independently poll the API to cover this up. 2) Mind blockchain reorganizations. Block notifications can revert to same and past heights. This actually happens pretty often. 3) See also --tx-notify option of loki-wallet-rpc daemon here . Performance \u00b6 These are advanced options that allow you to optimize performance of your lokid node, sometimes at the expense of reliability. Option Description --db-sync-mode Specify sync option, using format: [safe|fast|fastest]:[sync|async]:[<nblocks_per_sync>[blocks]|<nbytes_per_sync>[bytes]] The default is fast:async:250000000bytes . The fast:async:* can corrupt blockchain database in case of a system crash. It should not corrupt if just lokid crashes. If you are concerned with system crashes use safe:sync . --max-concurrency Max number of threads to use for a parallel jobs. The default value 0 uses the number of CPU threads. --prep-blocks-threads Max number of threads to use when computing block hashes (PoW) in groups. Defaults to 4. Decrease this if you don't want lokid hog your computer when syncing. --fast-block-sync Sync up most of the way by using embedded, \"known\" block hashes. Pass 1 to turn on and 0 to turn off. This is on ( 1 ) by default. Normally, for every block the full node must calculate the block hash to verify miner's proof of work. Because the CryptoNight PoW used in Loki is very expensive (even for verification), lokid offers skipping these calculations for old blocks. In other words, it's a mechanism to trust lokid binary regarding old blocks' PoW validity, to sync up faster. --block-sync-size How many blocks are processed in a single batch during chain synchronization. By default this is 20 blocks for newer history and 100 blocks for older history (\"pre v4\"). Default behavior is represented by value 0 . Intuitively, the more resources you have, the bigger batch size you may want to try out. Example: ./lokid --block-sync-size=500 --bootstrap-daemon-address The host:port of a \"bootstrap\" remote open node that the connected wallets can use while this node is still not fully synced. Example: ./lokid --bootstrap-daemon-address=opennode.xmr-tw.org:18089 . The node will forward selected RPC calls to the bootstrap node. The wallet will handle this automatically and transparently. Obviously, such bootstraping phase has privacy implications similar to directly using a remote node. --bootstrap-daemon-login Specify username:password for the bootstrap daemon login (if required). This considers the RPC interface used by the wallet. Normally, open nodes do not require any credentials. Mining \u00b6 The following options configure solo mining using CPU with the standard software stack lokid . This is mostly useful for: generating your stagenet or testnet coins experimentation and learning if you have super cheap access to vast CPU resources Be advised though that real mining happens in pools and with high-end GPU-s instead of CPU-s. Option Description --start-mining Specify wallet address to mining for. This must be a main address ! It can be neither a subaddres nor integrated address. --mining-threads Specify mining threads count. By default ony one thread will be used. For best results, set it to number of your physical cores. --extra-messages-file Specify file for extra messages to include into coinbase transactions. --bg-mining-enable Enable unobtrusive mining. In this mode mining will use a small percentage of your system resources to never noticeably slow down your computer. This is intended to encourage people to mine to improve decentralization. That being said chances of finding a block are diminishingly small with solo CPU mining, and even lesser with its unobtrusive version. You can tweak the unobtrusivness / power trade-offs with the further --bg-* options below. --bg-mining-ignore-battery If true, assumes plugged in when unable to query system power status. --bg-mining-min-idle-interval Specify min lookback interval in seconds for determining idle state. --bg-mining-idle-threshold Specify minimum avg idle percentage over lookback interval. --bg-mining-miner-target Specify maximum percentage cpu use by miner(s). Testing Loki itself \u00b6 These options are useful for Loki project developers and testers. Normal users shouldn't be concerned with these. Option Description --test-drop-download For net tests: in download, discard ALL blocks instead checking/saving them (very fast). --test-drop-download-height Like test-drop-download but discards only after around certain height. By default 0 . --regtest Run in a regression testing mode. --fixed-difficulty Fixed difficulty used for testing. By default 0 . --test-dbg-lock-sleep Sleep time in ms, defaults to 0 (off), used to debug before/after locking mutex. Values 100 to 1000 are good for tests. --save-graph Save data for dr Loki. Legacy \u00b6 These options should no longer be necessary. They are still present in lokid for backwards compatibility. Option Description --fluffy-blocks Relay compact blocks. Default. Compact block is just a header and a list of transaction IDs. --no-fluffy-blocks Relay classic full blocks. Classic block contains all transactions. --show-time-stats Official docs say \"Show time-stats when processing blocks/txs and disk synchronization\" but it does not seem to produce any output during usual blockchain synchronization. --zmq-rpc-bind-ip IP for ZMQ RPC server to listen on. By default 127.0.0.1 . This is not yet widely used as ZMQ interface currently does not provide meaningful advantage over classic JSON-RPC interface. Unfortunately, currently there is no way to disable the ZMQ server. --zmq-rpc-bind-port Port for ZMQ RPC server to listen on. By default 22024 for mainnet, 38154 for stagenet, and 38158 for testnet. --db-type Specify database type. The default and only available: lmdb . Commands \u00b6 Commands give access to specific services provided by the daemon. Commands are executed against the running daemon. Their names follow the command_name pattern. The following groups are only to make reference easier to follow. The daemon itself does not group commands in any way. See running for example usage. You can also type commands directly in the console of the running lokid (if not detached). Help, version, status \u00b6 Option Description help [<command>] Show help for <command> . version Show version information. Example output: Loki 'Festive Freya' (v2.0.2-68397db6) status Show status. Example output: Height: 186754/186754 (100.0%) on stagenet, not mining, net hash 317 H/s, v9, up to date, 8(out)+0(in) connections, uptime 0d 3h 48m 47s P2P network \u00b6 Option Description print_pl Show the full peer list. print_pl_stats Show the full peer list statistics (white vs gray peers). White peers are online and reachable. Grey peers are offline but your lokid remembers them from past sessions. print_cn Show connected peers with connection initiative (incoming/outgoing) and other stats. ban <IP> [<seconds>] Ban a given <IP> for a given amount of <seconds> . By default the ban is for 24h. Example: ./lokid ban 187.63.135.161 . unban <IP> Unban a given <IP> . bans Show the currently banned IPs. Example output: 187.63.135.161 banned for 86397 seconds . in_peers <max_number> Set the of incoming connections from other peers. out_peers <max_number> Set the of outgoing connections to other peers. limit [<kB/s>] Get or set the download and upload limit. limit_down [<kB/s>] Get or set the download limit. limit_up [<kB/s>] Get or set the upload limit. Service Nodes \u00b6 Option Description print_sn Show Serivce Node registration state for all Service Nodes on the network, including data such as contribution amount, registration height, expiry data, last reward received, operator cut, operator address, and contributors. print_sn Show Serivce Node registration state for only your Service Node, including data such as contribution amount, registration height, expiry data, last reward received, operator cut, operator address, and contributors. print_sn_key Show your Service Node pubkey if --service-node flag is running. print_sr <block-height> Show staking requirement at specific block height. print_quorum_state <height> Show the quorum state(The Service Node's performing uptime proof checks) at specific block height. prepare_registration Prepare service Node for staking Transaction pool \u00b6 Option Description flush_txpool [<txid>] Flush specified transaction from transactions pool, or flush the whole transactions pool if was not provided. print_pool Print the transaction pool using a verbose format. print_pool_sh Print the transaction pool using a short format. print_pool_stats Print the transaction pool's statistics (number of transactions, memory size, fees, double spend attempts etc). Transactions \u00b6 Option Description print_coinbase_tx_sum <start_height> [<block_count>] Show a sum of all emitted coins and paid fees within specified range. Example: ./lokid print_coinbase_tx_sum 0 1000000000000 print_tx <transaction_hash> [+hex] [+json] Show specified transaction as JSON and/or HEX. relay_tx <txid> Force relaying the transaction. Useful if you want to rebroadcast the transaction for any reason or if transaction was previously created with \"do_not_relay\":true. Blockchain \u00b6 Option Description print_height Show local blockchain height. sync_info Show blockchain sync progress and connected peers along with download / upload stats. print_bc <begin_height> [<end_height>] Show blocks in range <begin_height> .. <end_height> . The information will include block id, height, timestamp, version, size, weight, number of non-coinbase transactions, difficulty, nonce, and reward. print_block <block_hash> | <block_height> Show detailed data of specified block. hard_fork_info Show current consensus version and future hard fork block height, if any. is_key_image_spent <key_image> Check if specified key image is spent. Key image is a hash. Manage daemon \u00b6 Option Description exit , stop_daemon Ask daemon to exit gracefully. The exit and stop_daemon are identical (one is alias of the other). set_log <level>|<{+,-,}categories> Set the current log level/categories where <level> is a number 0-4. print_status Show if daemon is running. update (check|download) Check if update is available and optionally download it. The hash is SHA-256. On linux use sha256sum to verify. Mining \u00b6 Option Description show_hr Ask lokid daemon to stop printing current hash rate. Relevant only if lokid is mining. hide_hr Ask lokid daemon to print current hash rate. Relevant only if lokid is mining. start_mining <addr> [<threads>] [do_background_mining] [ignore_battery] Ask lokid daemon to start mining. Block reward will go to <addr> . stop_mining Ask lokid daemon to stop mining. Testing Loki itself \u00b6 Option Description start_save_graph Start saving data for dr Loki. stop_save_graph Stop saving data for dr Loki. Legacy \u00b6 Option Description save Flush blockchain data to disk. This is normally no longer necessary as lokid saves the blockchain automatically on exit. Sources: \u00b6 monerodocs","title":"lokid"},{"location":"Advanced/lokid/#lokid-reference","text":"","title":"lokid - Reference"},{"location":"Advanced/lokid/#overview","text":"","title":"Overview"},{"location":"Advanced/lokid/#connects-you-to-loki-network","text":"The Loki daemon lokid keeps your computer synced up with the Loki network. It downloads and validates the blockchain from the p2p network.","title":"Connects you to Loki network"},{"location":"Advanced/lokid/#not-aware-of-your-private-keys","text":"lokid is entirely decoupled from your wallet. lokid does not access your private keys - it is not aware of your transactions and balance. This allows you to run lokid on a separate computer or in the cloud. In fact, you can connect to a remote lokid instance provided by a semi-trusted 3rd party. Such 3rd party will not be able to steal your funds. This is very handy for learning and experimentation. However, there are privacy and reliability implications to using a remote, untrusted node. For any real business you should be running your own full node .","title":"Not aware of your private keys"},{"location":"Advanced/lokid/#syntax","text":"./lokid [options] [command] Options define how the daemon should be working. Their names follow the --option-name pattern. Commands give access to specific services provided by the daemon. Commands are executed against the running daemon. Their names follow the command_name pattern.","title":"Syntax"},{"location":"Advanced/lokid/#running","text":"Go to directory where you unpacked Loki. The stagenet is what your should be using for learning and experimentation. ./lokid --stagenet --detach # run as a daemon in background tail -f ~/.loki/stagenet/loki.log # watch the logs ./lokid --stagenet exit # ask daemon to exit gracefully The mainnnet is when you want to deal with the real $LOKI. ./lokid --detach # run as a daemon in background tail -f ~/.loki/loki.log # watch the logs ./lokid exit # ask daemon to exit gracefully","title":"Running"},{"location":"Advanced/lokid/#options","text":"Options define how the daemon should be working. Their names follow the --option-name pattern. The following groups are only to make reference easier to follow. The daemon itself does not group options in any way.","title":"Options"},{"location":"Advanced/lokid/#help-and-version","text":"Option Description --help Enlist available options. --version Show lokid version to stdout. Example: Loki 'Festive Freya' (v2.0.2-68397db6) --os-version Show build timestamp and target operating system. Example output: OS: Linux #46-Ubuntu SMP Thu Dec 6 14:45:28 UTC 2018 4.15.0-43-generic .","title":"Help and version"},{"location":"Advanced/lokid/#pick-network","text":"Option Description (missing) By default lokid assumes mainnet --stagenet Run on stagenet. Remember to run your wallet with --stagenet as well. --testnet Run on testnet. Remember to run your wallet with --testnet as well.","title":"Pick network"},{"location":"Advanced/lokid/#logging","text":"Option Description --log-file Full path to the log file. Example (mind file permissions): ./lokid --log-file=/var/log/loki/mainnet/lokid.log --log-level 0-4 with 0 being minimal logging and 4 being full tracing. Defaults to 0 . These are general presets and do not directly map to severity levels. For example, even with minimal 0 , you may see some most important INFO entries. Temporarily changing to 1 allows for much better understanding of how the full node operates. Example: ./lokid --log-level=1 --max-log-file-size Soft limit in bytes for the log file (=104850000 by default, which is just under 100MB). Once log file grows past that limit, lokid creates the next log file with a UTC timestamp postfix -YYYY-MM-DD-HH-MM-SS . In production deployments, you would probably prefer to use established solutions like logrotate instead. In that case, set --max-log-file-size=0 to prevent lokid from managing the log files. --max-log-files Limit on the number of log files (=50 by default). The oldest log files are removed. In production deployments, you would probably prefer to use established solutions like logrotate instead.","title":"Logging"},{"location":"Advanced/lokid/#server","text":"lokid defaults are adjusted for running it occasionally on the same computer as your Loki wallet. The following options will be helpful if you intend to have an always running node \u2014 most likely on a remote server or your own separate PC. Option Description --config-file Full path to the configuration file. By default loki looks for loki.conf in Loki data directory. --data-dir Full path to data directory. This is where the blockchain, log files, and p2p network memory are stored. For defaults and details see data directory. --pidfile Full path to the PID file. Works only with --detach . Example: ./lokid --detach --pidfile=/run/loki/lokid.pid --detach Go to background (decouple from the terminal). This is useful for long-running / server scenarios. Typically, you will also want to manage lokid daemon with systemd or similar. By default lokid runs in a foreground. --non-interactive Do not require tty in a foreground mode. Helpful when running in a container. By default lokid runs in a foreground and opens stdin for reading. This breaks containerization because no tty gets assigned and lokid process crashes. You can make it run in a background with --detach but this is inconvenient in a containerized environment because the canonical usage is that the container waits on the main process to exist (forking makes things more complicated). --no-igd Disable UPnP port mapping on the router (\"Internet Gateway Device\"). Add this option to improve security if you are not behind a NAT (you can bind directly to public IP or you run through Tor). --max-txpool-weight Set maximum transactions pool size in bytes. By default 648000000 (~618MB). These are transactions pending for confirmations (not included in any block).","title":"Server"},{"location":"Advanced/lokid/#p2p-network","text":"The following options define how your node participates in Loki peer-to-peer network. This is for node-to-node communication. The following options do not affect wallet-to-node interface. The node and peer words are used interchangeably. Option Description --p2p-bind-ip Network interface to bind to for p2p network protocol. Default value 0.0.0.0 binds to all network interfaces. This is typically what you want. You must change this if you want to constrain binding, for example to configure connection through Tor via torsocks: DNS_PUBLIC=tcp://1.1.1.1 TORSOCKS_ALLOW_INBOUND=1 torsocks ./lokid --p2p-bind-ip 127.0.0.1\u200a--no-igd\u200a--hide-my-port --p2p-bind-port TCP port to listen for p2p network connections. Defaults to 22022 for mainnet, 38156 for testnet, and 38153 for stagenet. You normally wouldn't change that. This is helpful to run several nodes on your machine to simulate private Loki p2p network (likely using private Testnet). Example: ./lokid --p2p-bind-port=48080 --p2p-bind-port-ipv6 TCP port to listen for p2p network connections. Defaults to 22022 for mainnet, 38156 for testnet, and 38153 for stagenet. --p2p-bind-ipv6-address Interface for p2p network protocol. --p2p-use-ipv6 Enable IPv6 for p2p. --p2p-external-port TCP port to listen for p2p network connections on your router. Relevant if you are behind a NAT and still want to accept incoming connections. You must then set this to relevant port on your router. This is to let lokid know what to advertise on the network. Default is 0 . --hide-my-port lokid will still open and listen on the p2p port. However, it will not announce itself as a peer list candidate. Technically, it will return port 0 in a response to p2p handshake ( node_data.my_port = 0 in get_local_node_data function). In effect nodes you connect to won't spread your IP to other nodes. To sum up, it is not really hiding, it is more like \"do not advertise\". --seed-node Connect to a node to retrieve other nodes' addresses, and disconnect. If not specified, lokid will use hardcoded seed nodes on the first run, and peers cached on disk on subsequent runs. --add-peer Manually add node to local peer list. --add-priority-node Specify list of nodes to connect to and then attempt to keep the connection open. To add multiple nodes use the option several times. Example: ./lokid --add-priority-node=178.128.192.138:18081 --add-priority-node=144.76.202.167:18081 --add-exclusive-node Specify list of nodes to connect to only. If this option is given the options --add-priority-node and --seed-node are ignored. To add multiple nodes use the option several times. Example: ./lokid --add-exclusive-node=178.128.192.138:18081 --add-exclusive-node=144.76.202.167:18081 --out-peers Set max number of outgoing connections to other nodes. By default 8. Value -1 represents the code default. --in-peers Set max number of incoming connections (nodes actively connecting to you). By default unlimited. Value -1 represents the code default. --limit-rate-up Set outgoing data transfer limit [kB/s]. By default 2048 kB/s. Value -1 represents the code default. --limit-rate-down Set incoming data transfer limit [kB/s]. By default 8192 kB/s. Value -1 represents the code default. --limit-rate Set the same limit value for incoming and outgoing data transfer. By default ( -1 ) the individual up/down default limits will be used. It is better to use --limit-rate-up and --limit-rate-down instead to avoid confusion. --offline Do not listen for peers, nor connect to any. Useful for working with a local, archival blockchain. --allow-local-ip Allow adding local IP to peer list. Useful mostly for debug purposes when you may want to have multiple nodes on a single machine. --service-node Generate a Service Node pubkey that identifies your Node to the network. This flag allows the ability to stake Loki","title":"P2P network"},{"location":"Advanced/lokid/#node-rpc-api","text":"lokid node offers powerful API. It serves 3 purposes: provides network data (stats, blocks, transactions, ...) provides local node information (peer list, hash rate if mining, ...) provides interface for wallets (send transactions, ...) This API is typically referred to as \"RPC\" because it is mostly based on JSON/RPC standard. The following options define how the API behaves. Option Description --rpc-bind-ip IP to listen on. By default 127.0.0.1 because API gives full administrative capabilities over the node. Set it to 0.0.0.0 to listen on all interfaces - but only in connection with one of *-restricted-* options and --confirm-external-bind . --rpc-bind-port TCP port to listen on. By default 22023 (mainnet), 38157 (testnet), 38154 (stagenet). --rpc-restricted-bind-port TCP port to listen on with the limited version of API. The limited API can be made public to create an Open Node. At the same time, you may firewall the full API port to still enjoy local querying and administration. --confirm-external-bind Confirm you consciously set --rpc-bind-ip to non-localhost IP and you understand the consequences. --restricted-rpc Restrict API to view only commands and do not return privacy sensitive data. Note this does not make sense with --rpc-restricted-bind-port because you would end up with two restricted APIs. --rpc-login Specify username[:password] required to connect to API. Practical usage seems limited because API communication is in plain text over HTTP. --rpc-access-control-origins Specify a comma separated list of origins to allow cross origin resource sharing. This is useful if you want to use lokid API directly from a web browser via JavaScript (say in a pure-fronted web appp scenario). With this option lokid will put proper HTTP CORS headers to its responses. You will also need to set --rpc-login if you use this option. Normally though, the API is used by backend app and this option isn't necessary. --rpc-bind-ipv6-address Specify IPv6 address to bind RPC server --rpc-use-ipv6 Allow IPv6 for RPC","title":"Node RPC API"},{"location":"Advanced/lokid/#accepting-loki","text":"Option Description --block-notify Run a program for each new block. The argument must be a full path . If the argument contains %s it will be replaced by the block hash. Example: ./lokid --block-notify=\"/usr/bin/echo %s\" Couple of notes: 1) Block notifications are good for immediate reaction. However, you should always assume you will miss some block notifications and you should independently poll the API to cover this up. 2) Mind blockchain reorganizations. Block notifications can revert to same and past heights. This actually happens pretty often. 3) See also --tx-notify option of loki-wallet-rpc daemon here .","title":"Accepting Loki"},{"location":"Advanced/lokid/#performance","text":"These are advanced options that allow you to optimize performance of your lokid node, sometimes at the expense of reliability. Option Description --db-sync-mode Specify sync option, using format: [safe|fast|fastest]:[sync|async]:[<nblocks_per_sync>[blocks]|<nbytes_per_sync>[bytes]] The default is fast:async:250000000bytes . The fast:async:* can corrupt blockchain database in case of a system crash. It should not corrupt if just lokid crashes. If you are concerned with system crashes use safe:sync . --max-concurrency Max number of threads to use for a parallel jobs. The default value 0 uses the number of CPU threads. --prep-blocks-threads Max number of threads to use when computing block hashes (PoW) in groups. Defaults to 4. Decrease this if you don't want lokid hog your computer when syncing. --fast-block-sync Sync up most of the way by using embedded, \"known\" block hashes. Pass 1 to turn on and 0 to turn off. This is on ( 1 ) by default. Normally, for every block the full node must calculate the block hash to verify miner's proof of work. Because the CryptoNight PoW used in Loki is very expensive (even for verification), lokid offers skipping these calculations for old blocks. In other words, it's a mechanism to trust lokid binary regarding old blocks' PoW validity, to sync up faster. --block-sync-size How many blocks are processed in a single batch during chain synchronization. By default this is 20 blocks for newer history and 100 blocks for older history (\"pre v4\"). Default behavior is represented by value 0 . Intuitively, the more resources you have, the bigger batch size you may want to try out. Example: ./lokid --block-sync-size=500 --bootstrap-daemon-address The host:port of a \"bootstrap\" remote open node that the connected wallets can use while this node is still not fully synced. Example: ./lokid --bootstrap-daemon-address=opennode.xmr-tw.org:18089 . The node will forward selected RPC calls to the bootstrap node. The wallet will handle this automatically and transparently. Obviously, such bootstraping phase has privacy implications similar to directly using a remote node. --bootstrap-daemon-login Specify username:password for the bootstrap daemon login (if required). This considers the RPC interface used by the wallet. Normally, open nodes do not require any credentials.","title":"Performance"},{"location":"Advanced/lokid/#mining","text":"The following options configure solo mining using CPU with the standard software stack lokid . This is mostly useful for: generating your stagenet or testnet coins experimentation and learning if you have super cheap access to vast CPU resources Be advised though that real mining happens in pools and with high-end GPU-s instead of CPU-s. Option Description --start-mining Specify wallet address to mining for. This must be a main address ! It can be neither a subaddres nor integrated address. --mining-threads Specify mining threads count. By default ony one thread will be used. For best results, set it to number of your physical cores. --extra-messages-file Specify file for extra messages to include into coinbase transactions. --bg-mining-enable Enable unobtrusive mining. In this mode mining will use a small percentage of your system resources to never noticeably slow down your computer. This is intended to encourage people to mine to improve decentralization. That being said chances of finding a block are diminishingly small with solo CPU mining, and even lesser with its unobtrusive version. You can tweak the unobtrusivness / power trade-offs with the further --bg-* options below. --bg-mining-ignore-battery If true, assumes plugged in when unable to query system power status. --bg-mining-min-idle-interval Specify min lookback interval in seconds for determining idle state. --bg-mining-idle-threshold Specify minimum avg idle percentage over lookback interval. --bg-mining-miner-target Specify maximum percentage cpu use by miner(s).","title":"Mining"},{"location":"Advanced/lokid/#testing-loki-itself","text":"These options are useful for Loki project developers and testers. Normal users shouldn't be concerned with these. Option Description --test-drop-download For net tests: in download, discard ALL blocks instead checking/saving them (very fast). --test-drop-download-height Like test-drop-download but discards only after around certain height. By default 0 . --regtest Run in a regression testing mode. --fixed-difficulty Fixed difficulty used for testing. By default 0 . --test-dbg-lock-sleep Sleep time in ms, defaults to 0 (off), used to debug before/after locking mutex. Values 100 to 1000 are good for tests. --save-graph Save data for dr Loki.","title":"Testing Loki itself"},{"location":"Advanced/lokid/#legacy","text":"These options should no longer be necessary. They are still present in lokid for backwards compatibility. Option Description --fluffy-blocks Relay compact blocks. Default. Compact block is just a header and a list of transaction IDs. --no-fluffy-blocks Relay classic full blocks. Classic block contains all transactions. --show-time-stats Official docs say \"Show time-stats when processing blocks/txs and disk synchronization\" but it does not seem to produce any output during usual blockchain synchronization. --zmq-rpc-bind-ip IP for ZMQ RPC server to listen on. By default 127.0.0.1 . This is not yet widely used as ZMQ interface currently does not provide meaningful advantage over classic JSON-RPC interface. Unfortunately, currently there is no way to disable the ZMQ server. --zmq-rpc-bind-port Port for ZMQ RPC server to listen on. By default 22024 for mainnet, 38154 for stagenet, and 38158 for testnet. --db-type Specify database type. The default and only available: lmdb .","title":"Legacy"},{"location":"Advanced/lokid/#commands","text":"Commands give access to specific services provided by the daemon. Commands are executed against the running daemon. Their names follow the command_name pattern. The following groups are only to make reference easier to follow. The daemon itself does not group commands in any way. See running for example usage. You can also type commands directly in the console of the running lokid (if not detached).","title":"Commands"},{"location":"Advanced/lokid/#help-version-status","text":"Option Description help [<command>] Show help for <command> . version Show version information. Example output: Loki 'Festive Freya' (v2.0.2-68397db6) status Show status. Example output: Height: 186754/186754 (100.0%) on stagenet, not mining, net hash 317 H/s, v9, up to date, 8(out)+0(in) connections, uptime 0d 3h 48m 47s","title":"Help, version, status"},{"location":"Advanced/lokid/#p2p-network_1","text":"Option Description print_pl Show the full peer list. print_pl_stats Show the full peer list statistics (white vs gray peers). White peers are online and reachable. Grey peers are offline but your lokid remembers them from past sessions. print_cn Show connected peers with connection initiative (incoming/outgoing) and other stats. ban <IP> [<seconds>] Ban a given <IP> for a given amount of <seconds> . By default the ban is for 24h. Example: ./lokid ban 187.63.135.161 . unban <IP> Unban a given <IP> . bans Show the currently banned IPs. Example output: 187.63.135.161 banned for 86397 seconds . in_peers <max_number> Set the of incoming connections from other peers. out_peers <max_number> Set the of outgoing connections to other peers. limit [<kB/s>] Get or set the download and upload limit. limit_down [<kB/s>] Get or set the download limit. limit_up [<kB/s>] Get or set the upload limit.","title":"P2P network"},{"location":"Advanced/lokid/#service-nodes","text":"Option Description print_sn Show Serivce Node registration state for all Service Nodes on the network, including data such as contribution amount, registration height, expiry data, last reward received, operator cut, operator address, and contributors. print_sn Show Serivce Node registration state for only your Service Node, including data such as contribution amount, registration height, expiry data, last reward received, operator cut, operator address, and contributors. print_sn_key Show your Service Node pubkey if --service-node flag is running. print_sr <block-height> Show staking requirement at specific block height. print_quorum_state <height> Show the quorum state(The Service Node's performing uptime proof checks) at specific block height. prepare_registration Prepare service Node for staking","title":"Service Nodes"},{"location":"Advanced/lokid/#transaction-pool","text":"Option Description flush_txpool [<txid>] Flush specified transaction from transactions pool, or flush the whole transactions pool if was not provided. print_pool Print the transaction pool using a verbose format. print_pool_sh Print the transaction pool using a short format. print_pool_stats Print the transaction pool's statistics (number of transactions, memory size, fees, double spend attempts etc).","title":"Transaction pool"},{"location":"Advanced/lokid/#transactions","text":"Option Description print_coinbase_tx_sum <start_height> [<block_count>] Show a sum of all emitted coins and paid fees within specified range. Example: ./lokid print_coinbase_tx_sum 0 1000000000000 print_tx <transaction_hash> [+hex] [+json] Show specified transaction as JSON and/or HEX. relay_tx <txid> Force relaying the transaction. Useful if you want to rebroadcast the transaction for any reason or if transaction was previously created with \"do_not_relay\":true.","title":"Transactions"},{"location":"Advanced/lokid/#blockchain","text":"Option Description print_height Show local blockchain height. sync_info Show blockchain sync progress and connected peers along with download / upload stats. print_bc <begin_height> [<end_height>] Show blocks in range <begin_height> .. <end_height> . The information will include block id, height, timestamp, version, size, weight, number of non-coinbase transactions, difficulty, nonce, and reward. print_block <block_hash> | <block_height> Show detailed data of specified block. hard_fork_info Show current consensus version and future hard fork block height, if any. is_key_image_spent <key_image> Check if specified key image is spent. Key image is a hash.","title":"Blockchain"},{"location":"Advanced/lokid/#manage-daemon","text":"Option Description exit , stop_daemon Ask daemon to exit gracefully. The exit and stop_daemon are identical (one is alias of the other). set_log <level>|<{+,-,}categories> Set the current log level/categories where <level> is a number 0-4. print_status Show if daemon is running. update (check|download) Check if update is available and optionally download it. The hash is SHA-256. On linux use sha256sum to verify.","title":"Manage daemon"},{"location":"Advanced/lokid/#mining_1","text":"Option Description show_hr Ask lokid daemon to stop printing current hash rate. Relevant only if lokid is mining. hide_hr Ask lokid daemon to print current hash rate. Relevant only if lokid is mining. start_mining <addr> [<threads>] [do_background_mining] [ignore_battery] Ask lokid daemon to start mining. Block reward will go to <addr> . stop_mining Ask lokid daemon to stop mining.","title":"Mining"},{"location":"Advanced/lokid/#testing-loki-itself_1","text":"Option Description start_save_graph Start saving data for dr Loki. stop_save_graph Stop saving data for dr Loki.","title":"Testing Loki itself"},{"location":"Advanced/lokid/#legacy_1","text":"Option Description save Flush blockchain data to disk. This is normally no longer necessary as lokid saves the blockchain automatically on exit.","title":"Legacy"},{"location":"Advanced/lokid/#sources","text":"monerodocs","title":"Sources:"},{"location":"Contributing/HowToContributeToLokiDocs/","text":"How to Contribute to Loki-Docs \u00b6 There is two ways to contribute to the Loki-Docs repository. Editing the files on Github. Building the website and editing the content locally. This guide will teach you how to build the website and edit it on your local machine. Requirements: \u00b6 You will need the following software packages: Python Pip Mkdocs github Step 1: Installing Python and Pip \u00b6 If you have and use a package manager (such as apt-get , dnf , homebrew , yum , chocolatey , etc.) to install packages on your system, then you may want to search for a \"MkDocs\" package and, if a recent version is available, install it with your package manager (check your system's documentation for details). That's it, you're done! If your package manager does not have a recent \"MkDocs\" package, you can still use your package manager to install \"Python\" and \"pip\". Then you can use pip to install MkDocs . Manual Installation \u00b6 In order to manually install MkDocs you'll need Python installed on your system, as well as the Python package manager, pip . You can check if you have these already installed from the command line: $ python --version Python 2.7.2 $ pip --version pip 1.5.2 MkDocs supports Python versions 2.7, 3.4, 3.5, 3.6, 3.7 and pypy. Installing Python \u00b6 Install Python by downloading an installer appropriate for your system from python.org and running it. Note : If you are installing Python on Windows, be sure to check the box to have Python added to your PATH if the installer offers such an option (it's normally off by default). Installing pip \u00b6 If you're using a recent version of Python, the Python package manager, pip , is most likely installed by default. However, you may need to upgrade pip to the lasted version: pip install --upgrade pip If you need to install pip for the first time, download get-pip.py . Then run the following command to install it: python get-pip.py Step 2: Installing MkDocs \u00b6 Install the mkdocs package using pip: pip install mkdocs You should now have the mkdocs command installed on your system. Run mkdocs --version to check that everything worked okay. $ mkdocs --version mkdocs, version 0.15.3 For a more permanent solution, you may need to edit your PATH environment variable to include the Scripts directory of your Python installation. Recent versions of Python include a script to do this for you. Navigate to your Python installation directory (for example C:\\Python34), open the Tools, then Scripts folder, and run the win_add2path.py file by double clicking on it. Alternatively, you can download the script and run it (python win_add2path.py). Step 3: Download the loki-docs files \u00b6 Now that we have mkdocs, python and pip we can download the repository to our local machine and start working on making changes. We can download the files by typing in the terminal: git clone [https://github.com/loki-project/loki-docs](https://github.com/loki-project/loki-docs) You can now edit the text files locally and create pull requests when you make changes Step 4: Making changes to loki-docs \u00b6 I would suggest downloading a txt editor called sublime. In sublime click open folder and open the loki-docs directory within the software. You\u2019re screen should look similar to the below. Go into the docs folder and open the desired .md file you want to edit. For the below example we are going to go into LokiNetwork.md which is in the introduction folder. From here you can edit the file using markdown syntax. Any changes you make will automatically show up as a potential pull request. If you have the Github gui for windows you will first need to add the local repository folder. And now if we make any changes the Github gui will know straight away the changes we have made. Once you\u2019ve made all your changes click commit to master. Step 5: Local testing \u00b6 Change directories to your loki-docs local repository. cd loki-docs From here we can type in the terminal: mkdocs serve This will run Mkdocs built in development server. When the mkdocs serve command is running any changes saved to your local repository files will be updated onto your built site. Any issues such as links to websites or documentation that is not there or not working will show as a error when serving. Go to http://127.0.0.1:8000/ in web browser to view the changes you\u2019ve made prior to committing them to the Loki-docs Github. Additional: Changing the filepaths on Loki-docs. \u00b6 The file in our loki-docs folder called mkdocs.yml is where we edit the left sidebar on the Loki-docs website. If you create any new guides you will need to save the file as a .md file within a folder that is relevant. You must also then add it to the mkdocs.yml file similar to the below. Note : moving files within your local folders should always be reflected within the mkdocs.yml file. If you move the file within your local files but do not reflect the changes the website will not be able to find the file.","title":"How to Contribute to LokiDocs"},{"location":"Contributing/HowToContributeToLokiDocs/#how-to-contribute-to-loki-docs","text":"There is two ways to contribute to the Loki-Docs repository. Editing the files on Github. Building the website and editing the content locally. This guide will teach you how to build the website and edit it on your local machine.","title":"How to Contribute to Loki-Docs"},{"location":"Contributing/HowToContributeToLokiDocs/#requirements","text":"You will need the following software packages: Python Pip Mkdocs github","title":"Requirements:"},{"location":"Contributing/HowToContributeToLokiDocs/#step-1-installing-python-and-pip","text":"If you have and use a package manager (such as apt-get , dnf , homebrew , yum , chocolatey , etc.) to install packages on your system, then you may want to search for a \"MkDocs\" package and, if a recent version is available, install it with your package manager (check your system's documentation for details). That's it, you're done! If your package manager does not have a recent \"MkDocs\" package, you can still use your package manager to install \"Python\" and \"pip\". Then you can use pip to install MkDocs .","title":"Step 1: Installing Python and Pip"},{"location":"Contributing/HowToContributeToLokiDocs/#manual-installation","text":"In order to manually install MkDocs you'll need Python installed on your system, as well as the Python package manager, pip . You can check if you have these already installed from the command line: $ python --version Python 2.7.2 $ pip --version pip 1.5.2 MkDocs supports Python versions 2.7, 3.4, 3.5, 3.6, 3.7 and pypy.","title":"Manual Installation"},{"location":"Contributing/HowToContributeToLokiDocs/#installing-python","text":"Install Python by downloading an installer appropriate for your system from python.org and running it. Note : If you are installing Python on Windows, be sure to check the box to have Python added to your PATH if the installer offers such an option (it's normally off by default).","title":"Installing Python"},{"location":"Contributing/HowToContributeToLokiDocs/#installing-pip","text":"If you're using a recent version of Python, the Python package manager, pip , is most likely installed by default. However, you may need to upgrade pip to the lasted version: pip install --upgrade pip If you need to install pip for the first time, download get-pip.py . Then run the following command to install it: python get-pip.py","title":"Installing pip"},{"location":"Contributing/HowToContributeToLokiDocs/#step-2-installing-mkdocs","text":"Install the mkdocs package using pip: pip install mkdocs You should now have the mkdocs command installed on your system. Run mkdocs --version to check that everything worked okay. $ mkdocs --version mkdocs, version 0.15.3 For a more permanent solution, you may need to edit your PATH environment variable to include the Scripts directory of your Python installation. Recent versions of Python include a script to do this for you. Navigate to your Python installation directory (for example C:\\Python34), open the Tools, then Scripts folder, and run the win_add2path.py file by double clicking on it. Alternatively, you can download the script and run it (python win_add2path.py).","title":"Step 2: Installing MkDocs"},{"location":"Contributing/HowToContributeToLokiDocs/#step-3-download-the-loki-docs-files","text":"Now that we have mkdocs, python and pip we can download the repository to our local machine and start working on making changes. We can download the files by typing in the terminal: git clone [https://github.com/loki-project/loki-docs](https://github.com/loki-project/loki-docs) You can now edit the text files locally and create pull requests when you make changes","title":"Step 3: Download the loki-docs files"},{"location":"Contributing/HowToContributeToLokiDocs/#step-4-making-changes-to-loki-docs","text":"I would suggest downloading a txt editor called sublime. In sublime click open folder and open the loki-docs directory within the software. You\u2019re screen should look similar to the below. Go into the docs folder and open the desired .md file you want to edit. For the below example we are going to go into LokiNetwork.md which is in the introduction folder. From here you can edit the file using markdown syntax. Any changes you make will automatically show up as a potential pull request. If you have the Github gui for windows you will first need to add the local repository folder. And now if we make any changes the Github gui will know straight away the changes we have made. Once you\u2019ve made all your changes click commit to master.","title":"Step 4: Making changes to loki-docs"},{"location":"Contributing/HowToContributeToLokiDocs/#step-5-local-testing","text":"Change directories to your loki-docs local repository. cd loki-docs From here we can type in the terminal: mkdocs serve This will run Mkdocs built in development server. When the mkdocs serve command is running any changes saved to your local repository files will be updated onto your built site. Any issues such as links to websites or documentation that is not there or not working will show as a error when serving. Go to http://127.0.0.1:8000/ in web browser to view the changes you\u2019ve made prior to committing them to the Loki-docs Github.","title":"Step 5: Local testing"},{"location":"Contributing/HowToContributeToLokiDocs/#additional-changing-the-filepaths-on-loki-docs","text":"The file in our loki-docs folder called mkdocs.yml is where we edit the left sidebar on the Loki-docs website. If you create any new guides you will need to save the file as a .md file within a folder that is relevant. You must also then add it to the mkdocs.yml file similar to the below. Note : moving files within your local folders should always be reflected within the mkdocs.yml file. If you move the file within your local files but do not reflect the changes the website will not be able to find the file.","title":"Additional: Changing the filepaths on Loki-docs."},{"location":"Contributing/Issue_Template/","text":"Issue templates \u00b6 If you have found a bug or issue with a Loki repository initially you should confirm with the moderators on Loki's Discord or Telegram to see if a fix has already been made. Additionally someone may have already found this issue and have notified the team through the issues section of Github. Double check the repositories issues to make sure you are not doubling up on any reporting. If this is a new bug or issue we recommend opening up a new issue ticket with the repository in question and use the below template to provide the relevant information to the developers. ## Prerequisites Please answer the following questions for yourself before submitting an issue. - [ ] I am running the latest version - [ ] I checked the documentation and found no answer - [ ] I checked to make sure that this issue has not already been filed - [ ] I'm reporting the issue to the correct repository (for multi-repository projects) ## Expected Behavior Please describe the behavior you are expecting. ## Current Behavior What is the current behavior? ## Failure Information (for bugs) Please help provide information about the failure if this is a bug. If it is not a bug, please remove the rest of this template. ### Steps to Reproduce Please provide detailed steps for reproducing the issue. 1. Step 1 2. Step 2 3. You get it... ### Context Please provide any relevant information about your setup. This is important in case the issue is not reproducible except for under certain conditions. * Firmware Version: * Operating System: * SDK version: * Toolchain version: ### Failure Logs Please include any relevant log snippets or files here.","title":"Github Issue Template Example"},{"location":"Contributing/Issue_Template/#issue-templates","text":"If you have found a bug or issue with a Loki repository initially you should confirm with the moderators on Loki's Discord or Telegram to see if a fix has already been made. Additionally someone may have already found this issue and have notified the team through the issues section of Github. Double check the repositories issues to make sure you are not doubling up on any reporting. If this is a new bug or issue we recommend opening up a new issue ticket with the repository in question and use the below template to provide the relevant information to the developers. ## Prerequisites Please answer the following questions for yourself before submitting an issue. - [ ] I am running the latest version - [ ] I checked the documentation and found no answer - [ ] I checked to make sure that this issue has not already been filed - [ ] I'm reporting the issue to the correct repository (for multi-repository projects) ## Expected Behavior Please describe the behavior you are expecting. ## Current Behavior What is the current behavior? ## Failure Information (for bugs) Please help provide information about the failure if this is a bug. If it is not a bug, please remove the rest of this template. ### Steps to Reproduce Please provide detailed steps for reproducing the issue. 1. Step 1 2. Step 2 3. You get it... ### Context Please provide any relevant information about your setup. This is important in case the issue is not reproducible except for under certain conditions. * Firmware Version: * Operating System: * SDK version: * Toolchain version: ### Failure Logs Please include any relevant log snippets or files here.","title":"Issue templates"},{"location":"Contributing/VULNERABILITY_RESPONSE_LOKI/","text":"Vulnerability disclosure Loki \u00b6 This Vulnerability Response Process and subsequent bounty reward apply to the following: Code implementation as seen in the Loki repository which sits underneath the Loki Project Written research from the Loki Team which dictates said code implementation Researchers/Hackers: while you research/hack, we ask that you please refrain from committing the following: Denial of Service / Active exploiting against the Loki mainnet, Mixnet, or Service node networks Social Engineering of Loki staff, contractors or Foundation members Any physical or electronic attempts against Loki community property and/or data centers As a pro-privacy project we have volunteers running copies of the websites on hidden services on Tor and I2P, as well as on multiple public domains. The live sites are NOT in the scope of this process; only the code is! Bounty will be released for all projects in Loki (LOKI) only. For more information on how to use Loki, visit the Loki website Bounty is not eligible to those who: Do not abide by the VRP for responsible disclosure 1. Points of contact for security issues \u00b6 Kee [at] Loki.network PGP fingerprint = 8877 EEBB 9721 ABC5 DF64 9AE4 AC97 1489 5CE4 5D55 -----BEGIN PGP PUBLIC KEY BLOCK----- Version: GnuPG v1 mQENBFrbANQBCAC5HMKeapz+WECQ3vY1XuSOM32yUfzp4V/rY5+YvJ/Gb7wxczF2 NTLxfr7ueJTyICXcj/h7qnvdtpbN87ZhjWTZzG0lmrCIfZX75dOQIjch8DkGblEB RUG90edRx4GwYHPjfIUbIxYHcINKYMgH9jKqfHAVQD7HuvkBX1IYbNi/Kgj0wVgJ vVA94x8JCD5blqGbos7r02bZxQHujAHnC19/PQxRyZwJNI0v1xJgy6w/cQduFLzL GeEnkQfmJiSKEYzRLY3BYRSmysqD0bLGWLLSa1fcxAD+kllY1kSZXpHKH1XmErpi pRCLblQs0kZYqHDKG2gscfpuaaM4fSiGmY8nABEBAAG0H0tlZSBKZWZmZXJ5cyA8 S2VlQGxva2kubmV0d29yaz6JATwEEwEKACYFAlrbANQCGwMFCQlmRIwFCwkIBwMF FQoJCAsEFgIBAAIeAQIXgAAKCRCslxSJXORdVa7zCACAw7eEYcXlZXxXOB43TSKq BTBtqISmu0+Me94PXNGo5XOp0gzVhgXPedbuz58Y1g9aCp0/wwg5cZvh6ky8zwgt q2BtayTb36elUkcejo9IdgN+1Ruzr8bUdWQrw7w/sZGgI3ZaoMlHvm7mus1cqKH4 3gKaBYG/zPG25hgne13j365kxi+xgklvo0lL3atHV61UxdTlgDm2s4ZtfrMeV9fY DRwcIjzyYv3HWAJvD60dN1RHzTCBxiMiyl6HLawh/3dpHVDOAdrIGqHfIbzodVLW SA4JLw8at3JA8ColWkyFQj1srxvJJunT+haH32h2g9rNS/lf5z+Mdv+LfIPv/iZ5 uQENBFrbANQBCAC+4N/f+RZ8jYHW6VLPGT8nspuEyEgE++zab5XOkS8qcnP0e2sR F0G1RLlJr6hfaowEqLOO0CTIguOBpRfeTWLHzSUK+w8pFx2GfvxXAyxViNbsA5/U E4gbDgOu8AkZWOQLK0nPnE0eyBhHCz22yTJY7P5AUcbo2jw9q9Ye78GbTQx8JPXl jia/VZprMILFOGQROGkH1amqDcaNuX6iOMKS6GtyP+eElPj+IWqwMUlr9aX+ptBQ zfsw+KzgYC+RBS44SM98ZgNBEibZXKfQMT2t80riKgRUPTBQcOref9T+jAtfZl1A OAKm0tLc3o0n0WvmjvxxOOfzdpvEDya12e4VABEBAAGJASUEGAEKAA8FAlrbANQC GwwFCQlmRIwACgkQrJcUiVzkXVWaNQf8C0oYU0iN3YuA+AXGxBlfMHlxz4xhbbd7 Fn8EOIxi3scOltYeU/WvdSdXZ4IJEjydPo7TmVrQ746MUfLC+6ZfH9EDP322s+T/ TYbt3oNA0RWl2CxakpIlRKgCIuC6EEc1U32nKsXH3Uz7UVx8u9GrDxSvGhTSVppN k3nhtcWeSBtANrWuhei1MC4+bRdHHExf6kHtdDMNsuwJmG3FtlKoP9l/Vpb3KscX 9FqdEYPrJSNk3QrndS/a9QzWsm4PR0LTp2+2WC2cDgFjPUqZqZVLA5hSutUVTzGG fKg1gFLyG7Ed4fSa25pe5nUSJUCjFy1HprSM+I9IsSxc8sDll60a3Q== =iX6u -----END PGP PUBLIC KEY BLOCK----- Simon [at] Loki.network PGP fingerprint = 45FF F23B 7805 CEC7 7C7E 15F6 2246 DFA8 0945 A5BD -----BEGIN PGP PUBLIC KEY BLOCK----- Version: GnuPG v1 mQENBFrmnhgBCAC3LWatVxk3QWV7V42B++En8l3xDeQ3uAaXwRot98/4ybImAwmc ur4YCuLBXBiyZPrUQ8m6DxGG9a2RaNll+2dEkaxjDxIJsM7Op+2nUxlDBGrSS3Cf p40BxM4pDBDe1j9haSdoamujYpUDCpYTLA1npKiCUncITsmc+ivefkXBskgh66eI f69yEdeN7dvAqOWaaogBKucQfk9Si3MDXTAqm+hJbR1ByHBw/C0yXfNuq46mEVn6 Tu25cquQPIfYebXldJ4MDD5vogzPJqjMH5Kna/24PqKiR9KpI8NYjUbiRlhuJj2q SjOvks9bJ4Qf+yp7o7qA41TCecsVxdciqtnJABEBAAG0IVNpbW9uIEhhcm1hbiA8 c2ltb25AbG9raS5uZXR3b3JrPokBPAQTAQoAJgUCWuaeGAIbAwUJCWaEyAULCQgH AwUVCgkICwQWAgEAAh4BAheAAAoJECJG36gJRaW9G9QH+gLTCoILegkdJDqGvjsK r7eeD4jxuuRWcWohf+g/Xt9WUR4vOYdUY5+zXwpB7jMK0TKfNt2XMuWU6s32baXT M5dpQs7np5lCkFl7KFyz6AZtz5l8f1pW3PevMDILmqDiljFAXCYzG6GZ4AaB9s5c ikyrnRKreMdFLNR62pOCb5B8PAUBkT4BA5q2Yzfjo8oPX325zdsIlIOLvGDL8E2B 28vzm0MCbnwiimCb8GlddjjpLWMjNe/SU4YeSOUxK0/zr902+X3ooJPmDtDnC5rs I5Kdfh7H9wWPbOcZhfYGL/pNZHIfIErY17qpNyv+s3YJNh/Be5dXG3QBbTcLH5xV sK65AQ0EWuaeGAEIAL3piiswJOJQHNtTbdwSc0xzTm/iPfpZUyobcSSZpVzOZUPQ D3ULlx/5RGO6cdwq+8Tz/OR+mUJHCJSxOnI+/PWMs+3ZyKPMIlhC9Khq3RiWHPQt aRD7USRSWXWwZH6JVCCFpMnhnnHfY+eJzlZC7G8nCJzUk15s/3425HTRlavfRaf7 S6i28wQ98AEUBTITOx3mesnKF7oprZX89El/ToplC0QGRNJj7ZPPNw3QAC244u7B ExKiZKSWjDpcLANB6ORQv1eriy/VuIg/dDwwVIi9pR561tmqbVM7QeIsg52QpY63 ctyHa2CrCyBt4ceR5mqJLuAWow7xmZWrT2+LA2cAEQEAAYkBJQQYAQoADwUCWuae GAIbDAUJCWaEyAAKCRAiRt+oCUWlvQL2B/9gcSBhf0FwAmVUVM/OFe1yww38i/xA IMUI5rPO8bKh5i3uOVZx7QucY9xPctu4YkCI8SgWLfOnQJtNbjbvduSVlWMjlmGW 9qDOpjiFX95AFlUboZ5ii4hxAetFjCOqpMamd6DAFP7ojIbrOE3chN8axqOe4Lx0 Ydsi20b25qT+IRAoIFWker14PHoAo8Xh+JgQ7tCijS8FzLpLZh/K99qhCz32FMIH 5cMPQTI3EPCo+08tWpkjC/a/vtm/Q9/55+5mbdwRVpWfmQ1X0881PybvGqQbmfrT tnRmtnBe0ZSQ8P79bMq+OQMVdrCDTUEp3JqFgH1z2yd4BIeEKN69fy6Q =iGxZ -----END PGP PUBLIC KEY BLOCK----- 2. Incident response \u00b6 Researcher submits report via PGP encrypted email to the relevant Disclosure manager (DA), use the appropriate public keys listed in section 1 to contact specific DA\u2019s, the subject of the email should be \u201cVulnerability disclosure\u201d In no more than 3 working days, the DA should respond to the researcher using encrypted, secure channels DA makes inquiries to satisfy any needed information to confirm if submission is indeed a vulnerability a. If submission proves to be vulnerable with PoC code / exploit, proceed to next step b. If not vulnerable: i . DA responds with reasons why submission is not a vulnerability ii . DA moves discussion to a new or existing ticket on GitHub if necessary DA Establishes severity of vulnerability: a. HIGH : impacts network as a whole, has potential to break entire Loki network, or service nodes, could result in the loss of Loki. b. MEDIUM : impacts individual nodes, routers, wallets, or must be carefully exploited c. LOW : is not easily exploitable or is low impact d. If there are any disputes regarding bug severity, the Loki Foundation will ultimately define bug severity Respond according to the severity of the vulnerability: a. HIGH severities must be notified on website and reddit /r/LokiProject within 3 working days of classification i . The notification should list appropriate steps for users to take, if any ii . The notification must not include any details that could suggest an exploitation path iii . The latter takes precedence over the former b. MEDIUM and HIGH severities will require a Point Release c. LOW severities will be addressed in the next Regular Release DA and Loki project team will apply appropriate patch(es) a. DA designates a PRIVATE git \"hotfix branch\" to work in b. Patches are reviewed with the researcher c. Any messages associated with PUBLIC commits during the time of review should not make reference to the security nature of the PRIVATE branch or its commits d. Vulnerability announcement is drafted i . Include the severity of the vulnerability ii . Include all vulnerable systems/apps/code iii . Include solutions (if any) if patch cannot be applied e. Release date is discussed At release date, DA coordinates with developers to finalize update: a. Response Manager propagates the \"hotfix branch\" to trunk b. Response Manager includes vulnerability announcement draft in release notes c. Proceed with the Point or Regular Release 3. Post-release disclosure process \u00b6 The DA has 90 days to fulfill all points within section 2 If the Incident Response process in section 2 is successfully completed: a. Researcher decides whether or not to opt out of receiving name/handle/organization credit. By default, the researcher will receive name/handle/organization credit. i . If bounty is applicable, release bounty to the researcher as defined in section \"Bounty Distribution\" b. Finalize vulnerability announcement draft and include the following: i . Project name and URL ii . Versions known to be affected iii . Versions known to be not affected (for example, the vulnerable code was introduced in a recent version, and older versions are therefore unaffected) iv . Versions not checked v . Type of vulnerability and its impact vi . If already obtained or applicable, a CVE-ID vii . The planned, coordinated release date viii . Mitigating factors (for example, the vulnerability is only exposed in uncommon, non-default configurations) ix . Workarounds (configuration changes users can make to reduce their exposure to the vulnerability) x . If applicable, credits to the original reporter c. Release finalized vulnerability announcement on website and reddit d. If applicable, developers request a CVE-ID i . The commit that applied the fix is made reference too in a future commit and includes a CVE-ID If the Incident Response process in section 2 is not successfully completed: a. DA and developers organize a meeting to discuss why/what points in section 2 were not resolved and how the team can resolve them in the future b. If disputes arise about whether or when to disclose information about a vulnerability, the DA will publicly discuss the issue via IRC and attempt to reach consensus c. If consensus on a timely disclosure is not met (no later than 90 days), the researcher (after 90 days) has every right to expose the vulnerability to the public 4. Bounty Amount and distribution \u00b6 The Total Pool of Loki bounties is 100,000 LOK this will decrease over time as bugs are claimed, rewards are given as a percentage of the reward pool size, incentivizing fast disclosure Bug bounties are rewarded by the severity of the Bug 10% reserved for LOW severity bugs 30% reserved for MEDIUM severity bugs 60% for HIGH severity bugs Each bug will receive at most 10% of their relevant category dependent on the inter-category classification by the DA, the DA also reserves the right to give less than the 10% specified depending on the severity of the bug. Updated last on 14/11/2018","title":"Vulnerability Response"},{"location":"Contributing/VULNERABILITY_RESPONSE_LOKI/#vulnerability-disclosure-loki","text":"This Vulnerability Response Process and subsequent bounty reward apply to the following: Code implementation as seen in the Loki repository which sits underneath the Loki Project Written research from the Loki Team which dictates said code implementation Researchers/Hackers: while you research/hack, we ask that you please refrain from committing the following: Denial of Service / Active exploiting against the Loki mainnet, Mixnet, or Service node networks Social Engineering of Loki staff, contractors or Foundation members Any physical or electronic attempts against Loki community property and/or data centers As a pro-privacy project we have volunteers running copies of the websites on hidden services on Tor and I2P, as well as on multiple public domains. The live sites are NOT in the scope of this process; only the code is! Bounty will be released for all projects in Loki (LOKI) only. For more information on how to use Loki, visit the Loki website Bounty is not eligible to those who: Do not abide by the VRP for responsible disclosure","title":"Vulnerability disclosure Loki"},{"location":"Contributing/VULNERABILITY_RESPONSE_LOKI/#1-points-of-contact-for-security-issues","text":"Kee [at] Loki.network PGP fingerprint = 8877 EEBB 9721 ABC5 DF64 9AE4 AC97 1489 5CE4 5D55 -----BEGIN PGP PUBLIC KEY BLOCK----- Version: GnuPG v1 mQENBFrbANQBCAC5HMKeapz+WECQ3vY1XuSOM32yUfzp4V/rY5+YvJ/Gb7wxczF2 NTLxfr7ueJTyICXcj/h7qnvdtpbN87ZhjWTZzG0lmrCIfZX75dOQIjch8DkGblEB RUG90edRx4GwYHPjfIUbIxYHcINKYMgH9jKqfHAVQD7HuvkBX1IYbNi/Kgj0wVgJ vVA94x8JCD5blqGbos7r02bZxQHujAHnC19/PQxRyZwJNI0v1xJgy6w/cQduFLzL GeEnkQfmJiSKEYzRLY3BYRSmysqD0bLGWLLSa1fcxAD+kllY1kSZXpHKH1XmErpi pRCLblQs0kZYqHDKG2gscfpuaaM4fSiGmY8nABEBAAG0H0tlZSBKZWZmZXJ5cyA8 S2VlQGxva2kubmV0d29yaz6JATwEEwEKACYFAlrbANQCGwMFCQlmRIwFCwkIBwMF FQoJCAsEFgIBAAIeAQIXgAAKCRCslxSJXORdVa7zCACAw7eEYcXlZXxXOB43TSKq BTBtqISmu0+Me94PXNGo5XOp0gzVhgXPedbuz58Y1g9aCp0/wwg5cZvh6ky8zwgt q2BtayTb36elUkcejo9IdgN+1Ruzr8bUdWQrw7w/sZGgI3ZaoMlHvm7mus1cqKH4 3gKaBYG/zPG25hgne13j365kxi+xgklvo0lL3atHV61UxdTlgDm2s4ZtfrMeV9fY DRwcIjzyYv3HWAJvD60dN1RHzTCBxiMiyl6HLawh/3dpHVDOAdrIGqHfIbzodVLW SA4JLw8at3JA8ColWkyFQj1srxvJJunT+haH32h2g9rNS/lf5z+Mdv+LfIPv/iZ5 uQENBFrbANQBCAC+4N/f+RZ8jYHW6VLPGT8nspuEyEgE++zab5XOkS8qcnP0e2sR F0G1RLlJr6hfaowEqLOO0CTIguOBpRfeTWLHzSUK+w8pFx2GfvxXAyxViNbsA5/U E4gbDgOu8AkZWOQLK0nPnE0eyBhHCz22yTJY7P5AUcbo2jw9q9Ye78GbTQx8JPXl jia/VZprMILFOGQROGkH1amqDcaNuX6iOMKS6GtyP+eElPj+IWqwMUlr9aX+ptBQ zfsw+KzgYC+RBS44SM98ZgNBEibZXKfQMT2t80riKgRUPTBQcOref9T+jAtfZl1A OAKm0tLc3o0n0WvmjvxxOOfzdpvEDya12e4VABEBAAGJASUEGAEKAA8FAlrbANQC GwwFCQlmRIwACgkQrJcUiVzkXVWaNQf8C0oYU0iN3YuA+AXGxBlfMHlxz4xhbbd7 Fn8EOIxi3scOltYeU/WvdSdXZ4IJEjydPo7TmVrQ746MUfLC+6ZfH9EDP322s+T/ TYbt3oNA0RWl2CxakpIlRKgCIuC6EEc1U32nKsXH3Uz7UVx8u9GrDxSvGhTSVppN k3nhtcWeSBtANrWuhei1MC4+bRdHHExf6kHtdDMNsuwJmG3FtlKoP9l/Vpb3KscX 9FqdEYPrJSNk3QrndS/a9QzWsm4PR0LTp2+2WC2cDgFjPUqZqZVLA5hSutUVTzGG fKg1gFLyG7Ed4fSa25pe5nUSJUCjFy1HprSM+I9IsSxc8sDll60a3Q== =iX6u -----END PGP PUBLIC KEY BLOCK----- Simon [at] Loki.network PGP fingerprint = 45FF F23B 7805 CEC7 7C7E 15F6 2246 DFA8 0945 A5BD -----BEGIN PGP PUBLIC KEY BLOCK----- Version: GnuPG v1 mQENBFrmnhgBCAC3LWatVxk3QWV7V42B++En8l3xDeQ3uAaXwRot98/4ybImAwmc ur4YCuLBXBiyZPrUQ8m6DxGG9a2RaNll+2dEkaxjDxIJsM7Op+2nUxlDBGrSS3Cf p40BxM4pDBDe1j9haSdoamujYpUDCpYTLA1npKiCUncITsmc+ivefkXBskgh66eI f69yEdeN7dvAqOWaaogBKucQfk9Si3MDXTAqm+hJbR1ByHBw/C0yXfNuq46mEVn6 Tu25cquQPIfYebXldJ4MDD5vogzPJqjMH5Kna/24PqKiR9KpI8NYjUbiRlhuJj2q SjOvks9bJ4Qf+yp7o7qA41TCecsVxdciqtnJABEBAAG0IVNpbW9uIEhhcm1hbiA8 c2ltb25AbG9raS5uZXR3b3JrPokBPAQTAQoAJgUCWuaeGAIbAwUJCWaEyAULCQgH AwUVCgkICwQWAgEAAh4BAheAAAoJECJG36gJRaW9G9QH+gLTCoILegkdJDqGvjsK r7eeD4jxuuRWcWohf+g/Xt9WUR4vOYdUY5+zXwpB7jMK0TKfNt2XMuWU6s32baXT M5dpQs7np5lCkFl7KFyz6AZtz5l8f1pW3PevMDILmqDiljFAXCYzG6GZ4AaB9s5c ikyrnRKreMdFLNR62pOCb5B8PAUBkT4BA5q2Yzfjo8oPX325zdsIlIOLvGDL8E2B 28vzm0MCbnwiimCb8GlddjjpLWMjNe/SU4YeSOUxK0/zr902+X3ooJPmDtDnC5rs I5Kdfh7H9wWPbOcZhfYGL/pNZHIfIErY17qpNyv+s3YJNh/Be5dXG3QBbTcLH5xV sK65AQ0EWuaeGAEIAL3piiswJOJQHNtTbdwSc0xzTm/iPfpZUyobcSSZpVzOZUPQ D3ULlx/5RGO6cdwq+8Tz/OR+mUJHCJSxOnI+/PWMs+3ZyKPMIlhC9Khq3RiWHPQt aRD7USRSWXWwZH6JVCCFpMnhnnHfY+eJzlZC7G8nCJzUk15s/3425HTRlavfRaf7 S6i28wQ98AEUBTITOx3mesnKF7oprZX89El/ToplC0QGRNJj7ZPPNw3QAC244u7B ExKiZKSWjDpcLANB6ORQv1eriy/VuIg/dDwwVIi9pR561tmqbVM7QeIsg52QpY63 ctyHa2CrCyBt4ceR5mqJLuAWow7xmZWrT2+LA2cAEQEAAYkBJQQYAQoADwUCWuae GAIbDAUJCWaEyAAKCRAiRt+oCUWlvQL2B/9gcSBhf0FwAmVUVM/OFe1yww38i/xA IMUI5rPO8bKh5i3uOVZx7QucY9xPctu4YkCI8SgWLfOnQJtNbjbvduSVlWMjlmGW 9qDOpjiFX95AFlUboZ5ii4hxAetFjCOqpMamd6DAFP7ojIbrOE3chN8axqOe4Lx0 Ydsi20b25qT+IRAoIFWker14PHoAo8Xh+JgQ7tCijS8FzLpLZh/K99qhCz32FMIH 5cMPQTI3EPCo+08tWpkjC/a/vtm/Q9/55+5mbdwRVpWfmQ1X0881PybvGqQbmfrT tnRmtnBe0ZSQ8P79bMq+OQMVdrCDTUEp3JqFgH1z2yd4BIeEKN69fy6Q =iGxZ -----END PGP PUBLIC KEY BLOCK-----","title":"1. Points of contact for security issues"},{"location":"Contributing/VULNERABILITY_RESPONSE_LOKI/#2-incident-response","text":"Researcher submits report via PGP encrypted email to the relevant Disclosure manager (DA), use the appropriate public keys listed in section 1 to contact specific DA\u2019s, the subject of the email should be \u201cVulnerability disclosure\u201d In no more than 3 working days, the DA should respond to the researcher using encrypted, secure channels DA makes inquiries to satisfy any needed information to confirm if submission is indeed a vulnerability a. If submission proves to be vulnerable with PoC code / exploit, proceed to next step b. If not vulnerable: i . DA responds with reasons why submission is not a vulnerability ii . DA moves discussion to a new or existing ticket on GitHub if necessary DA Establishes severity of vulnerability: a. HIGH : impacts network as a whole, has potential to break entire Loki network, or service nodes, could result in the loss of Loki. b. MEDIUM : impacts individual nodes, routers, wallets, or must be carefully exploited c. LOW : is not easily exploitable or is low impact d. If there are any disputes regarding bug severity, the Loki Foundation will ultimately define bug severity Respond according to the severity of the vulnerability: a. HIGH severities must be notified on website and reddit /r/LokiProject within 3 working days of classification i . The notification should list appropriate steps for users to take, if any ii . The notification must not include any details that could suggest an exploitation path iii . The latter takes precedence over the former b. MEDIUM and HIGH severities will require a Point Release c. LOW severities will be addressed in the next Regular Release DA and Loki project team will apply appropriate patch(es) a. DA designates a PRIVATE git \"hotfix branch\" to work in b. Patches are reviewed with the researcher c. Any messages associated with PUBLIC commits during the time of review should not make reference to the security nature of the PRIVATE branch or its commits d. Vulnerability announcement is drafted i . Include the severity of the vulnerability ii . Include all vulnerable systems/apps/code iii . Include solutions (if any) if patch cannot be applied e. Release date is discussed At release date, DA coordinates with developers to finalize update: a. Response Manager propagates the \"hotfix branch\" to trunk b. Response Manager includes vulnerability announcement draft in release notes c. Proceed with the Point or Regular Release","title":"2. Incident response"},{"location":"Contributing/VULNERABILITY_RESPONSE_LOKI/#3-post-release-disclosure-process","text":"The DA has 90 days to fulfill all points within section 2 If the Incident Response process in section 2 is successfully completed: a. Researcher decides whether or not to opt out of receiving name/handle/organization credit. By default, the researcher will receive name/handle/organization credit. i . If bounty is applicable, release bounty to the researcher as defined in section \"Bounty Distribution\" b. Finalize vulnerability announcement draft and include the following: i . Project name and URL ii . Versions known to be affected iii . Versions known to be not affected (for example, the vulnerable code was introduced in a recent version, and older versions are therefore unaffected) iv . Versions not checked v . Type of vulnerability and its impact vi . If already obtained or applicable, a CVE-ID vii . The planned, coordinated release date viii . Mitigating factors (for example, the vulnerability is only exposed in uncommon, non-default configurations) ix . Workarounds (configuration changes users can make to reduce their exposure to the vulnerability) x . If applicable, credits to the original reporter c. Release finalized vulnerability announcement on website and reddit d. If applicable, developers request a CVE-ID i . The commit that applied the fix is made reference too in a future commit and includes a CVE-ID If the Incident Response process in section 2 is not successfully completed: a. DA and developers organize a meeting to discuss why/what points in section 2 were not resolved and how the team can resolve them in the future b. If disputes arise about whether or when to disclose information about a vulnerability, the DA will publicly discuss the issue via IRC and attempt to reach consensus c. If consensus on a timely disclosure is not met (no later than 90 days), the researcher (after 90 days) has every right to expose the vulnerability to the public","title":"3. Post-release disclosure process"},{"location":"Contributing/VULNERABILITY_RESPONSE_LOKI/#4-bounty-amount-and-distribution","text":"The Total Pool of Loki bounties is 100,000 LOK this will decrease over time as bugs are claimed, rewards are given as a percentage of the reward pool size, incentivizing fast disclosure Bug bounties are rewarded by the severity of the Bug 10% reserved for LOW severity bugs 30% reserved for MEDIUM severity bugs 60% for HIGH severity bugs Each bug will receive at most 10% of their relevant category dependent on the inter-category classification by the DA, the DA also reserves the right to give less than the 10% specified depending on the severity of the bug. Updated last on 14/11/2018","title":"4. Bounty Amount and distribution"},{"location":"Developer/DaemonRPCBeta/","text":"Introduction \u00b6 This is a list of the RPC calls, their inputs and outputs, and examples of each. This list is autogenerated and was last generated on: 2020-05-13 Many RPC calls use the JSON RPC interface while others use their own interfaces, as demonstrated below. Note: \"atomic units\" refer to the smallest fraction of 1 LOKI which is 1e9 atomic units. JSON \u00b6 BANNED FLUSH_TRANSACTION_POOL GENERATEBLOCKS GETBANS GETBLOCKCOUNT GETBLOCKHASH GETBLOCKTEMPLATE GET_ALTERNATE_CHAINS GET_BASE_FEE_ESTIMATE GET_BLOCK GET_BLOCK_HEADERS_RANGE GET_BLOCK_HEADER_BY_HASH GET_BLOCK_HEADER_BY_HEIGHT GET_CHECKPOINTS GET_COINBASE_TX_SUM GET_CONNECTIONS GET_HEIGHT GET_INFO GET_LAST_BLOCK_HEADER GET_LIMIT GET_NET_STATS GET_OUTPUTS GET_OUTPUT_DISTRIBUTION GET_OUTPUT_HISTOGRAM GET_PEER_LIST GET_QUORUM_STATE GET_RANDOM_OUTS GET_SERVICE_KEYS GET_SERVICE_NODES GET_SERVICE_NODE_BLACKLISTED_KEY_IMAGES GET_SERVICE_NODE_REGISTRATION_CMD GET_SERVICE_NODE_REGISTRATION_CMD_RAW GET_SERVICE_NODE_STATUS GET_SERVICE_PRIVKEYS GET_SN_STATE_CHANGES GET_STAKING_REQUIREMENT GET_TRANSACTIONS GET_TRANSACTION_POOL GET_TRANSACTION_POOL_BACKLOG GET_TRANSACTION_POOL_HASHES GET_TRANSACTION_POOL_STATS GET_VERSION HARD_FORK_INFO IMPORT_WALLET_REQUEST IN_PEERS IS_KEY_IMAGE_SPENT LNS_NAMES_TO_OWNERS LNS_OWNERS_TO_NAMES LOGIN LOKINET_PING MINING_STATUS OUT_PEERS PERFORM_BLOCKCHAIN_TEST POP_BLOCKS PRUNE_BLOCKCHAIN RELAY_TX REPORT_PEER_SS_STATUS SAVE_BC SEND_RAW_TX SETBANS SET_LIMIT SET_LOG_CATEGORIES SET_LOG_HASH_RATE SET_LOG_LEVEL START_MINING STOP_DAEMON STOP_MINING STORAGE_SERVER_PING SUBMITBLOCK SUBMIT_RAW_TX SYNC_INFO UPDATE Binary \u00b6 GET_ALT_BLOCKS_HASHES GET_BLOCKS_BY_HEIGHT GET_BLOCKS_FAST GET_HASHES_FAST GET_OUTPUTS_BIN GET_OUTPUT_BLACKLIST GET_TRANSACTION_POOL_HASHES_BIN GET_TX_GLOBAL_OUTPUTS_INDEXES JSON \u00b6 BANNED \u00b6 Back to top Determine whether a given IP address is banned Endpoints: banned Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"banned\", \"params\": { \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"banned\": true, \"seconds\": 2130706433 } } Inputs: address - string : The IP address to check Outputs: status - string : General RPC error code. \"OK\" means everything looks good. banned - bool : True if the given address is banned, false otherwise. seconds - uint32 : The number of seconds remaining in the ban. FLUSH_TRANSACTION_POOL \u00b6 Back to top Flush tx ids from transaction pool.. Endpoints: flush_txpool Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"flush_txpool\", \"params\": { \"txids\": [\"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\"] } } EOF Inputs: txids - string[] : Optional, list of transactions IDs to flush from pool (all tx ids flushed if empty). GENERATEBLOCKS \u00b6 Back to top Developer only. Endpoints: generateblocks Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"generateblocks\", \"params\": { \"amount_of_blocks\": 123, \"wallet_address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"prev_block\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"starting_nonce\": 2130706433 } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"height\": 234767, \"blocks\": [\"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\"], \"status\": \"OK\" } } Inputs: amount_of_blocks - uint64 wallet_address - string prev_block - string starting_nonce - uint32 Outputs: height - uint64 blocks - string[] status - string : General RPC error code. \"OK\" means everything looks good. GETBANS \u00b6 Back to top Get list of banned IPs. Endpoints: get_bans Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_bans\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"bans\": [{ \"host\": \"127.0.0.1\", \"ip\": 2130706433, \"seconds\": 2130706433 }] } } Outputs: status - string : General RPC error code. \"OK\" means everything looks good. bans - ban[] : List of banned nodes: host - string : Banned host (IP in A.B.C.D form). ip - uint32 : Banned IP address, in Int format. seconds - uint32 : Local Unix time that IP is banned until. GETBLOCKCOUNT \u00b6 Back to top Look up how many blocks are in the longest chain known to the node. Endpoints: get_block_count, getblockcount Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_block_count\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"count\": 123, \"status\": \"OK\" } } Outputs: count - uint64 : Number of blocks in longest chain seen by the node. status - string : General RPC error code. \"OK\" means everything looks good. GETBLOCKHASH \u00b6 Back to top Look up a block's hash by its height. Endpoints: get_block_hash, on_get_block_hash, on_getblockhash Constants: * `response - string`: Block hash (string). Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_block_hash\", \"params\": { \"height\": [234767] } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": \"061e5b4734c5e338c1d2a25acb007d806725e51cdb2aa8aac17101afd60cd002\" } Inputs: height - uint64[] : Block height (int array of length 1). Outputs: result - string : Block hash (string). GETBLOCKTEMPLATE \u00b6 Back to top Get a block template on which mining a new block. Endpoints: get_block_template, getblocktemplate Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_block_template\", \"params\": { \"reserve_size\": 123, \"wallet_address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"prev_block\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"difficulty\": 123, \"height\": 234767, \"reserved_offset\": 123, \"expected_reward\": 123, \"prev_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"seed_hash\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"next_seed_hash\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"blocktemplate_blob\": \"sd2b5f838e8cc7774d92f5a6ce0d72cb9bd8db2ef28948087f8a50ff46d188dd9\", \"blockhashing_blob\": \"sd2b5f838e8cc7774d92f5a6ce0d72cb9bd8db2ef28948087f8a50ff46d188dd9\", \"status\": \"OK\", \"untrusted\": false } } Inputs: reserve_size - uint64 : Max 255 bytes wallet_address - string : Address of wallet to receive coinbase transactions if block is successfully mined. prev_block - string Outputs: difficulty - uint64 : Difficulty of next block. height - uint64 : Height on which to mine. reserved_offset - uint64 : Reserved offset. expected_reward - uint64 : Coinbase reward expected to be received if block is successfully mined. prev_hash - string : Hash of the most recent block on which to mine the next block. seed_hash - string : RandomX current seed hash next_seed_hash - string : RandomX upcoming seed hash blocktemplate_blob - string : Blob on which to try to mine a new block. blockhashing_blob - string : Blob on which to try to find a valid nonce. status - string : General RPC error code. \"OK\" means everything looks good. untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). GET_ALTERNATE_CHAINS \u00b6 Back to top Display alternative chains seen by the node. Endpoints: get_alternative_chains Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_alternative_chains\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"chains\": [{ \"block_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"height\": 234767, \"length\": 123, \"difficulty\": 123, \"block_hashes\": [\"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\"], \"main_chain_parent_block\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\" }] } } Outputs: status - string : General RPC error code. \"OK\" means everything looks good. chains - chain_info[] : Array of Chains. block_hash - string : The block hash of the first diverging block of this alternative chain. height - uint64 : The block height of the first diverging block of this alternative chain. length - uint64 : The length in blocks of this alternative chain, after divergence. difficulty - uint64 : The cumulative difficulty of all blocks in the alternative chain. block_hashes - string[] main_chain_parent_block - string GET_BASE_FEE_ESTIMATE \u00b6 Back to top Gives an estimation of per-output + per-byte fees Endpoints: get_fee_estimate Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_fee_estimate\", \"params\": { \"grace_blocks\": 123 } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"fee_per_byte\": 123, \"fee_per_output\": 123, \"quantization_mask\": 123, \"untrusted\": false } } Inputs: grace_blocks - uint64 : Optional Outputs: status - string : General RPC error code. \"OK\" means everything looks good. fee_per_byte - uint64 : Amount of fees estimated per byte in atomic units fee_per_output - uint64 : Amount of fees per output generated by the tx (adds to the fee_per_byte per-byte value) quantization_mask - uint64 untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). GET_BLOCK \u00b6 Back to top Full block information can be retrieved by either block height or hash, like with the above block header calls. For full block information, both lookups use the same method, but with different input parameters. Endpoints: get_block, getblock Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_block\", \"params\": { \"hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"height\": 234767, \"fill_pow_hash\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"block_header\": { \"major_version\": 11, \"minor_version\": 11, \"timestamp\": 123, \"prev_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"nonce\": 2130706433, \"orphan_status\": true, \"height\": 234767, \"depth\": 123, \"hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"difficulty\": 25179406071, \"cumulative_difficulty\": 25179406071, \"reward\": 123, \"miner_reward\": 123, \"block_size\": 123, \"block_weight\": 123, \"num_txes\": 123, \"pow_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"long_term_weight\": 123, \"miner_tx_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"service_node_winner\": \"4a8c30cea9e729b06c91132295cce32d2a8e6e5bcf7b74a998e2ee1b3ed590b3\" }, \"miner_tx_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"tx_hashes\": [\"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\"], \"blob\": \"0b0b85819be50599a27f959e4bf53d6ed1d862958ae9734bb53e2a3c9085c74dc9a64f1ffe7ecbac5c003b02bae50e01ff9ce50e02c6e5b7be3b02599dd5dd36f71ea8baaf0cdf06487954cdeefc08c4a015deabccfd322c539f6a85ffbd8c4202d568949320e96569773b68bf4a081bed23b7c18c8e0fcd12007e922f2b361deea301019d4c141e08ec3a567a179d544ee6c0fe5b301482c052e7f1b8fda08253dc8f19032100de2de1e442cbe12171e1e4a02acb1fb2f19d1edf1b34ea46beab4aa84a3b8c1e021b00000000000000000000000008b742a096fc00000000000000000001cff3b81be28f27c7967ace59ad6d4117bb59beb45b42b6e6628550de36e41e4372639c05971665ab70273c8a0827397f82face8f18c0380901e425554606a4a90a0000\", \"json\": \"{\\n \\\"major_version\\\": 11, \\n \\\"minor_version\\\": 11, \\n \\\"timestamp\\\": 1554432133, \\n \\\"prev_id\\\": \\\"99a27f959e4bf53d6ed1d862958ae9734bb53e2a3c9085c74dc9a64f1ffe7ecb\\\", \\n \\\"nonce\\\": 989879468, \\n \\\"miner_tx\\\": {\\n \\\"version\\\": 2, \\n \\\"unlock_time\\\": 242362, \\n \\\"vin\\\": [ {\\n \\\"gen\\\": {\\n \\\"height\\\": 242332\\n }\\n }\\n ], \\n \\\"vout\\\": [ {\\n \\\"amount\\\": 15968629446, \\n \\\"target\\\": {\\n \\\"key\\\": \\\"599dd5dd36f71ea8baaf0cdf06487954cdeefc08c4a015deabccfd322c539f6a\\\"\\n }\\n }, {\\n \\\"amount\\\": 17742921605, \\n \\\"target\\\": {\\n \\\"key\\\": \\\"d568949320e96569773b68bf4a081bed23b7c18c8e0fcd12007e922f2b361dee\\\"\\n }\\n }\\n ], \\n \\\"extra\\\": [ 1, 157, 76, 20, 30, 8, 236, 58, 86, 122, 23, 157, 84, 78, 230, 192, 254, 91, 48, 20, 130, 192, 82, 231, 241, 184, 253, 160, 130, 83, 220, 143, 25, 3, 33, 0, 222, 45, 225, 228, 66, 203, 225, 33, 113, 225, 228, 160, 42, 203, 31, 178, 241, 157, 30, 223, 27, 52, 234, 70, 190, 171, 74, 168, 74, 59, 140, 30, 2, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 183, 66, 160, 150, 252, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 207, 243, 184, 27, 226, 143, 39, 199, 150, 122, 206, 89, 173, 109, 65, 23, 187, 89, 190, 180, 91, 66, 182, 230, 98, 133,80, 222, 54, 228, 30, 67, 114, 99, 156, 5, 151, 22, 101, 171, 112, 39, 60, 138, 8, 39, 57, 127, 130, 250, 206, 143, 24, 192, 56, 9, 1, 228, 37, 85, 70, 6, 164, 169, 10\\n], \\n \\\"rct_signatures\\\": {\\n \\\"type\\\": 0\\n }\\n }, \\n \\\"tx_hashes\\\": [ ]\\n}\", \"untrusted\": false } } Inputs: hash - string : The block's hash. height - uint64 : The block's height. fill_pow_hash - bool : Tell the daemon if it should fill out pow_hash field. Outputs: status - string : General RPC error code. \"OK\" means everything looks good. block_header - block_header_response : A structure containing block header information. See get_last_block_header. major_version - uint8 : The major version of the loki protocol at this block height. minor_version - uint8 : The minor version of the loki protocol at this block height. timestamp - uint64 : The unix time at which the block was recorded into the blockchain. prev_hash - string : The hash of the block immediately preceding this block in the chain. nonce - uint32 : A cryptographic random one-time number used in mining a Loki block. orphan_status - bool : Usually false . If true , this block is not part of the longest chain. height - uint64 : The number of blocks preceding this block on the blockchain. depth - uint64 : The number of blocks succeeding this block on the blockchain. A larger number means an older block. hash - string : The hash of this block. difficulty - uint64 : The strength of the Loki network based on mining power. cumulative_difficulty - uint64 : The cumulative strength of the Loki network based on mining power. reward - uint64 : The amount of new generated in this block and rewarded to the miner, foundation and service Nodes. Note: 1 LOKI = 1e9 atomic units. miner_reward - uint64 : The amount of new generated in this block and rewarded to the miner. Note: 1 LOKI = 1e9 atomic units. block_size - uint64 : The block size in bytes. block_weight - uint64 : The block weight in bytes. num_txes - uint64 : Number of transactions in the block, not counting the coinbase tx. pow_hash - string : The hash of the block's proof of work. long_term_weight - uint64 : Long term weight of the block. miner_tx_hash - string : The TX hash of the miner transaction service_node_winner - string : Service node that received a reward for this block miner_tx_hash - string : Miner transaction information tx_hashes - string[] : List of hashes of non-coinbase transactions in the block. If there are no other transactions, this will be an empty list. blob - string : Hexadecimal blob of block information. json - string : JSON formatted block details. untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). GET_BLOCK_HEADERS_RANGE \u00b6 Back to top Similar to get_block_header_by_height above, but for a range of blocks. This method includes a starting block height and an ending block height as parameters to retrieve basic information about the range of blocks. Endpoints: get_block_headers_range, getblockheadersrange Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_block_headers_range\", \"params\": { \"start_height\": 123, \"end_height\": 123, \"fill_pow_hash\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"headers\": [{ \"major_version\": 11, \"minor_version\": 11, \"timestamp\": 123, \"prev_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"nonce\": 2130706433, \"orphan_status\": true, \"height\": 234767, \"depth\": 123, \"hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"difficulty\": 25179406071, \"cumulative_difficulty\": 25179406071, \"reward\": 123, \"miner_reward\": 123, \"block_size\": 123, \"block_weight\": 123, \"num_txes\": 123, \"pow_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"long_term_weight\": 123, \"miner_tx_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"service_node_winner\": \"4a8c30cea9e729b06c91132295cce32d2a8e6e5bcf7b74a998e2ee1b3ed590b3\" }], \"untrusted\": false } } Inputs: start_height - uint64 : The starting block's height. end_height - uint64 : The ending block's height. fill_pow_hash - bool : Tell the daemon if it should fill out pow_hash field. Outputs: status - string : General RPC error code. \"OK\" means everything looks good. headers - block_header_response[] : Array of block_header (a structure containing block header information. See get_last_block_header). major_version - uint8 : The major version of the loki protocol at this block height. minor_version - uint8 : The minor version of the loki protocol at this block height. timestamp - uint64 : The unix time at which the block was recorded into the blockchain. prev_hash - string : The hash of the block immediately preceding this block in the chain. nonce - uint32 : A cryptographic random one-time number used in mining a Loki block. orphan_status - bool : Usually false . If true , this block is not part of the longest chain. height - uint64 : The number of blocks preceding this block on the blockchain. depth - uint64 : The number of blocks succeeding this block on the blockchain. A larger number means an older block. hash - string : The hash of this block. difficulty - uint64 : The strength of the Loki network based on mining power. cumulative_difficulty - uint64 : The cumulative strength of the Loki network based on mining power. reward - uint64 : The amount of new generated in this block and rewarded to the miner, foundation and service Nodes. Note: 1 LOKI = 1e9 atomic units. miner_reward - uint64 : The amount of new generated in this block and rewarded to the miner. Note: 1 LOKI = 1e9 atomic units. block_size - uint64 : The block size in bytes. block_weight - uint64 : The block weight in bytes. num_txes - uint64 : Number of transactions in the block, not counting the coinbase tx. pow_hash - string : The hash of the block's proof of work. long_term_weight - uint64 : Long term weight of the block. miner_tx_hash - string : The TX hash of the miner transaction service_node_winner - string : Service node that received a reward for this block untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). GET_BLOCK_HEADER_BY_HASH \u00b6 Back to top Block header information can be retrieved using either a block's hash or height. This method includes a block's hash as an input parameter to retrieve basic information about the block. Endpoints: get_block_header_by_hash, getblockheaderbyhash Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_block_header_by_hash\", \"params\": { \"hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"fill_pow_hash\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"block_header\": { \"major_version\": 11, \"minor_version\": 11, \"timestamp\": 123, \"prev_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"nonce\": 2130706433, \"orphan_status\": true, \"height\": 234767, \"depth\": 123, \"hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"difficulty\": 25179406071, \"cumulative_difficulty\": 25179406071, \"reward\": 123, \"miner_reward\": 123, \"block_size\": 123, \"block_weight\": 123, \"num_txes\": 123, \"pow_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"long_term_weight\": 123, \"miner_tx_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"service_node_winner\": \"4a8c30cea9e729b06c91132295cce32d2a8e6e5bcf7b74a998e2ee1b3ed590b3\" }, \"untrusted\": false } } Inputs: hash - string : The block's SHA256 hash. fill_pow_hash - bool : Tell the daemon if it should fill out pow_hash field. Outputs: status - string : General RPC error code. \"OK\" means everything looks good. block_header - block_header_response : A structure containing block header information. major_version - uint8 : The major version of the loki protocol at this block height. minor_version - uint8 : The minor version of the loki protocol at this block height. timestamp - uint64 : The unix time at which the block was recorded into the blockchain. prev_hash - string : The hash of the block immediately preceding this block in the chain. nonce - uint32 : A cryptographic random one-time number used in mining a Loki block. orphan_status - bool : Usually false . If true , this block is not part of the longest chain. height - uint64 : The number of blocks preceding this block on the blockchain. depth - uint64 : The number of blocks succeeding this block on the blockchain. A larger number means an older block. hash - string : The hash of this block. difficulty - uint64 : The strength of the Loki network based on mining power. cumulative_difficulty - uint64 : The cumulative strength of the Loki network based on mining power. reward - uint64 : The amount of new generated in this block and rewarded to the miner, foundation and service Nodes. Note: 1 LOKI = 1e9 atomic units. miner_reward - uint64 : The amount of new generated in this block and rewarded to the miner. Note: 1 LOKI = 1e9 atomic units. block_size - uint64 : The block size in bytes. block_weight - uint64 : The block weight in bytes. num_txes - uint64 : Number of transactions in the block, not counting the coinbase tx. pow_hash - string : The hash of the block's proof of work. long_term_weight - uint64 : Long term weight of the block. miner_tx_hash - string : The TX hash of the miner transaction service_node_winner - string : Service node that received a reward for this block untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). GET_BLOCK_HEADER_BY_HEIGHT \u00b6 Back to top Similar to get_block_header_by_hash above, this method includes a block's height as an input parameter to retrieve basic information about the block. Endpoints: get_block_header_by_height, getblockheaderbyheight Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_block_header_by_height\", \"params\": { \"height\": 234767, \"fill_pow_hash\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"block_header\": { \"major_version\": 11, \"minor_version\": 11, \"timestamp\": 123, \"prev_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"nonce\": 2130706433, \"orphan_status\": true, \"height\": 234767, \"depth\": 123, \"hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"difficulty\": 25179406071, \"cumulative_difficulty\": 25179406071, \"reward\": 123, \"miner_reward\": 123, \"block_size\": 123, \"block_weight\": 123, \"num_txes\": 123, \"pow_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"long_term_weight\": 123, \"miner_tx_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"service_node_winner\": \"4a8c30cea9e729b06c91132295cce32d2a8e6e5bcf7b74a998e2ee1b3ed590b3\" }, \"untrusted\": false } } Inputs: height - uint64 : The block's height. fill_pow_hash - bool : Tell the daemon if it should fill out pow_hash field. Outputs: status - string : General RPC error code. \"OK\" means everything looks good. block_header - block_header_response : A structure containing block header information. major_version - uint8 : The major version of the loki protocol at this block height. minor_version - uint8 : The minor version of the loki protocol at this block height. timestamp - uint64 : The unix time at which the block was recorded into the blockchain. prev_hash - string : The hash of the block immediately preceding this block in the chain. nonce - uint32 : A cryptographic random one-time number used in mining a Loki block. orphan_status - bool : Usually false . If true , this block is not part of the longest chain. height - uint64 : The number of blocks preceding this block on the blockchain. depth - uint64 : The number of blocks succeeding this block on the blockchain. A larger number means an older block. hash - string : The hash of this block. difficulty - uint64 : The strength of the Loki network based on mining power. cumulative_difficulty - uint64 : The cumulative strength of the Loki network based on mining power. reward - uint64 : The amount of new generated in this block and rewarded to the miner, foundation and service Nodes. Note: 1 LOKI = 1e9 atomic units. miner_reward - uint64 : The amount of new generated in this block and rewarded to the miner. Note: 1 LOKI = 1e9 atomic units. block_size - uint64 : The block size in bytes. block_weight - uint64 : The block weight in bytes. num_txes - uint64 : Number of transactions in the block, not counting the coinbase tx. pow_hash - string : The hash of the block's proof of work. long_term_weight - uint64 : Long term weight of the block. miner_tx_hash - string : The TX hash of the miner transaction service_node_winner - string : Service node that received a reward for this block untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). GET_CHECKPOINTS \u00b6 Back to top Query hardcoded/service node checkpoints stored for the blockchain. Omit all arguments to retrieve the latest \"count\" checkpoints. Endpoints: get_checkpoints Constants: * `MAX_COUNT - uint64 = 256` * `NUM_CHECKPOINTS_TO_QUERY_BY_DEFAULT - uint32 = 60` * `HEIGHT_SENTINEL_VALUE - uint64 = std::numeric_limits<uint64_t>::max() - 1` Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_checkpoints\", \"params\": { \"start_height\": 123, \"end_height\": 123, \"count\": 2130706433 } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"checkpoints\": [{ \"version\": 11, \"type\": \"ServiceNode\", \"height\": 234767, \"block_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"signatures\": [{ \"voter_index\": 12345, \"signature\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\" }], \"prev_height\": 123 }], \"status\": \"OK\", \"untrusted\": false } } Inputs: start_height - uint64 : Optional: Get the first count checkpoints starting from this height. Specify both start and end to get the checkpoints inbetween. end_height - uint64 : Optional: Get the first count checkpoints before end height. Specify both start and end to get the checkpoints inbetween. count - uint32 : Optional: Number of checkpoints to query. Outputs: checkpoints - checkpoint_serialized[] : Array of requested checkpoints version - uint8 type - string : Either \"Hardcoded\" or \"ServiceNode\" for checkpoints generated by Service Nodes or declared in the code height - uint64 : The height the checkpoint is relevant for block_hash - string : The block hash the checkpoint is specifying signatures - voter_to_signature_serialized[] : Signatures from Service Nodes who agree on the block hash voter_index - uint16 : Index of the voter in the relevant quorum signature - string : The signature generated by the voter in the quorum prev_height - uint64 : The previous height the checkpoint is based off status - string : Generic RPC error code. \"OK\" is the success value. untrusted - bool : If the result is obtained using bootstrap mode, and therefore not trusted true , or otherwise false . GET_COINBASE_TX_SUM \u00b6 Back to top Get the coinbase amount and the fees amount for n last blocks starting at particular height. Endpoints: get_coinbase_tx_sum Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_coinbase_tx_sum\", \"params\": { \"height\": 234767, \"count\": 123 } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"emission_amount\": 123, \"fee_amount\": 123, \"burn_amount\": 123 } } Inputs: height - uint64 : Block height from which getting the amounts. count - uint64 : Number of blocks to include in the sum. Outputs: status - string : General RPC error code. \"OK\" means everything looks good. emission_amount - uint64 : Amount of coinbase reward in atomic units. fee_amount - uint64 : Amount of fees in atomic units. burn_amount - uint64 : Amount of burnt loki. GET_CONNECTIONS \u00b6 Back to top Retrieve information about incoming and outgoing connections to your node. Endpoints: get_connections Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_connections\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"connections\": [{ \"incoming\": true, \"localhost\": true, \"local_ip\": true, \"ssl\": true, \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"host\": \"127.0.0.1\", \"ip\": \"TODO(loki): Write example string\", \"port\": \"62950\", \"rpc_port\": 12345, \"peer_id\": \"c959fbfbed9e44fb\", \"recv_count\": 123, \"recv_idle_time\": 123, \"send_count\": 123, \"send_idle_time\": 123, \"state\": \"TODO(loki): Write example string\", \"live_time\": 123, \"avg_download\": 123, \"current_download\": 123, \"avg_upload\": 123, \"current_upload\": 123, \"support_flags\": 2130706433, \"connection_id\": \"083c301a3030329a487adb12ad981d2c\", \"height\": 234767, \"pruning_seed\": 2130706433, \"address_type\": 11 }] } } Outputs: status - string : General RPC error code. \"OK\" means everything looks good. connections - connection_info[] : List of all connections and their info: incoming - bool localhost - bool local_ip - bool ssl - bool address - string host - string ip - string port - string rpc_port - uint16 peer_id - string recv_count - uint64 recv_idle_time - uint64 send_count - uint64 send_idle_time - uint64 state - string live_time - uint64 avg_download - uint64 current_download - uint64 avg_upload - uint64 current_upload - uint64 support_flags - uint32 connection_id - string height - uint64 pruning_seed - uint32 address_type - uint8 GET_HEIGHT \u00b6 Back to top Get the node's current height. Endpoints: get_height, getheight Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_height\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"height\": 234767, \"status\": \"OK\", \"untrusted\": false, \"hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"immutable_height\": 123, \"immutable_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\" } } Outputs: height - uint64 : The current blockchain height according to the queried daemon. status - string : Generic RPC error code. \"OK\" is the success value. untrusted - bool : If the result is obtained using bootstrap mode, and therefore not trusted true , or otherwise false . hash - string : Hash of the block at the current height immutable_height - uint64 : The latest height in the blockchain that can not be reorganized from (backed by atleast 2 Service Node, or 1 hardcoded checkpoint, 0 if N/A). immutable_hash - string : Hash of the highest block in the chain that can not be reorganized. GET_INFO \u00b6 Back to top Retrieve general information about the state of your node and the network. Endpoints: get_info, getinfo Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_info\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"height\": 234767, \"target_height\": 123, \"immutable_height\": 123, \"difficulty\": 123, \"target\": 123, \"tx_count\": 123, \"tx_pool_size\": 123, \"alt_blocks_count\": 123, \"outgoing_connections_count\": 123, \"incoming_connections_count\": 123, \"rpc_connections_count\": 123, \"white_peerlist_size\": 123, \"grey_peerlist_size\": 123, \"mainnet\": true, \"testnet\": true, \"stagenet\": true, \"nettype\": \"MAINNET\", \"top_block_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"immutable_block_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"cumulative_difficulty\": 123, \"block_size_limit\": 123, \"block_weight_limit\": 123, \"block_size_median\": 123, \"block_weight_median\": 123, \"start_time\": 123, \"service_node\": true, \"last_storage_server_ping\": 123, \"last_lokinet_ping\": 123, \"free_space\": 123, \"offline\": true, \"untrusted\": false, \"bootstrap_daemon_address\": \"127.0.0.1:22023\", \"height_without_bootstrap\": 123, \"was_bootstrap_ever_used\": true, \"database_size\": 123, \"update_available\": true, \"version\": \"7\", \"status_line\": \"v15; Height: 531686\" } } Outputs: status - string : General RPC error code. \"OK\" means everything looks good. height - uint64 : Current length of longest chain known to daemon. target_height - uint64 : The height of the next block in the chain. immutable_height - uint64 : The latest height in the blockchain that can not be reorganized from (backed by atleast 2 Service Node, or 1 hardcoded checkpoint, 0 if N/A). difficulty - uint64 : Network difficulty (analogous to the strength of the network). target - uint64 : Current target for next proof of work. tx_count - uint64 : Total number of non-coinbase transaction in the chain. tx_pool_size - uint64 : Number of transactions that have been broadcast but not included in a block. alt_blocks_count - uint64 : Number of alternative blocks to main chain. outgoing_connections_count - uint64 : Number of peers that you are connected to and getting information from. incoming_connections_count - uint64 : Number of peers connected to and pulling from your node. rpc_connections_count - uint64 : Number of RPC client connected to the daemon (Including this RPC request). white_peerlist_size - uint64 : White Peerlist Size grey_peerlist_size - uint64 : Grey Peerlist Size mainnet - bool : States if the node is on the mainnet ( true ) or not ( false ). testnet - bool : States if the node is on the testnet ( true ) or not ( false ). stagenet - bool : States if the node is on the stagenet ( true ) or not ( false ). nettype - string : Nettype value used. top_block_hash - string : Hash of the highest block in the chain. immutable_block_hash - string : Hash of the highest block in the chain that can not be reorganized. cumulative_difficulty - uint64 : Cumulative difficulty of all blocks in the blockchain. block_size_limit - uint64 : Maximum allowed block size. block_weight_limit - uint64 : Maximum allowed block weight. block_size_median - uint64 : Median block size of latest 100 blocks. block_weight_median - uint64 : Median block weight of latest 100 blocks. start_time - uint64 : Start time of the daemon, as UNIX time. service_node - bool : Will be true if the node is running in --service-node mode. last_storage_server_ping - uint64 : Last ping time of the storage server (0 if never or not running as a service node) last_lokinet_ping - uint64 : Last ping time of lokinet (0 if never or not running as a service node) free_space - uint64 : Available disk space on the node. offline - bool : States if the node is offline ( true ) or online ( false ). untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). bootstrap_daemon_address - string : Bootstrap node to give immediate usability to wallets while syncing by proxying RPC to it. (Note: the replies may be untrustworthy). height_without_bootstrap - uint64 : Current length of the local chain of the daemon. was_bootstrap_ever_used - bool : States if a bootstrap node has ever been used since the daemon started. database_size - uint64 : Current size of Blockchain data. update_available - bool : States if a update is available ('true') and if one is not available ('false'). version - string : Current version of software running. status_line - string : A short one-line summary status of the node (requires an admin/unrestricted connection for most details) GET_LAST_BLOCK_HEADER \u00b6 Back to top Block header information for the most recent block is easily retrieved with this method. No inputs are needed. Endpoints: get_last_block_header, getlastblockheader Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_last_block_header\", \"params\": { \"fill_pow_hash\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"block_header\": { \"major_version\": 11, \"minor_version\": 11, \"timestamp\": 123, \"prev_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"nonce\": 2130706433, \"orphan_status\": true, \"height\": 234767, \"depth\": 123, \"hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"difficulty\": 25179406071, \"cumulative_difficulty\": 25179406071, \"reward\": 123, \"miner_reward\": 123, \"block_size\": 123, \"block_weight\": 123, \"num_txes\": 123, \"pow_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"long_term_weight\": 123, \"miner_tx_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"service_node_winner\": \"4a8c30cea9e729b06c91132295cce32d2a8e6e5bcf7b74a998e2ee1b3ed590b3\" }, \"untrusted\": false } } Inputs: fill_pow_hash - bool : Tell the daemon if it should fill out pow_hash field. Outputs: status - string : General RPC error code. \"OK\" means everything looks good. block_header - block_header_response : A structure containing block header information. major_version - uint8 : The major version of the loki protocol at this block height. minor_version - uint8 : The minor version of the loki protocol at this block height. timestamp - uint64 : The unix time at which the block was recorded into the blockchain. prev_hash - string : The hash of the block immediately preceding this block in the chain. nonce - uint32 : A cryptographic random one-time number used in mining a Loki block. orphan_status - bool : Usually false . If true , this block is not part of the longest chain. height - uint64 : The number of blocks preceding this block on the blockchain. depth - uint64 : The number of blocks succeeding this block on the blockchain. A larger number means an older block. hash - string : The hash of this block. difficulty - uint64 : The strength of the Loki network based on mining power. cumulative_difficulty - uint64 : The cumulative strength of the Loki network based on mining power. reward - uint64 : The amount of new generated in this block and rewarded to the miner, foundation and service Nodes. Note: 1 LOKI = 1e9 atomic units. miner_reward - uint64 : The amount of new generated in this block and rewarded to the miner. Note: 1 LOKI = 1e9 atomic units. block_size - uint64 : The block size in bytes. block_weight - uint64 : The block weight in bytes. num_txes - uint64 : Number of transactions in the block, not counting the coinbase tx. pow_hash - string : The hash of the block's proof of work. long_term_weight - uint64 : Long term weight of the block. miner_tx_hash - string : The TX hash of the miner transaction service_node_winner - string : Service node that received a reward for this block untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). GET_LIMIT \u00b6 Back to top Get daemon bandwidth limits. Endpoints: get_limit Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_limit\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"limit_up\": 123, \"limit_down\": 123, \"untrusted\": false } } Outputs: status - string : General RPC error code. \"OK\" means everything looks good. limit_up - uint64 : Upload limit in kBytes per second. limit_down - uint64 : Download limit in kBytes per second. untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). GET_NET_STATS \u00b6 Back to top Endpoints: get_net_stats Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_net_stats\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"start_time\": 123, \"total_packets_in\": 123, \"total_bytes_in\": 123, \"total_packets_out\": 123, \"total_bytes_out\": 123 } } Outputs: status - string start_time - uint64 total_packets_in - uint64 total_bytes_in - uint64 total_packets_out - uint64 total_bytes_out - uint64 GET_OUTPUTS \u00b6 Back to top Endpoints: get_outs Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_outs\", \"params\": { \"outputs\": [{ \"amount\": 26734261552878, \"index\": 123 }], \"get_txid\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"outs\": [{ \"key\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"mask\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"unlocked\": true, \"height\": 234767, \"txid\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\" }], \"status\": \"OK\", \"untrusted\": false } } Inputs: outputs - get_outputs_out[] : Array of structure get_outputs_out . amount - uint64 : Amount of Loki in TXID. index - uint64 get_txid - bool : Request the TXID/hash of the transaction as well. Outputs: outs - outkey[] : List of outkey information. key - string : The public key of the output. mask - string unlocked - bool : States if output is locked ( false ) or not ( true ). height - uint64 : Block height of the output. txid - string : Transaction id. status - string : General RPC error code. \"OK\" means everything looks good. untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). GET_OUTPUT_DISTRIBUTION \u00b6 Back to top Endpoints: get_output_distribution Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_output_distribution\", \"params\": { \"amounts\": [123], \"from_height\": 123, \"to_height\": 123, \"cumulative\": true, \"binary\": true, \"compress\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"distributions\": [{ \"data\": { \"distribution\": [\"TODO(loki): Write example string\"], \"start_height\": \"TODO(loki): Write example string\", \"base\": \"TODO(loki): Write example string\" }, \"amount\": 26734261552878, \"compressed_data\": \"TODO(loki): Write example string\", \"binary\": true, \"compress\": true }], \"untrusted\": false } } Inputs: amounts - uint64[] : Amounts to look for in atomic units. from_height - uint64 : (optional, default is 0) starting height to check from. to_height - uint64 : (optional, default is 0) ending height to check up to. cumulative - bool : (optional, default is false) States if the result should be cumulative (true) or not (false). binary - bool compress - bool Outputs: status - string : General RPC error code. \"OK\" means everything looks good. distributions - distribution[] data - rpc::output_distribution_data distribution - uint64[] start_height - uint64 base - uint64 amount - uint64 compressed_data - string binary - bool compress - bool untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). GET_OUTPUT_HISTOGRAM \u00b6 Back to top Get a histogram of output amounts. For all amounts (possibly filtered by parameters), gives the number of outputs on the chain for that amount. RingCT outputs counts as 0 amount. Endpoints: get_output_histogram Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_output_histogram\", \"params\": { \"amounts\": [123], \"min_count\": 123, \"max_count\": 123, \"unlocked\": true, \"recent_cutoff\": 123 } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"histogram\": [{ \"amount\": 26734261552878, \"total_instances\": 123, \"unlocked_instances\": 123, \"recent_instances\": 123 }], \"untrusted\": false } } Inputs: amounts - uint64[] : list of amounts in Atomic Units. min_count - uint64 : The minimum amounts you are requesting. max_count - uint64 : The maximum amounts you are requesting. unlocked - bool : Look for locked only. recent_cutoff - uint64 Outputs: status - string : General RPC error code. \"OK\" means everything looks good. histogram - entry[] : List of histogram entries: amount - uint64 : Output amount in atomic units. total_instances - uint64 unlocked_instances - uint64 recent_instances - uint64 untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). GET_PEER_LIST \u00b6 Back to top Get the known peers list. Endpoints: get_peer_list Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_peer_list\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"white_list\": [{ \"id\": 123, \"host\": \"127.0.0.1\", \"ip\": 2130706433, \"port\": 12345, \"rpc_port\": 12345, \"last_seen\": 1554685440, \"pruning_seed\": 2130706433 }], \"gray_list\": [{ \"id\": 123, \"host\": \"127.0.0.1\", \"ip\": 2130706433, \"port\": 12345, \"rpc_port\": 12345, \"last_seen\": 1554685440, \"pruning_seed\": 2130706433 }] } } Outputs: status - string : General RPC error code. \"OK\" means everything looks good. Any other value means that something went wrong. white_list - peer[] : Array of online peer structure. id - uint64 : Peer id. host - string : IP address in string format. ip - uint32 : IP address in integer format. port - uint16 : TCP port the peer is using to connect to loki network. rpc_port - uint16 : RPC port the peer is using last_seen - uint64 : Unix time at which the peer has been seen for the last time pruning_seed - uint32 gray_list - peer[] : Array of offline peer structure. id - uint64 : Peer id. host - string : IP address in string format. ip - uint32 : IP address in integer format. port - uint16 : TCP port the peer is using to connect to loki network. rpc_port - uint16 : RPC port the peer is using last_seen - uint64 : Unix time at which the peer has been seen for the last time pruning_seed - uint32 GET_QUORUM_STATE \u00b6 Back to top Get the quorum state which is the list of public keys of the nodes who are voting, and the list of public keys of the nodes who are being tested. Endpoints: get_quorum_state Constants: * `MAX_COUNT - uint64 = 256` * `HEIGHT_SENTINEL_VALUE - uint64 = UINT64_MAX` * `ALL_QUORUMS_SENTINEL_VALUE - uint8 = 255` Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_quorum_state\", \"params\": { \"start_height\": 123, \"end_height\": 123, \"quorum_type\": 11 } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"quorums\": [{ \"height\": 234767, \"quorum_type\": 11, \"quorum\": { \"validators\": [\"4a8c30cea9e729b06c91132295cce32d2a8e6e5bcf7b74a998e2ee1b3ed590b3\"], \"workers\": [\"4a8c30cea9e729b06c91132295cce32d2a8e6e5bcf7b74a998e2ee1b3ed590b3\"] } }], \"untrusted\": false } } Inputs: start_height - uint64 : (Optional): Start height, omit both start and end height to request the latest quorum end_height - uint64 : (Optional): End height, omit both start and end height to request the latest quorum quorum_type - uint8 : (Optional): Set value to request a specific quorum, 0 = Obligation, 1 = Checkpointing, 255 = all quorums, default is all quorums; Outputs: status - string : Generic RPC error code. \"OK\" is the success value. quorums - quorum_for_height[] : An array of quorums associated with the requested height height - uint64 : The height the quorums are relevant for quorum_type - uint8 : The quorum type quorum - quorum_t : Quorum of Service Nodes validators - string[] : Public key of the service node workers - string[] : Public key of the service node untrusted - bool : If the result is obtained using bootstrap mode, and therefore not trusted true , or otherwise false . GET_RANDOM_OUTS \u00b6 Back to top TODO: Undocumented light wallet RPC call Inputs: amounts - string[] count - uint32 Outputs: amount_outs - amount_out[] amount - uint64 outputs - output[] public_key - string global_index - uint64 rct - string : 64+64+64 characters long ( + + ) Error - string GET_SERVICE_KEYS \u00b6 Back to top Get the service public keys of the queried daemon, encoded in hex. All three keys are used when running as a service node; when running as a regular node only the x25519 key is regularly used for some RPC and and node-to-SN communication requests. Endpoints: get_service_keys, get_service_node_key Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_service_keys\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"service_node_pubkey\": \"4a8c30cea9e729b06c91132295cce32d2a8e6e5bcf7b74a998e2ee1b3ed590b3\", \"service_node_ed25519_pubkey\": \"1de25fd280b9b08da62f06a5521c735fd94b7ecf237ca7409748295e75b48104\", \"service_node_x25519_pubkey\": \"7a8d1961ec9d1ac77aa67a2cded9271b0b6b9e4406005b36e260d0a230943b0e\", \"status\": \"OK\" } } Outputs: service_node_pubkey - string : The queried daemon's service node public key. Will be empty if not running as a service node. service_node_ed25519_pubkey - string : The daemon's ed25519 auxiliary public key. service_node_x25519_pubkey - string : The daemon's x25519 auxiliary public key. status - string : Generic RPC error code. \"OK\" is the success value. GET_SERVICE_NODES \u00b6 Back to top Get information on some, all, or a random subset of Service Nodes. Endpoints: get_service_nodes, get_n_service_nodes, get_all_service_nodes Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_service_nodes\", \"params\": { \"service_node_pubkeys\": [\"4a8c30cea9e729b06c91132295cce32d2a8e6e5bcf7b74a998e2ee1b3ed590b3\"], \"include_json\": true, \"limit\": 2130706433, \"active_only\": true, \"fields\": { \"all\": true, \"service_node_pubkey\": true, \"registration_height\": true, \"registration_hf_version\": true, \"requested_unlock_height\": true, \"last_reward_block_height\": true, \"last_reward_transaction_index\": true, \"active\": true, \"funded\": true, \"state_height\": true, \"decommission_count\": true, \"earned_downtime_blocks\": true, \"service_node_version\": true, \"contributors\": true, \"total_contributed\": true, \"total_reserved\": true, \"staking_requirement\": true, \"portions_for_operator\": true, \"swarm_id\": true, \"operator_address\": true, \"public_ip\": true, \"storage_port\": true, \"storage_lmq_port\": true, \"quorumnet_port\": true, \"pubkey_ed25519\": true, \"pubkey_x25519\": true, \"last_uptime_proof\": true, \"storage_server_reachable\": true, \"storage_server_reachable_timestamp\": true, \"version_major\": true, \"version_minor\": true, \"version_patch\": true, \"votes\": true, \"block_hash\": true, \"height\": true, \"target_height\": true, \"hardfork\": true }, \"poll_block_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"service_node_states\": [{ \"service_node_pubkey\": \"4a8c30cea9e729b06c91132295cce32d2a8e6e5bcf7b74a998e2ee1b3ed590b3\", \"registration_height\": 234767, \"registration_hf_version\": 12345, \"requested_unlock_height\": 123, \"last_reward_block_height\": 234767, \"last_reward_transaction_index\": 2130706433, \"active\": true, \"funded\": true, \"state_height\": 123, \"decommission_count\": 2130706433, \"earned_downtime_blocks\": 123, \"service_node_version\": [\"TODO(loki): Write example string\"], \"contributors\": [{ \"amount\": 26734261552878, \"reserved\": 123, \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"locked_contributions\": [{ \"key_image\": \"8d1bd8181bf7d857bdb281e0153d84cd55a3fcaa57c3e570f4a49f935850b5e3\", \"key_image_pub_key\": \"b1b696dd0a0d1815e341d9fed85708703c57b5d553a3615bcf4a06a36fa4bc38\", \"amount\": 26734261552878 }] }], \"total_contributed\": 123, \"total_reserved\": 123, \"staking_requirement\": 100000000000, \"portions_for_operator\": 18446744073709551612, \"swarm_id\": 123, \"operator_address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"public_ip\": \"8.8.8.8\", \"storage_port\": 12345, \"storage_lmq_port\": 12345, \"quorumnet_port\": 12345, \"pubkey_ed25519\": \"1de25fd280b9b08da62f06a5521c735fd94b7ecf237ca7409748295e75b48104\", \"pubkey_x25519\": \"7a8d1961ec9d1ac77aa67a2cded9271b0b6b9e4406005b36e260d0a230943b0e\", \"last_uptime_proof\": 123, \"storage_server_reachable\": true, \"storage_server_reachable_timestamp\": 123, \"version_major\": 12345, \"version_minor\": 12345, \"version_patch\": 12345, \"votes\": [{ \"height\": 234767, \"voted\": true }] }], \"height\": 234767, \"target_height\": 123, \"block_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"unchanged\": true, \"hardfork\": 11, \"status\": \"OK\", \"as_json\": \"TODO(loki): Write example string\" } } Inputs: service_node_pubkeys - string[] : Array of public keys of registered Service Nodes to get information about. Omit to query all Service Nodes. include_json - bool : When set, the response's as_json member is filled out. limit - uint32 : If non-zero, select a random sample (in random order) of the given number of service nodes to return from the full list. active_only - bool : If true, only include results for active (fully staked, not decommissioned) service nodes. fields - requested_fields_t all - bool = true : internal use only: indicates whether none of the other parameters have been explicitly set service_node_pubkey - bool registration_height - bool registration_hf_version - bool requested_unlock_height - bool last_reward_block_height - bool last_reward_transaction_index - bool active - bool funded - bool state_height - bool decommission_count - bool earned_downtime_blocks - bool service_node_version - bool contributors - bool total_contributed - bool total_reserved - bool staking_requirement - bool portions_for_operator - bool swarm_id - bool operator_address - bool public_ip - bool storage_port - bool storage_lmq_port - bool quorumnet_port - bool pubkey_ed25519 - bool pubkey_x25519 - bool last_uptime_proof - bool storage_server_reachable - bool storage_server_reachable_timestamp - bool version_major - bool version_minor - bool version_patch - bool votes - bool block_hash - bool height - bool target_height - bool hardfork - bool poll_block_hash - string : If specified this changes the behaviour to only return service node records if the block hash is not equal to the given hash; otherwise it omits the records and instead sets \"unchanged\": true in the response. This is primarily used to poll for new results where the requested results only change with new blocks. Outputs: service_node_states - entry[] : Array of service node registration information service_node_pubkey - string : The public key of the Service Node. registration_height - uint64 : The height at which the registration for the Service Node arrived on the blockchain. registration_hf_version - uint16 : The hard fork at which the registration for the Service Node arrived on the blockchain. requested_unlock_height - uint64 : The height at which contributions will be released and the Service Node expires. 0 if not requested yet. last_reward_block_height - uint64 : The last height at which this Service Node received a reward. last_reward_transaction_index - uint32 : When multiple Service Nodes register on the same height, the order the transaction arrive dictate the order you receive rewards. active - bool : True if fully funded and not currently decommissioned (and so active && !funded implicitly defines decommissioned) funded - bool : True if the required stakes have been submitted to activate this Service Node state_height - uint64 : If active: the state at which registration was completed; if decommissioned: the decommissioning height; if awaiting: the last contribution (or registration) height decommission_count - uint32 : The number of times the Service Node has been decommissioned since registration earned_downtime_blocks - int64 : The number of blocks earned towards decommissioning, or the number of blocks remaining until deregistration if currently decommissioned service_node_version - uint16[3] : The major, minor, patch version of the Service Node respectively. contributors - service_node_contributor[] : Array of contributors, contributing to this Service Node. amount - uint64 : The total amount of locked Loki in atomic units for this contributor. reserved - uint64 : The amount of Loki in atomic units reserved by this contributor for this Service Node. address - string : The wallet address for this contributor rewards are sent to and contributions came from. locked_contributions - service_node_contribution[] : Array of contributions from this contributor. key_image - string : The contribution's key image that is locked on the network. key_image_pub_key - string : The contribution's key image, public key component amount - uint64 : The amount that is locked in this contribution. total_contributed - uint64 : The total amount of Loki in atomic units contributed to this Service Node. total_reserved - uint64 : The total amount of Loki in atomic units reserved in this Service Node. staking_requirement - uint64 : The staking requirement in atomic units that is required to be contributed to become a Service Node. portions_for_operator - uint64 : The operator percentage cut to take from each reward expressed in portions, see cryptonote_config.h's STAKING_PORTIONS. swarm_id - uint64 : The identifier of the Service Node's current swarm. operator_address - string : The wallet address of the operator to which the operator cut of the staking reward is sent to. public_ip - string : The public ip address of the service node storage_port - uint16 : The port number associated with the storage server storage_lmq_port - uint16 : The port number associated with the storage server (lokimq interface) quorumnet_port - uint16 : The port for direct SN-to-SN communication pubkey_ed25519 - string : The service node's ed25519 public key for auxiliary services pubkey_x25519 - string : The service node's x25519 public key for auxiliary services last_uptime_proof - uint64 : The last time this Service Node's uptime proof was relayed by at least 1 Service Node other than itself in unix epoch time. storage_server_reachable - bool : Whether the node's storage server has been reported as unreachable for a long time storage_server_reachable_timestamp - uint64 : The last time this Service Node's storage server was contacted version_major - uint16 : Major version the node is currently running version_minor - uint16 : Minor version the node is currently running version_patch - uint16 : Patch version the node is currently running votes - service_nodes::checkpoint_vote_record[] : Of the last N checkpoints the Service Node is in a checkpointing quorum, record whether or not the Service Node voted to checkpoint a block height - uint64 = INVALID_HEIGHT voted - bool = true height - uint64 : Current block's height. target_height - uint64 : Blockchain's target height. block_hash - string : Current block's hash. unchanged - bool : Will be true (and service_node_states omitted) if you gave the current block hash to poll_block_hash hardfork - uint8 : Current hardfork version. status - string : Generic RPC error code. \"OK\" is the success value. as_json - string : If include_json is set in the request, this contains the json representation of the entry data structure GET_SERVICE_NODE_BLACKLISTED_KEY_IMAGES \u00b6 Back to top Get information on blacklisted Service Node key images. Endpoints: get_service_node_blacklisted_key_images Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_service_node_blacklisted_key_images\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"blacklist\": [{ \"key_image\": \"8d1bd8181bf7d857bdb281e0153d84cd55a3fcaa57c3e570f4a49f935850b5e3\", \"unlock_height\": 123, \"amount\": 26734261552878 }], \"status\": \"OK\" } } Outputs: blacklist - entry[] : Array of blacklisted key images, i.e. unspendable transactions key_image - string : The key image of the transaction that is blacklisted on the network. unlock_height - uint64 : The height at which the key image is removed from the blacklist and becomes spendable. amount - uint64 : The total amount of locked Loki in atomic units in this blacklisted stake. status - string : Generic RPC error code. \"OK\" is the success value. GET_SERVICE_NODE_REGISTRATION_CMD \u00b6 Back to top Endpoints: get_service_node_registration_cmd Constants: * `response - GET_SERVICE_NODE_REGISTRATION_CMD_RAW::response` Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_service_node_registration_cmd\", \"params\": { \"operator_cut\": \"1.1%\", \"contributions\": [{ \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"amount\": 26734261552878 }], \"staking_requirement\": 100000000000 } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"registration_cmd\": \"register_service_node 18446744073709551612 L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk 18446744073709551612 1555894565 f90424b23c7969bb2f0191bca45e6433a59b0b37039a5e38a2ba8cc7ea1075a3 ba24e4bfb4af0f5f9f74e35f1a5685dc9250ee83f62a9ee8964c9a689cceb40b4f125c83d0cbb434e56712d0300e5a23fd37a5b60cddbcd94e2d578209532a0d\" } } Inputs: operator_cut - string : The percentage of cut per reward the operator receives expressed as a string, i.e. \"1.1%\" contributions - contribution_t[] : Array of contributors for this Service Node address - string : The wallet address for the contributor amount - uint64 : The amount that the contributor will reserve in Loki atomic units towards the staking requirement staking_requirement - uint64 : The staking requirement to become a Service Node the registration command will be generated upon Outputs: status - string : Generic RPC error code. \"OK\" is the success value. registration_cmd - string : The command to execute in the wallet CLI to register the queried daemon as a Service Node. GET_SERVICE_NODE_REGISTRATION_CMD_RAW \u00b6 Back to top Endpoints: get_service_node_registration_cmd_raw Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_service_node_registration_cmd_raw\", \"params\": { \"args\": [\"TODO(loki): Write example string\"], \"make_friendly\": true, \"staking_requirement\": 100000000000 } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"registration_cmd\": \"register_service_node 18446744073709551612 L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk 18446744073709551612 1555894565 f90424b23c7969bb2f0191bca45e6433a59b0b37039a5e38a2ba8cc7ea1075a3 ba24e4bfb4af0f5f9f74e35f1a5685dc9250ee83f62a9ee8964c9a689cceb40b4f125c83d0cbb434e56712d0300e5a23fd37a5b60cddbcd94e2d578209532a0d\" } } Inputs: args - string[] : (Developer) The arguments used in raw registration, i.e. portions make_friendly - bool : Provide information about how to use the command in the result. staking_requirement - uint64 : The staking requirement to become a Service Node the registration command will be generated upon Outputs: status - string : Generic RPC error code. \"OK\" is the success value. registration_cmd - string : The command to execute in the wallet CLI to register the queried daemon as a Service Node. GET_SERVICE_NODE_STATUS \u00b6 Back to top Get information on the queried daemon's Service Node state. Endpoints: get_service_node_status Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_service_node_status\", \"params\": { \"include_json\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"service_node_state\": \"TODO(loki): Write example string\", \"height\": 234767, \"block_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"status\": \"OK\", \"as_json\": \"TODO(loki): Write example string\" } } Inputs: include_json - bool : When set, the response's as_json member is filled out. Outputs: service_node_state - GET_SERVICE_NODES::response::entry : Service node registration information height - uint64 : Current block's height. block_hash - string : Current block's hash. status - string : Generic RPC error code. \"OK\" is the success value. as_json - string : If include_json is set in the request, this contains the json representation of the entry data structure GET_SERVICE_PRIVKEYS \u00b6 Back to top Get the service private keys of the queried daemon, encoded in hex. Do not ever share these keys: they would allow someone to impersonate your service node. All three keys are used when running as a service node; when running as a regular node only the x25519 key is regularly used for some RPC and and node-to-SN communication requests. Endpoints: get_service_privkeys, get_service_node_privkey Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_service_privkeys\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"service_node_privkey\": \"4a8c30cea9e729b06c91132295cce32d2a8e6e5bcf7b74a998e2ee1b3ed590b3\", \"service_node_ed25519_privkey\": \"1de25fd280b9b08da62f06a5521c735fd94b7ecf237ca7409748295e75b48104\", \"service_node_x25519_privkey\": \"7a8d1961ec9d1ac77aa67a2cded9271b0b6b9e4406005b36e260d0a230943b0e\", \"status\": \"OK\" } } Outputs: service_node_privkey - string : The queried daemon's service node private key. Will be empty if not running as a service node. service_node_ed25519_privkey - string : The daemon's ed25519 private key (note that this is in sodium's format, which consists of the private and public keys concatenated together) service_node_x25519_privkey - string : The daemon's x25519 private key. status - string : Generic RPC error code. \"OK\" is the success value. GET_SN_STATE_CHANGES \u00b6 Back to top Query hardcoded/service node checkpoints stored for the blockchain. Omit all arguments to retrieve the latest \"count\" checkpoints. Endpoints: get_service_nodes_state_changes Constants: * `HEIGHT_SENTINEL_VALUE - uint64 = std::numeric_limits<uint64_t>::max() - 1` Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_service_nodes_state_changes\", \"params\": { \"start_height\": 123, \"end_height\": 123 } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"untrusted\": false, \"total_deregister\": 2130706433, \"total_ip_change_penalty\": 2130706433, \"total_decommission\": 2130706433, \"total_recommission\": 2130706433, \"total_unlock\": 2130706433, \"start_height\": 123, \"end_height\": 123 } } Inputs: start_height - uint64 end_height - uint64 : Optional: If omitted, the tally runs until the current block Outputs: status - string : Generic RPC error code. \"OK\" is the success value. untrusted - bool : If the result is obtained using bootstrap mode, and therefore not trusted true , or otherwise false . total_deregister - uint32 total_ip_change_penalty - uint32 total_decommission - uint32 total_recommission - uint32 total_unlock - uint32 start_height - uint64 end_height - uint64 GET_STAKING_REQUIREMENT \u00b6 Back to top Get the required amount of Loki to become a Service Node at the queried height. For stagenet and testnet values, ensure the daemon is started with the `--stagenet` or `--testnet` flags respectively. Endpoints: get_staking_requirement Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_staking_requirement\", \"params\": { \"height\": 234767 } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"staking_requirement\": 100000000000, \"height\": 234767, \"status\": \"OK\" } } Inputs: height - uint64 : The height to query the staking requirement for. 0 (or omitting) means current height. Outputs: staking_requirement - uint64 : The staking requirement in Loki, in atomic units. height - uint64 : The height requested (or current height if 0 was requested) status - string : Generic RPC error code. \"OK\" is the success value. GET_TRANSACTIONS \u00b6 Back to top Look up one or more transactions by hash. Endpoints: get_transactions, gettransactions Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_transactions\", \"params\": { \"txs_hashes\": [\"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\"], \"decode_as_json\": true, \"prune\": true, \"split\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"txs_as_hex\": [\"TODO(loki): Write example string\"], \"txs_as_json\": [\"TODO(loki): Write example string\"], \"missed_tx\": [\"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\"], \"txs\": [{ \"tx_hash\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"as_hex\": \"TODO(loki): Write example string\", \"pruned_as_hex\": \"TODO(loki): Write example string\", \"prunable_as_hex\": \"TODO(loki): Write example string\", \"prunable_hash\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"as_json\": \"TODO(loki): Write example string\", \"in_pool\": true, \"double_spend_seen\": true, \"block_height\": 123, \"block_timestamp\": 123, \"output_indices\": [123], \"relayed\": true, \"blink\": true }], \"status\": \"OK\", \"untrusted\": false } } Inputs: txs_hashes - string[] : List of transaction hashes to look up. decode_as_json - bool : Optional ( false by default). If set true, the returned transaction information will be decoded rather than binary. prune - bool : Prunes the blockchain, drops off 7/8 off the block iirc. Optional ( False by default). split - bool : Optional ( false by default). Outputs: txs_as_hex - string[] : Full transaction information as a hex string (old compatibility parameter) txs_as_json - string[] : Transactions decoded as json (old compat) missed_tx - string[] : (Optional - returned if not empty) Transaction hashes that could not be found. txs - entry[] : Array of structure entry as follows: tx_hash - string : Transaction hash. as_hex - string : Full transaction information as a hex string. pruned_as_hex - string prunable_as_hex - string prunable_hash - string as_json - string : List of transaction info. in_pool - bool : States if the transaction is in pool ( true ) or included in a block ( false ). double_spend_seen - bool : States if the transaction is a double-spend ( true ) or not ( false ). block_height - uint64 : Block height including the transaction. block_timestamp - uint64 : Unix time at chich the block has been added to the blockchain. output_indices - uint64[] : List of transaction indexes. relayed - bool blink - bool : True if this is an approved, blink transaction (only for in_pool transactions or txes in recent blocks) status - string : General RPC error code. \"OK\" means everything looks good. untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). GET_TRANSACTION_POOL \u00b6 Back to top Show information about valid transactions seen by the node but not yet mined into a block, as well as spent key image information for the txpool in the node's memory. Endpoints: get_transaction_pool Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_transaction_pool\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"transactions\": [{ \"id_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"tx_json\": \"TODO(loki): Write example string\", \"blob_size\": 123, \"weight\": 123, \"fee\": 123, \"max_used_block_id_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"max_used_block_height\": 123, \"kept_by_block\": true, \"last_failed_height\": 123, \"last_failed_id_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"receive_time\": 123, \"relayed\": true, \"last_relayed_time\": 123, \"do_not_relay\": true, \"double_spend_seen\": true, \"tx_blob\": \"0402f78b05f78b05f78b0501ffd98b0502b888ddcf730229f056f5594cfcfd8d44f8033c9fda22450693d1694038e1cecaaaac25a8fc12af8992bc800102534df00c14ead3b3dedea9e7bdcf71c44803349b5e9aee2f73e22d5385ac147b7601008e5729d9329320444666d9d9d9dc602a3ae585de91ab2ca125665e3a363610021100000001839fdb0000000000000000000001200408d5ad7ab79d9b05c94033c2029f4902a98ec51f5175564f6978467dbb28723f929cf806d4ee1c781d7771183a93a1fd74f0827bddee9baac7e3083ab2b5840000\", \"blink\": true }], \"spent_key_images\": [{ \"id_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"txs_hashes\": [\"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\"] }], \"untrusted\": false } } Outputs: status - string : General RPC error code. \"OK\" means everything looks good. transactions - tx_info[] : List of transactions in the mempool are not in a block on the main chain at the moment: id_hash - string : The transaction ID hash. tx_json - string : JSON structure of all information in the transaction blob_size - uint64 : The size of the full transaction blob. weight - uint64 : The weight of the transaction. fee - uint64 : The amount of the mining fee included in the transaction, in atomic units. max_used_block_id_hash - string : Tells the hash of the most recent block with an output used in this transaction. max_used_block_height - uint64 : Tells the height of the most recent block with an output used in this transaction. kept_by_block - bool : States if the tx was included in a block at least once ( true ) or not ( false ). last_failed_height - uint64 : If the transaction validation has previously failed, this tells at what height that occured. last_failed_id_hash - string : Like the previous, this tells the previous transaction ID hash. receive_time - uint64 : The Unix time that the transaction was first seen on the network by the node. relayed - bool : States if this transaction has been relayed last_relayed_time - uint64 : Last unix time at which the transaction has been relayed. do_not_relay - bool : States if this transaction should not be relayed. double_spend_seen - bool : States if this transaction has been seen as double spend. tx_blob - string : Hexadecimal blob represnting the transaction. blink - bool : True if this is a signed blink transaction spent_key_images - spent_key_image_info[] : List of spent output key images: id_hash - string : Key image. txs_hashes - string[] : List of tx hashes of the txes (usually one) spending that key image. untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). GET_TRANSACTION_POOL_BACKLOG \u00b6 Back to top Get all transaction pool backlog. Endpoints: get_txpool_backlog Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_txpool_backlog\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"backlog\": [{ \"weight\": 123, \"fee\": 123, \"time_in_pool\": 123 }], \"untrusted\": false } } Outputs: status - string : General RPC error code. \"OK\" means everything looks good. backlog - tx_backlog_entry[] : Array of structures tx_backlog_entry (in binary form): weight - uint64 fee - uint64 : Fee in Loki measured in atomic units. time_in_pool - uint64 untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). GET_TRANSACTION_POOL_HASHES \u00b6 Back to top Get hashes from transaction pool. Endpoints: get_transaction_pool_hashes Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_transaction_pool_hashes\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"tx_hashes\": [\"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\"], \"untrusted\": false } } Outputs: status - string : General RPC error code. \"OK\" means everything looks good. tx_hashes - string[] : List of transaction hashes, untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). GET_TRANSACTION_POOL_STATS \u00b6 Back to top Get the transaction pool statistics. Endpoints: get_transaction_pool_stats Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_transaction_pool_stats\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"pool_stats\": { \"bytes_total\": 123, \"bytes_min\": 2130706433, \"bytes_max\": 2130706433, \"bytes_med\": 2130706433, \"fee_total\": 123, \"oldest\": 123, \"txs_total\": 2130706433, \"num_failing\": 2130706433, \"num_10m\": 2130706433, \"num_not_relayed\": 2130706433, \"histo_98pc\": 123, \"histo\": [{ \"txs\": 2130706433, \"bytes\": 123 }], \"num_double_spends\": 2130706433 }, \"untrusted\": false } } Outputs: status - string : General RPC error code. \"OK\" means everything looks good. pool_stats - txpool_stats : List of pool stats: bytes_total - uint64 : Total size of all transactions in pool. bytes_min - uint32 : Min transaction size in pool. bytes_max - uint32 : Max transaction size in pool. bytes_med - uint32 : Median transaction size in pool. fee_total - uint64 : Total fee's in pool in atomic units. oldest - uint64 : Unix time of the oldest transaction in the pool. txs_total - uint32 : Total number of transactions. num_failing - uint32 : Bumber of failing transactions. num_10m - uint32 : Number of transactions in pool for more than 10 minutes. num_not_relayed - uint32 : Number of non-relayed transactions. histo_98pc - uint64 : the time 98% of txes are \"younger\" than. histo - txpool_histo[] : List of txpool histo. txs - uint32 : Number of transactions. bytes - uint64 : Size in bytes. num_double_spends - uint32 : Number of double spend transactions. untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). GET_VERSION \u00b6 Back to top Get current RPC protocol version. Endpoints: get_version Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_version\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"version\": 2130706433, \"untrusted\": false } } Outputs: status - string : General RPC error code. \"OK\" means everything looks good. version - uint32 : RPC current version. untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). HARD_FORK_INFO \u00b6 Back to top Look up information regarding hard fork voting and readiness. Endpoints: hard_fork_info Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"hard_fork_info\", \"params\": { \"version\": 11 } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"version\": 11, \"enabled\": true, \"window\": 2130706433, \"votes\": 2130706433, \"threshold\": 2130706433, \"voting\": 11, \"state\": 2130706433, \"earliest_height\": 123, \"status\": \"OK\", \"untrusted\": false } } Inputs: version - uint8 : The major block version for the fork. Outputs: version - uint8 : The major block version for the fork. enabled - bool : Tells if hard fork is enforced. window - uint32 : Number of blocks over which current votes are cast. Default is 10080 blocks. votes - uint32 : Number of votes towards hard fork. threshold - uint32 : Minimum percent of votes to trigger hard fork. Default is 80. voting - uint8 : Hard fork voting status. state - uint32 : Current hard fork state: 0 (There is likely a hard fork), 1 (An update is needed to fork properly), or 2 (Everything looks good). earliest_height - uint64 : Block height at which hard fork would be enabled if voted in. status - string : General RPC error code. \"OK\" means everything looks good. untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). IMPORT_WALLET_REQUEST \u00b6 Back to top TODO: Undocumented light wallet RPC call Inputs: address - string view_key - string Outputs: payment_id - string import_fee - uint64 new_request - bool request_fulfilled - bool payment_address - string status - string IN_PEERS \u00b6 Back to top Limit number of Incoming peers. Endpoints: in_peers Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"in_peers\", \"params\": { \"set\": true, \"in_peers\": 2130706433 } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"in_peers\": 2130706433, \"status\": \"OK\" } } Inputs: set - bool : If true, set the number of incoming peers, otherwise the response returns the current limit of incoming peers. (Defaults to true) in_peers - uint32 : Max number of incoming peers Outputs: in_peers - uint32 : The current limit set for outgoing peers status - string : General RPC error code. \"OK\" means everything looks good. IS_KEY_IMAGE_SPENT \u00b6 Back to top Check if outputs have been spent using the key image associated with the output. Endpoints: is_key_image_spent Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"is_key_image_spent\", \"params\": { \"key_images\": [\"8d1bd8181bf7d857bdb281e0153d84cd55a3fcaa57c3e570f4a49f935850b5e3\"] } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"spent_status\": [0, 1], \"status\": \"OK\", \"untrusted\": false } } Inputs: key_images - string[] : List of key image hex strings to check. Outputs: spent_status - int32[] : List of statuses for each image checked. Statuses are follows: 0 = unspent, 1 = spent in blockchain, 2 = spent in transaction pool status - string : General RPC error code. \"OK\" means everything looks good. untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). LNS_NAMES_TO_OWNERS \u00b6 Back to top Get the name mapping for a Loki Name Service entry. Loki currently supports mappings for Session. Endpoints: lns_names_to_owners Constants: * `MAX_REQUEST_ENTRIES - uint64 = 256` * `MAX_TYPE_REQUEST_ENTRIES - uint64 = 8` Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"lns_names_to_owners\", \"params\": { \"entries\": [{ \"name_hash\": \"BzT9ln2zY7/DxSqNeNXeEpYx3fxu2B+guA0ClqtSb0E=\", \"types\": [12345] }] } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"entries\": [{ \"entry_index\": 123, \"type\": session, \"name_hash\": \"BzT9ln2zY7/DxSqNeNXeEpYx3fxu2B+guA0ClqtSb0E=\", \"owner\": \"L8ssYFtxi1HTFQdbmG9Lt71tyudgageDgBqBLcgLnw5XBiJ1NQLFYNAAfYpYS3jHaSe8UsFYjSgKadKhC7edTSQB15s6T7g\", \"backup_owner\": \"L8PYYYTh6yEewvuPmF75uhjDn9fBzKXp8CeMuwKNZBvZT8wAoe9hJ4favnZMvTTkNdT56DMNDcdWyheb3icfk4MS3udsP4R\", \"encrypted_value\": \"8fe253e6f15addfbce5c87583e970cb09294ec5b9fc7a1891c2ac34937e5a5c116c210ddf313f5fcccd8ee28cfeb0fa8e9\", \"register_height\": 123, \"update_height\": 123, \"txid\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"prev_txid\": \"f26efb11e8eb6b446c5e0247e8883f41689591356f7abe65afe9fe75f567d40e\" }], \"status\": \"OK\" } } Inputs: entries - request_entry[] name_hash - string : The name hashed using libsodium's crypto_generichash_blake2b in base64 to resolve to a public key via Loki Name Service types - uint16[] : If empty, query all types. Currently only Session(0). In future updates more mapping types will be available. Outputs: entries - response_entry[] entry_index - uint64 : The index in request_entry's entries array that was resolved via Loki Name Service. type - uint16 : The type of Loki Name Service entry that the owner owns. name_hash - string : The hash of the name that was queried in base64 owner - string : The public key that purchased the Loki Name Service entry. backup_owner - string : The backup public key that the owner specified when purchasing the Loki Name Service entry. encrypted_value - string : The encrypted value that the name maps to. This value is encrypted using the name (not the hash) as the secret. register_height - uint64 : The height that this Loki Name Service entry was purchased on the Blockchain. update_height - uint64 : The last height that this Loki Name Service entry was updated on the Blockchain. txid - string : The txid of who purchased the mapping, null hash if not applicable. prev_txid - string : The previous txid that purchased the mapping, null hash if not applicable. status - string : Generic RPC error code. \"OK\" is the success value. LNS_OWNERS_TO_NAMES \u00b6 Back to top Get all the name mappings for the queried owner. The owner can be either a ed25519 public key or Monero style public key; by default purchases are owned by the spend public key of the purchasing wallet. Endpoints: lns_owners_to_names Constants: * `MAX_REQUEST_ENTRIES - uint64 = 256` Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"lns_owners_to_names\", \"params\": { \"entries\": [\"25be5504d9f092f02f2c7ac8d2d277327dbfb00118c64faa5eccbecfa9bce90b\"] } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"entries\": [{ \"request_index\": 0, \"type\": session, \"name_hash\": \"BzT9ln2zY7/DxSqNeNXeEpYx3fxu2B+guA0ClqtSb0E=\", \"owner\": \"L8ssYFtxi1HTFQdbmG9Lt71tyudgageDgBqBLcgLnw5XBiJ1NQLFYNAAfYpYS3jHaSe8UsFYjSgKadKhC7edTSQB15s6T7g\", \"backup_owner\": \"L8PYYYTh6yEewvuPmF75uhjDn9fBzKXp8CeMuwKNZBvZT8wAoe9hJ4favnZMvTTkNdT56DMNDcdWyheb3icfk4MS3udsP4R\", \"encrypted_value\": \"8fe253e6f15addfbce5c87583e970cb09294ec5b9fc7a1891c2ac34937e5a5c116c210ddf313f5fcccd8ee28cfeb0fa8e9\", \"register_height\": 123, \"update_height\": 123, \"txid\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"prev_txid\": \"f26efb11e8eb6b446c5e0247e8883f41689591356f7abe65afe9fe75f567d40e\" }], \"status\": \"OK\" } } Inputs: entries - string[] : The owner's public key to find all Loki Name Service entries for. Outputs: entries - response_entry[] request_index - uint64 : (Deprecated) The index in request's entries array that was resolved via Loki Name Service. type - uint16 : The category the Loki Name Service entry belongs to, currently only Session whose value is 0. name_hash - string : The hash of the name that the owner purchased via Loki Name Service in base64 owner - string : The backup public key specified by the owner that purchased the Loki Name Service entry. backup_owner - string : The backup public key specified by the owner that purchased the Loki Name Service entry. encrypted_value - string : The encrypted value that the name maps to. This value is encrypted using the name (not the hash) as the secret. register_height - uint64 : The height that this Loki Name Service entry was purchased on the Blockchain. update_height - uint64 : The last height that this Loki Name Service entry was updated on the Blockchain. txid - string : The txid of who purchases the mapping. prev_txid - string : The previous txid that purchased the mapping, null hash if not applicable. status - string : Generic RPC error code. \"OK\" is the success value. LOGIN \u00b6 Back to top TODO: Undocumented light wallet RPC call Inputs: address - string view_key - string create_account - bool Outputs: status - string reason - string new_address - bool LOKINET_PING \u00b6 Back to top Endpoints: lokinet_ping Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"lokinet_ping\", \"params\": { \"version\": [\"TODO(loki): Write example string\"] } } EOF Inputs: version - int[3] : Lokinet version MINING_STATUS \u00b6 Back to top Get the mining status of the daemon. Endpoints: mining_status Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"mining_status\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"active\": true, \"speed\": 123, \"threads_count\": 8, \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"pow_algorithm\": \"RandomX (LOKI variant)\", \"block_target\": 2130706433, \"block_reward\": 123, \"difficulty\": 123 } } Outputs: status - string : General RPC error code. \"OK\" means everything looks good. Any other value means that something went wrong. active - bool : States if mining is enabled ( true ) or disabled ( false ). speed - uint64 : Mining power in hashes per seconds. threads_count - uint32 : Number of running mining threads. address - string : Account address daemon is mining to. Empty if not mining. pow_algorithm - string : Current hashing algorithm name block_target - uint32 : The expected time to solve per block, i.e. DIFFICULTY_TARGET_V2 block_reward - uint64 : Block reward for the current block being mined. difficulty - uint64 : The difficulty for the current block being mined. OUT_PEERS \u00b6 Back to top Limit number of Outgoing peers. Endpoints: out_peers Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"out_peers\", \"params\": { \"set\": true, \"out_peers\": 2130706433 } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"out_peers\": 2130706433, \"status\": \"OK\" } } Inputs: set - bool : If true, set the number of outgoing peers, otherwise the response returns the current limit of outgoing peers. (Defaults to true) out_peers - uint32 : Max number of outgoing peers Outputs: out_peers - uint32 : The current limit set for outgoing peers status - string : General RPC error code. \"OK\" means everything looks good. PERFORM_BLOCKCHAIN_TEST \u00b6 Back to top TODO: Undocumented, -- unused Endpoints: perform_blockchain_test Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"perform_blockchain_test\", \"params\": { \"max_height\": 123, \"seed\": 123 } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"res_height\": 123 } } Inputs: max_height - uint64 seed - uint64 Outputs: status - string res_height - uint64 POP_BLOCKS \u00b6 Back to top Endpoints: pop_blocks Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"pop_blocks\", \"params\": { \"nblocks\": 123 } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"height\": 234767 } } Inputs: nblocks - uint64 : Number of blocks in that span. Outputs: status - string : General RPC error code. \"OK\" means everything looks good. height - uint64 PRUNE_BLOCKCHAIN \u00b6 Back to top Endpoints: prune_blockchain Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"prune_blockchain\", \"params\": { \"check\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"pruned\": true, \"pruning_seed\": 2130706433, \"status\": \"OK\" } } Inputs: check - bool Outputs: pruned - bool pruning_seed - uint32 status - string RELAY_TX \u00b6 Back to top Relay a list of transaction IDs. Endpoints: relay_tx Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"relay_tx\", \"params\": { \"txids\": [\"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\"] } } EOF Inputs: txids - string[] : List of transactions IDs to relay from pool. REPORT_PEER_SS_STATUS \u00b6 Back to top Endpoints: report_peer_storage_server_status Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"report_peer_storage_server_status\", \"params\": { \"type\": \"TODO(loki): Write example string\", \"pubkey\": \"1de25fd280b9b08da62f06a5521c735fd94b7ecf237ca7409748295e75b48104\", \"passed\": true } } EOF Inputs: type - string : test type (currently used: [\"reachability\"]) pubkey - string : service node pubkey passed - bool : whether the node is passing the test SAVE_BC \u00b6 Back to top Save the blockchain. The blockchain does not need saving and is always saved when modified, however it does a sync to flush the filesystem cache onto the disk for safety purposes against Operating System or Hardware crashes. Endpoints: save_bc Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"save_bc\" } EOF SEND_RAW_TX \u00b6 Back to top Broadcast a raw transaction to the network. Endpoints: send_raw_transaction, sendrawtransaction Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"send_raw_transaction\", \"params\": { \"tx_as_hex\": \"TODO(loki): Write example string\", \"do_not_relay\": true, \"do_sanity_checks\": true, \"blink\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"reason\": \"TODO(loki): Write example string\", \"not_relayed\": true, \"untrusted\": false, \"tvc\": { \"m_should_be_relayed\": true, \"m_verifivation_failed\": true, \"m_verifivation_impossible\": true, \"m_added_to_pool\": true, \"m_low_mixin\": true, \"m_double_spend\": true, \"m_invalid_input\": true, \"m_invalid_output\": true, \"m_too_big\": true, \"m_overspend\": true, \"m_fee_too_low\": true, \"m_not_rct\": true, \"m_invalid_version\": true, \"m_invalid_type\": true, \"m_key_image_locked_by_snode\": true, \"m_key_image_blacklisted\": true, \"m_verbose_error\": \"TODO(loki): Write example string\", \"m_vote_ctx\": { \"m_verification_failed\": true, \"m_invalid_block_height\": true, \"m_duplicate_voters\": true, \"m_validator_index_out_of_bounds\": true, \"m_worker_index_out_of_bounds\": true, \"m_signature_not_valid\": true, \"m_added_to_pool\": true, \"m_not_enough_votes\": true, \"m_incorrect_voting_group\": true, \"m_invalid_vote_type\": true, \"m_votes_not_sorted\": true } }, \"sanity_check_failed\": true, \"blink_status\": \"TODO(loki): Write example string\" } } Inputs: tx_as_hex - string : Full transaction information as hexidecimal string. do_not_relay - bool : (Optional: Default false) Stop relaying transaction to other nodes. Ignored if blink is true. do_sanity_checks - bool : (Optional: Default true) Verify TX params have sane values. blink - bool : (Optional: Default false) Submit this as a blink tx rather than into the mempool. Outputs: status - string : General RPC error code. \"OK\" means everything looks good. Any other value means that something went wrong. reason - string : Additional information. Currently empty, \"Not relayed\" if transaction was accepted but not relayed, or some descriptive message of why the tx failed. not_relayed - bool : Transaction was not relayed (true) or relayed (false). untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). tvc - tx_verification_context m_should_be_relayed - bool m_verifivation_failed - bool : bad tx, should drop connection m_verifivation_impossible - bool : the transaction is related with an alternative blockchain m_added_to_pool - bool m_low_mixin - bool m_double_spend - bool m_invalid_input - bool m_invalid_output - bool m_too_big - bool m_overspend - bool m_fee_too_low - bool m_not_rct - bool m_invalid_version - bool m_invalid_type - bool m_key_image_locked_by_snode - bool m_key_image_blacklisted - bool m_verbose_error - string m_vote_ctx - vote_verification_context m_verification_failed - bool m_invalid_block_height - bool m_duplicate_voters - bool m_validator_index_out_of_bounds - bool m_worker_index_out_of_bounds - bool m_signature_not_valid - bool m_added_to_pool - bool m_not_enough_votes - bool m_incorrect_voting_group - bool m_invalid_vote_type - bool m_votes_not_sorted - bool sanity_check_failed - bool blink_status - blink_result : 0 for a non-blink tx. For a blink tx: 1 means rejected, 2 means accepted, 3 means timeout. SETBANS \u00b6 Back to top Ban another node by IP. Endpoints: set_bans Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"set_bans\", \"params\": { \"bans\": [{ \"host\": \"127.0.0.1\", \"ip\": 2130706433, \"ban\": true, \"seconds\": 2130706433 }] } } EOF Inputs: bans - ban[] : List of nodes to ban. host - string : Host to ban (IP in A.B.C.D form - will support I2P address in the future). ip - uint32 : IP address to ban, in Int format. ban - bool : Set true to ban. seconds - uint32 : Number of seconds to ban node. SET_LIMIT \u00b6 Back to top Set daemon bandwidth limits. Endpoints: set_limit Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"set_limit\", \"params\": { \"limit_down\": 123, \"limit_up\": 123 } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"limit_up\": 123, \"limit_down\": 123 } } Inputs: limit_down - int64 : Download limit in kBytes per second (-1 reset to default, 0 don't change the current limit) limit_up - int64 : Upload limit in kBytes per second (-1 reset to default, 0 don't change the current limit) Outputs: status - string : General RPC error code. \"OK\" means everything looks good. limit_up - int64 : Upload limit in kBytes per second. limit_down - int64 : Download limit in kBytes per second. SET_LOG_CATEGORIES \u00b6 Back to top Set the daemon log categories. Categories are represented as a comma separated list of `<Category>:<level>` (similarly to syslog standard `<Facility>:<Severity-level>`), where: Category is one of the following: * (all facilities), default, net, net.http, net.p2p, logging, net.trottle, blockchain.db, blockchain.db.lmdb, bcutil, checkpoints, net.dns, net.dl, i18n, perf,stacktrace, updates, account, cn ,difficulty, hardfork, miner, blockchain, txpool, cn.block_queue, net.cn, daemon, debugtools.deserialize, debugtools.objectsizes, device.ledger, wallet.gen_multisig, multisig, bulletproofs, ringct, daemon.rpc, wallet.simplewallet, WalletAPI, wallet.ringdb, wallet.wallet2, wallet.rpc, tests.core. Level is one of the following: FATAL - higher level, ERROR, WARNING, INFO, DEBUG, TRACE. Lower level A level automatically includes higher level. By default, categories are set to: `*:WARNING,net:FATAL,net.p2p:FATAL,net.cn:FATAL,global:INFO,verify:FATAL,stacktrace:INFO,logging:INFO,msgwriter:INFO` Setting the categories to \"\" prevent any logs to be outputed. You can append to the current the log level for updating just one or more categories while leaving other log levels unchanged by specifying one or more \"<category>:<level>\" pairs preceded by a \"+\", for example \"+difficulty:DEBUG,net:WARNING\". Endpoints: set_log_categories Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"set_log_categories\", \"params\": { \"categories\": \"TODO(loki): Write example string\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"categories\": \"TODO(loki): Write example string\" } } Inputs: categories - string : Optional, daemon log categories to enable Outputs: status - string : General RPC error code. \"OK\" means everything looks good. Any other value means that something went wrong. categories - string : Daemon log enabled categories SET_LOG_HASH_RATE \u00b6 Back to top Set the log hash rate display mode. Endpoints: set_log_hash_rate Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"set_log_hash_rate\", \"params\": { \"visible\": true } } EOF Inputs: visible - bool : States if hash rate logs should be visible (true) or hidden (false) SET_LOG_LEVEL \u00b6 Back to top Set the daemon log level. By default, log level is set to `0`. For more fine-tuned logging control set the set_log_categories command instead. Endpoints: set_log_level Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"set_log_level\", \"params\": { \"level\": 8 } } EOF Inputs: level - int8 : Daemon log level to set from 0 (less verbose) to 4 (most verbose) START_MINING \u00b6 Back to top Start mining on the daemon. Endpoints: start_mining Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"start_mining\", \"params\": { \"miner_address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"threads_count\": 123, \"num_blocks\": 123, \"slow_mining\": true } } EOF Inputs: miner_address - string : Account address to mine to. threads_count - uint64 : Number of mining thread to run. num_blocks - uint64 : Mine until the blockchain has this many new blocks, then stop (no limit if 0, the default) slow_mining - bool : Do slow mining (i.e. don't allocate RandomX cache); primarily intended for testing STOP_DAEMON \u00b6 Back to top Send a command to the daemon to safely disconnect and shut down. Endpoints: stop_daemon Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"stop_daemon\" } EOF STOP_MINING \u00b6 Back to top Stop mining on the daemon. Endpoints: stop_mining Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"stop_mining\" } EOF STORAGE_SERVER_PING \u00b6 Back to top Endpoints: storage_server_ping Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"storage_server_ping\", \"params\": { \"version_major\": 12345, \"version_minor\": 12345, \"version_patch\": 12345, \"storage_lmq_port\": 12345 } } EOF Inputs: version_major - int32 : Storage Server Major version version_minor - int32 : Storage Server Minor version version_patch - int32 : Storage Server Patch version storage_lmq_port - uint16 : Storage Server lmq port to include in uptime proofs SUBMITBLOCK \u00b6 Back to top Submit a mined block to the network. Endpoints: submit_block, submitblock Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"submit_block\", \"params\": { \"blob\": [\"TODO(loki): Write example string\"] } } EOF Inputs: blob - string[] : Block blob data - array containing exactly one block blob string which has been mined. See get_block_template to get a blob on which to mine. SUBMIT_RAW_TX \u00b6 Back to top TODO: Undocumented light wallet RPC call Inputs: address - string view_key - string tx - string blink - bool Outputs: status - string error - string SYNC_INFO \u00b6 Back to top Get synchronisation information. Endpoints: sync_info Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"sync_info\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"height\": 234767, \"target_height\": 123, \"next_needed_pruning_seed\": 2130706433, \"peers\": [{ \"info\": { \"incoming\": true, \"localhost\": true, \"local_ip\": true, \"ssl\": true, \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"host\": \"127.0.0.1\", \"ip\": \"TODO(loki): Write example string\", \"port\": \"62950\", \"rpc_port\": 12345, \"peer_id\": \"c959fbfbed9e44fb\", \"recv_count\": 123, \"recv_idle_time\": 123, \"send_count\": 123, \"send_idle_time\": 123, \"state\": \"TODO(loki): Write example string\", \"live_time\": 123, \"avg_download\": 123, \"current_download\": 123, \"avg_upload\": 123, \"current_upload\": 123, \"support_flags\": 2130706433, \"connection_id\": \"083c301a3030329a487adb12ad981d2c\", \"height\": 234767, \"pruning_seed\": 2130706433, \"address_type\": 11 } }], \"spans\": [{ \"start_block_height\": 123, \"nblocks\": 123, \"connection_id\": \"083c301a3030329a487adb12ad981d2c\", \"rate\": 2130706433, \"speed\": 2130706433, \"size\": 123, \"remote_address\": \"127.0.0.1:22023\" }], \"overview\": \"TODO(loki): Write example string\" } } Outputs: status - string : General RPC error code. \"OK\" means everything looks good. Any other value means that something went wrong. height - uint64 : Block height. target_height - uint64 : Target height the node is syncing from (optional, absent if node is fully synced). next_needed_pruning_seed - uint32 peers - peer[] : Array of Peer structure info - connection_info : Structure of connection info, as defined in get_connections. incoming - bool localhost - bool local_ip - bool ssl - bool address - string host - string ip - string port - string rpc_port - uint16 peer_id - string recv_count - uint64 recv_idle_time - uint64 send_count - uint64 send_idle_time - uint64 state - string live_time - uint64 avg_download - uint64 current_download - uint64 avg_upload - uint64 current_upload - uint64 support_flags - uint32 connection_id - string height - uint64 pruning_seed - uint32 address_type - uint8 spans - span[] : Array of Span Structure. start_block_height - uint64 : Block height of the first block in that span. nblocks - uint64 : Number of blocks in that span. connection_id - string : Id of connection. rate - uint32 : Connection rate. speed - uint32 : Connection speed. size - uint64 : Total number of bytes in that span's blocks (including txes). remote_address - string : Peer address the node is downloading (or has downloaded) than span from. overview - string UPDATE \u00b6 Back to top Update daemon. Endpoints: update Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"update\", \"params\": { \"command\": \"TODO(loki): Write example string\", \"path\": \"TODO(loki): Write example string\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"update\": true, \"version\": \"7\", \"user_uri\": \"TODO(loki): Write example string\", \"auto_uri\": \"TODO(loki): Write example string\", \"hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"path\": \"TODO(loki): Write example string\" } } Inputs: command - string : Command to use, either check or download. path - string : Optional, path where to download the update. Outputs: status - string : General RPC error code. \"OK\" means everything looks good. update - bool : States if an update is available to download ( true ) or not ( false ). version - string : Version available for download. user_uri - string auto_uri - string hash - string path - string : Path to download the update. Binary \u00b6 GET_ALT_BLOCKS_HASHES \u00b6 Back to top Get the known blocks hashes which are not on the main chain. Endpoints: get_alt_blocks_hashes.bin Outputs: blks_hashes - string[] : List of alternative blocks hashes to main chain. status - string : General RPC error code. \"OK\" means everything looks good. untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). GET_BLOCKS_BY_HEIGHT \u00b6 Back to top Get blocks by height. Binary request. Endpoints: get_blocks_by_height.bin, getblocksbyheight.bin Inputs: heights - uint64[] : List of block heights Outputs: blocks - block_complete_entry[] : Array of block complete entries block - string txs - string[] checkpoint - string blinks - serializable_blink_metadata[] tx_hash - string[64] height - uint64 quorum - uint8[] position - uint8[] signature - string[128][] status - string : General RPC error code. \"OK\" means everything looks good. untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). GET_BLOCKS_FAST \u00b6 Back to top Get all blocks info. Binary request. Endpoints: get_blocks.bin, getblocks.bin Constants: * `MAX_COUNT - uint64 = 1000` Inputs: block_ids - string[64][] : First 10 blocks id goes sequential, next goes in pow(2,n) offset, like 2, 4, 8, 16, 32, 64 and so on, and the last one is always genesis block start_height - uint64 : The starting block's height. prune - bool : Prunes the blockchain, drops off 7/8 off the block iirc. no_miner_tx - bool : Optional (false by default). Outputs: blocks - block_complete_entry[] : Array of block complete entries block - string txs - string[] checkpoint - string blinks - serializable_blink_metadata[] tx_hash - string[64] height - uint64 quorum - uint8[] position - uint8[] signature - string[128][] start_height - uint64 : The starting block's height. current_height - uint64 : The current block height. status - string : General RPC error code. \"OK\" means everything looks good. output_indices - block_output_indices[] : Array of indices. indices - tx_output_indices[] : Array of TX output indices: indices - uint64[] : Array of unsigned int. untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). GET_HASHES_FAST \u00b6 Back to top Get hashes. Binary request. Endpoints: get_hashes.bin, gethashes.bin Inputs: block_ids - string[64][] : First 10 blocks id goes sequential, next goes in pow(2,n) offset, like 2, 4, 8, 16, 32, 64 and so on, and the last one is always genesis block */ start_height - uint64 : The starting block's height. Outputs: m_block_ids - string[64][] : Binary array of hashes, See block_ids above. start_height - uint64 : The starting block's height. current_height - uint64 : The current block height. status - string : General RPC error code. \"OK\" means everything looks good. untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). GET_OUTPUTS_BIN \u00b6 Back to top Get outputs. Binary request. Endpoints: get_outs.bin Inputs: outputs - get_outputs_out[] : Array of structure get_outputs_out . amount - uint64 : Amount of Loki in TXID. index - uint64 get_txid - bool : TXID Outputs: outs - outkey[] : List of outkey information. key - string[64] : The public key of the output. mask - string[64] unlocked - bool : States if output is locked ( false ) or not ( true ). height - uint64 : Block height of the output. txid - string[64] : Transaction id. status - string : General RPC error code. \"OK\" means everything looks good. untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). GET_OUTPUT_BLACKLIST \u00b6 Back to top Get information on output blacklist. Endpoints: get_output_blacklist Outputs: blacklist - uint64[] : (Developer): Array of indexes from the global output list, corresponding to blacklisted key images. status - string : Generic RPC error code. \"OK\" is the success value. untrusted - bool : If the result is obtained using bootstrap mode, and therefore not trusted true , or otherwise false . GET_TRANSACTION_POOL_HASHES_BIN \u00b6 Back to top Get hashes from transaction pool. Binary request. Endpoints: get_transaction_pool_hashes.bin Inputs: long_poll - bool : Optional: If true, this call is blocking until timeout OR tx pool has changed since the last query. TX pool change is detected by comparing the hash of all the hashes in the tx pool. Ignored when using LMQ RPC. tx_pool_checksum - string[64] : Optional: If long_poll is true the caller must pass the hashes of all their known tx pool hashes, XOR'ed together. Ignored when using LMQ RPC. Outputs: status - string : General RPC error code. \"OK\" means everything looks good. tx_hashes - string[64][] : List of transaction hashes, untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). GET_TX_GLOBAL_OUTPUTS_INDEXES \u00b6 Back to top Get global outputs of transactions. Binary request. Endpoints: get_o_indexes.bin Inputs: txid - string[64] : Binary txid. Outputs: o_indexes - uint64[] : List of output indexes status - string : General RPC error code. \"OK\" means everything looks good. untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ).","title":"Daemon RPC Guide - Beta"},{"location":"Developer/DaemonRPCBeta/#introduction","text":"This is a list of the RPC calls, their inputs and outputs, and examples of each. This list is autogenerated and was last generated on: 2020-05-13 Many RPC calls use the JSON RPC interface while others use their own interfaces, as demonstrated below. Note: \"atomic units\" refer to the smallest fraction of 1 LOKI which is 1e9 atomic units.","title":"Introduction"},{"location":"Developer/DaemonRPCBeta/#json","text":"BANNED FLUSH_TRANSACTION_POOL GENERATEBLOCKS GETBANS GETBLOCKCOUNT GETBLOCKHASH GETBLOCKTEMPLATE GET_ALTERNATE_CHAINS GET_BASE_FEE_ESTIMATE GET_BLOCK GET_BLOCK_HEADERS_RANGE GET_BLOCK_HEADER_BY_HASH GET_BLOCK_HEADER_BY_HEIGHT GET_CHECKPOINTS GET_COINBASE_TX_SUM GET_CONNECTIONS GET_HEIGHT GET_INFO GET_LAST_BLOCK_HEADER GET_LIMIT GET_NET_STATS GET_OUTPUTS GET_OUTPUT_DISTRIBUTION GET_OUTPUT_HISTOGRAM GET_PEER_LIST GET_QUORUM_STATE GET_RANDOM_OUTS GET_SERVICE_KEYS GET_SERVICE_NODES GET_SERVICE_NODE_BLACKLISTED_KEY_IMAGES GET_SERVICE_NODE_REGISTRATION_CMD GET_SERVICE_NODE_REGISTRATION_CMD_RAW GET_SERVICE_NODE_STATUS GET_SERVICE_PRIVKEYS GET_SN_STATE_CHANGES GET_STAKING_REQUIREMENT GET_TRANSACTIONS GET_TRANSACTION_POOL GET_TRANSACTION_POOL_BACKLOG GET_TRANSACTION_POOL_HASHES GET_TRANSACTION_POOL_STATS GET_VERSION HARD_FORK_INFO IMPORT_WALLET_REQUEST IN_PEERS IS_KEY_IMAGE_SPENT LNS_NAMES_TO_OWNERS LNS_OWNERS_TO_NAMES LOGIN LOKINET_PING MINING_STATUS OUT_PEERS PERFORM_BLOCKCHAIN_TEST POP_BLOCKS PRUNE_BLOCKCHAIN RELAY_TX REPORT_PEER_SS_STATUS SAVE_BC SEND_RAW_TX SETBANS SET_LIMIT SET_LOG_CATEGORIES SET_LOG_HASH_RATE SET_LOG_LEVEL START_MINING STOP_DAEMON STOP_MINING STORAGE_SERVER_PING SUBMITBLOCK SUBMIT_RAW_TX SYNC_INFO UPDATE","title":"JSON"},{"location":"Developer/DaemonRPCBeta/#binary","text":"GET_ALT_BLOCKS_HASHES GET_BLOCKS_BY_HEIGHT GET_BLOCKS_FAST GET_HASHES_FAST GET_OUTPUTS_BIN GET_OUTPUT_BLACKLIST GET_TRANSACTION_POOL_HASHES_BIN GET_TX_GLOBAL_OUTPUTS_INDEXES","title":"Binary"},{"location":"Developer/DaemonRPCBeta/#json_1","text":"","title":"JSON"},{"location":"Developer/DaemonRPCBeta/#banned","text":"Back to top Determine whether a given IP address is banned Endpoints: banned Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"banned\", \"params\": { \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"banned\": true, \"seconds\": 2130706433 } } Inputs: address - string : The IP address to check Outputs: status - string : General RPC error code. \"OK\" means everything looks good. banned - bool : True if the given address is banned, false otherwise. seconds - uint32 : The number of seconds remaining in the ban.","title":"BANNED"},{"location":"Developer/DaemonRPCBeta/#flush_transaction_pool","text":"Back to top Flush tx ids from transaction pool.. Endpoints: flush_txpool Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"flush_txpool\", \"params\": { \"txids\": [\"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\"] } } EOF Inputs: txids - string[] : Optional, list of transactions IDs to flush from pool (all tx ids flushed if empty).","title":"FLUSH_TRANSACTION_POOL"},{"location":"Developer/DaemonRPCBeta/#generateblocks","text":"Back to top Developer only. Endpoints: generateblocks Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"generateblocks\", \"params\": { \"amount_of_blocks\": 123, \"wallet_address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"prev_block\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"starting_nonce\": 2130706433 } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"height\": 234767, \"blocks\": [\"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\"], \"status\": \"OK\" } } Inputs: amount_of_blocks - uint64 wallet_address - string prev_block - string starting_nonce - uint32 Outputs: height - uint64 blocks - string[] status - string : General RPC error code. \"OK\" means everything looks good.","title":"GENERATEBLOCKS"},{"location":"Developer/DaemonRPCBeta/#getbans","text":"Back to top Get list of banned IPs. Endpoints: get_bans Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_bans\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"bans\": [{ \"host\": \"127.0.0.1\", \"ip\": 2130706433, \"seconds\": 2130706433 }] } } Outputs: status - string : General RPC error code. \"OK\" means everything looks good. bans - ban[] : List of banned nodes: host - string : Banned host (IP in A.B.C.D form). ip - uint32 : Banned IP address, in Int format. seconds - uint32 : Local Unix time that IP is banned until.","title":"GETBANS"},{"location":"Developer/DaemonRPCBeta/#getblockcount","text":"Back to top Look up how many blocks are in the longest chain known to the node. Endpoints: get_block_count, getblockcount Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_block_count\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"count\": 123, \"status\": \"OK\" } } Outputs: count - uint64 : Number of blocks in longest chain seen by the node. status - string : General RPC error code. \"OK\" means everything looks good.","title":"GETBLOCKCOUNT"},{"location":"Developer/DaemonRPCBeta/#getblockhash","text":"Back to top Look up a block's hash by its height. Endpoints: get_block_hash, on_get_block_hash, on_getblockhash Constants: * `response - string`: Block hash (string). Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_block_hash\", \"params\": { \"height\": [234767] } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": \"061e5b4734c5e338c1d2a25acb007d806725e51cdb2aa8aac17101afd60cd002\" } Inputs: height - uint64[] : Block height (int array of length 1). Outputs: result - string : Block hash (string).","title":"GETBLOCKHASH"},{"location":"Developer/DaemonRPCBeta/#getblocktemplate","text":"Back to top Get a block template on which mining a new block. Endpoints: get_block_template, getblocktemplate Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_block_template\", \"params\": { \"reserve_size\": 123, \"wallet_address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"prev_block\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"difficulty\": 123, \"height\": 234767, \"reserved_offset\": 123, \"expected_reward\": 123, \"prev_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"seed_hash\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"next_seed_hash\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"blocktemplate_blob\": \"sd2b5f838e8cc7774d92f5a6ce0d72cb9bd8db2ef28948087f8a50ff46d188dd9\", \"blockhashing_blob\": \"sd2b5f838e8cc7774d92f5a6ce0d72cb9bd8db2ef28948087f8a50ff46d188dd9\", \"status\": \"OK\", \"untrusted\": false } } Inputs: reserve_size - uint64 : Max 255 bytes wallet_address - string : Address of wallet to receive coinbase transactions if block is successfully mined. prev_block - string Outputs: difficulty - uint64 : Difficulty of next block. height - uint64 : Height on which to mine. reserved_offset - uint64 : Reserved offset. expected_reward - uint64 : Coinbase reward expected to be received if block is successfully mined. prev_hash - string : Hash of the most recent block on which to mine the next block. seed_hash - string : RandomX current seed hash next_seed_hash - string : RandomX upcoming seed hash blocktemplate_blob - string : Blob on which to try to mine a new block. blockhashing_blob - string : Blob on which to try to find a valid nonce. status - string : General RPC error code. \"OK\" means everything looks good. untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ).","title":"GETBLOCKTEMPLATE"},{"location":"Developer/DaemonRPCBeta/#get_alternate_chains","text":"Back to top Display alternative chains seen by the node. Endpoints: get_alternative_chains Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_alternative_chains\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"chains\": [{ \"block_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"height\": 234767, \"length\": 123, \"difficulty\": 123, \"block_hashes\": [\"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\"], \"main_chain_parent_block\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\" }] } } Outputs: status - string : General RPC error code. \"OK\" means everything looks good. chains - chain_info[] : Array of Chains. block_hash - string : The block hash of the first diverging block of this alternative chain. height - uint64 : The block height of the first diverging block of this alternative chain. length - uint64 : The length in blocks of this alternative chain, after divergence. difficulty - uint64 : The cumulative difficulty of all blocks in the alternative chain. block_hashes - string[] main_chain_parent_block - string","title":"GET_ALTERNATE_CHAINS"},{"location":"Developer/DaemonRPCBeta/#get_base_fee_estimate","text":"Back to top Gives an estimation of per-output + per-byte fees Endpoints: get_fee_estimate Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_fee_estimate\", \"params\": { \"grace_blocks\": 123 } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"fee_per_byte\": 123, \"fee_per_output\": 123, \"quantization_mask\": 123, \"untrusted\": false } } Inputs: grace_blocks - uint64 : Optional Outputs: status - string : General RPC error code. \"OK\" means everything looks good. fee_per_byte - uint64 : Amount of fees estimated per byte in atomic units fee_per_output - uint64 : Amount of fees per output generated by the tx (adds to the fee_per_byte per-byte value) quantization_mask - uint64 untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ).","title":"GET_BASE_FEE_ESTIMATE"},{"location":"Developer/DaemonRPCBeta/#get_block","text":"Back to top Full block information can be retrieved by either block height or hash, like with the above block header calls. For full block information, both lookups use the same method, but with different input parameters. Endpoints: get_block, getblock Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_block\", \"params\": { \"hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"height\": 234767, \"fill_pow_hash\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"block_header\": { \"major_version\": 11, \"minor_version\": 11, \"timestamp\": 123, \"prev_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"nonce\": 2130706433, \"orphan_status\": true, \"height\": 234767, \"depth\": 123, \"hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"difficulty\": 25179406071, \"cumulative_difficulty\": 25179406071, \"reward\": 123, \"miner_reward\": 123, \"block_size\": 123, \"block_weight\": 123, \"num_txes\": 123, \"pow_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"long_term_weight\": 123, \"miner_tx_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"service_node_winner\": \"4a8c30cea9e729b06c91132295cce32d2a8e6e5bcf7b74a998e2ee1b3ed590b3\" }, \"miner_tx_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"tx_hashes\": [\"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\"], \"blob\": \"0b0b85819be50599a27f959e4bf53d6ed1d862958ae9734bb53e2a3c9085c74dc9a64f1ffe7ecbac5c003b02bae50e01ff9ce50e02c6e5b7be3b02599dd5dd36f71ea8baaf0cdf06487954cdeefc08c4a015deabccfd322c539f6a85ffbd8c4202d568949320e96569773b68bf4a081bed23b7c18c8e0fcd12007e922f2b361deea301019d4c141e08ec3a567a179d544ee6c0fe5b301482c052e7f1b8fda08253dc8f19032100de2de1e442cbe12171e1e4a02acb1fb2f19d1edf1b34ea46beab4aa84a3b8c1e021b00000000000000000000000008b742a096fc00000000000000000001cff3b81be28f27c7967ace59ad6d4117bb59beb45b42b6e6628550de36e41e4372639c05971665ab70273c8a0827397f82face8f18c0380901e425554606a4a90a0000\", \"json\": \"{\\n \\\"major_version\\\": 11, \\n \\\"minor_version\\\": 11, \\n \\\"timestamp\\\": 1554432133, \\n \\\"prev_id\\\": \\\"99a27f959e4bf53d6ed1d862958ae9734bb53e2a3c9085c74dc9a64f1ffe7ecb\\\", \\n \\\"nonce\\\": 989879468, \\n \\\"miner_tx\\\": {\\n \\\"version\\\": 2, \\n \\\"unlock_time\\\": 242362, \\n \\\"vin\\\": [ {\\n \\\"gen\\\": {\\n \\\"height\\\": 242332\\n }\\n }\\n ], \\n \\\"vout\\\": [ {\\n \\\"amount\\\": 15968629446, \\n \\\"target\\\": {\\n \\\"key\\\": \\\"599dd5dd36f71ea8baaf0cdf06487954cdeefc08c4a015deabccfd322c539f6a\\\"\\n }\\n }, {\\n \\\"amount\\\": 17742921605, \\n \\\"target\\\": {\\n \\\"key\\\": \\\"d568949320e96569773b68bf4a081bed23b7c18c8e0fcd12007e922f2b361dee\\\"\\n }\\n }\\n ], \\n \\\"extra\\\": [ 1, 157, 76, 20, 30, 8, 236, 58, 86, 122, 23, 157, 84, 78, 230, 192, 254, 91, 48, 20, 130, 192, 82, 231, 241, 184, 253, 160, 130, 83, 220, 143, 25, 3, 33, 0, 222, 45, 225, 228, 66, 203, 225, 33, 113, 225, 228, 160, 42, 203, 31, 178, 241, 157, 30, 223, 27, 52, 234, 70, 190, 171, 74, 168, 74, 59, 140, 30, 2, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 183, 66, 160, 150, 252, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 207, 243, 184, 27, 226, 143, 39, 199, 150, 122, 206, 89, 173, 109, 65, 23, 187, 89, 190, 180, 91, 66, 182, 230, 98, 133,80, 222, 54, 228, 30, 67, 114, 99, 156, 5, 151, 22, 101, 171, 112, 39, 60, 138, 8, 39, 57, 127, 130, 250, 206, 143, 24, 192, 56, 9, 1, 228, 37, 85, 70, 6, 164, 169, 10\\n], \\n \\\"rct_signatures\\\": {\\n \\\"type\\\": 0\\n }\\n }, \\n \\\"tx_hashes\\\": [ ]\\n}\", \"untrusted\": false } } Inputs: hash - string : The block's hash. height - uint64 : The block's height. fill_pow_hash - bool : Tell the daemon if it should fill out pow_hash field. Outputs: status - string : General RPC error code. \"OK\" means everything looks good. block_header - block_header_response : A structure containing block header information. See get_last_block_header. major_version - uint8 : The major version of the loki protocol at this block height. minor_version - uint8 : The minor version of the loki protocol at this block height. timestamp - uint64 : The unix time at which the block was recorded into the blockchain. prev_hash - string : The hash of the block immediately preceding this block in the chain. nonce - uint32 : A cryptographic random one-time number used in mining a Loki block. orphan_status - bool : Usually false . If true , this block is not part of the longest chain. height - uint64 : The number of blocks preceding this block on the blockchain. depth - uint64 : The number of blocks succeeding this block on the blockchain. A larger number means an older block. hash - string : The hash of this block. difficulty - uint64 : The strength of the Loki network based on mining power. cumulative_difficulty - uint64 : The cumulative strength of the Loki network based on mining power. reward - uint64 : The amount of new generated in this block and rewarded to the miner, foundation and service Nodes. Note: 1 LOKI = 1e9 atomic units. miner_reward - uint64 : The amount of new generated in this block and rewarded to the miner. Note: 1 LOKI = 1e9 atomic units. block_size - uint64 : The block size in bytes. block_weight - uint64 : The block weight in bytes. num_txes - uint64 : Number of transactions in the block, not counting the coinbase tx. pow_hash - string : The hash of the block's proof of work. long_term_weight - uint64 : Long term weight of the block. miner_tx_hash - string : The TX hash of the miner transaction service_node_winner - string : Service node that received a reward for this block miner_tx_hash - string : Miner transaction information tx_hashes - string[] : List of hashes of non-coinbase transactions in the block. If there are no other transactions, this will be an empty list. blob - string : Hexadecimal blob of block information. json - string : JSON formatted block details. untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ).","title":"GET_BLOCK"},{"location":"Developer/DaemonRPCBeta/#get_block_headers_range","text":"Back to top Similar to get_block_header_by_height above, but for a range of blocks. This method includes a starting block height and an ending block height as parameters to retrieve basic information about the range of blocks. Endpoints: get_block_headers_range, getblockheadersrange Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_block_headers_range\", \"params\": { \"start_height\": 123, \"end_height\": 123, \"fill_pow_hash\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"headers\": [{ \"major_version\": 11, \"minor_version\": 11, \"timestamp\": 123, \"prev_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"nonce\": 2130706433, \"orphan_status\": true, \"height\": 234767, \"depth\": 123, \"hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"difficulty\": 25179406071, \"cumulative_difficulty\": 25179406071, \"reward\": 123, \"miner_reward\": 123, \"block_size\": 123, \"block_weight\": 123, \"num_txes\": 123, \"pow_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"long_term_weight\": 123, \"miner_tx_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"service_node_winner\": \"4a8c30cea9e729b06c91132295cce32d2a8e6e5bcf7b74a998e2ee1b3ed590b3\" }], \"untrusted\": false } } Inputs: start_height - uint64 : The starting block's height. end_height - uint64 : The ending block's height. fill_pow_hash - bool : Tell the daemon if it should fill out pow_hash field. Outputs: status - string : General RPC error code. \"OK\" means everything looks good. headers - block_header_response[] : Array of block_header (a structure containing block header information. See get_last_block_header). major_version - uint8 : The major version of the loki protocol at this block height. minor_version - uint8 : The minor version of the loki protocol at this block height. timestamp - uint64 : The unix time at which the block was recorded into the blockchain. prev_hash - string : The hash of the block immediately preceding this block in the chain. nonce - uint32 : A cryptographic random one-time number used in mining a Loki block. orphan_status - bool : Usually false . If true , this block is not part of the longest chain. height - uint64 : The number of blocks preceding this block on the blockchain. depth - uint64 : The number of blocks succeeding this block on the blockchain. A larger number means an older block. hash - string : The hash of this block. difficulty - uint64 : The strength of the Loki network based on mining power. cumulative_difficulty - uint64 : The cumulative strength of the Loki network based on mining power. reward - uint64 : The amount of new generated in this block and rewarded to the miner, foundation and service Nodes. Note: 1 LOKI = 1e9 atomic units. miner_reward - uint64 : The amount of new generated in this block and rewarded to the miner. Note: 1 LOKI = 1e9 atomic units. block_size - uint64 : The block size in bytes. block_weight - uint64 : The block weight in bytes. num_txes - uint64 : Number of transactions in the block, not counting the coinbase tx. pow_hash - string : The hash of the block's proof of work. long_term_weight - uint64 : Long term weight of the block. miner_tx_hash - string : The TX hash of the miner transaction service_node_winner - string : Service node that received a reward for this block untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ).","title":"GET_BLOCK_HEADERS_RANGE"},{"location":"Developer/DaemonRPCBeta/#get_block_header_by_hash","text":"Back to top Block header information can be retrieved using either a block's hash or height. This method includes a block's hash as an input parameter to retrieve basic information about the block. Endpoints: get_block_header_by_hash, getblockheaderbyhash Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_block_header_by_hash\", \"params\": { \"hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"fill_pow_hash\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"block_header\": { \"major_version\": 11, \"minor_version\": 11, \"timestamp\": 123, \"prev_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"nonce\": 2130706433, \"orphan_status\": true, \"height\": 234767, \"depth\": 123, \"hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"difficulty\": 25179406071, \"cumulative_difficulty\": 25179406071, \"reward\": 123, \"miner_reward\": 123, \"block_size\": 123, \"block_weight\": 123, \"num_txes\": 123, \"pow_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"long_term_weight\": 123, \"miner_tx_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"service_node_winner\": \"4a8c30cea9e729b06c91132295cce32d2a8e6e5bcf7b74a998e2ee1b3ed590b3\" }, \"untrusted\": false } } Inputs: hash - string : The block's SHA256 hash. fill_pow_hash - bool : Tell the daemon if it should fill out pow_hash field. Outputs: status - string : General RPC error code. \"OK\" means everything looks good. block_header - block_header_response : A structure containing block header information. major_version - uint8 : The major version of the loki protocol at this block height. minor_version - uint8 : The minor version of the loki protocol at this block height. timestamp - uint64 : The unix time at which the block was recorded into the blockchain. prev_hash - string : The hash of the block immediately preceding this block in the chain. nonce - uint32 : A cryptographic random one-time number used in mining a Loki block. orphan_status - bool : Usually false . If true , this block is not part of the longest chain. height - uint64 : The number of blocks preceding this block on the blockchain. depth - uint64 : The number of blocks succeeding this block on the blockchain. A larger number means an older block. hash - string : The hash of this block. difficulty - uint64 : The strength of the Loki network based on mining power. cumulative_difficulty - uint64 : The cumulative strength of the Loki network based on mining power. reward - uint64 : The amount of new generated in this block and rewarded to the miner, foundation and service Nodes. Note: 1 LOKI = 1e9 atomic units. miner_reward - uint64 : The amount of new generated in this block and rewarded to the miner. Note: 1 LOKI = 1e9 atomic units. block_size - uint64 : The block size in bytes. block_weight - uint64 : The block weight in bytes. num_txes - uint64 : Number of transactions in the block, not counting the coinbase tx. pow_hash - string : The hash of the block's proof of work. long_term_weight - uint64 : Long term weight of the block. miner_tx_hash - string : The TX hash of the miner transaction service_node_winner - string : Service node that received a reward for this block untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ).","title":"GET_BLOCK_HEADER_BY_HASH"},{"location":"Developer/DaemonRPCBeta/#get_block_header_by_height","text":"Back to top Similar to get_block_header_by_hash above, this method includes a block's height as an input parameter to retrieve basic information about the block. Endpoints: get_block_header_by_height, getblockheaderbyheight Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_block_header_by_height\", \"params\": { \"height\": 234767, \"fill_pow_hash\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"block_header\": { \"major_version\": 11, \"minor_version\": 11, \"timestamp\": 123, \"prev_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"nonce\": 2130706433, \"orphan_status\": true, \"height\": 234767, \"depth\": 123, \"hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"difficulty\": 25179406071, \"cumulative_difficulty\": 25179406071, \"reward\": 123, \"miner_reward\": 123, \"block_size\": 123, \"block_weight\": 123, \"num_txes\": 123, \"pow_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"long_term_weight\": 123, \"miner_tx_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"service_node_winner\": \"4a8c30cea9e729b06c91132295cce32d2a8e6e5bcf7b74a998e2ee1b3ed590b3\" }, \"untrusted\": false } } Inputs: height - uint64 : The block's height. fill_pow_hash - bool : Tell the daemon if it should fill out pow_hash field. Outputs: status - string : General RPC error code. \"OK\" means everything looks good. block_header - block_header_response : A structure containing block header information. major_version - uint8 : The major version of the loki protocol at this block height. minor_version - uint8 : The minor version of the loki protocol at this block height. timestamp - uint64 : The unix time at which the block was recorded into the blockchain. prev_hash - string : The hash of the block immediately preceding this block in the chain. nonce - uint32 : A cryptographic random one-time number used in mining a Loki block. orphan_status - bool : Usually false . If true , this block is not part of the longest chain. height - uint64 : The number of blocks preceding this block on the blockchain. depth - uint64 : The number of blocks succeeding this block on the blockchain. A larger number means an older block. hash - string : The hash of this block. difficulty - uint64 : The strength of the Loki network based on mining power. cumulative_difficulty - uint64 : The cumulative strength of the Loki network based on mining power. reward - uint64 : The amount of new generated in this block and rewarded to the miner, foundation and service Nodes. Note: 1 LOKI = 1e9 atomic units. miner_reward - uint64 : The amount of new generated in this block and rewarded to the miner. Note: 1 LOKI = 1e9 atomic units. block_size - uint64 : The block size in bytes. block_weight - uint64 : The block weight in bytes. num_txes - uint64 : Number of transactions in the block, not counting the coinbase tx. pow_hash - string : The hash of the block's proof of work. long_term_weight - uint64 : Long term weight of the block. miner_tx_hash - string : The TX hash of the miner transaction service_node_winner - string : Service node that received a reward for this block untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ).","title":"GET_BLOCK_HEADER_BY_HEIGHT"},{"location":"Developer/DaemonRPCBeta/#get_checkpoints","text":"Back to top Query hardcoded/service node checkpoints stored for the blockchain. Omit all arguments to retrieve the latest \"count\" checkpoints. Endpoints: get_checkpoints Constants: * `MAX_COUNT - uint64 = 256` * `NUM_CHECKPOINTS_TO_QUERY_BY_DEFAULT - uint32 = 60` * `HEIGHT_SENTINEL_VALUE - uint64 = std::numeric_limits<uint64_t>::max() - 1` Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_checkpoints\", \"params\": { \"start_height\": 123, \"end_height\": 123, \"count\": 2130706433 } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"checkpoints\": [{ \"version\": 11, \"type\": \"ServiceNode\", \"height\": 234767, \"block_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"signatures\": [{ \"voter_index\": 12345, \"signature\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\" }], \"prev_height\": 123 }], \"status\": \"OK\", \"untrusted\": false } } Inputs: start_height - uint64 : Optional: Get the first count checkpoints starting from this height. Specify both start and end to get the checkpoints inbetween. end_height - uint64 : Optional: Get the first count checkpoints before end height. Specify both start and end to get the checkpoints inbetween. count - uint32 : Optional: Number of checkpoints to query. Outputs: checkpoints - checkpoint_serialized[] : Array of requested checkpoints version - uint8 type - string : Either \"Hardcoded\" or \"ServiceNode\" for checkpoints generated by Service Nodes or declared in the code height - uint64 : The height the checkpoint is relevant for block_hash - string : The block hash the checkpoint is specifying signatures - voter_to_signature_serialized[] : Signatures from Service Nodes who agree on the block hash voter_index - uint16 : Index of the voter in the relevant quorum signature - string : The signature generated by the voter in the quorum prev_height - uint64 : The previous height the checkpoint is based off status - string : Generic RPC error code. \"OK\" is the success value. untrusted - bool : If the result is obtained using bootstrap mode, and therefore not trusted true , or otherwise false .","title":"GET_CHECKPOINTS"},{"location":"Developer/DaemonRPCBeta/#get_coinbase_tx_sum","text":"Back to top Get the coinbase amount and the fees amount for n last blocks starting at particular height. Endpoints: get_coinbase_tx_sum Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_coinbase_tx_sum\", \"params\": { \"height\": 234767, \"count\": 123 } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"emission_amount\": 123, \"fee_amount\": 123, \"burn_amount\": 123 } } Inputs: height - uint64 : Block height from which getting the amounts. count - uint64 : Number of blocks to include in the sum. Outputs: status - string : General RPC error code. \"OK\" means everything looks good. emission_amount - uint64 : Amount of coinbase reward in atomic units. fee_amount - uint64 : Amount of fees in atomic units. burn_amount - uint64 : Amount of burnt loki.","title":"GET_COINBASE_TX_SUM"},{"location":"Developer/DaemonRPCBeta/#get_connections","text":"Back to top Retrieve information about incoming and outgoing connections to your node. Endpoints: get_connections Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_connections\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"connections\": [{ \"incoming\": true, \"localhost\": true, \"local_ip\": true, \"ssl\": true, \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"host\": \"127.0.0.1\", \"ip\": \"TODO(loki): Write example string\", \"port\": \"62950\", \"rpc_port\": 12345, \"peer_id\": \"c959fbfbed9e44fb\", \"recv_count\": 123, \"recv_idle_time\": 123, \"send_count\": 123, \"send_idle_time\": 123, \"state\": \"TODO(loki): Write example string\", \"live_time\": 123, \"avg_download\": 123, \"current_download\": 123, \"avg_upload\": 123, \"current_upload\": 123, \"support_flags\": 2130706433, \"connection_id\": \"083c301a3030329a487adb12ad981d2c\", \"height\": 234767, \"pruning_seed\": 2130706433, \"address_type\": 11 }] } } Outputs: status - string : General RPC error code. \"OK\" means everything looks good. connections - connection_info[] : List of all connections and their info: incoming - bool localhost - bool local_ip - bool ssl - bool address - string host - string ip - string port - string rpc_port - uint16 peer_id - string recv_count - uint64 recv_idle_time - uint64 send_count - uint64 send_idle_time - uint64 state - string live_time - uint64 avg_download - uint64 current_download - uint64 avg_upload - uint64 current_upload - uint64 support_flags - uint32 connection_id - string height - uint64 pruning_seed - uint32 address_type - uint8","title":"GET_CONNECTIONS"},{"location":"Developer/DaemonRPCBeta/#get_height","text":"Back to top Get the node's current height. Endpoints: get_height, getheight Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_height\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"height\": 234767, \"status\": \"OK\", \"untrusted\": false, \"hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"immutable_height\": 123, \"immutable_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\" } } Outputs: height - uint64 : The current blockchain height according to the queried daemon. status - string : Generic RPC error code. \"OK\" is the success value. untrusted - bool : If the result is obtained using bootstrap mode, and therefore not trusted true , or otherwise false . hash - string : Hash of the block at the current height immutable_height - uint64 : The latest height in the blockchain that can not be reorganized from (backed by atleast 2 Service Node, or 1 hardcoded checkpoint, 0 if N/A). immutable_hash - string : Hash of the highest block in the chain that can not be reorganized.","title":"GET_HEIGHT"},{"location":"Developer/DaemonRPCBeta/#get_info","text":"Back to top Retrieve general information about the state of your node and the network. Endpoints: get_info, getinfo Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_info\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"height\": 234767, \"target_height\": 123, \"immutable_height\": 123, \"difficulty\": 123, \"target\": 123, \"tx_count\": 123, \"tx_pool_size\": 123, \"alt_blocks_count\": 123, \"outgoing_connections_count\": 123, \"incoming_connections_count\": 123, \"rpc_connections_count\": 123, \"white_peerlist_size\": 123, \"grey_peerlist_size\": 123, \"mainnet\": true, \"testnet\": true, \"stagenet\": true, \"nettype\": \"MAINNET\", \"top_block_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"immutable_block_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"cumulative_difficulty\": 123, \"block_size_limit\": 123, \"block_weight_limit\": 123, \"block_size_median\": 123, \"block_weight_median\": 123, \"start_time\": 123, \"service_node\": true, \"last_storage_server_ping\": 123, \"last_lokinet_ping\": 123, \"free_space\": 123, \"offline\": true, \"untrusted\": false, \"bootstrap_daemon_address\": \"127.0.0.1:22023\", \"height_without_bootstrap\": 123, \"was_bootstrap_ever_used\": true, \"database_size\": 123, \"update_available\": true, \"version\": \"7\", \"status_line\": \"v15; Height: 531686\" } } Outputs: status - string : General RPC error code. \"OK\" means everything looks good. height - uint64 : Current length of longest chain known to daemon. target_height - uint64 : The height of the next block in the chain. immutable_height - uint64 : The latest height in the blockchain that can not be reorganized from (backed by atleast 2 Service Node, or 1 hardcoded checkpoint, 0 if N/A). difficulty - uint64 : Network difficulty (analogous to the strength of the network). target - uint64 : Current target for next proof of work. tx_count - uint64 : Total number of non-coinbase transaction in the chain. tx_pool_size - uint64 : Number of transactions that have been broadcast but not included in a block. alt_blocks_count - uint64 : Number of alternative blocks to main chain. outgoing_connections_count - uint64 : Number of peers that you are connected to and getting information from. incoming_connections_count - uint64 : Number of peers connected to and pulling from your node. rpc_connections_count - uint64 : Number of RPC client connected to the daemon (Including this RPC request). white_peerlist_size - uint64 : White Peerlist Size grey_peerlist_size - uint64 : Grey Peerlist Size mainnet - bool : States if the node is on the mainnet ( true ) or not ( false ). testnet - bool : States if the node is on the testnet ( true ) or not ( false ). stagenet - bool : States if the node is on the stagenet ( true ) or not ( false ). nettype - string : Nettype value used. top_block_hash - string : Hash of the highest block in the chain. immutable_block_hash - string : Hash of the highest block in the chain that can not be reorganized. cumulative_difficulty - uint64 : Cumulative difficulty of all blocks in the blockchain. block_size_limit - uint64 : Maximum allowed block size. block_weight_limit - uint64 : Maximum allowed block weight. block_size_median - uint64 : Median block size of latest 100 blocks. block_weight_median - uint64 : Median block weight of latest 100 blocks. start_time - uint64 : Start time of the daemon, as UNIX time. service_node - bool : Will be true if the node is running in --service-node mode. last_storage_server_ping - uint64 : Last ping time of the storage server (0 if never or not running as a service node) last_lokinet_ping - uint64 : Last ping time of lokinet (0 if never or not running as a service node) free_space - uint64 : Available disk space on the node. offline - bool : States if the node is offline ( true ) or online ( false ). untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). bootstrap_daemon_address - string : Bootstrap node to give immediate usability to wallets while syncing by proxying RPC to it. (Note: the replies may be untrustworthy). height_without_bootstrap - uint64 : Current length of the local chain of the daemon. was_bootstrap_ever_used - bool : States if a bootstrap node has ever been used since the daemon started. database_size - uint64 : Current size of Blockchain data. update_available - bool : States if a update is available ('true') and if one is not available ('false'). version - string : Current version of software running. status_line - string : A short one-line summary status of the node (requires an admin/unrestricted connection for most details)","title":"GET_INFO"},{"location":"Developer/DaemonRPCBeta/#get_last_block_header","text":"Back to top Block header information for the most recent block is easily retrieved with this method. No inputs are needed. Endpoints: get_last_block_header, getlastblockheader Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_last_block_header\", \"params\": { \"fill_pow_hash\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"block_header\": { \"major_version\": 11, \"minor_version\": 11, \"timestamp\": 123, \"prev_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"nonce\": 2130706433, \"orphan_status\": true, \"height\": 234767, \"depth\": 123, \"hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"difficulty\": 25179406071, \"cumulative_difficulty\": 25179406071, \"reward\": 123, \"miner_reward\": 123, \"block_size\": 123, \"block_weight\": 123, \"num_txes\": 123, \"pow_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"long_term_weight\": 123, \"miner_tx_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"service_node_winner\": \"4a8c30cea9e729b06c91132295cce32d2a8e6e5bcf7b74a998e2ee1b3ed590b3\" }, \"untrusted\": false } } Inputs: fill_pow_hash - bool : Tell the daemon if it should fill out pow_hash field. Outputs: status - string : General RPC error code. \"OK\" means everything looks good. block_header - block_header_response : A structure containing block header information. major_version - uint8 : The major version of the loki protocol at this block height. minor_version - uint8 : The minor version of the loki protocol at this block height. timestamp - uint64 : The unix time at which the block was recorded into the blockchain. prev_hash - string : The hash of the block immediately preceding this block in the chain. nonce - uint32 : A cryptographic random one-time number used in mining a Loki block. orphan_status - bool : Usually false . If true , this block is not part of the longest chain. height - uint64 : The number of blocks preceding this block on the blockchain. depth - uint64 : The number of blocks succeeding this block on the blockchain. A larger number means an older block. hash - string : The hash of this block. difficulty - uint64 : The strength of the Loki network based on mining power. cumulative_difficulty - uint64 : The cumulative strength of the Loki network based on mining power. reward - uint64 : The amount of new generated in this block and rewarded to the miner, foundation and service Nodes. Note: 1 LOKI = 1e9 atomic units. miner_reward - uint64 : The amount of new generated in this block and rewarded to the miner. Note: 1 LOKI = 1e9 atomic units. block_size - uint64 : The block size in bytes. block_weight - uint64 : The block weight in bytes. num_txes - uint64 : Number of transactions in the block, not counting the coinbase tx. pow_hash - string : The hash of the block's proof of work. long_term_weight - uint64 : Long term weight of the block. miner_tx_hash - string : The TX hash of the miner transaction service_node_winner - string : Service node that received a reward for this block untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ).","title":"GET_LAST_BLOCK_HEADER"},{"location":"Developer/DaemonRPCBeta/#get_limit","text":"Back to top Get daemon bandwidth limits. Endpoints: get_limit Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_limit\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"limit_up\": 123, \"limit_down\": 123, \"untrusted\": false } } Outputs: status - string : General RPC error code. \"OK\" means everything looks good. limit_up - uint64 : Upload limit in kBytes per second. limit_down - uint64 : Download limit in kBytes per second. untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ).","title":"GET_LIMIT"},{"location":"Developer/DaemonRPCBeta/#get_net_stats","text":"Back to top Endpoints: get_net_stats Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_net_stats\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"start_time\": 123, \"total_packets_in\": 123, \"total_bytes_in\": 123, \"total_packets_out\": 123, \"total_bytes_out\": 123 } } Outputs: status - string start_time - uint64 total_packets_in - uint64 total_bytes_in - uint64 total_packets_out - uint64 total_bytes_out - uint64","title":"GET_NET_STATS"},{"location":"Developer/DaemonRPCBeta/#get_outputs","text":"Back to top Endpoints: get_outs Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_outs\", \"params\": { \"outputs\": [{ \"amount\": 26734261552878, \"index\": 123 }], \"get_txid\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"outs\": [{ \"key\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"mask\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"unlocked\": true, \"height\": 234767, \"txid\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\" }], \"status\": \"OK\", \"untrusted\": false } } Inputs: outputs - get_outputs_out[] : Array of structure get_outputs_out . amount - uint64 : Amount of Loki in TXID. index - uint64 get_txid - bool : Request the TXID/hash of the transaction as well. Outputs: outs - outkey[] : List of outkey information. key - string : The public key of the output. mask - string unlocked - bool : States if output is locked ( false ) or not ( true ). height - uint64 : Block height of the output. txid - string : Transaction id. status - string : General RPC error code. \"OK\" means everything looks good. untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ).","title":"GET_OUTPUTS"},{"location":"Developer/DaemonRPCBeta/#get_output_distribution","text":"Back to top Endpoints: get_output_distribution Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_output_distribution\", \"params\": { \"amounts\": [123], \"from_height\": 123, \"to_height\": 123, \"cumulative\": true, \"binary\": true, \"compress\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"distributions\": [{ \"data\": { \"distribution\": [\"TODO(loki): Write example string\"], \"start_height\": \"TODO(loki): Write example string\", \"base\": \"TODO(loki): Write example string\" }, \"amount\": 26734261552878, \"compressed_data\": \"TODO(loki): Write example string\", \"binary\": true, \"compress\": true }], \"untrusted\": false } } Inputs: amounts - uint64[] : Amounts to look for in atomic units. from_height - uint64 : (optional, default is 0) starting height to check from. to_height - uint64 : (optional, default is 0) ending height to check up to. cumulative - bool : (optional, default is false) States if the result should be cumulative (true) or not (false). binary - bool compress - bool Outputs: status - string : General RPC error code. \"OK\" means everything looks good. distributions - distribution[] data - rpc::output_distribution_data distribution - uint64[] start_height - uint64 base - uint64 amount - uint64 compressed_data - string binary - bool compress - bool untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ).","title":"GET_OUTPUT_DISTRIBUTION"},{"location":"Developer/DaemonRPCBeta/#get_output_histogram","text":"Back to top Get a histogram of output amounts. For all amounts (possibly filtered by parameters), gives the number of outputs on the chain for that amount. RingCT outputs counts as 0 amount. Endpoints: get_output_histogram Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_output_histogram\", \"params\": { \"amounts\": [123], \"min_count\": 123, \"max_count\": 123, \"unlocked\": true, \"recent_cutoff\": 123 } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"histogram\": [{ \"amount\": 26734261552878, \"total_instances\": 123, \"unlocked_instances\": 123, \"recent_instances\": 123 }], \"untrusted\": false } } Inputs: amounts - uint64[] : list of amounts in Atomic Units. min_count - uint64 : The minimum amounts you are requesting. max_count - uint64 : The maximum amounts you are requesting. unlocked - bool : Look for locked only. recent_cutoff - uint64 Outputs: status - string : General RPC error code. \"OK\" means everything looks good. histogram - entry[] : List of histogram entries: amount - uint64 : Output amount in atomic units. total_instances - uint64 unlocked_instances - uint64 recent_instances - uint64 untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ).","title":"GET_OUTPUT_HISTOGRAM"},{"location":"Developer/DaemonRPCBeta/#get_peer_list","text":"Back to top Get the known peers list. Endpoints: get_peer_list Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_peer_list\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"white_list\": [{ \"id\": 123, \"host\": \"127.0.0.1\", \"ip\": 2130706433, \"port\": 12345, \"rpc_port\": 12345, \"last_seen\": 1554685440, \"pruning_seed\": 2130706433 }], \"gray_list\": [{ \"id\": 123, \"host\": \"127.0.0.1\", \"ip\": 2130706433, \"port\": 12345, \"rpc_port\": 12345, \"last_seen\": 1554685440, \"pruning_seed\": 2130706433 }] } } Outputs: status - string : General RPC error code. \"OK\" means everything looks good. Any other value means that something went wrong. white_list - peer[] : Array of online peer structure. id - uint64 : Peer id. host - string : IP address in string format. ip - uint32 : IP address in integer format. port - uint16 : TCP port the peer is using to connect to loki network. rpc_port - uint16 : RPC port the peer is using last_seen - uint64 : Unix time at which the peer has been seen for the last time pruning_seed - uint32 gray_list - peer[] : Array of offline peer structure. id - uint64 : Peer id. host - string : IP address in string format. ip - uint32 : IP address in integer format. port - uint16 : TCP port the peer is using to connect to loki network. rpc_port - uint16 : RPC port the peer is using last_seen - uint64 : Unix time at which the peer has been seen for the last time pruning_seed - uint32","title":"GET_PEER_LIST"},{"location":"Developer/DaemonRPCBeta/#get_quorum_state","text":"Back to top Get the quorum state which is the list of public keys of the nodes who are voting, and the list of public keys of the nodes who are being tested. Endpoints: get_quorum_state Constants: * `MAX_COUNT - uint64 = 256` * `HEIGHT_SENTINEL_VALUE - uint64 = UINT64_MAX` * `ALL_QUORUMS_SENTINEL_VALUE - uint8 = 255` Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_quorum_state\", \"params\": { \"start_height\": 123, \"end_height\": 123, \"quorum_type\": 11 } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"quorums\": [{ \"height\": 234767, \"quorum_type\": 11, \"quorum\": { \"validators\": [\"4a8c30cea9e729b06c91132295cce32d2a8e6e5bcf7b74a998e2ee1b3ed590b3\"], \"workers\": [\"4a8c30cea9e729b06c91132295cce32d2a8e6e5bcf7b74a998e2ee1b3ed590b3\"] } }], \"untrusted\": false } } Inputs: start_height - uint64 : (Optional): Start height, omit both start and end height to request the latest quorum end_height - uint64 : (Optional): End height, omit both start and end height to request the latest quorum quorum_type - uint8 : (Optional): Set value to request a specific quorum, 0 = Obligation, 1 = Checkpointing, 255 = all quorums, default is all quorums; Outputs: status - string : Generic RPC error code. \"OK\" is the success value. quorums - quorum_for_height[] : An array of quorums associated with the requested height height - uint64 : The height the quorums are relevant for quorum_type - uint8 : The quorum type quorum - quorum_t : Quorum of Service Nodes validators - string[] : Public key of the service node workers - string[] : Public key of the service node untrusted - bool : If the result is obtained using bootstrap mode, and therefore not trusted true , or otherwise false .","title":"GET_QUORUM_STATE"},{"location":"Developer/DaemonRPCBeta/#get_random_outs","text":"Back to top TODO: Undocumented light wallet RPC call Inputs: amounts - string[] count - uint32 Outputs: amount_outs - amount_out[] amount - uint64 outputs - output[] public_key - string global_index - uint64 rct - string : 64+64+64 characters long ( + + ) Error - string","title":"GET_RANDOM_OUTS"},{"location":"Developer/DaemonRPCBeta/#get_service_keys","text":"Back to top Get the service public keys of the queried daemon, encoded in hex. All three keys are used when running as a service node; when running as a regular node only the x25519 key is regularly used for some RPC and and node-to-SN communication requests. Endpoints: get_service_keys, get_service_node_key Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_service_keys\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"service_node_pubkey\": \"4a8c30cea9e729b06c91132295cce32d2a8e6e5bcf7b74a998e2ee1b3ed590b3\", \"service_node_ed25519_pubkey\": \"1de25fd280b9b08da62f06a5521c735fd94b7ecf237ca7409748295e75b48104\", \"service_node_x25519_pubkey\": \"7a8d1961ec9d1ac77aa67a2cded9271b0b6b9e4406005b36e260d0a230943b0e\", \"status\": \"OK\" } } Outputs: service_node_pubkey - string : The queried daemon's service node public key. Will be empty if not running as a service node. service_node_ed25519_pubkey - string : The daemon's ed25519 auxiliary public key. service_node_x25519_pubkey - string : The daemon's x25519 auxiliary public key. status - string : Generic RPC error code. \"OK\" is the success value.","title":"GET_SERVICE_KEYS"},{"location":"Developer/DaemonRPCBeta/#get_service_nodes","text":"Back to top Get information on some, all, or a random subset of Service Nodes. Endpoints: get_service_nodes, get_n_service_nodes, get_all_service_nodes Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_service_nodes\", \"params\": { \"service_node_pubkeys\": [\"4a8c30cea9e729b06c91132295cce32d2a8e6e5bcf7b74a998e2ee1b3ed590b3\"], \"include_json\": true, \"limit\": 2130706433, \"active_only\": true, \"fields\": { \"all\": true, \"service_node_pubkey\": true, \"registration_height\": true, \"registration_hf_version\": true, \"requested_unlock_height\": true, \"last_reward_block_height\": true, \"last_reward_transaction_index\": true, \"active\": true, \"funded\": true, \"state_height\": true, \"decommission_count\": true, \"earned_downtime_blocks\": true, \"service_node_version\": true, \"contributors\": true, \"total_contributed\": true, \"total_reserved\": true, \"staking_requirement\": true, \"portions_for_operator\": true, \"swarm_id\": true, \"operator_address\": true, \"public_ip\": true, \"storage_port\": true, \"storage_lmq_port\": true, \"quorumnet_port\": true, \"pubkey_ed25519\": true, \"pubkey_x25519\": true, \"last_uptime_proof\": true, \"storage_server_reachable\": true, \"storage_server_reachable_timestamp\": true, \"version_major\": true, \"version_minor\": true, \"version_patch\": true, \"votes\": true, \"block_hash\": true, \"height\": true, \"target_height\": true, \"hardfork\": true }, \"poll_block_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"service_node_states\": [{ \"service_node_pubkey\": \"4a8c30cea9e729b06c91132295cce32d2a8e6e5bcf7b74a998e2ee1b3ed590b3\", \"registration_height\": 234767, \"registration_hf_version\": 12345, \"requested_unlock_height\": 123, \"last_reward_block_height\": 234767, \"last_reward_transaction_index\": 2130706433, \"active\": true, \"funded\": true, \"state_height\": 123, \"decommission_count\": 2130706433, \"earned_downtime_blocks\": 123, \"service_node_version\": [\"TODO(loki): Write example string\"], \"contributors\": [{ \"amount\": 26734261552878, \"reserved\": 123, \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"locked_contributions\": [{ \"key_image\": \"8d1bd8181bf7d857bdb281e0153d84cd55a3fcaa57c3e570f4a49f935850b5e3\", \"key_image_pub_key\": \"b1b696dd0a0d1815e341d9fed85708703c57b5d553a3615bcf4a06a36fa4bc38\", \"amount\": 26734261552878 }] }], \"total_contributed\": 123, \"total_reserved\": 123, \"staking_requirement\": 100000000000, \"portions_for_operator\": 18446744073709551612, \"swarm_id\": 123, \"operator_address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"public_ip\": \"8.8.8.8\", \"storage_port\": 12345, \"storage_lmq_port\": 12345, \"quorumnet_port\": 12345, \"pubkey_ed25519\": \"1de25fd280b9b08da62f06a5521c735fd94b7ecf237ca7409748295e75b48104\", \"pubkey_x25519\": \"7a8d1961ec9d1ac77aa67a2cded9271b0b6b9e4406005b36e260d0a230943b0e\", \"last_uptime_proof\": 123, \"storage_server_reachable\": true, \"storage_server_reachable_timestamp\": 123, \"version_major\": 12345, \"version_minor\": 12345, \"version_patch\": 12345, \"votes\": [{ \"height\": 234767, \"voted\": true }] }], \"height\": 234767, \"target_height\": 123, \"block_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"unchanged\": true, \"hardfork\": 11, \"status\": \"OK\", \"as_json\": \"TODO(loki): Write example string\" } } Inputs: service_node_pubkeys - string[] : Array of public keys of registered Service Nodes to get information about. Omit to query all Service Nodes. include_json - bool : When set, the response's as_json member is filled out. limit - uint32 : If non-zero, select a random sample (in random order) of the given number of service nodes to return from the full list. active_only - bool : If true, only include results for active (fully staked, not decommissioned) service nodes. fields - requested_fields_t all - bool = true : internal use only: indicates whether none of the other parameters have been explicitly set service_node_pubkey - bool registration_height - bool registration_hf_version - bool requested_unlock_height - bool last_reward_block_height - bool last_reward_transaction_index - bool active - bool funded - bool state_height - bool decommission_count - bool earned_downtime_blocks - bool service_node_version - bool contributors - bool total_contributed - bool total_reserved - bool staking_requirement - bool portions_for_operator - bool swarm_id - bool operator_address - bool public_ip - bool storage_port - bool storage_lmq_port - bool quorumnet_port - bool pubkey_ed25519 - bool pubkey_x25519 - bool last_uptime_proof - bool storage_server_reachable - bool storage_server_reachable_timestamp - bool version_major - bool version_minor - bool version_patch - bool votes - bool block_hash - bool height - bool target_height - bool hardfork - bool poll_block_hash - string : If specified this changes the behaviour to only return service node records if the block hash is not equal to the given hash; otherwise it omits the records and instead sets \"unchanged\": true in the response. This is primarily used to poll for new results where the requested results only change with new blocks. Outputs: service_node_states - entry[] : Array of service node registration information service_node_pubkey - string : The public key of the Service Node. registration_height - uint64 : The height at which the registration for the Service Node arrived on the blockchain. registration_hf_version - uint16 : The hard fork at which the registration for the Service Node arrived on the blockchain. requested_unlock_height - uint64 : The height at which contributions will be released and the Service Node expires. 0 if not requested yet. last_reward_block_height - uint64 : The last height at which this Service Node received a reward. last_reward_transaction_index - uint32 : When multiple Service Nodes register on the same height, the order the transaction arrive dictate the order you receive rewards. active - bool : True if fully funded and not currently decommissioned (and so active && !funded implicitly defines decommissioned) funded - bool : True if the required stakes have been submitted to activate this Service Node state_height - uint64 : If active: the state at which registration was completed; if decommissioned: the decommissioning height; if awaiting: the last contribution (or registration) height decommission_count - uint32 : The number of times the Service Node has been decommissioned since registration earned_downtime_blocks - int64 : The number of blocks earned towards decommissioning, or the number of blocks remaining until deregistration if currently decommissioned service_node_version - uint16[3] : The major, minor, patch version of the Service Node respectively. contributors - service_node_contributor[] : Array of contributors, contributing to this Service Node. amount - uint64 : The total amount of locked Loki in atomic units for this contributor. reserved - uint64 : The amount of Loki in atomic units reserved by this contributor for this Service Node. address - string : The wallet address for this contributor rewards are sent to and contributions came from. locked_contributions - service_node_contribution[] : Array of contributions from this contributor. key_image - string : The contribution's key image that is locked on the network. key_image_pub_key - string : The contribution's key image, public key component amount - uint64 : The amount that is locked in this contribution. total_contributed - uint64 : The total amount of Loki in atomic units contributed to this Service Node. total_reserved - uint64 : The total amount of Loki in atomic units reserved in this Service Node. staking_requirement - uint64 : The staking requirement in atomic units that is required to be contributed to become a Service Node. portions_for_operator - uint64 : The operator percentage cut to take from each reward expressed in portions, see cryptonote_config.h's STAKING_PORTIONS. swarm_id - uint64 : The identifier of the Service Node's current swarm. operator_address - string : The wallet address of the operator to which the operator cut of the staking reward is sent to. public_ip - string : The public ip address of the service node storage_port - uint16 : The port number associated with the storage server storage_lmq_port - uint16 : The port number associated with the storage server (lokimq interface) quorumnet_port - uint16 : The port for direct SN-to-SN communication pubkey_ed25519 - string : The service node's ed25519 public key for auxiliary services pubkey_x25519 - string : The service node's x25519 public key for auxiliary services last_uptime_proof - uint64 : The last time this Service Node's uptime proof was relayed by at least 1 Service Node other than itself in unix epoch time. storage_server_reachable - bool : Whether the node's storage server has been reported as unreachable for a long time storage_server_reachable_timestamp - uint64 : The last time this Service Node's storage server was contacted version_major - uint16 : Major version the node is currently running version_minor - uint16 : Minor version the node is currently running version_patch - uint16 : Patch version the node is currently running votes - service_nodes::checkpoint_vote_record[] : Of the last N checkpoints the Service Node is in a checkpointing quorum, record whether or not the Service Node voted to checkpoint a block height - uint64 = INVALID_HEIGHT voted - bool = true height - uint64 : Current block's height. target_height - uint64 : Blockchain's target height. block_hash - string : Current block's hash. unchanged - bool : Will be true (and service_node_states omitted) if you gave the current block hash to poll_block_hash hardfork - uint8 : Current hardfork version. status - string : Generic RPC error code. \"OK\" is the success value. as_json - string : If include_json is set in the request, this contains the json representation of the entry data structure","title":"GET_SERVICE_NODES"},{"location":"Developer/DaemonRPCBeta/#get_service_node_blacklisted_key_images","text":"Back to top Get information on blacklisted Service Node key images. Endpoints: get_service_node_blacklisted_key_images Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_service_node_blacklisted_key_images\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"blacklist\": [{ \"key_image\": \"8d1bd8181bf7d857bdb281e0153d84cd55a3fcaa57c3e570f4a49f935850b5e3\", \"unlock_height\": 123, \"amount\": 26734261552878 }], \"status\": \"OK\" } } Outputs: blacklist - entry[] : Array of blacklisted key images, i.e. unspendable transactions key_image - string : The key image of the transaction that is blacklisted on the network. unlock_height - uint64 : The height at which the key image is removed from the blacklist and becomes spendable. amount - uint64 : The total amount of locked Loki in atomic units in this blacklisted stake. status - string : Generic RPC error code. \"OK\" is the success value.","title":"GET_SERVICE_NODE_BLACKLISTED_KEY_IMAGES"},{"location":"Developer/DaemonRPCBeta/#get_service_node_registration_cmd","text":"Back to top Endpoints: get_service_node_registration_cmd Constants: * `response - GET_SERVICE_NODE_REGISTRATION_CMD_RAW::response` Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_service_node_registration_cmd\", \"params\": { \"operator_cut\": \"1.1%\", \"contributions\": [{ \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"amount\": 26734261552878 }], \"staking_requirement\": 100000000000 } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"registration_cmd\": \"register_service_node 18446744073709551612 L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk 18446744073709551612 1555894565 f90424b23c7969bb2f0191bca45e6433a59b0b37039a5e38a2ba8cc7ea1075a3 ba24e4bfb4af0f5f9f74e35f1a5685dc9250ee83f62a9ee8964c9a689cceb40b4f125c83d0cbb434e56712d0300e5a23fd37a5b60cddbcd94e2d578209532a0d\" } } Inputs: operator_cut - string : The percentage of cut per reward the operator receives expressed as a string, i.e. \"1.1%\" contributions - contribution_t[] : Array of contributors for this Service Node address - string : The wallet address for the contributor amount - uint64 : The amount that the contributor will reserve in Loki atomic units towards the staking requirement staking_requirement - uint64 : The staking requirement to become a Service Node the registration command will be generated upon Outputs: status - string : Generic RPC error code. \"OK\" is the success value. registration_cmd - string : The command to execute in the wallet CLI to register the queried daemon as a Service Node.","title":"GET_SERVICE_NODE_REGISTRATION_CMD"},{"location":"Developer/DaemonRPCBeta/#get_service_node_registration_cmd_raw","text":"Back to top Endpoints: get_service_node_registration_cmd_raw Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_service_node_registration_cmd_raw\", \"params\": { \"args\": [\"TODO(loki): Write example string\"], \"make_friendly\": true, \"staking_requirement\": 100000000000 } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"registration_cmd\": \"register_service_node 18446744073709551612 L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk 18446744073709551612 1555894565 f90424b23c7969bb2f0191bca45e6433a59b0b37039a5e38a2ba8cc7ea1075a3 ba24e4bfb4af0f5f9f74e35f1a5685dc9250ee83f62a9ee8964c9a689cceb40b4f125c83d0cbb434e56712d0300e5a23fd37a5b60cddbcd94e2d578209532a0d\" } } Inputs: args - string[] : (Developer) The arguments used in raw registration, i.e. portions make_friendly - bool : Provide information about how to use the command in the result. staking_requirement - uint64 : The staking requirement to become a Service Node the registration command will be generated upon Outputs: status - string : Generic RPC error code. \"OK\" is the success value. registration_cmd - string : The command to execute in the wallet CLI to register the queried daemon as a Service Node.","title":"GET_SERVICE_NODE_REGISTRATION_CMD_RAW"},{"location":"Developer/DaemonRPCBeta/#get_service_node_status","text":"Back to top Get information on the queried daemon's Service Node state. Endpoints: get_service_node_status Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_service_node_status\", \"params\": { \"include_json\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"service_node_state\": \"TODO(loki): Write example string\", \"height\": 234767, \"block_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"status\": \"OK\", \"as_json\": \"TODO(loki): Write example string\" } } Inputs: include_json - bool : When set, the response's as_json member is filled out. Outputs: service_node_state - GET_SERVICE_NODES::response::entry : Service node registration information height - uint64 : Current block's height. block_hash - string : Current block's hash. status - string : Generic RPC error code. \"OK\" is the success value. as_json - string : If include_json is set in the request, this contains the json representation of the entry data structure","title":"GET_SERVICE_NODE_STATUS"},{"location":"Developer/DaemonRPCBeta/#get_service_privkeys","text":"Back to top Get the service private keys of the queried daemon, encoded in hex. Do not ever share these keys: they would allow someone to impersonate your service node. All three keys are used when running as a service node; when running as a regular node only the x25519 key is regularly used for some RPC and and node-to-SN communication requests. Endpoints: get_service_privkeys, get_service_node_privkey Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_service_privkeys\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"service_node_privkey\": \"4a8c30cea9e729b06c91132295cce32d2a8e6e5bcf7b74a998e2ee1b3ed590b3\", \"service_node_ed25519_privkey\": \"1de25fd280b9b08da62f06a5521c735fd94b7ecf237ca7409748295e75b48104\", \"service_node_x25519_privkey\": \"7a8d1961ec9d1ac77aa67a2cded9271b0b6b9e4406005b36e260d0a230943b0e\", \"status\": \"OK\" } } Outputs: service_node_privkey - string : The queried daemon's service node private key. Will be empty if not running as a service node. service_node_ed25519_privkey - string : The daemon's ed25519 private key (note that this is in sodium's format, which consists of the private and public keys concatenated together) service_node_x25519_privkey - string : The daemon's x25519 private key. status - string : Generic RPC error code. \"OK\" is the success value.","title":"GET_SERVICE_PRIVKEYS"},{"location":"Developer/DaemonRPCBeta/#get_sn_state_changes","text":"Back to top Query hardcoded/service node checkpoints stored for the blockchain. Omit all arguments to retrieve the latest \"count\" checkpoints. Endpoints: get_service_nodes_state_changes Constants: * `HEIGHT_SENTINEL_VALUE - uint64 = std::numeric_limits<uint64_t>::max() - 1` Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_service_nodes_state_changes\", \"params\": { \"start_height\": 123, \"end_height\": 123 } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"untrusted\": false, \"total_deregister\": 2130706433, \"total_ip_change_penalty\": 2130706433, \"total_decommission\": 2130706433, \"total_recommission\": 2130706433, \"total_unlock\": 2130706433, \"start_height\": 123, \"end_height\": 123 } } Inputs: start_height - uint64 end_height - uint64 : Optional: If omitted, the tally runs until the current block Outputs: status - string : Generic RPC error code. \"OK\" is the success value. untrusted - bool : If the result is obtained using bootstrap mode, and therefore not trusted true , or otherwise false . total_deregister - uint32 total_ip_change_penalty - uint32 total_decommission - uint32 total_recommission - uint32 total_unlock - uint32 start_height - uint64 end_height - uint64","title":"GET_SN_STATE_CHANGES"},{"location":"Developer/DaemonRPCBeta/#get_staking_requirement","text":"Back to top Get the required amount of Loki to become a Service Node at the queried height. For stagenet and testnet values, ensure the daemon is started with the `--stagenet` or `--testnet` flags respectively. Endpoints: get_staking_requirement Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_staking_requirement\", \"params\": { \"height\": 234767 } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"staking_requirement\": 100000000000, \"height\": 234767, \"status\": \"OK\" } } Inputs: height - uint64 : The height to query the staking requirement for. 0 (or omitting) means current height. Outputs: staking_requirement - uint64 : The staking requirement in Loki, in atomic units. height - uint64 : The height requested (or current height if 0 was requested) status - string : Generic RPC error code. \"OK\" is the success value.","title":"GET_STAKING_REQUIREMENT"},{"location":"Developer/DaemonRPCBeta/#get_transactions","text":"Back to top Look up one or more transactions by hash. Endpoints: get_transactions, gettransactions Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_transactions\", \"params\": { \"txs_hashes\": [\"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\"], \"decode_as_json\": true, \"prune\": true, \"split\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"txs_as_hex\": [\"TODO(loki): Write example string\"], \"txs_as_json\": [\"TODO(loki): Write example string\"], \"missed_tx\": [\"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\"], \"txs\": [{ \"tx_hash\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"as_hex\": \"TODO(loki): Write example string\", \"pruned_as_hex\": \"TODO(loki): Write example string\", \"prunable_as_hex\": \"TODO(loki): Write example string\", \"prunable_hash\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"as_json\": \"TODO(loki): Write example string\", \"in_pool\": true, \"double_spend_seen\": true, \"block_height\": 123, \"block_timestamp\": 123, \"output_indices\": [123], \"relayed\": true, \"blink\": true }], \"status\": \"OK\", \"untrusted\": false } } Inputs: txs_hashes - string[] : List of transaction hashes to look up. decode_as_json - bool : Optional ( false by default). If set true, the returned transaction information will be decoded rather than binary. prune - bool : Prunes the blockchain, drops off 7/8 off the block iirc. Optional ( False by default). split - bool : Optional ( false by default). Outputs: txs_as_hex - string[] : Full transaction information as a hex string (old compatibility parameter) txs_as_json - string[] : Transactions decoded as json (old compat) missed_tx - string[] : (Optional - returned if not empty) Transaction hashes that could not be found. txs - entry[] : Array of structure entry as follows: tx_hash - string : Transaction hash. as_hex - string : Full transaction information as a hex string. pruned_as_hex - string prunable_as_hex - string prunable_hash - string as_json - string : List of transaction info. in_pool - bool : States if the transaction is in pool ( true ) or included in a block ( false ). double_spend_seen - bool : States if the transaction is a double-spend ( true ) or not ( false ). block_height - uint64 : Block height including the transaction. block_timestamp - uint64 : Unix time at chich the block has been added to the blockchain. output_indices - uint64[] : List of transaction indexes. relayed - bool blink - bool : True if this is an approved, blink transaction (only for in_pool transactions or txes in recent blocks) status - string : General RPC error code. \"OK\" means everything looks good. untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ).","title":"GET_TRANSACTIONS"},{"location":"Developer/DaemonRPCBeta/#get_transaction_pool","text":"Back to top Show information about valid transactions seen by the node but not yet mined into a block, as well as spent key image information for the txpool in the node's memory. Endpoints: get_transaction_pool Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_transaction_pool\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"transactions\": [{ \"id_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"tx_json\": \"TODO(loki): Write example string\", \"blob_size\": 123, \"weight\": 123, \"fee\": 123, \"max_used_block_id_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"max_used_block_height\": 123, \"kept_by_block\": true, \"last_failed_height\": 123, \"last_failed_id_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"receive_time\": 123, \"relayed\": true, \"last_relayed_time\": 123, \"do_not_relay\": true, \"double_spend_seen\": true, \"tx_blob\": \"0402f78b05f78b05f78b0501ffd98b0502b888ddcf730229f056f5594cfcfd8d44f8033c9fda22450693d1694038e1cecaaaac25a8fc12af8992bc800102534df00c14ead3b3dedea9e7bdcf71c44803349b5e9aee2f73e22d5385ac147b7601008e5729d9329320444666d9d9d9dc602a3ae585de91ab2ca125665e3a363610021100000001839fdb0000000000000000000001200408d5ad7ab79d9b05c94033c2029f4902a98ec51f5175564f6978467dbb28723f929cf806d4ee1c781d7771183a93a1fd74f0827bddee9baac7e3083ab2b5840000\", \"blink\": true }], \"spent_key_images\": [{ \"id_hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"txs_hashes\": [\"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\"] }], \"untrusted\": false } } Outputs: status - string : General RPC error code. \"OK\" means everything looks good. transactions - tx_info[] : List of transactions in the mempool are not in a block on the main chain at the moment: id_hash - string : The transaction ID hash. tx_json - string : JSON structure of all information in the transaction blob_size - uint64 : The size of the full transaction blob. weight - uint64 : The weight of the transaction. fee - uint64 : The amount of the mining fee included in the transaction, in atomic units. max_used_block_id_hash - string : Tells the hash of the most recent block with an output used in this transaction. max_used_block_height - uint64 : Tells the height of the most recent block with an output used in this transaction. kept_by_block - bool : States if the tx was included in a block at least once ( true ) or not ( false ). last_failed_height - uint64 : If the transaction validation has previously failed, this tells at what height that occured. last_failed_id_hash - string : Like the previous, this tells the previous transaction ID hash. receive_time - uint64 : The Unix time that the transaction was first seen on the network by the node. relayed - bool : States if this transaction has been relayed last_relayed_time - uint64 : Last unix time at which the transaction has been relayed. do_not_relay - bool : States if this transaction should not be relayed. double_spend_seen - bool : States if this transaction has been seen as double spend. tx_blob - string : Hexadecimal blob represnting the transaction. blink - bool : True if this is a signed blink transaction spent_key_images - spent_key_image_info[] : List of spent output key images: id_hash - string : Key image. txs_hashes - string[] : List of tx hashes of the txes (usually one) spending that key image. untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ).","title":"GET_TRANSACTION_POOL"},{"location":"Developer/DaemonRPCBeta/#get_transaction_pool_backlog","text":"Back to top Get all transaction pool backlog. Endpoints: get_txpool_backlog Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_txpool_backlog\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"backlog\": [{ \"weight\": 123, \"fee\": 123, \"time_in_pool\": 123 }], \"untrusted\": false } } Outputs: status - string : General RPC error code. \"OK\" means everything looks good. backlog - tx_backlog_entry[] : Array of structures tx_backlog_entry (in binary form): weight - uint64 fee - uint64 : Fee in Loki measured in atomic units. time_in_pool - uint64 untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ).","title":"GET_TRANSACTION_POOL_BACKLOG"},{"location":"Developer/DaemonRPCBeta/#get_transaction_pool_hashes","text":"Back to top Get hashes from transaction pool. Endpoints: get_transaction_pool_hashes Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_transaction_pool_hashes\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"tx_hashes\": [\"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\"], \"untrusted\": false } } Outputs: status - string : General RPC error code. \"OK\" means everything looks good. tx_hashes - string[] : List of transaction hashes, untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ).","title":"GET_TRANSACTION_POOL_HASHES"},{"location":"Developer/DaemonRPCBeta/#get_transaction_pool_stats","text":"Back to top Get the transaction pool statistics. Endpoints: get_transaction_pool_stats Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_transaction_pool_stats\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"pool_stats\": { \"bytes_total\": 123, \"bytes_min\": 2130706433, \"bytes_max\": 2130706433, \"bytes_med\": 2130706433, \"fee_total\": 123, \"oldest\": 123, \"txs_total\": 2130706433, \"num_failing\": 2130706433, \"num_10m\": 2130706433, \"num_not_relayed\": 2130706433, \"histo_98pc\": 123, \"histo\": [{ \"txs\": 2130706433, \"bytes\": 123 }], \"num_double_spends\": 2130706433 }, \"untrusted\": false } } Outputs: status - string : General RPC error code. \"OK\" means everything looks good. pool_stats - txpool_stats : List of pool stats: bytes_total - uint64 : Total size of all transactions in pool. bytes_min - uint32 : Min transaction size in pool. bytes_max - uint32 : Max transaction size in pool. bytes_med - uint32 : Median transaction size in pool. fee_total - uint64 : Total fee's in pool in atomic units. oldest - uint64 : Unix time of the oldest transaction in the pool. txs_total - uint32 : Total number of transactions. num_failing - uint32 : Bumber of failing transactions. num_10m - uint32 : Number of transactions in pool for more than 10 minutes. num_not_relayed - uint32 : Number of non-relayed transactions. histo_98pc - uint64 : the time 98% of txes are \"younger\" than. histo - txpool_histo[] : List of txpool histo. txs - uint32 : Number of transactions. bytes - uint64 : Size in bytes. num_double_spends - uint32 : Number of double spend transactions. untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ).","title":"GET_TRANSACTION_POOL_STATS"},{"location":"Developer/DaemonRPCBeta/#get_version","text":"Back to top Get current RPC protocol version. Endpoints: get_version Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_version\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"version\": 2130706433, \"untrusted\": false } } Outputs: status - string : General RPC error code. \"OK\" means everything looks good. version - uint32 : RPC current version. untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ).","title":"GET_VERSION"},{"location":"Developer/DaemonRPCBeta/#hard_fork_info","text":"Back to top Look up information regarding hard fork voting and readiness. Endpoints: hard_fork_info Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"hard_fork_info\", \"params\": { \"version\": 11 } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"version\": 11, \"enabled\": true, \"window\": 2130706433, \"votes\": 2130706433, \"threshold\": 2130706433, \"voting\": 11, \"state\": 2130706433, \"earliest_height\": 123, \"status\": \"OK\", \"untrusted\": false } } Inputs: version - uint8 : The major block version for the fork. Outputs: version - uint8 : The major block version for the fork. enabled - bool : Tells if hard fork is enforced. window - uint32 : Number of blocks over which current votes are cast. Default is 10080 blocks. votes - uint32 : Number of votes towards hard fork. threshold - uint32 : Minimum percent of votes to trigger hard fork. Default is 80. voting - uint8 : Hard fork voting status. state - uint32 : Current hard fork state: 0 (There is likely a hard fork), 1 (An update is needed to fork properly), or 2 (Everything looks good). earliest_height - uint64 : Block height at which hard fork would be enabled if voted in. status - string : General RPC error code. \"OK\" means everything looks good. untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ).","title":"HARD_FORK_INFO"},{"location":"Developer/DaemonRPCBeta/#import_wallet_request","text":"Back to top TODO: Undocumented light wallet RPC call Inputs: address - string view_key - string Outputs: payment_id - string import_fee - uint64 new_request - bool request_fulfilled - bool payment_address - string status - string","title":"IMPORT_WALLET_REQUEST"},{"location":"Developer/DaemonRPCBeta/#in_peers","text":"Back to top Limit number of Incoming peers. Endpoints: in_peers Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"in_peers\", \"params\": { \"set\": true, \"in_peers\": 2130706433 } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"in_peers\": 2130706433, \"status\": \"OK\" } } Inputs: set - bool : If true, set the number of incoming peers, otherwise the response returns the current limit of incoming peers. (Defaults to true) in_peers - uint32 : Max number of incoming peers Outputs: in_peers - uint32 : The current limit set for outgoing peers status - string : General RPC error code. \"OK\" means everything looks good.","title":"IN_PEERS"},{"location":"Developer/DaemonRPCBeta/#is_key_image_spent","text":"Back to top Check if outputs have been spent using the key image associated with the output. Endpoints: is_key_image_spent Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"is_key_image_spent\", \"params\": { \"key_images\": [\"8d1bd8181bf7d857bdb281e0153d84cd55a3fcaa57c3e570f4a49f935850b5e3\"] } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"spent_status\": [0, 1], \"status\": \"OK\", \"untrusted\": false } } Inputs: key_images - string[] : List of key image hex strings to check. Outputs: spent_status - int32[] : List of statuses for each image checked. Statuses are follows: 0 = unspent, 1 = spent in blockchain, 2 = spent in transaction pool status - string : General RPC error code. \"OK\" means everything looks good. untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ).","title":"IS_KEY_IMAGE_SPENT"},{"location":"Developer/DaemonRPCBeta/#lns_names_to_owners","text":"Back to top Get the name mapping for a Loki Name Service entry. Loki currently supports mappings for Session. Endpoints: lns_names_to_owners Constants: * `MAX_REQUEST_ENTRIES - uint64 = 256` * `MAX_TYPE_REQUEST_ENTRIES - uint64 = 8` Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"lns_names_to_owners\", \"params\": { \"entries\": [{ \"name_hash\": \"BzT9ln2zY7/DxSqNeNXeEpYx3fxu2B+guA0ClqtSb0E=\", \"types\": [12345] }] } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"entries\": [{ \"entry_index\": 123, \"type\": session, \"name_hash\": \"BzT9ln2zY7/DxSqNeNXeEpYx3fxu2B+guA0ClqtSb0E=\", \"owner\": \"L8ssYFtxi1HTFQdbmG9Lt71tyudgageDgBqBLcgLnw5XBiJ1NQLFYNAAfYpYS3jHaSe8UsFYjSgKadKhC7edTSQB15s6T7g\", \"backup_owner\": \"L8PYYYTh6yEewvuPmF75uhjDn9fBzKXp8CeMuwKNZBvZT8wAoe9hJ4favnZMvTTkNdT56DMNDcdWyheb3icfk4MS3udsP4R\", \"encrypted_value\": \"8fe253e6f15addfbce5c87583e970cb09294ec5b9fc7a1891c2ac34937e5a5c116c210ddf313f5fcccd8ee28cfeb0fa8e9\", \"register_height\": 123, \"update_height\": 123, \"txid\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"prev_txid\": \"f26efb11e8eb6b446c5e0247e8883f41689591356f7abe65afe9fe75f567d40e\" }], \"status\": \"OK\" } } Inputs: entries - request_entry[] name_hash - string : The name hashed using libsodium's crypto_generichash_blake2b in base64 to resolve to a public key via Loki Name Service types - uint16[] : If empty, query all types. Currently only Session(0). In future updates more mapping types will be available. Outputs: entries - response_entry[] entry_index - uint64 : The index in request_entry's entries array that was resolved via Loki Name Service. type - uint16 : The type of Loki Name Service entry that the owner owns. name_hash - string : The hash of the name that was queried in base64 owner - string : The public key that purchased the Loki Name Service entry. backup_owner - string : The backup public key that the owner specified when purchasing the Loki Name Service entry. encrypted_value - string : The encrypted value that the name maps to. This value is encrypted using the name (not the hash) as the secret. register_height - uint64 : The height that this Loki Name Service entry was purchased on the Blockchain. update_height - uint64 : The last height that this Loki Name Service entry was updated on the Blockchain. txid - string : The txid of who purchased the mapping, null hash if not applicable. prev_txid - string : The previous txid that purchased the mapping, null hash if not applicable. status - string : Generic RPC error code. \"OK\" is the success value.","title":"LNS_NAMES_TO_OWNERS"},{"location":"Developer/DaemonRPCBeta/#lns_owners_to_names","text":"Back to top Get all the name mappings for the queried owner. The owner can be either a ed25519 public key or Monero style public key; by default purchases are owned by the spend public key of the purchasing wallet. Endpoints: lns_owners_to_names Constants: * `MAX_REQUEST_ENTRIES - uint64 = 256` Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"lns_owners_to_names\", \"params\": { \"entries\": [\"25be5504d9f092f02f2c7ac8d2d277327dbfb00118c64faa5eccbecfa9bce90b\"] } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"entries\": [{ \"request_index\": 0, \"type\": session, \"name_hash\": \"BzT9ln2zY7/DxSqNeNXeEpYx3fxu2B+guA0ClqtSb0E=\", \"owner\": \"L8ssYFtxi1HTFQdbmG9Lt71tyudgageDgBqBLcgLnw5XBiJ1NQLFYNAAfYpYS3jHaSe8UsFYjSgKadKhC7edTSQB15s6T7g\", \"backup_owner\": \"L8PYYYTh6yEewvuPmF75uhjDn9fBzKXp8CeMuwKNZBvZT8wAoe9hJ4favnZMvTTkNdT56DMNDcdWyheb3icfk4MS3udsP4R\", \"encrypted_value\": \"8fe253e6f15addfbce5c87583e970cb09294ec5b9fc7a1891c2ac34937e5a5c116c210ddf313f5fcccd8ee28cfeb0fa8e9\", \"register_height\": 123, \"update_height\": 123, \"txid\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"prev_txid\": \"f26efb11e8eb6b446c5e0247e8883f41689591356f7abe65afe9fe75f567d40e\" }], \"status\": \"OK\" } } Inputs: entries - string[] : The owner's public key to find all Loki Name Service entries for. Outputs: entries - response_entry[] request_index - uint64 : (Deprecated) The index in request's entries array that was resolved via Loki Name Service. type - uint16 : The category the Loki Name Service entry belongs to, currently only Session whose value is 0. name_hash - string : The hash of the name that the owner purchased via Loki Name Service in base64 owner - string : The backup public key specified by the owner that purchased the Loki Name Service entry. backup_owner - string : The backup public key specified by the owner that purchased the Loki Name Service entry. encrypted_value - string : The encrypted value that the name maps to. This value is encrypted using the name (not the hash) as the secret. register_height - uint64 : The height that this Loki Name Service entry was purchased on the Blockchain. update_height - uint64 : The last height that this Loki Name Service entry was updated on the Blockchain. txid - string : The txid of who purchases the mapping. prev_txid - string : The previous txid that purchased the mapping, null hash if not applicable. status - string : Generic RPC error code. \"OK\" is the success value.","title":"LNS_OWNERS_TO_NAMES"},{"location":"Developer/DaemonRPCBeta/#login","text":"Back to top TODO: Undocumented light wallet RPC call Inputs: address - string view_key - string create_account - bool Outputs: status - string reason - string new_address - bool","title":"LOGIN"},{"location":"Developer/DaemonRPCBeta/#lokinet_ping","text":"Back to top Endpoints: lokinet_ping Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"lokinet_ping\", \"params\": { \"version\": [\"TODO(loki): Write example string\"] } } EOF Inputs: version - int[3] : Lokinet version","title":"LOKINET_PING"},{"location":"Developer/DaemonRPCBeta/#mining_status","text":"Back to top Get the mining status of the daemon. Endpoints: mining_status Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"mining_status\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"active\": true, \"speed\": 123, \"threads_count\": 8, \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"pow_algorithm\": \"RandomX (LOKI variant)\", \"block_target\": 2130706433, \"block_reward\": 123, \"difficulty\": 123 } } Outputs: status - string : General RPC error code. \"OK\" means everything looks good. Any other value means that something went wrong. active - bool : States if mining is enabled ( true ) or disabled ( false ). speed - uint64 : Mining power in hashes per seconds. threads_count - uint32 : Number of running mining threads. address - string : Account address daemon is mining to. Empty if not mining. pow_algorithm - string : Current hashing algorithm name block_target - uint32 : The expected time to solve per block, i.e. DIFFICULTY_TARGET_V2 block_reward - uint64 : Block reward for the current block being mined. difficulty - uint64 : The difficulty for the current block being mined.","title":"MINING_STATUS"},{"location":"Developer/DaemonRPCBeta/#out_peers","text":"Back to top Limit number of Outgoing peers. Endpoints: out_peers Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"out_peers\", \"params\": { \"set\": true, \"out_peers\": 2130706433 } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"out_peers\": 2130706433, \"status\": \"OK\" } } Inputs: set - bool : If true, set the number of outgoing peers, otherwise the response returns the current limit of outgoing peers. (Defaults to true) out_peers - uint32 : Max number of outgoing peers Outputs: out_peers - uint32 : The current limit set for outgoing peers status - string : General RPC error code. \"OK\" means everything looks good.","title":"OUT_PEERS"},{"location":"Developer/DaemonRPCBeta/#perform_blockchain_test","text":"Back to top TODO: Undocumented, -- unused Endpoints: perform_blockchain_test Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"perform_blockchain_test\", \"params\": { \"max_height\": 123, \"seed\": 123 } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"res_height\": 123 } } Inputs: max_height - uint64 seed - uint64 Outputs: status - string res_height - uint64","title":"PERFORM_BLOCKCHAIN_TEST"},{"location":"Developer/DaemonRPCBeta/#pop_blocks","text":"Back to top Endpoints: pop_blocks Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"pop_blocks\", \"params\": { \"nblocks\": 123 } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"height\": 234767 } } Inputs: nblocks - uint64 : Number of blocks in that span. Outputs: status - string : General RPC error code. \"OK\" means everything looks good. height - uint64","title":"POP_BLOCKS"},{"location":"Developer/DaemonRPCBeta/#prune_blockchain","text":"Back to top Endpoints: prune_blockchain Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"prune_blockchain\", \"params\": { \"check\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"pruned\": true, \"pruning_seed\": 2130706433, \"status\": \"OK\" } } Inputs: check - bool Outputs: pruned - bool pruning_seed - uint32 status - string","title":"PRUNE_BLOCKCHAIN"},{"location":"Developer/DaemonRPCBeta/#relay_tx","text":"Back to top Relay a list of transaction IDs. Endpoints: relay_tx Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"relay_tx\", \"params\": { \"txids\": [\"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\"] } } EOF Inputs: txids - string[] : List of transactions IDs to relay from pool.","title":"RELAY_TX"},{"location":"Developer/DaemonRPCBeta/#report_peer_ss_status","text":"Back to top Endpoints: report_peer_storage_server_status Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"report_peer_storage_server_status\", \"params\": { \"type\": \"TODO(loki): Write example string\", \"pubkey\": \"1de25fd280b9b08da62f06a5521c735fd94b7ecf237ca7409748295e75b48104\", \"passed\": true } } EOF Inputs: type - string : test type (currently used: [\"reachability\"]) pubkey - string : service node pubkey passed - bool : whether the node is passing the test","title":"REPORT_PEER_SS_STATUS"},{"location":"Developer/DaemonRPCBeta/#save_bc","text":"Back to top Save the blockchain. The blockchain does not need saving and is always saved when modified, however it does a sync to flush the filesystem cache onto the disk for safety purposes against Operating System or Hardware crashes. Endpoints: save_bc Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"save_bc\" } EOF","title":"SAVE_BC"},{"location":"Developer/DaemonRPCBeta/#send_raw_tx","text":"Back to top Broadcast a raw transaction to the network. Endpoints: send_raw_transaction, sendrawtransaction Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"send_raw_transaction\", \"params\": { \"tx_as_hex\": \"TODO(loki): Write example string\", \"do_not_relay\": true, \"do_sanity_checks\": true, \"blink\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"reason\": \"TODO(loki): Write example string\", \"not_relayed\": true, \"untrusted\": false, \"tvc\": { \"m_should_be_relayed\": true, \"m_verifivation_failed\": true, \"m_verifivation_impossible\": true, \"m_added_to_pool\": true, \"m_low_mixin\": true, \"m_double_spend\": true, \"m_invalid_input\": true, \"m_invalid_output\": true, \"m_too_big\": true, \"m_overspend\": true, \"m_fee_too_low\": true, \"m_not_rct\": true, \"m_invalid_version\": true, \"m_invalid_type\": true, \"m_key_image_locked_by_snode\": true, \"m_key_image_blacklisted\": true, \"m_verbose_error\": \"TODO(loki): Write example string\", \"m_vote_ctx\": { \"m_verification_failed\": true, \"m_invalid_block_height\": true, \"m_duplicate_voters\": true, \"m_validator_index_out_of_bounds\": true, \"m_worker_index_out_of_bounds\": true, \"m_signature_not_valid\": true, \"m_added_to_pool\": true, \"m_not_enough_votes\": true, \"m_incorrect_voting_group\": true, \"m_invalid_vote_type\": true, \"m_votes_not_sorted\": true } }, \"sanity_check_failed\": true, \"blink_status\": \"TODO(loki): Write example string\" } } Inputs: tx_as_hex - string : Full transaction information as hexidecimal string. do_not_relay - bool : (Optional: Default false) Stop relaying transaction to other nodes. Ignored if blink is true. do_sanity_checks - bool : (Optional: Default true) Verify TX params have sane values. blink - bool : (Optional: Default false) Submit this as a blink tx rather than into the mempool. Outputs: status - string : General RPC error code. \"OK\" means everything looks good. Any other value means that something went wrong. reason - string : Additional information. Currently empty, \"Not relayed\" if transaction was accepted but not relayed, or some descriptive message of why the tx failed. not_relayed - bool : Transaction was not relayed (true) or relayed (false). untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). tvc - tx_verification_context m_should_be_relayed - bool m_verifivation_failed - bool : bad tx, should drop connection m_verifivation_impossible - bool : the transaction is related with an alternative blockchain m_added_to_pool - bool m_low_mixin - bool m_double_spend - bool m_invalid_input - bool m_invalid_output - bool m_too_big - bool m_overspend - bool m_fee_too_low - bool m_not_rct - bool m_invalid_version - bool m_invalid_type - bool m_key_image_locked_by_snode - bool m_key_image_blacklisted - bool m_verbose_error - string m_vote_ctx - vote_verification_context m_verification_failed - bool m_invalid_block_height - bool m_duplicate_voters - bool m_validator_index_out_of_bounds - bool m_worker_index_out_of_bounds - bool m_signature_not_valid - bool m_added_to_pool - bool m_not_enough_votes - bool m_incorrect_voting_group - bool m_invalid_vote_type - bool m_votes_not_sorted - bool sanity_check_failed - bool blink_status - blink_result : 0 for a non-blink tx. For a blink tx: 1 means rejected, 2 means accepted, 3 means timeout.","title":"SEND_RAW_TX"},{"location":"Developer/DaemonRPCBeta/#setbans","text":"Back to top Ban another node by IP. Endpoints: set_bans Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"set_bans\", \"params\": { \"bans\": [{ \"host\": \"127.0.0.1\", \"ip\": 2130706433, \"ban\": true, \"seconds\": 2130706433 }] } } EOF Inputs: bans - ban[] : List of nodes to ban. host - string : Host to ban (IP in A.B.C.D form - will support I2P address in the future). ip - uint32 : IP address to ban, in Int format. ban - bool : Set true to ban. seconds - uint32 : Number of seconds to ban node.","title":"SETBANS"},{"location":"Developer/DaemonRPCBeta/#set_limit","text":"Back to top Set daemon bandwidth limits. Endpoints: set_limit Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"set_limit\", \"params\": { \"limit_down\": 123, \"limit_up\": 123 } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"limit_up\": 123, \"limit_down\": 123 } } Inputs: limit_down - int64 : Download limit in kBytes per second (-1 reset to default, 0 don't change the current limit) limit_up - int64 : Upload limit in kBytes per second (-1 reset to default, 0 don't change the current limit) Outputs: status - string : General RPC error code. \"OK\" means everything looks good. limit_up - int64 : Upload limit in kBytes per second. limit_down - int64 : Download limit in kBytes per second.","title":"SET_LIMIT"},{"location":"Developer/DaemonRPCBeta/#set_log_categories","text":"Back to top Set the daemon log categories. Categories are represented as a comma separated list of `<Category>:<level>` (similarly to syslog standard `<Facility>:<Severity-level>`), where: Category is one of the following: * (all facilities), default, net, net.http, net.p2p, logging, net.trottle, blockchain.db, blockchain.db.lmdb, bcutil, checkpoints, net.dns, net.dl, i18n, perf,stacktrace, updates, account, cn ,difficulty, hardfork, miner, blockchain, txpool, cn.block_queue, net.cn, daemon, debugtools.deserialize, debugtools.objectsizes, device.ledger, wallet.gen_multisig, multisig, bulletproofs, ringct, daemon.rpc, wallet.simplewallet, WalletAPI, wallet.ringdb, wallet.wallet2, wallet.rpc, tests.core. Level is one of the following: FATAL - higher level, ERROR, WARNING, INFO, DEBUG, TRACE. Lower level A level automatically includes higher level. By default, categories are set to: `*:WARNING,net:FATAL,net.p2p:FATAL,net.cn:FATAL,global:INFO,verify:FATAL,stacktrace:INFO,logging:INFO,msgwriter:INFO` Setting the categories to \"\" prevent any logs to be outputed. You can append to the current the log level for updating just one or more categories while leaving other log levels unchanged by specifying one or more \"<category>:<level>\" pairs preceded by a \"+\", for example \"+difficulty:DEBUG,net:WARNING\". Endpoints: set_log_categories Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"set_log_categories\", \"params\": { \"categories\": \"TODO(loki): Write example string\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"categories\": \"TODO(loki): Write example string\" } } Inputs: categories - string : Optional, daemon log categories to enable Outputs: status - string : General RPC error code. \"OK\" means everything looks good. Any other value means that something went wrong. categories - string : Daemon log enabled categories","title":"SET_LOG_CATEGORIES"},{"location":"Developer/DaemonRPCBeta/#set_log_hash_rate","text":"Back to top Set the log hash rate display mode. Endpoints: set_log_hash_rate Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"set_log_hash_rate\", \"params\": { \"visible\": true } } EOF Inputs: visible - bool : States if hash rate logs should be visible (true) or hidden (false)","title":"SET_LOG_HASH_RATE"},{"location":"Developer/DaemonRPCBeta/#set_log_level","text":"Back to top Set the daemon log level. By default, log level is set to `0`. For more fine-tuned logging control set the set_log_categories command instead. Endpoints: set_log_level Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"set_log_level\", \"params\": { \"level\": 8 } } EOF Inputs: level - int8 : Daemon log level to set from 0 (less verbose) to 4 (most verbose)","title":"SET_LOG_LEVEL"},{"location":"Developer/DaemonRPCBeta/#start_mining","text":"Back to top Start mining on the daemon. Endpoints: start_mining Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"start_mining\", \"params\": { \"miner_address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"threads_count\": 123, \"num_blocks\": 123, \"slow_mining\": true } } EOF Inputs: miner_address - string : Account address to mine to. threads_count - uint64 : Number of mining thread to run. num_blocks - uint64 : Mine until the blockchain has this many new blocks, then stop (no limit if 0, the default) slow_mining - bool : Do slow mining (i.e. don't allocate RandomX cache); primarily intended for testing","title":"START_MINING"},{"location":"Developer/DaemonRPCBeta/#stop_daemon","text":"Back to top Send a command to the daemon to safely disconnect and shut down. Endpoints: stop_daemon Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"stop_daemon\" } EOF","title":"STOP_DAEMON"},{"location":"Developer/DaemonRPCBeta/#stop_mining","text":"Back to top Stop mining on the daemon. Endpoints: stop_mining Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"stop_mining\" } EOF","title":"STOP_MINING"},{"location":"Developer/DaemonRPCBeta/#storage_server_ping","text":"Back to top Endpoints: storage_server_ping Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"storage_server_ping\", \"params\": { \"version_major\": 12345, \"version_minor\": 12345, \"version_patch\": 12345, \"storage_lmq_port\": 12345 } } EOF Inputs: version_major - int32 : Storage Server Major version version_minor - int32 : Storage Server Minor version version_patch - int32 : Storage Server Patch version storage_lmq_port - uint16 : Storage Server lmq port to include in uptime proofs","title":"STORAGE_SERVER_PING"},{"location":"Developer/DaemonRPCBeta/#submitblock","text":"Back to top Submit a mined block to the network. Endpoints: submit_block, submitblock Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"submit_block\", \"params\": { \"blob\": [\"TODO(loki): Write example string\"] } } EOF Inputs: blob - string[] : Block blob data - array containing exactly one block blob string which has been mined. See get_block_template to get a blob on which to mine.","title":"SUBMITBLOCK"},{"location":"Developer/DaemonRPCBeta/#submit_raw_tx","text":"Back to top TODO: Undocumented light wallet RPC call Inputs: address - string view_key - string tx - string blink - bool Outputs: status - string error - string","title":"SUBMIT_RAW_TX"},{"location":"Developer/DaemonRPCBeta/#sync_info","text":"Back to top Get synchronisation information. Endpoints: sync_info Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"sync_info\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"height\": 234767, \"target_height\": 123, \"next_needed_pruning_seed\": 2130706433, \"peers\": [{ \"info\": { \"incoming\": true, \"localhost\": true, \"local_ip\": true, \"ssl\": true, \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"host\": \"127.0.0.1\", \"ip\": \"TODO(loki): Write example string\", \"port\": \"62950\", \"rpc_port\": 12345, \"peer_id\": \"c959fbfbed9e44fb\", \"recv_count\": 123, \"recv_idle_time\": 123, \"send_count\": 123, \"send_idle_time\": 123, \"state\": \"TODO(loki): Write example string\", \"live_time\": 123, \"avg_download\": 123, \"current_download\": 123, \"avg_upload\": 123, \"current_upload\": 123, \"support_flags\": 2130706433, \"connection_id\": \"083c301a3030329a487adb12ad981d2c\", \"height\": 234767, \"pruning_seed\": 2130706433, \"address_type\": 11 } }], \"spans\": [{ \"start_block_height\": 123, \"nblocks\": 123, \"connection_id\": \"083c301a3030329a487adb12ad981d2c\", \"rate\": 2130706433, \"speed\": 2130706433, \"size\": 123, \"remote_address\": \"127.0.0.1:22023\" }], \"overview\": \"TODO(loki): Write example string\" } } Outputs: status - string : General RPC error code. \"OK\" means everything looks good. Any other value means that something went wrong. height - uint64 : Block height. target_height - uint64 : Target height the node is syncing from (optional, absent if node is fully synced). next_needed_pruning_seed - uint32 peers - peer[] : Array of Peer structure info - connection_info : Structure of connection info, as defined in get_connections. incoming - bool localhost - bool local_ip - bool ssl - bool address - string host - string ip - string port - string rpc_port - uint16 peer_id - string recv_count - uint64 recv_idle_time - uint64 send_count - uint64 send_idle_time - uint64 state - string live_time - uint64 avg_download - uint64 current_download - uint64 avg_upload - uint64 current_upload - uint64 support_flags - uint32 connection_id - string height - uint64 pruning_seed - uint32 address_type - uint8 spans - span[] : Array of Span Structure. start_block_height - uint64 : Block height of the first block in that span. nblocks - uint64 : Number of blocks in that span. connection_id - string : Id of connection. rate - uint32 : Connection rate. speed - uint32 : Connection speed. size - uint64 : Total number of bytes in that span's blocks (including txes). remote_address - string : Peer address the node is downloading (or has downloaded) than span from. overview - string","title":"SYNC_INFO"},{"location":"Developer/DaemonRPCBeta/#update","text":"Back to top Update daemon. Endpoints: update Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"update\", \"params\": { \"command\": \"TODO(loki): Write example string\", \"path\": \"TODO(loki): Write example string\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"status\": \"OK\", \"update\": true, \"version\": \"7\", \"user_uri\": \"TODO(loki): Write example string\", \"auto_uri\": \"TODO(loki): Write example string\", \"hash\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"path\": \"TODO(loki): Write example string\" } } Inputs: command - string : Command to use, either check or download. path - string : Optional, path where to download the update. Outputs: status - string : General RPC error code. \"OK\" means everything looks good. update - bool : States if an update is available to download ( true ) or not ( false ). version - string : Version available for download. user_uri - string auto_uri - string hash - string path - string : Path to download the update.","title":"UPDATE"},{"location":"Developer/DaemonRPCBeta/#binary_1","text":"","title":"Binary"},{"location":"Developer/DaemonRPCBeta/#get_alt_blocks_hashes","text":"Back to top Get the known blocks hashes which are not on the main chain. Endpoints: get_alt_blocks_hashes.bin Outputs: blks_hashes - string[] : List of alternative blocks hashes to main chain. status - string : General RPC error code. \"OK\" means everything looks good. untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ).","title":"GET_ALT_BLOCKS_HASHES"},{"location":"Developer/DaemonRPCBeta/#get_blocks_by_height","text":"Back to top Get blocks by height. Binary request. Endpoints: get_blocks_by_height.bin, getblocksbyheight.bin Inputs: heights - uint64[] : List of block heights Outputs: blocks - block_complete_entry[] : Array of block complete entries block - string txs - string[] checkpoint - string blinks - serializable_blink_metadata[] tx_hash - string[64] height - uint64 quorum - uint8[] position - uint8[] signature - string[128][] status - string : General RPC error code. \"OK\" means everything looks good. untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ).","title":"GET_BLOCKS_BY_HEIGHT"},{"location":"Developer/DaemonRPCBeta/#get_blocks_fast","text":"Back to top Get all blocks info. Binary request. Endpoints: get_blocks.bin, getblocks.bin Constants: * `MAX_COUNT - uint64 = 1000` Inputs: block_ids - string[64][] : First 10 blocks id goes sequential, next goes in pow(2,n) offset, like 2, 4, 8, 16, 32, 64 and so on, and the last one is always genesis block start_height - uint64 : The starting block's height. prune - bool : Prunes the blockchain, drops off 7/8 off the block iirc. no_miner_tx - bool : Optional (false by default). Outputs: blocks - block_complete_entry[] : Array of block complete entries block - string txs - string[] checkpoint - string blinks - serializable_blink_metadata[] tx_hash - string[64] height - uint64 quorum - uint8[] position - uint8[] signature - string[128][] start_height - uint64 : The starting block's height. current_height - uint64 : The current block height. status - string : General RPC error code. \"OK\" means everything looks good. output_indices - block_output_indices[] : Array of indices. indices - tx_output_indices[] : Array of TX output indices: indices - uint64[] : Array of unsigned int. untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ).","title":"GET_BLOCKS_FAST"},{"location":"Developer/DaemonRPCBeta/#get_hashes_fast","text":"Back to top Get hashes. Binary request. Endpoints: get_hashes.bin, gethashes.bin Inputs: block_ids - string[64][] : First 10 blocks id goes sequential, next goes in pow(2,n) offset, like 2, 4, 8, 16, 32, 64 and so on, and the last one is always genesis block */ start_height - uint64 : The starting block's height. Outputs: m_block_ids - string[64][] : Binary array of hashes, See block_ids above. start_height - uint64 : The starting block's height. current_height - uint64 : The current block height. status - string : General RPC error code. \"OK\" means everything looks good. untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ).","title":"GET_HASHES_FAST"},{"location":"Developer/DaemonRPCBeta/#get_outputs_bin","text":"Back to top Get outputs. Binary request. Endpoints: get_outs.bin Inputs: outputs - get_outputs_out[] : Array of structure get_outputs_out . amount - uint64 : Amount of Loki in TXID. index - uint64 get_txid - bool : TXID Outputs: outs - outkey[] : List of outkey information. key - string[64] : The public key of the output. mask - string[64] unlocked - bool : States if output is locked ( false ) or not ( true ). height - uint64 : Block height of the output. txid - string[64] : Transaction id. status - string : General RPC error code. \"OK\" means everything looks good. untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ).","title":"GET_OUTPUTS_BIN"},{"location":"Developer/DaemonRPCBeta/#get_output_blacklist","text":"Back to top Get information on output blacklist. Endpoints: get_output_blacklist Outputs: blacklist - uint64[] : (Developer): Array of indexes from the global output list, corresponding to blacklisted key images. status - string : Generic RPC error code. \"OK\" is the success value. untrusted - bool : If the result is obtained using bootstrap mode, and therefore not trusted true , or otherwise false .","title":"GET_OUTPUT_BLACKLIST"},{"location":"Developer/DaemonRPCBeta/#get_transaction_pool_hashes_bin","text":"Back to top Get hashes from transaction pool. Binary request. Endpoints: get_transaction_pool_hashes.bin Inputs: long_poll - bool : Optional: If true, this call is blocking until timeout OR tx pool has changed since the last query. TX pool change is detected by comparing the hash of all the hashes in the tx pool. Ignored when using LMQ RPC. tx_pool_checksum - string[64] : Optional: If long_poll is true the caller must pass the hashes of all their known tx pool hashes, XOR'ed together. Ignored when using LMQ RPC. Outputs: status - string : General RPC error code. \"OK\" means everything looks good. tx_hashes - string[64][] : List of transaction hashes, untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ).","title":"GET_TRANSACTION_POOL_HASHES_BIN"},{"location":"Developer/DaemonRPCBeta/#get_tx_global_outputs_indexes","text":"Back to top Get global outputs of transactions. Binary request. Endpoints: get_o_indexes.bin Inputs: txid - string[64] : Binary txid. Outputs: o_indexes - uint64[] : List of output indexes status - string : General RPC error code. \"OK\" means everything looks good. untrusted - bool : States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ).","title":"GET_TX_GLOBAL_OUTPUTS_INDEXES"},{"location":"Developer/DaemonRPCGuide/","text":"Loki Daemon RPC \u00b6 Introduction \u00b6 This is a list of the lokid daemon RPC calls, their inputs and outputs, and examples of each. Many RPC calls use the daemon's JSON RPC interface while others use their own interfaces, as demonstrated below. Note: \"atomic units\" refer to the smallest fraction of 1 LOKI according to the lokid implementation. 1 LOKI = 1e12 atomic units. JSON RPC Methods: \u00b6 get_block_count on_get_block_hash get_block_template submit_block get_last_block_header get_block_header_by_hash get_block_header_by_height get_block_headers_range get_block get_connections get_info hard_fork_info set_bans get_bans flush_txpool get_output_histogram get_version get_coinbase_tx_sum get_fee_estimate get_alternate_chains relay_tx sync_info get_txpool_backlog get_output_distribution Other RPC Methods: \u00b6 /get_height /get_blocks.bin /get_blocks_by_height.bin /get_hashes.bin /get_o_indexes.bin /get_outs.bin /get_transactions /get_alt_blocks_hashes /is_key_image_spent /send_raw_transaction /start_mining /stop_mining /mining_status /save_bc /get_peer_list /set_log_hash_rate /set_log_level /set_log_categories /get_transaction_pool /get_transaction_pool_hashes.bin /get_transaction_pool_stats /stop_daemon /get_info (not JSON) /get_limit /set_limit /out_peers /in_peers /start_save_graph /stop_save_graph /get_outs /update JSON RPC Methods \u00b6 The majority of lokid RPC calls use the daemon's json_rpc interface to request various bits of information. These methods all follow a similar structure, for example: IP=127.0.0.1 PORT=18081 METHOD='get_block_header_by_height' ALIAS='getblockheaderbyheight' PARAMS='{\"height\":912345}' curl \\ -X POST http://$IP:$PORT/json_rpc \\ -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"'$METHOD'\",\"params\":'$PARAMS'}' \\ -H 'Content-Type: application/json' Some methods include parameters, while others do not. Examples of each JSON RPC method follow. get_block_count \u00b6 Look up how many blocks are in the longest chain known to the node. Alias: getblockcount . Inputs: None . Outputs: count - unsigned int; Number of blocks in longest chain seen by the node. status - string; General RPC error code. \"OK\" means everything looks good. Example: $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_block_count\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"count\": 993163, \"status\": \"OK\" } } on_get_block_hash \u00b6 Look up a block's hash by its height. Alias: on_getblockhash . Inputs: block height (int array of length 1) Outputs: block hash (string) Example: $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"on_get_block_hash\",\"params\":[912345]}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": \"e22cf75f39ae720e8b71b3d120a5ac03f0db50bba6379e2850975b4859190bc6\" } get_block_template \u00b6 Get a block template on which mining a new block. Alias: getblocktemplate . Inputs: wallet_address - string; Address of wallet to receive coinbase transactions if block is successfully mined. reserve_size - unsigned int; Reserve size. Outputs: blocktemplate_blob - string; Blob on which to try to mine a new block. blockhashing_blob - string; Blob on which to try to find a valid nonce. difficulty - unsigned int; Difficulty of next block. expected_reward - unsigned int; Coinbase reward expected to be received if block is successfully mined. height - unsigned int; Height on which to mine. prev_hash - string; Hash of the most recent block on which to mine the next block. reserved_offset - unsigned int; Reserved offset. status - string; General RPC error code. \"OK\" means everything looks good. untrusted - boolean; States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). Example: $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_block_template\",\"params\":{\"wallet_address\":\"44GBHzv6ZyQdJkjqZje6KLZ3xSyN1hBSFAnLP6EAqJtCRVzMzZmeXTC2AHKDS9aEDTRKmo6a6o9r9j86pYfhCWDkKjbtcns\",\"reserve_size\":60}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"blockhashing_blob\": \"070786a498d705f8dc58791266179087907a2ff4cd883615216749b97d2f12173171c725a6f84a00000000fc751ea4a94c2f840751eaa36138eee66dda15ef554e7d6594395827994e31da10\", \"blocktemplate_blob\": \"070786a498d705f8dc58791266179087907a2ff4cd883615216749b97d2f12173171c725a6f84a0000000002aeab5f01fff2aa5f01e0a9d0f2f08a01028fdb3d5b5a2c363d36ea17a4add99a23a3ec7935b4c3e1e0364fcc4295c7a2ef5f01f912b15f5d17c1539d4722f79d8856d8654c5af87f54cfb3a4ff7f6b512b2a08023c000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f1755090c809421d69873c161e7969b8bf33cee3b451dd4859bfc244a705f0b4900498f804b6023e13fa023a0fb759e8b7c9a39506a21442bc47077beeedc6b78d34c4ebdae91bd96097ccc9a882bc5056568b0d2f1f06559368fea4acba8e745444e883e53156d5083c1fd260edf05292934c8b40c098b81fe4e261720bdd272b209e317247a1d2c55dc4718891af0d16273c5a610f36f382a3bf50f54808aaa6a508e51d4601dd0d8fbf8b3b1685066ce121666a1409e8ac7a4d673c1cc36d10b825f764af647441f53230518e4d2efbcf8791c6060912c76e90db4982a66d51bbd96290bbb34db8080b216c2940cec407260bf5e2c3a5ee280835f15298f0801e9d98c4d414792282fbc2c28c3e20bc0fcb1829b5c3ad8f8d20847be8fdb2a949fd96f0205fbd6d271c880c5d8c83e9813606cd803a44d377fdeae45bfa67112132af601e9b3b0613ba7dff2ec3d4b935c447b47bfe39f7b950981b2f4c66c0d853e2218f1f69229a9b608c3d98be09b6d4d640a9f6ff0e920dbacf7e58b59554c0b398b1ae4b1d497104b4e4e745d850eed7eddb8aa93437427bf442ae5beb22cbf10a8fa738ea38cfa5d86dfd30675d4be11a38016e36936fd5601e52643e8b8bc433702ea7ae6149309c95b898cc854850e73fe0b95c5b8879b7325ecd4\", \"difficulty\": 61043624293, \"expected_reward\": 4771949057248, \"height\": 1561970, \"prev_hash\": \"f8dc58791266179087907a2ff4cd883615216749b97d2f12173171c725a6f84a\", \"reserved_offset\": 129, \"status\": \"OK\", \"untrusted\": false } } submit_block \u00b6 Submit a mined block to the network. Alias: submitblock . Inputs: Block blob data - array of strings; list of block blobs which have been mined. See get_block_template to get a blob on which to mine. Outputs: status - string; Block submit status. In this example, a block blob which has not been mined is submitted: $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"submit_block\",\"params\":[\"0707e6bdfedc053771512f1bc27c62731ae9e8f2443db64ce742f4e57f5cf8d393de28551e441a0000000002fb830a01ffbf830a018cfe88bee283060274c0aae2ef5730e680308d9c00b6da59187ad0352efe3c71d36eeeb28782f29f2501bd56b952c3ddc3e350c2631d3a5086cac172c56893831228b17de296ff4669de020200000000\"]' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"error\": { \"code\": -7, \"message\": \"Block not accepted\" } } get_last_block_header \u00b6 Block header information for the most recent block is easily retrieved with this method. No inputs are needed. Alias: getlastblockheader . Inputs: None . Outputs: block_header - A structure containing block header information. block_size - unsigned int; The block size in bytes. depth - unsigned int; The number of blocks succeeding this block on the blockchain. A larger number means an older block. difficulty - unsigned int; The strength of the Loki network based on mining power. hash - string; The hash of this block. height - unsigned int; The number of blocks preceding this block on the blockchain. major_version - unsigned int; The major version of the loki protocol at this block height. minor_version - unsigned int; The minor version of the loki protocol at this block height. nonce - unsigned int; a cryptographic random one-time number used in mining a Loki block. num_txes - unsigned int; Number of transactions in the block, not counting the coinbase tx. orphan_status - boolean; Usually false . If true , this block is not part of the longest chain. prev_hash - string; The hash of the block immediately preceding this block in the chain. reward - unsigned int; The amount of new generated in this block and rewarded to the miner. Note: 1 LOKI = 1e12 atomic units. timestamp - unsigned int; The unix time at which the block was recorded into the blockchain. status - string; General RPC error code. \"OK\" means everything looks good. untrusted - boolean; States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). In this example, the most recent block (1562023 at the time) is returned: $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_last_block_header\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"block_header\": { \"block_size\": 62774, \"depth\": 0, \"difficulty\": 60097900840, \"hash\": \"3a289b8fa88b10e2163826c230b45d79f2be37d14fa3153ee58ff8a427782d14\", \"height\": 1562023, \"major_version\": 7, \"minor_version\": 7, \"nonce\": 3789681204, \"num_txes\": 5, \"orphan_status\": false, \"prev_hash\": \"743e5d0a26849efe27b96086f2c4ecc39a0bc744bf21473dad6710221aff6ac3\", \"reward\": 4724029079703, \"timestamp\": 1525029411 }, \"status\": \"OK\", \"untrusted\": false } } get_block_header_by_hash \u00b6 Block header information can be retrieved using either a block's hash or height. This method includes a block's hash as an input parameter to retrieve basic information about the block. Alias: getblockheaderbyhash . Inputs: hash - string; The block's sha256 hash. Outputs: block_header - A structure containing block header information. See get_last_block_header . status - string; General RPC error code. \"OK\" means everything looks good. untrusted - boolean; States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). In this example, block 912345 is looked up by its hash: $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_block_header_by_hash\",\"params\":{\"hash\":\"e22cf75f39ae720e8b71b3d120a5ac03f0db50bba6379e2850975b4859190bc6\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"block_header\": { \"block_size\": 210, \"depth\": 649717, \"difficulty\": 815625611, \"hash\": \"e22cf75f39ae720e8b71b3d120a5ac03f0db50bba6379e2850975b4859190bc6\", \"height\": 912345, \"major_version\": 1, \"minor_version\": 2, \"nonce\": 1646, \"num_txes\": 0, \"orphan_status\": false, \"prev_hash\": \"b61c58b2e0be53fad5ef9d9731a55e8a81d972b8d90ed07c04fd37ca6403ff78\", \"reward\": 7388968946286, \"timestamp\": 1452793716 }, \"status\": \"OK\", \"untrusted\": false } } get_block_header_by_height \u00b6 Similar to get_block_header_by_hash above, this method includes a block's height as an input parameter to retrieve basic information about the block. Alias: getblockheaderbyheight . Inputs: height - unsigned int; The block's height. Outputs: block_header - A structure containing block header information. See get_last_block_header . status - string; General RPC error code. \"OK\" means everything looks good. untrusted - boolean; States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). In this example, block 912345 is looked up by its height (notice that the returned information is the same as in the previous example): $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_block_header_by_height\",\"params\":{\"height\":912345}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"block_header\": { \"block_size\": 210, \"depth\": 649721, \"difficulty\": 815625611, \"hash\": \"e22cf75f39ae720e8b71b3d120a5ac03f0db50bba6379e2850975b4859190bc6\", \"height\": 912345, \"major_version\": 1, \"minor_version\": 2, \"nonce\": 1646, \"num_txes\": 0, \"orphan_status\": false, \"prev_hash\": \"b61c58b2e0be53fad5ef9d9731a55e8a81d972b8d90ed07c04fd37ca6403ff78\", \"reward\": 7388968946286, \"timestamp\": 1452793716 }, \"status\": \"OK\", \"untrusted\": false } } get_block_headers_range \u00b6 Similar to get_block_header_by_height above, but for a range of blocks. This method includes a starting block height and an ending block height as parameters to retrieve basic information about the range of blocks. Alias: getblockheadersrange . Inputs: start_height - unsigned int; The starting block's height. end_height - unsigned int; The ending block's height. Outputs: headers - array of block_header (a structure containing block header information. See get_last_block_header ). status - string; General RPC error code. \"OK\" means everything looks good. untrusted - boolean; States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). In this example, blocks range from height 1545999 to 1546000 is looked up (notice that the returned informations are ascending order and that it is at the April 2018 network upgrade time): $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_block_headers_range\",\"params\":{\"start_height\":1545999,\"end_height\":1546000}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"headers\": [{ \"block_size\": 301413, \"depth\": 16085, \"difficulty\": 134636057921, \"hash\": \"86d1d20a40cefcf3dd410ff6967e0491613b77bf73ea8f1bf2e335cf9cf7d57a\", \"height\": 1545999, \"major_version\": 6, \"minor_version\": 6, \"nonce\": 3246403956, \"num_txes\": 20, \"orphan_status\": false, \"prev_hash\": \"0ef6e948f77b8f8806621003f5de24b1bcbea150bc0e376835aea099674a5db5\", \"reward\": 5025593029981, \"timestamp\": 1523002893 },{ \"block_size\": 13322, \"depth\": 16084, \"difficulty\": 134716086238, \"hash\": \"b408bf4cfcd7de13e7e370c84b8314c85b24f0ba4093ca1d6eeb30b35e34e91a\", \"height\": 1546000, \"major_version\": 7, \"minor_version\": 7, \"nonce\": 3737164176, \"num_txes\": 1, \"orphan_status\": false, \"prev_hash\": \"86d1d20a40cefcf3dd410ff6967e0491613b77bf73ea8f1bf2e335cf9cf7d57a\", \"reward\": 4851952181070, \"timestamp\": 1523002931 }], \"status\": \"OK\", \"untrusted\": false } } get_block \u00b6 Full block information can be retrieved by either block height or hash, like with the above block header calls. For full block information, both lookups use the same method, but with different input parameters. Alias: getblock . Inputs (pick one of the following): height - unsigned int; The block's height. hash - string; The block's hash. Outputs: blob - string; Hexadecimal blob of block information. block_header - A structure containing block header information. See get_last_block_header . json - json string; JSON formatted block details: major_version - Same as in block header. minor_version - Same as in block header. timestamp - Same as in block header. prev_id - Same as prev_hash in block header. nonce - Same as in block header. miner_tx - Miner transaction information version - Transaction version number. unlock_time - The block height when the coinbase transaction becomes spendable. vin - List of transaction inputs: gen - Miner txs are coinbase txs, or \"gen\". height - This block height, a.k.a. when the coinbase is generated. vout - List of transaction outputs. Each output contains: amount - The amount of the output, in atomic units. target - key - extra - Usually called the \"transaction ID\" but can be used to include any random 32 byte/64 character hex string. signatures - Contain signatures of tx signers. Coinbased txs do not have signatures. tx_hashes - List of hashes of non-coinbase transactions in the block. If there are no other transactions, this will be an empty list. status - string; General RPC error code. \"OK\" means everything looks good. untrusted - boolean; States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). Look up by height: In the following example, block 912345 is looked up by its height. Note that block 912345 does not have any non-coinbase transactions. (See the next example for a block with extra transactions): $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_block\",\"params\":{\"height\":912345}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"blob\": \"0102f4bedfb405b61c58b2e0be53fad5ef9d9731a55e8a81d972b8d90ed07c04fd37ca6403ff786e0600000195d83701ffd9d73704ee84ddb42102378b043c1724c92c69d923d266fe86477d3a5ddd21145062e148c64c5767700880c0fc82aa020273733cbd6e6218bda671596462a4b062f95cfe5e1dbb5b990dacb30e827d02f280f092cbdd080247a5dab669770da69a860acde21616a119818e1a489bb3c4b1b6b3c50547bc0c80e08d84ddcb01021f7e4762b8b755e3e3c72b8610cc87b9bc25d1f0a87c0c816ebb952e4f8aff3d2b01fd0a778957f4f3103a838afda488c3cdadf2697b3d34ad71234282b2fad9100e02080000000bdfc2c16c00\", \"block_header\": { \"block_size\": 210, \"depth\": 649772, \"difficulty\": 815625611, \"hash\": \"e22cf75f39ae720e8b71b3d120a5ac03f0db50bba6379e2850975b4859190bc6\", \"height\": 912345, \"major_version\": 1, \"minor_version\": 2, \"nonce\": 1646, \"num_txes\": 0, \"orphan_status\": false, \"prev_hash\": \"b61c58b2e0be53fad5ef9d9731a55e8a81d972b8d90ed07c04fd37ca6403ff78\", \"reward\": 7388968946286, \"timestamp\": 1452793716 }, \"json\": \"{\\n \\\"major_version\\\": 1, \\n \\\"minor_version\\\": 2, \\n \\\"timestamp\\\": 1452793716, \\n \\\"prev_id\\\": \\\"b61c58b2e0be53fad5ef9d9731a55e8a81d972b8d90ed07c04fd37ca6403ff78\\\", \\n \\\"nonce\\\": 1646, \\n \\\"miner_tx\\\": {\\n \\\"version\\\": 1, \\n \\\"unlock_time\\\": 912405, \\n \\\"vin\\\": [ {\\n \\\"gen\\\": {\\n \\\"height\\\": 912345\\n }\\n }\\n ], \\n \\\"vout\\\": [ {\\n \\\"amount\\\": 8968946286, \\n \\\"target\\\": {\\n \\\"key\\\": \\\"378b043c1724c92c69d923d266fe86477d3a5ddd21145062e148c64c57677008\\\"\\n }\\n }, {\\n \\\"amount\\\": 80000000000, \\n \\\"target\\\": {\\n \\\"key\\\": \\\"73733cbd6e6218bda671596462a4b062f95cfe5e1dbb5b990dacb30e827d02f2\\\"\\n }\\n }, {\\n \\\"amount\\\": 300000000000, \\n \\\"target\\\": {\\n \\\"key\\\": \\\"47a5dab669770da69a860acde21616a119818e1a489bb3c4b1b6b3c50547bc0c\\\"\\n }\\n }, {\\n \\\"amount\\\": 7000000000000, \\n \\\"target\\\": {\\n \\\"key\\\": \\\"1f7e4762b8b755e3e3c72b8610cc87b9bc25d1f0a87c0c816ebb952e4f8aff3d\\\"\\n }\\n }\\n ], \\n \\\"extra\\\": [ 1, 253, 10, 119, 137, 87, 244, 243, 16, 58, 131, 138, 253, 164, 136, 195, 205, 173, 242, 105, 123, 61, 52, 173, 113, 35, 66, 130, 178, 250, 217, 16, 14, 2, 8, 0, 0, 0, 11, 223, 194, 193, 108\\n ], \\n \\\"signatures\\\": [ ]\\n }, \\n \\\"tx_hashes\\\": [ ]\\n}\", \"miner_tx_hash\": \"c7da3965f25c19b8eb7dd8db48dcd4e7c885e2491db77e289f0609bf8e08ec30\", \"status\": \"OK\", \"untrusted\": false } } Look up by hash: In the following example, block 993056 is looked up by its hash. Note that block 993056 has 3 non-coinbase transactions: $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_block\",\"params\":{\"hash\":\"510ee3c4e14330a7b96e883c323a60ebd1b5556ac1262d0bc03c24a3b785516f\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"blob\": \"0102a3978cb7050ea4af6547c05c965afc8df6d31509ff3105dc7ae6b10172521d77e09711fd6df407000001dcce3c01ffa0ce3c049da8bece070259e9d685b3484886bc7b47c133e6099ecdf212d5eaa16ce19cd58e8c3c1e590a80d88ee16f024c5e2f542d25513c46b9e3b7d40140a22d0ae5314bfcae492ad9f56fff8185f080d0b8e1981a0213dd8ffdac9e6a2f71e327dad65328198dc879a492d145eae72677c0703a351580c0f9decfae010262bda00341681dccbc066757862da593734395745bdfe1fdc89b5948c86a5d4c2b01b691851cf057b9c302a3dbca879e1cba4cc45061ca55aaa6e03cdc67ab9e455002080000000c617fdf160379c6b9f00db027bde151705aafe85c495883aae2597d5cb8e1adb2e0f3ae1d07d715db73331abc3ec588ef07c7bb195786a4724b08dff431b51ffa32a4ce899bb197066426c0ed89f0b431fe171f7fd62bc95dd29943daa7cf3585cf1fdfc99d\", \"block_header\": { \"block_size\": 3981, \"depth\": 569068, \"difficulty\": 964985344, \"hash\": \"510ee3c4e14330a7b96e883c323a60ebd1b5556ac1262d0bc03c24a3b785516f\", \"height\": 993056, \"major_version\": 1, \"minor_version\": 2, \"nonce\": 2036, \"num_txes\": 3, \"orphan_status\": false, \"prev_hash\": \"0ea4af6547c05c965afc8df6d31509ff3105dc7ae6b10172521d77e09711fd6d\", \"reward\": 6932043647005, \"timestamp\": 1457720227 }, \"json\": \"{\\n \\\"major_version\\\": 1, \\n \\\"minor_version\\\": 2, \\n \\\"timestamp\\\": 1457720227, \\n \\\"prev_id\\\": \\\"0ea4af6547c05c965afc8df6d31509ff3105dc7ae6b10172521d77e09711fd6d\\\", \\n \\\"nonce\\\": 2036, \\n \\\"miner_tx\\\": {\\n \\\"version\\\": 1, \\n \\\"unlock_time\\\": 993116, \\n \\\"vin\\\": [ {\\n \\\"gen\\\": {\\n \\\"height\\\": 993056\\n }\\n }\\n ], \\n \\\"vout\\\": [ {\\n \\\"amount\\\": 2043647005, \\n \\\"target\\\": {\\n \\\"key\\\": \\\"59e9d685b3484886bc7b47c133e6099ecdf212d5eaa16ce19cd58e8c3c1e590a\\\"\\n }\\n }, {\\n \\\"amount\\\": 30000000000, \\n \\\"target\\\": {\\n \\\"key\\\": \\\"4c5e2f542d25513c46b9e3b7d40140a22d0ae5314bfcae492ad9f56fff8185f0\\\"\\n }\\n }, {\\n \\\"amount\\\": 900000000000, \\n \\\"target\\\": {\\n \\\"key\\\": \\\"13dd8ffdac9e6a2f71e327dad65328198dc879a492d145eae72677c0703a3515\\\"\\n }\\n }, {\\n \\\"amount\\\": 6000000000000, \\n \\\"target\\\": {\\n \\\"key\\\": \\\"62bda00341681dccbc066757862da593734395745bdfe1fdc89b5948c86a5d4c\\\"\\n }\\n }\\n ], \\n \\\"extra\\\": [ 1, 182, 145, 133, 28, 240, 87, 185, 195, 2, 163, 219, 202, 135, 158, 28, 186, 76, 196, 80, 97, 202, 85, 170, 166, 224, 60, 220, 103, 171, 158, 69, 80, 2, 8, 0, 0, 0, 12, 97, 127, 223, 22\\n ], \\n \\\"signatures\\\": [ ]\\n }, \\n \\\"tx_hashes\\\": [ \\\"79c6b9f00db027bde151705aafe85c495883aae2597d5cb8e1adb2e0f3ae1d07\\\", \\\"d715db73331abc3ec588ef07c7bb195786a4724b08dff431b51ffa32a4ce899b\\\", \\\"b197066426c0ed89f0b431fe171f7fd62bc95dd29943daa7cf3585cf1fdfc99d\\\"\\n ]\\n}\", \"miner_tx_hash\": \"372395aeac5e5ad2c40b4c546b0bad00c4242fb2bd88e2e25f4e43231876f81e\", \"status\": \"OK\", \"tx_hashes\": [\"79c6b9f00db027bde151705aafe85c495883aae2597d5cb8e1adb2e0f3ae1d07\",\"d715db73331abc3ec588ef07c7bb195786a4724b08dff431b51ffa32a4ce899b\",\"b197066426c0ed89f0b431fe171f7fd62bc95dd29943daa7cf3585cf1fdfc99d\"], \"untrusted\": false } } get_connections \u00b6 Retrieve information about incoming and outgoing connections to your node. Alias: None . Inputs: None . Outputs: connections - List of all connections and their info: address - string; The peer's address, actually IPv4 & port avg_download - unsigned int; Average bytes of data downloaded by node. avg_upload - unsigned int; Average bytes of data uploaded by node. connection_id - string; The connection ID current_download - unsigned int; Current bytes downloaded by node. current_upload - unsigned int; Current bytes uploaded by node. height - unsigned int; The peer height host - string; The peer host incoming - boolean; Is the node getting information from your node? ip - string; The node's IP address. live_time - unsigned int local_ip - boolean localhost - boolean peer_id - string; The node's ID on the network. port - string; The port that the node is using to connect to the network. recv_count - unsigned int recv_idle_time - unsigned int send_count - unsigned int send_idle_time - unsigned int state - string support_flags - unsigned int Following is an example of get_connections and it's return: $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_connections\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"connections\": [{ \"address\": \"173.90.69.136:62950\", \"avg_download\": 0, \"avg_upload\": 2, \"connection_id\": \"083c301a3030329a487adb12ad981d2c\", \"current_download\": 0, \"current_upload\": 2, \"height\": 1562127, \"host\": \"173.90.69.136\", \"incoming\": true, \"ip\": \"173.90.69.136\", \"live_time\": 8, \"local_ip\": false, \"localhost\": false, \"peer_id\": \"c959fbfbed9e44fb\", \"port\": \"62950\", \"recv_count\": 259, \"recv_idle_time\": 8, \"send_count\": 24342, \"send_idle_time\": 8, \"state\": \"state_normal\", \"support_flags\": 0 },{ ... }], \"status\": \"OK\" } } get_info \u00b6 Retrieve general information about the state of your node and the network. Alias: /get_info /getinfo See other RPC Methods /get_info (not JSON) Inputs: None . Outputs: alt_blocks_count - unsigned int; Number of alternative blocks to main chain. block_size_limit - unsigned int; Maximum allowed block size block_size_median - unsigned int; Median block size of latest 100 blocks bootstrap_daemon_address - string; bootstrap node to give immediate usability to wallets while syncing by proxying RPC to it. (Note: the replies may be untrustworthy). cumulative_difficulty - unsigned int; Cumulative difficulty of all blocks in the blockchain. difficulty - unsigned int; Network difficulty (analogous to the strength of the network) free_space - unsigned int; Available disk space on the node. grey_peerlist_size - unsigned int; Grey Peerlist Size height - unsigned int; Current length of longest chain known to daemon. height_without_bootstrap - unsigned int; Current length of the local chain of the daemon. incoming_connections_count - unsigned int; Number of peers connected to and pulling from your node. mainnet - boolean; States if the node is on the mainnet ( true ) or not ( false ). offline - boolean; States if the node is offline ( true ) or online ( false ). outgoing_connections_count - unsigned int; Number of peers that you are connected to and getting information from. rpc_connections_count - unsigned int; Number of RPC client connected to the daemon (Including this RPC request). stagenet - boolean; States if the node is on the stagenet ( true ) or not ( false ). start_time - unsigned int; Start time of the daemon, as UNIX time. status - string; General RPC error code. \"OK\" means everything looks good. target - unsigned int; Current target for next proof of work. target_height - unsigned int; The height of the next block in the chain. testnet - boolean; States if the node is on the testnet ( true ) or not ( false ). top_block_hash - string; Hash of the highest block in the chain. tx_count - unsigned int; Total number of non-coinbase transaction in the chain. tx_pool_size - unsigned int; Number of transactions that have been broadcast but not included in a block. untrusted - boolean; States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). was_bootstrap_ever_used - boolean; States if a bootstrap node has ever been used since the daemon started. white_peerlist_size - unsigned int; White Peerlist Size Following is an example get_info call and its return: $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_info\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"alt_blocks_count\": 6, \"block_size_limit\": 600000, \"block_size_median\": 129017, \"bootstrap_daemon_address\": \"\", \"cumulative_difficulty\": 14121125493385685, \"difficulty\": 60580751777, \"free_space\": 138758750208, \"grey_peerlist_size\": 4998, \"height\": 1562168, \"height_without_bootstrap\": 1562168, \"incoming_connections_count\": 2, \"mainnet\": true, \"offline\": false, \"outgoing_connections_count\": 8, \"rpc_connections_count\": 2, \"stagenet\": false, \"start_time\": 1524751757, \"status\": \"OK\", \"target\": 120, \"target_height\": 1562063, \"testnet\": false, \"top_block_hash\": \"7a7ba647080844073fdd8e3a069e00554c773d6e6863354dba1dec45a43f5592\", \"tx_count\": 2759894, \"tx_pool_size\": 755, \"untrusted\": false, \"was_bootstrap_ever_used\": false, \"white_peerlist_size\": 1000 } } hard_fork_info \u00b6 Look up information regarding hard fork voting and readiness. Alias: None . Inputs: None . Outputs: earliest_height - unsigned int; Block height at which hard fork would be enabled if voted in. enabled - boolean; Tells if hard fork is enforced. state - unsigned int; Current hard fork state: 0 (There is likely a hard fork), 1 (An update is needed to fork properly), or 2 (Everything looks good). status - string; General RPC error code. \"OK\" means everything looks good. threshold - unsigned int; Minimum percent of votes to trigger hard fork. Default is 80. version - unsigned int; The major block version for the fork. votes - unsigned int; Number of votes towards hard fork. voting - unsigned int; Hard fork voting status. window - unsigned int; Number of blocks over which current votes are cast. Default is 10080 blocks. Example: $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"hard_fork_info\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"earliest_height\": 1009827, \"enabled\": false, \"state\": 2, \"status\": \"OK\", \"threshold\": 0, \"version\": 1, \"votes\": 7277, \"voting\": 2, \"window\": 10080 } } set_bans \u00b6 Ban another node by IP. Alias: None . Inputs: bans - A list of nodes to ban: host - string; Host to ban (IP in A.B.C.D form - will support I2P address in the future). ip - unsigned int; IP address to ban, in Int format. ban - boolean; Set true to ban. seconds - unsigned int; Number of seconds to ban node. Outputs: status - string; General RPC error code. \"OK\" means everything looks good. Examples: banning by host In the following example, host is banned with its IP address string-formatted as A.B.C.D: $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"set_bans\",\"params\":{\"bans\":[{\"host\":\"192.168.1.51\",\"ban\":true,\"seconds\":30}]}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"status\": \"OK\" } } banning by ip In the following example, integer-formatted IP is banned: $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"set_bans\",\"params\":{\"bans\":[{\"ip\":838969536,\"ban\":true,\"seconds\":30}]}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"status\": \"OK\" } } get_bans \u00b6 Get list of banned IPs. Alias: None . Inputs: None . Outputs: bans - List of banned nodes: host - string; Banned host (IP in A.B.C.D form). ip - unsigned int; Banned IP address, in Int format. seconds - unsigned int; Local Unix time that IP is banned until. status - string; General RPC error code. \"OK\" means everything looks good. Example: $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_bans\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"bans\": [{ \"host\": \"102.168.1.51\", \"ip\": 855746662, \"seconds\": 22 },{ \"host\": \"192.168.1.50\", \"ip\": 838969536, \"seconds\": 28 }], \"status\": \"OK\" } } flush_txpool \u00b6 Flush tx ids from transaction pool Alias: None . Inputs: txids - array of strings; Optional, list of transactions IDs to flush from pool (all tx ids flushed if empty). Outputs: status - string; General RPC error code. \"OK\" means everything looks good. Example: $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"flush_txpool\",\"params\":{\"txids\":[\"dc16fa8eaffe1484ca9014ea050e13131d3acf23b419f33bb4cc0b32b6c49308\",\"\"]}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"status\": \"OK\" } } get_output_histogram \u00b6 Get a histogram of output amounts. For all amounts (possibly filtered by parameters), gives the number of outputs on the chain for that amount. RingCT outputs counts as 0 amount. Inputs: amounts - list of unsigned int min_count - unsigned int max_count - unsigned int unlocked - boolean recent_cutoff - unsigned int Outputs: histogram - list of histogram entries, in the following structure: amount - unsigned int; Output amount in atomic units total_instances - unsigned int; unlocked_instances - unsigned int; recent_instances - unsigned int; status - string; General RPC error code. \"OK\" means everything looks good. untrusted - boolean; States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). Example: $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_output_histogram\",\"params\":{\"amounts\":[20000000000]}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"histogram\": [{ \"amount\": 20000000000, \"recent_instances\": 0, \"total_instances\": 381458, \"unlocked_instances\": 0 }], \"status\": \"OK\", \"untrusted\": false } } get_coinbase_tx_sum \u00b6 Get the coinbase ammount and the fees ammount for n last blocks starting at particular height Alias: None . Inputs: height - unsigned int; Block height from which getting the amounts count - unsigned int; number of blocks to include in the sum Outputs: emission_amount - unsigned int; amount of coinbase reward in atomic units fee_amount - unsigned int; amount of fees in atomic units status - string; General RPC error code. \"OK\" means everything looks good. Example: $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_coinbase_tx_sum\",\"params\":{\"height\":1563078,\"count\":2}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"emission_amount\": 9387854817320, \"fee_amount\": 83981380000, \"status\": \"OK\" } } get_version \u00b6 Give the node current version Alias: None . Inputs: None . Outputs: status - string; General RPC error code. \"OK\" means everything looks good. untrusted - boolean; States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). version - unsigned int; Example: $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_version\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"status\": \"OK\", \"untrusted\": false, \"version\": 65555 } } get_fee_estimate \u00b6 Gives an estimation on fees per kB. Alias: None . Inputs: grace_blocks - unsigned int; Optional Outputs: fee - unsigned int; Amount of fees estimated per kB in atomic units status - string; General RPC error code. \"OK\" means everything looks good. untrusted - boolean; States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). Example: $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_fee_estimate\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"fee\": 187610000, \"status\": \"OK\", \"untrusted\": false } } get_alternate_chains \u00b6 Display alternative chains seen by the node. Alias: None . Inputs: None . Outputs: chains - array of chains, the following structure: block_hash - string; the block hash of the first diverging block of this alternative chain. difficulty - unsigned int; the cumulative difficulty of all blocks in the alternative chain. height - unsigned int; the block height of the first diverging block of this alternative chain. length - unsigned int; the length in blocks of this alternative chain, after divergence. status - string; General RPC error code. \"OK\" means everything looks good. Example: $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_alternate_chains\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"chains\": [{ \"block_hash\": \"697cf03c89a9b118f7bdf11b1b3a6a028d7b3617d2d0ed91322c5709acf75625\", \"difficulty\": 14114729638300280, \"height\": 1562062, \"length\": 2 }], \"status\": \"OK\" } } relay_tx \u00b6 Relay a list of transaction IDs. Alias: None . Inputs: txids - array of string; list of transaction IDs to relay Outputs: status - string; General RPC error code. \"OK\" means everything looks good. Example: $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"relay_tx\",\"params\":{\"txids\":[9fd75c429cbe52da9a52f2ffc5fbd107fe7fd2099c0d8de274dc8a67e0c98613]}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"status\": \"OK\" } } sync_info \u00b6 Get synchronisation informations Alias: None . Inputs: None . Outputs: height - unsigned int; peers - array of peer structure, defined as follows: info - structure of connection info, as defined in get_connections spans - array of span structure, defined as follows (optional, absent if node is fully synced): connection_id - string; Id of connection nblocks - unsigned int; number of blocks in that span rate - unsigned int; connection rate remote_address - string; peer address the node is downloading (or has downloaded) than span from size - unsigned int; total number of bytes in that span's blocks (including txes) speed - unsigned int; connection speed start_block_height - unsigned int; block height of the first block in that span status - string; General RPC error code. \"OK\" means everything looks good. target_height - unsigned int; target height the node is syncing from (optional, absent if node is fully synced) Example: $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"sync_info\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"height\": 1563543, \"peers\": [{ \"info\": { \"address\": \"70.109.53.128:60064\", \"avg_download\": 0, \"avg_upload\": 5, \"connection_id\": \"204067223b9b3415c265dd25ad29ee48\", \"current_download\": 0, \"current_upload\": 1, \"height\": 1559975, \"host\": \"70.109.53.128\", \"incoming\": true, \"ip\": \"70.109.53.128\", \"live_time\": 38, \"local_ip\": false, \"localhost\": false, \"peer_id\": \"96b8545dbc7a8866\", \"port\": \"60064\", \"recv_count\": 1580, \"recv_idle_time\": 28, \"send_count\": 203603, \"send_idle_time\": 8, \"state\": \"state_normal\", \"support_flags\": 1 } },{ \"info\": { ... } },{ ... },{ ... },{ ... }], \"status\": \"OK\", \"target_height\": 1564067 } } get_txpool_backlog \u00b6 Get all transaction pool backlog Alias: None . Inputs: None . Outputs: backlog : array of structures tx_backlog_entry (in binary form): blob_size - unsigned int (in binary form) fee - unsigned int (in binary form) time_in_pool - unsigned int (in binary form) status - string; General RPC error code. \"OK\" means everything looks good. untrusted - boolean; States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). Example: $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_txpool_backlog\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"backlog\": \"...Binary...\", \"status\": \"OK\", \"untrusted\": false } } get_output_distribution \u00b6 Alias: None . Inputs: amounts - array of unsigned int; amounts to look for cumulative - boolean; (optional, default is false ) States if the result should be cumulative ( true ) or not ( false ) from_height - unsigned int; (optional, default is 0) starting height to check from to_height - unsigned int; (optional, default is 0) ending height to check up to Outputs: distributions - array of structure distribution as follows: amount - unsigned int base - unsigned int distribution - array of unsigned int start_height - unsigned int status - string; General RPC error code. \"OK\" means everything looks good. Example: $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_output_distribution\",\"params\":{\"amounts\":[628780000],\"from_height\":1462078}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"distributions\": [{ \"amount\": 2628780000, \"base\": 0, \"distribution\": \"\", \"start_height\": 1462078 }], \"status\": \"OK\" } } Other Daemon RPC Calls \u00b6 Not all daemon RPC calls use the JSON_RPC interface. This section gives examples of these calls. The data structure for these calls is different than the JSON RPC calls. Whereas the JSON RPC methods were called using the /json_rpc extension and specifying a method, these methods are called at their own extensions. For example: IP=127.0.0.1 PORT=18081 METHOD='gettransactions' PARAMS='{\"txs_hashes\":[\"d6e48158472848e6687173a91ae6eebfa3e1d778e65252ee99d7515d63090408\"]}' curl \\ -X POST http://$IP:$PORT/$METHOD \\ -d $PARAMS \\ -H 'Content-Type: application/json' Note: It is recommended to use JSON RPC where such alternatives exist, rather than the following methods. For example, the recommended way to get a node's height is via the JSON RPC methods get_info or get_last_block_header , rather than getheight below. For calls that end with .bin , the data is exchanged in the form of binary, serialized objects, as defined in the Core RPC Server. /get_height \u00b6 Get the node's current height. Alias: /getheight . Inputs: None . Outputs: height - unsigned int; Current length of longest chain known to daemon. status - string; General RPC error code. \"OK\" means everything looks good. untrusted - boolean; States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). $ curl -X POST http://127.0.0.1:18081/get_height -H 'Content-Type: application/json' { \"height\": 1564055, \"status\": \"OK\", \"untrusted\": false } /get_blocks.bin \u00b6 Get all blocks info. Binary request. Alias: /getblocks.bin . Inputs: block_ids - binary array of hashes; first 10 blocks id goes sequential, next goes in pow(2,n) offset, like 2, 4, 8, 16, 32, 64 and so on, and the last one is always genesis block start_height - unsigned int prune - boolean Outputs: blocks - array of block complete entries current_height - unsigned int output_indices - structure as follows: indices - array of tx output indices, structure as follows: indices - array of unsigned int start_height - unsigned int status - string; General RPC error code. \"OK\" means everything looks good. untrusted - boolean; States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). /get_blocks_by_height.bin \u00b6 Get blocks by height. Binary request. Alias: /getblocks_by_height.bin . Inputs: heights - array of unsigned int; list of block heights Outputs: blocks - array of block complete entries status - string; General RPC error code. \"OK\" means everything looks good. untrusted - boolean; States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). /get_hashes.bin \u00b6 Get hashes. Binary request. Alias: /gethashes.bin . Inputs: block_ids - binary array of hashes; first 10 blocks id goes sequential, next goes in pow(2,n) offset, like 2, 4, 8, 16, 32, 64 and so on, and the last one is always genesis block start_height - unsigned int Outputs: current_height - unsigned int m_block_ids - binary array of hashes; see block_ids above. start_height - unsigned int status - string; General RPC error code. \"OK\" means everything looks good. untrusted - boolean; States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). /get_o_indexes.bin \u00b6 Get global outputs of transactions. Binary request. Alias: None . Inputs: txid - binary txid Outputs: o_indexes - array of unsigned int; List of output indexes status - string; General RPC error code. \"OK\" means everything looks good. untrusted - boolean; States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). /get_outs.bin \u00b6 Get outputs. Binary request. Alias: None . Inputs: outputs - array of structure get_outputs_out as follows: amount - unsigned int; index - unsigned int; Outputs: outs - array of structure outkey as follows: amount - unsigned int; height - unsigned int; block height of the output key - the public key of the output mask txid - transaction id unlocked - boolean; States if output is locked ( false ) or not ( true ) status - string; General RPC error code. \"OK\" means everything looks good. untrusted - boolean; States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). /get_transactions \u00b6 Look up one or more transactions by hash. Alias: /gettransactions . Inputs: txs_hashes - string list; List of transaction hashes to look up. decode_as_json - boolean; Optional ( false by default). If set true , the returned transaction information will be decoded rather than binary. prune - boolean; Optional ( false by default). Outputs: missed_tx - array of strings. (Optional - returned if not empty) Transaction hashes that could not be found. status - General RPC error code. \"OK\" means everything looks good. txs - array of structure entry as follows: as_hex - string; Full transaction information as a hex string. as_json - json string; List of transaction info: version - Transaction version unlock_time - If not 0, this tells when a transaction output is spendable. vin - List of inputs into transaction: key - The public key of the previous output spent in this transaction. amount - The amount of the input, in atomic units. key_offsets - A list of integer offets to the input. k_image - The key image for the given input vout - List of outputs from transaction: amount - Amount of transaction output, in atomic units. target - Output destination information: key - The stealth public key of the receiver. Whoever owns the private key associated with this key controls this transaction output. extra - Usually called the \"payment ID\" but can be used to include any random 32 bytes. signatures - List of signatures used in ring signature to hide the true origin of the transaction. block_height - unsigned int; block height including the transaction block_timestamp - unsigned int; Unix time at chich the block has been added to the blockchain double_spend_seen - boolean; States if the transaction is a double-spend ( true ) or not ( false ) in_pool - boolean; States if the transaction is in pool ( true ) or included in a block ( false ) output_indices - array of unsigned int; transaction indexes tx_hash - string; transaction hash txs_as_hex - string; Full transaction information as a hex string (old compatibility parameter) txs_as_json - json string; (Optional - returned if set in inputs. Old compatibility parameter) List of transaction as in as_json above: Example 1: Return transaction information in binary format. $ curl -X POST http://127.0.0.1:18081/get_transactions -d '{\"txs_hashes\":[\"d6e48158472848e6687173a91ae6eebfa3e1d778e65252ee99d7515d63090408\"]}' -H 'Content-Type: application/json' { \"status\": \"OK\", \"txs\": [{ \"as_hex\": \"...\", \"as_json\": \"\", \"block_height\": 993442, \"block_timestamp\": 1457749396, \"double_spend_seen\": false, \"in_pool\": false, \"output_indices\": [198769,418598,176616,50345,509], \"tx_hash\": \"d6e48158472848e6687173a91ae6eebfa3e1d778e65252ee99d7515d63090408\" }], \"txs_as_hex\": [\"...\"], \"untrusted\": false } Example 2: Decode returned transaction information in JSON format. Note: the \"vin\", \"vout\" and \"signatures\" list have been truncated in the displayed return for space considerations. $ curl -X POST http://127.0.0.1:18081/get_transactions -d '{\"txs_hashes\":[\"d6e48158472848e6687173a91ae6eebfa3e1d778e65252ee99d7515d63090408\"],\"decode_as_json\":true}' -H 'Content-Type: application/json' { \"status\": \"OK\", \"txs\": [{ \"as_hex\": \"...\", \"as_json\": \"{\\n \\\"version\\\": 1, \\n \\\"unlock_time\\\": 0, \\n \\\"vin\\\": [ {\\n \\\"key\\\": {\\n \\\"amount\\\": 9999999999, \\n \\\"key_offsets\\\": [ 691\\n ], \\n \\\"k_image\\\": \\\"6ebee1b651a8da723462b4891d471b990ddc226049a0866d3029b8e2f75b7012\\\"\\n }\\n }, {\\n \\\"key\\\": {\\n \\\"amount\\\": 9000000000000, \\n \\\"key_offsets\\\": [ 175760\\n ], \\n \\\"k_image\\\": \\\"200bd02b70ee707441a8863c5279b4e4d9f376dc97a140b1e5bc7d72bc508069\\\"\\n }\\n }, ... \\n ], \\n \\\"vout\\\": [ {\\n \\\"amount\\\": 60000000000, \\n \\\"target\\\": {\\n \\\"key\\\": \\\"8c792dea94dab48160e067fb681edd6247ba375281fbcfedc03cb970f3b98e2d\\\"\\n }\\n }, {\\n \\\"amount\\\": 700000000000, \\n \\\"target\\\": {\\n \\\"key\\\": \\\"1ab33e69737e157d23e33274c42793be06a8711670e73fa10ecebc604f87cc71\\\"\\n }\\n }, ... \\n ], \\n \\\"extra\\\": [ 1, 3, 140, 109, 156, 205, 47, 148, 153, 9, 17, 93, 83, 33, 162, 110, 152, 1, 139, 70, 121, 19, 138, 10, 44, 6, 55, 140, 242, 124, 143, 219, 172\\n ], \\n \\\"signatures\\\": [ \\\"fd82214a59c99d9251fa00126d353f9cf502a80d8993a6c223e3c802a40ab405555637f495903d3ba558312881e586d452e6e95826d8e128345f6c0a8f9f350e\\\", \\\"8c04ef50cf34afa3a9ec19c457143496f8cf7045ed869b581f9efa2f1d65e30f1cec5272b00e9c61a34bdd3c78cf82ae8ef4df3132f70861391069b9c255cd08\\\", ... ]\\n}\", \"block_height\": 993442, \"block_timestamp\": 1457749396, \"double_spend_seen\": false, \"in_pool\": false, \"output_indices\": [198769,418598,176616,50345,509], \"tx_hash\": \"d6e48158472848e6687173a91ae6eebfa3e1d778e65252ee99d7515d63090408\" }], \"txs_as_hex\": [\"...\"], \"txs_as_json\": [\"{\\n \\\"version\\\": 1, \\n \\\"unlock_time\\\": 0, \\n \\\"vin\\\": [ {\\n \\\"key\\\": {\\n \\\"amount\\\": 9999999999, \\n \\\"key_offsets\\\": [ 691\\n ], \\n \\\"k_image\\\": \\\"6ebee1b651a8da723462b4891d471b990ddc226049a0866d3029b8e2f75b7012\\\"\\n }\\n }, {\\n \\\"key\\\": {\\n \\\"amount\\\": 9000000000000, \\n \\\"key_offsets\\\": [ 175760\\n ], \\n \\\"k_image\\\": \\\"200bd02b70ee707441a8863c5279b4e4d9f376dc97a140b1e5bc7d72bc508069\\\"\\n }\\n }, ... \\n ], \\n \\\"vout\\\": [ {\\n \\\"amount\\\": 60000000000, \\n \\\"target\\\": {\\n \\\"key\\\": \\\"8c792dea94dab48160e067fb681edd6247ba375281fbcfedc03cb970f3b98e2d\\\"\\n }\\n }, {\\n \\\"amount\\\": 700000000000, \\n \\\"target\\\": {\\n \\\"key\\\": \\\"1ab33e69737e157d23e33274c42793be06a8711670e73fa10ecebc604f87cc71\\\"\\n }\\n }, ... \\n ], \\n \\\"extra\\\": [ 1, 3, 140, 109, 156, 205, 47, 148, 153, 9, 17, 93, 83, 33, 162, 110, 152, 1, 139, 70, 121, 19, 138, 10, 44, 6, 55, 140, 242, 124, 143, 219, 172\\n ], \\n \\\"signatures\\\": [ \\\"fd82214a59c99d9251fa00126d353f9cf502a80d8993a6c223e3c802a40ab405555637f495903d3ba558312881e586d452e6e95826d8e128345f6c0a8f9f350e\\\", \\\"8c04ef50cf34afa3a9ec19c457143496f8cf7045ed869b581f9efa2f1d65e30f1cec5272b00e9c61a34bdd3c78cf82ae8ef4df3132f70861391069b9c255cd08\\\", ... ]\\n}\"], \"untrusted\": false } Example 3: Returned a missed (unexisting) transaction. curl -X POST http://127.0.0.1:18081/get_transactions -d '{\"txs_hashes\":[\"d6e48158472848e6687173a91ae6eebfa3e1d778e65252ee99d7515d63090409\"]}' -H 'Content-Type: application/json' { \"missed_tx\": [\"d6e48158472848e6687173a91ae6eebfa3e1d778e65252ee99d7515d63090409\"], \"status\": \"OK\", \"untrusted\": false } /get_alt_blocks_hashes \u00b6 Get the known blocks hashes which are not on the main chain. Alias: None . Inputs: None Outputs: blks_hashes - array of strings; list of alternative blocks hashes to main chain status - string; General RPC error code. \"OK\" means everything looks good. untrusted - boolean; States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). Example: $ curl -X POST http://127.0.0.1:18081/get_alt_blocks_hashes -H 'Content-Type: application/json' { \"blks_hashes\": [\"9c2277c5470234be8b32382cdf8094a103aba4fcd5e875a6fc159dc2ec00e011\",\"637c0e0f0558e284493f38a5fcca3615db59458d90d3a5eff0a18ff59b83f46f\",\"6f3adc174a2e8082819ebb965c96a095e3e8b63929ad9be2d705ad9c086a6b1c\",\"697cf03c89a9b118f7bdf11b1b3a6a028d7b3617d2d0ed91322c5709acf75625\",\"d99b3cf3ac6f17157ac7526782a3c3b9537f89d07e069f9ce7821d74bd9cad0e\",\"e97b62109a6303233dcd697fa8545c9fcbc0bf8ed2268fede57ddfc36d8c939c\",\"70ff822066a53ad64b04885c89bbe5ce3e537cdc1f7fa0dc55317986f01d1788\",\"b0d36b209bd0d4442b55ea2f66b5c633f522401f921f5a85ea6f113fd2988866\"], \"status\": \"OK\", \"untrusted\": false } /is_key_image_spent \u00b6 Check if outputs have been spent using the key image associated with the output. Alias: None . Inputs: key_images - string list; List of key image hex strings to check. Outputs: spent_status - unsigned int list; List of statuses for each image checked. Statuses are follows: 0 = unspent, 1 = spent in blockchain, 2 = spent in transaction pool status - string; General RPC error code. \"OK\" means everything looks good. untrusted - boolean; States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). Example: $ curl -X POST http://127.0.0.1:18081/is_key_image_spent -d '{\"key_images\":[\"8d1bd8181bf7d857bdb281e0153d84cd55a3fcaa57c3e570f4a49f935850b5e3\",\"7319134bfc50668251f5b899c66b005805ee255c136f0e1cecbb0f3a912e09d4\"]}' -H 'Content-Type: application/json' { \"spent_status\": [1,2], \"status\": \"OK\" \"untrusted\": false } /send_raw_transaction \u00b6 Broadcast a raw transaction to the network. Alias: /sendrawtransaction . Inputs: tx_as_hex - string; Full transaction information as hexidecimal string. do_not_relay - boolean; Stop relaying transaction to other nodes (default is false ). Outputs: double_spend - boolean; Transaction is a double spend ( true ) or not ( false ). fee_too_low - boolean; Fee is too low ( true ) or OK ( false ). invalid_input - boolean; Input is invalid ( true ) or valid ( false ). invalid_output - boolean; Output is invalid ( true ) or valid ( false ). low_mixin - boolean; Mixin count is too low ( true ) or OK ( false ). not_rct - boolean; Transaction is a standard ring transaction ( true ) or a ring confidential transaction ( false ). not_relayed - boolean; Transaction was not relayed ( true ) or relayed ( false ). overspend - boolean; Transaction uses more money than available ( true ) or not ( false ). reason - string; Additional information. Currently empty or \"Not relayed\" if transaction was accepted but not relayed. status - string; General RPC error code. \"OK\" means everything looks good. Any other value means that something went wrong. too_big - boolean; Transaction size is too big ( true ) or OK ( false ). untrusted - boolean; States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). Example (No return information included here.): $ curl -X POST http://127.0.0.1:18081/send_raw_transaction -d '{\"tx_as_hex\":\"de6a3...\", \"do_not_relay\":false}' -H 'Content-Type: application/json' /start_mining \u00b6 Start mining on the daemon. Alias: None . Inputs: do_background_mining - boolean; States if the mining should run in background ( true ) or foreground ( false ). ignore_battery - boolean; States if batery state (on laptop) should be ignored ( true ) or not ( false ). miner_address - string; Account address to mine to. threads_count - unsigned int; Number of mining thread to run. Outputs: status - string; General RPC error code. \"OK\" means everything looks good. Any other value means that something went wrong. Example: $ curl -X POST http://127.0.0.1:18081/start_mining -d '{\"do_background_mining\":false,\"ignore_battery\":true,\"miner_address\":\"47xu3gQpF569au9C2ajo5SSMrWji6xnoE5vhr94EzFRaKAGw6hEGFXYAwVADKuRpzsjiU1PtmaVgcjUJF89ghGPhUXkndHc\",\"threads_count\":1}' -H 'Content-Type: application/json' { \"status\": \"OK\" } /stop_mining \u00b6 Stop mining on the daemon. Alias: None . Inputs: None . Outputs: status - string; General RPC error code. \"OK\" means everything looks good. Any other value means that something went wrong. Example: $ curl -X POST http://127.0.0.1:18081/stop_mining -H 'Content-Type: application/json' { \"status\": \"OK\" } /mining_status \u00b6 Get the mining status of the daemon. Alias: None . Inputs: None . Outputs: active - boolean; States if mining is enabled ( true ) or disabled ( false ). address - string; Account address daemon is mining to. Empty if not mining. is_background_mining_enabled - boolean; States if the mining is running in background ( true ) or foreground ( false ). speed - unsigned int; Mining power in hashes per seconds. status - string; General RPC error code. \"OK\" means everything looks good. Any other value means that something went wrong. threads_count - unsigned int; Number of running mining threads. Example while mining: $ curl -X POST http://127.0.0.1:18081/mining_status -H 'Content-Type: application/json' { \"active\": true, \"address\": \"47xu3gQpF569au9C2ajo5SSMrWji6xnoE5vhr94EzFRaKAGw6hEGFXYAwVADKuRpzsjiU1PtmaVgcjUJF89ghGPhUXkndHc\", \"is_background_mining_enabled\": false, \"speed\": 20, \"status\": \"OK\", \"threads_count\": 1 } Example while not mining: $ curl -X POST http://127.0.0.1:18081/mining_status -H 'Content-Type: application/json' { \"active\": false, \"address\": \"\", \"is_background_mining_enabled\": false, \"speed\": 0, \"status\": \"OK\", \"threads_count\": 0 } /save_bc \u00b6 Save the blockchain. The blockchain does not need saving and is always saved when modified, however it does a sync to flush the filesystem cache onto the disk for safety purposes against Operating System or Harware crashes. Alias: None . Inputs: None . Outputs: status - string; General RPC error code. \"OK\" means everything looks good. Any other value means that something went wrong. Example: $ curl -X POST http://127.0.0.1:18081/save_bc -H 'Content-Type: application/json' { \"status\": \"OK\" } /get_peer_list \u00b6 Get the known peers list. Alias: None . Inputs: None . Outputs: gray_list - array of offline peer structure as follows: host - unsigned int; IP address in integer format id - string; Peer id ip - unsigned int; IP address in integer format last_seen - unsigned int; unix time at which the peer has been seen for the last time port - unsigned int; TCP port the peer is using to connect to loki network. status - string; General RPC error code. \"OK\" means everything looks good. Any other value means that something went wrong. white_list - array of online peer structure, as above. Example (truncated lists): $ curl -X POST http://127.0.0.1:18081/get_peer_list -H 'Content-Type: application/json' { \"gray_list\": [{ \"host\": \"640304833\", \"id\": 5345237316225602120, \"ip\": 640304833, \"last_seen\": 1525540510, \"port\": 18080 },{ \"host\": \"2183731038\", \"id\": 14955030573998424430, \"ip\": 2183731038, \"last_seen\": 1525540499, \"port\": 28080 }, ... ], \"status\": \"OK\", \"white_list\": [{ \"host\": \"1221637955\", \"id\": 10354694710033118926, \"ip\": 1221637955, \"last_seen\": 1525540511, \"port\": 18080 },{ \"host\": \"1780407354\", \"id\": 17193661050352240890, \"ip\": 1780407354, \"last_seen\": 1525540510, \"port\": 18080 }, ... ] } /set_log_hash_rate \u00b6 Set the log hash rate display mode. Alias: None . Inputs: visible - boolean; States if hash rate logs should be visible ( true ) or hidden ( false ) Outputs: status - string; General RPC error code. \"OK\" means everything looks good. Any other value means that something went wrong. Example while mining: $ curl -X POST http://127.0.0.1:18081/set_log_hash_rate -d '{\"visible\":true}' -H 'Content-Type: application/json' { \"status\": \"OK\" } Error while not mining: $ curl -X POST http://127.0.0.1:18081/set_log_hash_rate -d '{\"visible\":true}' -H 'Content-Type: application/json' { \"status\": \"NOT MINING\" } /set_log_level \u00b6 Set the daemon log level. By default, log level is set to 0 . Alias: None . Inputs: level - integer; daemon log level to set from 0 (less verbose) to 4 (most verbose) Outputs: status - string; General RPC error code. \"OK\" means everything looks good. Any other value means that something went wrong. Example: $ curl -X POST http://127.0.0.1:18081/set_log_level -d '{\"level\":1}' -H 'Content-Type: application/json' { \"status\": \"OK\" } /set_log_categories \u00b6 Set the daemon log categories. Categories are represented as a comma separated list of <Category>:<level> (similarly to syslog standard <Facility>:<Severity-level> ), where: Category is one of the following: * - All facilities default net net.http net.p2p logging net.throttle blockchain.db blockchain.db.lmdb bcutil checkpoints net.dns net.dl i18n perf stacktrace updates account cn difficulty hardfork miner blockchain txpool cn.block_queue net.cn daemon debugtools.deserialize debugtools.objectsizes device.ledger wallet.gen_multisig multisig bulletproofs ringct daemon.rpc wallet.simplewallet WalletAPI wallet.ringdb wallet.wallet2 wallet.rpc tests.core Level is one of the following: FATAL - higher level ERROR WARNING INFO DEBUG TRACE - lower level A level automatically includes higher level. By default, categories are set to *:WARNING,net:FATAL,net.p2p:FATAL,net.cn:FATAL,global:INFO,verify:FATAL,stacktrace:INFO,logging:INFO,msgwriter:INFO . Setting the categories to \"\" prevent any logs to be outputed. Alias: None . Inputs: categories - string; Optional, daemon log categories to enable Outputs: categories - string; daemon log enabled categories status - string; General RPC error code. \"OK\" means everything looks good. Any other value means that something went wrong. Example to set all facilities to Security Level Info : $ curl -X POST http://127.0.0.1:18081/set_log_categories -d '{\"categories\": \"*:INFO\"}' -H 'Content-Type: application/json' { \"categories\": \"*:INFO\", \"status\": \"OK\" } Example without input to set the default categories: $ curl -X POST http://127.0.0.1:18081/set_log_categories -H 'Content-Type: application/json' { \"categories\": \"*:WARNING,net:FATAL,net.p2p:FATAL,net.cn:FATAL,global:INFO,verify:FATAL,stacktrace:INFO,logging:INFO,msgwriter:INFO\", \"status\": \"OK\" } /get_transaction_pool \u00b6 Show information about valid transactions seen by the node but not yet mined into a block, as well as spent key image information for the txpool in the node's memory. Alias: None . Inputs: None . Outputs: spent_key_images - List of spent output key images: id_hash - string; Key image. txs_hashes - string list; tx hashes of the txes (usually one) spending that key image. status - string; General RPC error code. \"OK\" means everything looks good. transactions - List of transactions in the mempool are not in a block on the main chain at the moment: blob_size - unsigned int; The size of the full transaction blob. double_spend_seen - boolean; States if this transaction has been seen as double spend. do_not_relay ; boolean; States if this transaction should not be relayed fee - unsigned int; The amount of the mining fee included in the transaction, in atomic units. id_hash - string; The transaction ID hash. kept_by_block - boolean; States if the tx was included in a block at least once ( true ) or not ( false ). last_failed_height - unsigned int; If the transaction validation has previously failed, this tells at what height that occured. last_failed_id_hash - string; Like the previous, this tells the previous transaction ID hash. last_relayed_time - unsigned int; Last unix time at which the transaction has been relayed. max_used_block_height - unsigned int; Tells the height of the most recent block with an output used in this transaction. max_used_block_hash - string; Tells the hash of the most recent block with an output used in this transaction. receive_time - unsigned int; The Unix time that the transaction was first seen on the network by the node. relayed - boolean; States if this transaction has been relayed tx_blob - unsigned int; Hexadecimal blob represnting the transaction. tx_json - json string; JSON structure of all information in the transaction: version - Transaction version unlock_time - If not 0, this tells when a transaction output is spendable. vin - List of inputs into transaction: key - The public key of the previous output spent in this transaction. amount - The amount of the input, in atomic units. key_offsets - A list of integer offets to the input. k_image - The key image for the given input vout - List of outputs from transaction: amount - Amount of transaction output, in atomic units. target - Output destination information: key - The stealth public key of the receiver. Whoever owns the private key associated with this key controls this transaction output. extra - Usually called the \"transaction ID\" but can be used to include any random 32 bytes. rct_signatures - Ring signatures: type txnFee ecdhInfo - array of Diffie Helman Elipctic curves structures as follows: mask - String amount - String outPk rctsig_prunable rangeSigs - array of structures as follows: asig Ci MGs - array of structures as follows: ss - array of arrays of two strings. cc - String Example (Note: Some lists in the returned information have been truncated for display reasons): $ curl -X POST http://127.0.0.1:18081/get_transaction_pool -H 'Content-Type: application/json' { \"spent_key_images\": [{ \"id_hash\": \"a2af919609db4ff5ab8d4ba18502e647d521760e1cbc30288f06fa87bf9a0c1c\", \"txs_hashes\": [\"1ee6a4873b638711795fc3b0b73fc7146505a09a7f4749534fd408d571a273cf\"] },{ \"id_hash\": \"02d5f6559e9bca5ae5a335130aeeb05df2db518ab9837fa64ebbab276c100792\", \"txs_hashes\": [\"531aacc0ceb8514cdde5f104285202ccc3e969c77584e3c6fa614c987c583965\"] }, ...], \"status\": \"OK\", \"transactions\": [{ \"blob_size\": 13193, \"do_not_relay\": false, \"double_spend_seen\": false, \"fee\": 9694360000, \"id_hash\": \"f8fb875cfc9e2e59bcf96a42474c79e01d50b69e6548d445d45984f7db66e50f\", \"kept_by_block\": false, \"last_failed_height\": 0, \"last_failed_id_hash\": \"0000000000000000000000000000000000000000000000000000000000000000\", \"last_relayed_time\": 1525615049, \"max_used_block_height\": 1564924, \"max_used_block_id_hash\": \"4bae7856979f46c7de31f3fb58cac36d4dfd2765bf33f876edf33d0e05ebb4a7\", \"receive_time\": 1525615049, \"relayed\": true, \"tx_blob\": \" ... \", \"tx_json\": \"{\\n \\\"version\\\": 2, \\n \\\"unlock_time\\\": 0, \\n \\\"vin\\\": [ {\\n \\\"key\\\": {\\n \\\"amount\\\": 0, \\n \\\"key_offsets\\\": [ 2630347, 594429, 1047509, 758973, 464501, 61971, 22268\\n ], \\n \\\"k_image\\\": \\\"0731363c58dd4492f031fa20c82fe6ddcb9cc070d73938afe8a5f7f77897f8b4\\\"\\n }\\n }\\n ], \\n \\\"vout\\\": [ {\\n \\\"amount\\\": 0, \\n \\\"target\\\": {\\n \\\"key\\\": \\\"f3b3dd09483616e343b9866eed50a0ce01d5c0d0f2612ce2c4d0e9cce5c218cd\\\"\\n }\\n }, {\\n \\\"amount\\\": 0, \\n \\\"target\\\": {\\n \\\"key\\\": \\\"9796f2d477a696b6282bf3cb1a41cefba0c4604eedcc2e7a44904d7033643e0e\\\"\\n }\\n }\\n ], \\n \\\"extra\\\": [ 1, 25, 228, 80, 5, 214, 117, 150, 9, 125, 98, 17, 113, 208, 89, 223, 242, 227, 188, 197, 141, 190, 135, 140, 152, 117, 240, 150, 21, 93, 62, 108, 124\\n ], \\n \\\"rct_signatures\\\": {\\n \\\"type\\\": 1, \\n \\\"txnFee\\\": 9694360000, \\n \\\"ecdhInfo\\\": [ {\\n \\\"mask\\\": \\\"645f06a2816aecf83d5041c3320eb31092b994fb2733bb74c8c47e288d452c04\\\", \\n \\\"amount\\\": \\\"3908f14d39dcb3831331cb255eeadc5b0aea0143645b9cd3034abf613995740d\\\"\\n }, {\\n \\\"mask\\\": \\\"0785b5df0a994b14d59da810503a022721d8f629720f526e15bd848ad3c2c509\\\", \\n \\\"amount\\\": \\\"fbd81cf2368dcd742905ded5287457030467aaf5bc9939e13f1d6bf8d4c8ca09\\\"\\n }], \\n \\\"outPk\\\": [ \\\"c19f5fa052859126e0eed0e3c860aadab049677b2b3dd14cc74d02f92f1d013f\\\", \\\"1581ef6368de1608ea366566b88272db220479cf215f6d88d7b60ec221d11e0a\\\"]\\n }, \\n \\\"rctsig_prunable\\\": {\\n \\\"rangeSigs\\\": [ {\\n \\\"asig\\\": \\\" ... \\\", \\n \\\"Ci\\\": \\\" .. \\\"\\n }, {\\n \\\"asig\\\": \\\" ... \\\", \\n \\\"Ci\\\": \\\" ... \\\"\\n }], \\n \\\"MGs\\\": [ {\\n \\\"ss\\\": [ [ \\\"218a10a29e0f66e5a324af67b7734708a8a4cc8f16b28acd8cda538aaa495a02\\\", \\\"b368b4e956df5808c5c257f0dc3f7eff8c28463d0bb20759d19977fa02d6f205\\\"], [ \\\"f741d2c96bc23b362b4155a03fb6f1351ab5bf4445a43b3e52ba776f526af305\\\", \\\"a10ad1ee80dce3f311dd3dc141803daeecaa4d2a25a390cd9c35e4161b7c9e0c\\\"], ...], \\n \\\"cc\\\": \\\"e93801b707261ca76e146fdf2085abae71ad9203a00edc843c74f4ead8a39601\\\"\\n }]\\n }\\n}\" }, ...] } /get_transaction_pool_hashes.bin \u00b6 Get hashes from transaction pool. Binary request. Alias: None . Inputs: None . Outputs: status - string; General RPC error code. \"OK\" means everything looks good. tx_hashes - binary array of transaction hashes. untrusted - boolean; States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). Example: $ curl -X POST http://127.0.0.1:18081/get_transaction_pool_hashes.bin -H 'Content-Type: application/json' { \"status\": \"OK\", \"tx_hashes\": \" ... \", \"untrusted\": false } /get_transaction_pool_stats \u00b6 Get the transaction pool statistics. Alias: None . Inputs: None . Outputs: pool_stats - Structure as follows: bytes_max - unsigned int; Max transaction size in pool bytes_med - unsigned int; Median transaction size in pool bytes_min - unsigned int; Min transaction size in pool bytes_total - unsigned int; total size of all transactions in pool histo - structure txpool_histo as follows: txs - unsigned int; number of transactions bytes - unsigned int; size in bytes. histo_98pc unsigned int; the time 98% of txes are \"younger\" than num_10m unsigned int; number of transactions in pool for more than 10 minutes num_double_spends unsigned int; number of double spend transactions num_failing unsigned int; number of failing transactions num_not_relayed unsigned int; number of non-relayed transactions oldest unsigned int; unix time of the oldest transaction in the pool txs_total unsigned int; total number of transactions. status - string; General RPC error code. \"OK\" means everything looks good. untrusted - boolean; States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). Example: $ curl -X POST http://127.0.0.1:18081/get_transaction_pool_stats -H 'Content-Type: application/json' { \"pool_stats\": { \"bytes_max\": 47222, \"bytes_med\": 13290, \"bytes_min\": 13092, \"bytes_total\": 449511, \"fee_total\": 289715320000, \"histo\": \"\\t\u2592'\u25925\u25924\u2592\\/\u2592\u2592\u2592$3\", \"histo_98pc\": 0, \"num_10m\": 18, \"num_double_spends\": 1, \"num_failing\": 17, \"num_not_relayed\": 0, \"oldest\": 1525457001, \"txs_total\": 26 }, \"status\": \"OK\", \"untrusted\": false } /stop_daemon \u00b6 Send a command to the daemon to safely disconnect and shut down. Alias: None . Inputs: None . Outputs: status - string; General RPC error code. \"OK\" means everything looks good. Example: $ curl -X POST http://127.0.0.1:18081/stop_daemon -H 'Content-Type: application/json' { \"status\": \"OK\" } /get_info (not JSON) \u00b6 This method is a convenient backward support and should not be used anymore. See get_info JSON RPC for details. Alias: /getinfo get_info /get_limit \u00b6 Get daemon bandwidth limits. Alias: None . Inputs: None . Outputs: limit_down - unsigned int; Download limit in kBytes per second limit_up - unsigned int; Upload limit in kBytes per second status - string; General RPC error code. \"OK\" means everything looks good. untrusted - boolean; States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). Example: $ curl -X POST http://127.0.0.1:18081/get_limit -H 'Content-Type: application/json' { \"limit_down\": 8192, \"limit_up\": 128, \"status\": \"OK\", \"untrusted\": false } /set_limit \u00b6 Set daemon bandwidth limits. Alias: None . Inputs: limit_down - signed int; Download limit in kBytes per second (-1 reset to default, 0 don't change the current limit) limit_up - signed int; Upload limit in kBytes per second (-1 reset to default, 0 don't change the current limit) Outputs: limit_down - unsigned int; Download limit in kBytes per second limit_up - unsigned int; Upload limit in kBytes per second status - string; General RPC error code. \"OK\" means everything looks good. Example: $ curl -X POST http://127.0.0.1:18081/set_limit -d '{\"limit_down\": 1024}' -H 'Content-Type: application/json' { \"limit_down\": 1024, \"limit_up\": 128, \"status\": \"OK\" } /out_peers \u00b6 Limit number of Outgoing peers. Alias: None . Inputs: out_peers - unsigned int; Max number of outgoing peers Outputs: status - string; General RPC error code. \"OK\" means everything looks good. Example: $ curl -X POST http://127.0.0.1:18081/out_peers -d '{\"out_peers\": 3232235535}' -H 'Content-Type: application/json' { \"status\": \"OK\" } /in_peers \u00b6 Limit number of Incoming peers. Alias: None . Inputs: in_peers - unsigned int; Max number of incoming peers Outputs: status - string; General RPC error code. \"OK\" means everything looks good. Example: $ curl -X POST http://127.0.0.1:18081/out_peers -d '{\"in_peers\": 3232235535}' -H 'Content-Type: application/json' { \"status\": \"OK\" } /start_save_graph \u00b6 Obsolete. Conserved here for reference. Alias: None . Inputs: None . Outputs: status - string; General RPC error code. \"OK\" means everything looks good. Example: $ curl -X POST http://127.0.0.1:18081/start_save_graph -H 'Content-Type: application/json' { \"status\": \"OK\" } /stop_save_graph \u00b6 Obsolete. Conserved here for reference. Alias: None . Inputs: None . Outputs: status - string; General RPC error code. \"OK\" means everything looks good. Example: $ curl -X POST http://127.0.0.1:18081/stop_save_graph -H 'Content-Type: application/json' { \"status\": \"OK\" } /get_outs \u00b6 Get outputs. Alias: None . Inputs: outputs array of get_outputs_out structure as follows: amount - unsigned int; index - unsigned int; Outputs: outs - array of structure outkey as follows: height - unsigned int; block height of the output key - String; the public key of the output mask - String txid - String; transaction id unlocked - boolean; States if output is locked ( false ) or not ( true ) status - string; General RPC error code. \"OK\" means everything looks good. untrusted - boolean; States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). /update \u00b6 Update daemon. Alias: None . Inputs: command - String; command to use, either check or download path - String; Optional, path where to download the update. Outputs: auto_uri - string; hash - string; path - String; path to download the update status - string; General RPC error code. \"OK\" means everything looks good. update - boolean; States if an update is available to download ( true ) or not ( false ) user_uri - string; version - string; Version available for download. Example: $ curl -X POST http://127.0.0.1:18081/update -d '{\"command\":\"check\"}' -H 'Content-Type: application/json' { \"auto_uri\": \"\", \"hash\": \"\", \"path\": \"\", \"status\": \"OK\", \"update\": false, \"user_uri\": \"\", \"version\": \"\" } Sources: \u00b6 Reworked from GetMonero.org RPC calls for Loki under their copyright license .","title":"Daemon RPC Guide - Old"},{"location":"Developer/DaemonRPCGuide/#loki-daemon-rpc","text":"","title":"Loki Daemon RPC"},{"location":"Developer/DaemonRPCGuide/#introduction","text":"This is a list of the lokid daemon RPC calls, their inputs and outputs, and examples of each. Many RPC calls use the daemon's JSON RPC interface while others use their own interfaces, as demonstrated below. Note: \"atomic units\" refer to the smallest fraction of 1 LOKI according to the lokid implementation. 1 LOKI = 1e12 atomic units.","title":"Introduction"},{"location":"Developer/DaemonRPCGuide/#json-rpc-methods","text":"get_block_count on_get_block_hash get_block_template submit_block get_last_block_header get_block_header_by_hash get_block_header_by_height get_block_headers_range get_block get_connections get_info hard_fork_info set_bans get_bans flush_txpool get_output_histogram get_version get_coinbase_tx_sum get_fee_estimate get_alternate_chains relay_tx sync_info get_txpool_backlog get_output_distribution","title":"JSON RPC Methods:"},{"location":"Developer/DaemonRPCGuide/#other-rpc-methods","text":"/get_height /get_blocks.bin /get_blocks_by_height.bin /get_hashes.bin /get_o_indexes.bin /get_outs.bin /get_transactions /get_alt_blocks_hashes /is_key_image_spent /send_raw_transaction /start_mining /stop_mining /mining_status /save_bc /get_peer_list /set_log_hash_rate /set_log_level /set_log_categories /get_transaction_pool /get_transaction_pool_hashes.bin /get_transaction_pool_stats /stop_daemon /get_info (not JSON) /get_limit /set_limit /out_peers /in_peers /start_save_graph /stop_save_graph /get_outs /update","title":"Other RPC Methods:"},{"location":"Developer/DaemonRPCGuide/#json-rpc-methods_1","text":"The majority of lokid RPC calls use the daemon's json_rpc interface to request various bits of information. These methods all follow a similar structure, for example: IP=127.0.0.1 PORT=18081 METHOD='get_block_header_by_height' ALIAS='getblockheaderbyheight' PARAMS='{\"height\":912345}' curl \\ -X POST http://$IP:$PORT/json_rpc \\ -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"'$METHOD'\",\"params\":'$PARAMS'}' \\ -H 'Content-Type: application/json' Some methods include parameters, while others do not. Examples of each JSON RPC method follow.","title":"JSON RPC Methods"},{"location":"Developer/DaemonRPCGuide/#get_block_count","text":"Look up how many blocks are in the longest chain known to the node. Alias: getblockcount . Inputs: None . Outputs: count - unsigned int; Number of blocks in longest chain seen by the node. status - string; General RPC error code. \"OK\" means everything looks good. Example: $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_block_count\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"count\": 993163, \"status\": \"OK\" } }","title":"get_block_count"},{"location":"Developer/DaemonRPCGuide/#on_get_block_hash","text":"Look up a block's hash by its height. Alias: on_getblockhash . Inputs: block height (int array of length 1) Outputs: block hash (string) Example: $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"on_get_block_hash\",\"params\":[912345]}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": \"e22cf75f39ae720e8b71b3d120a5ac03f0db50bba6379e2850975b4859190bc6\" }","title":"on_get_block_hash"},{"location":"Developer/DaemonRPCGuide/#get_block_template","text":"Get a block template on which mining a new block. Alias: getblocktemplate . Inputs: wallet_address - string; Address of wallet to receive coinbase transactions if block is successfully mined. reserve_size - unsigned int; Reserve size. Outputs: blocktemplate_blob - string; Blob on which to try to mine a new block. blockhashing_blob - string; Blob on which to try to find a valid nonce. difficulty - unsigned int; Difficulty of next block. expected_reward - unsigned int; Coinbase reward expected to be received if block is successfully mined. height - unsigned int; Height on which to mine. prev_hash - string; Hash of the most recent block on which to mine the next block. reserved_offset - unsigned int; Reserved offset. status - string; General RPC error code. \"OK\" means everything looks good. untrusted - boolean; States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). Example: $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_block_template\",\"params\":{\"wallet_address\":\"44GBHzv6ZyQdJkjqZje6KLZ3xSyN1hBSFAnLP6EAqJtCRVzMzZmeXTC2AHKDS9aEDTRKmo6a6o9r9j86pYfhCWDkKjbtcns\",\"reserve_size\":60}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"blockhashing_blob\": \"070786a498d705f8dc58791266179087907a2ff4cd883615216749b97d2f12173171c725a6f84a00000000fc751ea4a94c2f840751eaa36138eee66dda15ef554e7d6594395827994e31da10\", \"blocktemplate_blob\": \"070786a498d705f8dc58791266179087907a2ff4cd883615216749b97d2f12173171c725a6f84a0000000002aeab5f01fff2aa5f01e0a9d0f2f08a01028fdb3d5b5a2c363d36ea17a4add99a23a3ec7935b4c3e1e0364fcc4295c7a2ef5f01f912b15f5d17c1539d4722f79d8856d8654c5af87f54cfb3a4ff7f6b512b2a08023c000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f1755090c809421d69873c161e7969b8bf33cee3b451dd4859bfc244a705f0b4900498f804b6023e13fa023a0fb759e8b7c9a39506a21442bc47077beeedc6b78d34c4ebdae91bd96097ccc9a882bc5056568b0d2f1f06559368fea4acba8e745444e883e53156d5083c1fd260edf05292934c8b40c098b81fe4e261720bdd272b209e317247a1d2c55dc4718891af0d16273c5a610f36f382a3bf50f54808aaa6a508e51d4601dd0d8fbf8b3b1685066ce121666a1409e8ac7a4d673c1cc36d10b825f764af647441f53230518e4d2efbcf8791c6060912c76e90db4982a66d51bbd96290bbb34db8080b216c2940cec407260bf5e2c3a5ee280835f15298f0801e9d98c4d414792282fbc2c28c3e20bc0fcb1829b5c3ad8f8d20847be8fdb2a949fd96f0205fbd6d271c880c5d8c83e9813606cd803a44d377fdeae45bfa67112132af601e9b3b0613ba7dff2ec3d4b935c447b47bfe39f7b950981b2f4c66c0d853e2218f1f69229a9b608c3d98be09b6d4d640a9f6ff0e920dbacf7e58b59554c0b398b1ae4b1d497104b4e4e745d850eed7eddb8aa93437427bf442ae5beb22cbf10a8fa738ea38cfa5d86dfd30675d4be11a38016e36936fd5601e52643e8b8bc433702ea7ae6149309c95b898cc854850e73fe0b95c5b8879b7325ecd4\", \"difficulty\": 61043624293, \"expected_reward\": 4771949057248, \"height\": 1561970, \"prev_hash\": \"f8dc58791266179087907a2ff4cd883615216749b97d2f12173171c725a6f84a\", \"reserved_offset\": 129, \"status\": \"OK\", \"untrusted\": false } }","title":"get_block_template"},{"location":"Developer/DaemonRPCGuide/#submit_block","text":"Submit a mined block to the network. Alias: submitblock . Inputs: Block blob data - array of strings; list of block blobs which have been mined. See get_block_template to get a blob on which to mine. Outputs: status - string; Block submit status. In this example, a block blob which has not been mined is submitted: $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"submit_block\",\"params\":[\"0707e6bdfedc053771512f1bc27c62731ae9e8f2443db64ce742f4e57f5cf8d393de28551e441a0000000002fb830a01ffbf830a018cfe88bee283060274c0aae2ef5730e680308d9c00b6da59187ad0352efe3c71d36eeeb28782f29f2501bd56b952c3ddc3e350c2631d3a5086cac172c56893831228b17de296ff4669de020200000000\"]' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"error\": { \"code\": -7, \"message\": \"Block not accepted\" } }","title":"submit_block"},{"location":"Developer/DaemonRPCGuide/#get_last_block_header","text":"Block header information for the most recent block is easily retrieved with this method. No inputs are needed. Alias: getlastblockheader . Inputs: None . Outputs: block_header - A structure containing block header information. block_size - unsigned int; The block size in bytes. depth - unsigned int; The number of blocks succeeding this block on the blockchain. A larger number means an older block. difficulty - unsigned int; The strength of the Loki network based on mining power. hash - string; The hash of this block. height - unsigned int; The number of blocks preceding this block on the blockchain. major_version - unsigned int; The major version of the loki protocol at this block height. minor_version - unsigned int; The minor version of the loki protocol at this block height. nonce - unsigned int; a cryptographic random one-time number used in mining a Loki block. num_txes - unsigned int; Number of transactions in the block, not counting the coinbase tx. orphan_status - boolean; Usually false . If true , this block is not part of the longest chain. prev_hash - string; The hash of the block immediately preceding this block in the chain. reward - unsigned int; The amount of new generated in this block and rewarded to the miner. Note: 1 LOKI = 1e12 atomic units. timestamp - unsigned int; The unix time at which the block was recorded into the blockchain. status - string; General RPC error code. \"OK\" means everything looks good. untrusted - boolean; States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). In this example, the most recent block (1562023 at the time) is returned: $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_last_block_header\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"block_header\": { \"block_size\": 62774, \"depth\": 0, \"difficulty\": 60097900840, \"hash\": \"3a289b8fa88b10e2163826c230b45d79f2be37d14fa3153ee58ff8a427782d14\", \"height\": 1562023, \"major_version\": 7, \"minor_version\": 7, \"nonce\": 3789681204, \"num_txes\": 5, \"orphan_status\": false, \"prev_hash\": \"743e5d0a26849efe27b96086f2c4ecc39a0bc744bf21473dad6710221aff6ac3\", \"reward\": 4724029079703, \"timestamp\": 1525029411 }, \"status\": \"OK\", \"untrusted\": false } }","title":"get_last_block_header"},{"location":"Developer/DaemonRPCGuide/#get_block_header_by_hash","text":"Block header information can be retrieved using either a block's hash or height. This method includes a block's hash as an input parameter to retrieve basic information about the block. Alias: getblockheaderbyhash . Inputs: hash - string; The block's sha256 hash. Outputs: block_header - A structure containing block header information. See get_last_block_header . status - string; General RPC error code. \"OK\" means everything looks good. untrusted - boolean; States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). In this example, block 912345 is looked up by its hash: $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_block_header_by_hash\",\"params\":{\"hash\":\"e22cf75f39ae720e8b71b3d120a5ac03f0db50bba6379e2850975b4859190bc6\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"block_header\": { \"block_size\": 210, \"depth\": 649717, \"difficulty\": 815625611, \"hash\": \"e22cf75f39ae720e8b71b3d120a5ac03f0db50bba6379e2850975b4859190bc6\", \"height\": 912345, \"major_version\": 1, \"minor_version\": 2, \"nonce\": 1646, \"num_txes\": 0, \"orphan_status\": false, \"prev_hash\": \"b61c58b2e0be53fad5ef9d9731a55e8a81d972b8d90ed07c04fd37ca6403ff78\", \"reward\": 7388968946286, \"timestamp\": 1452793716 }, \"status\": \"OK\", \"untrusted\": false } }","title":"get_block_header_by_hash"},{"location":"Developer/DaemonRPCGuide/#get_block_header_by_height","text":"Similar to get_block_header_by_hash above, this method includes a block's height as an input parameter to retrieve basic information about the block. Alias: getblockheaderbyheight . Inputs: height - unsigned int; The block's height. Outputs: block_header - A structure containing block header information. See get_last_block_header . status - string; General RPC error code. \"OK\" means everything looks good. untrusted - boolean; States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). In this example, block 912345 is looked up by its height (notice that the returned information is the same as in the previous example): $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_block_header_by_height\",\"params\":{\"height\":912345}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"block_header\": { \"block_size\": 210, \"depth\": 649721, \"difficulty\": 815625611, \"hash\": \"e22cf75f39ae720e8b71b3d120a5ac03f0db50bba6379e2850975b4859190bc6\", \"height\": 912345, \"major_version\": 1, \"minor_version\": 2, \"nonce\": 1646, \"num_txes\": 0, \"orphan_status\": false, \"prev_hash\": \"b61c58b2e0be53fad5ef9d9731a55e8a81d972b8d90ed07c04fd37ca6403ff78\", \"reward\": 7388968946286, \"timestamp\": 1452793716 }, \"status\": \"OK\", \"untrusted\": false } }","title":"get_block_header_by_height"},{"location":"Developer/DaemonRPCGuide/#get_block_headers_range","text":"Similar to get_block_header_by_height above, but for a range of blocks. This method includes a starting block height and an ending block height as parameters to retrieve basic information about the range of blocks. Alias: getblockheadersrange . Inputs: start_height - unsigned int; The starting block's height. end_height - unsigned int; The ending block's height. Outputs: headers - array of block_header (a structure containing block header information. See get_last_block_header ). status - string; General RPC error code. \"OK\" means everything looks good. untrusted - boolean; States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). In this example, blocks range from height 1545999 to 1546000 is looked up (notice that the returned informations are ascending order and that it is at the April 2018 network upgrade time): $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_block_headers_range\",\"params\":{\"start_height\":1545999,\"end_height\":1546000}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"headers\": [{ \"block_size\": 301413, \"depth\": 16085, \"difficulty\": 134636057921, \"hash\": \"86d1d20a40cefcf3dd410ff6967e0491613b77bf73ea8f1bf2e335cf9cf7d57a\", \"height\": 1545999, \"major_version\": 6, \"minor_version\": 6, \"nonce\": 3246403956, \"num_txes\": 20, \"orphan_status\": false, \"prev_hash\": \"0ef6e948f77b8f8806621003f5de24b1bcbea150bc0e376835aea099674a5db5\", \"reward\": 5025593029981, \"timestamp\": 1523002893 },{ \"block_size\": 13322, \"depth\": 16084, \"difficulty\": 134716086238, \"hash\": \"b408bf4cfcd7de13e7e370c84b8314c85b24f0ba4093ca1d6eeb30b35e34e91a\", \"height\": 1546000, \"major_version\": 7, \"minor_version\": 7, \"nonce\": 3737164176, \"num_txes\": 1, \"orphan_status\": false, \"prev_hash\": \"86d1d20a40cefcf3dd410ff6967e0491613b77bf73ea8f1bf2e335cf9cf7d57a\", \"reward\": 4851952181070, \"timestamp\": 1523002931 }], \"status\": \"OK\", \"untrusted\": false } }","title":"get_block_headers_range"},{"location":"Developer/DaemonRPCGuide/#get_block","text":"Full block information can be retrieved by either block height or hash, like with the above block header calls. For full block information, both lookups use the same method, but with different input parameters. Alias: getblock . Inputs (pick one of the following): height - unsigned int; The block's height. hash - string; The block's hash. Outputs: blob - string; Hexadecimal blob of block information. block_header - A structure containing block header information. See get_last_block_header . json - json string; JSON formatted block details: major_version - Same as in block header. minor_version - Same as in block header. timestamp - Same as in block header. prev_id - Same as prev_hash in block header. nonce - Same as in block header. miner_tx - Miner transaction information version - Transaction version number. unlock_time - The block height when the coinbase transaction becomes spendable. vin - List of transaction inputs: gen - Miner txs are coinbase txs, or \"gen\". height - This block height, a.k.a. when the coinbase is generated. vout - List of transaction outputs. Each output contains: amount - The amount of the output, in atomic units. target - key - extra - Usually called the \"transaction ID\" but can be used to include any random 32 byte/64 character hex string. signatures - Contain signatures of tx signers. Coinbased txs do not have signatures. tx_hashes - List of hashes of non-coinbase transactions in the block. If there are no other transactions, this will be an empty list. status - string; General RPC error code. \"OK\" means everything looks good. untrusted - boolean; States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). Look up by height: In the following example, block 912345 is looked up by its height. Note that block 912345 does not have any non-coinbase transactions. (See the next example for a block with extra transactions): $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_block\",\"params\":{\"height\":912345}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"blob\": \"0102f4bedfb405b61c58b2e0be53fad5ef9d9731a55e8a81d972b8d90ed07c04fd37ca6403ff786e0600000195d83701ffd9d73704ee84ddb42102378b043c1724c92c69d923d266fe86477d3a5ddd21145062e148c64c5767700880c0fc82aa020273733cbd6e6218bda671596462a4b062f95cfe5e1dbb5b990dacb30e827d02f280f092cbdd080247a5dab669770da69a860acde21616a119818e1a489bb3c4b1b6b3c50547bc0c80e08d84ddcb01021f7e4762b8b755e3e3c72b8610cc87b9bc25d1f0a87c0c816ebb952e4f8aff3d2b01fd0a778957f4f3103a838afda488c3cdadf2697b3d34ad71234282b2fad9100e02080000000bdfc2c16c00\", \"block_header\": { \"block_size\": 210, \"depth\": 649772, \"difficulty\": 815625611, \"hash\": \"e22cf75f39ae720e8b71b3d120a5ac03f0db50bba6379e2850975b4859190bc6\", \"height\": 912345, \"major_version\": 1, \"minor_version\": 2, \"nonce\": 1646, \"num_txes\": 0, \"orphan_status\": false, \"prev_hash\": \"b61c58b2e0be53fad5ef9d9731a55e8a81d972b8d90ed07c04fd37ca6403ff78\", \"reward\": 7388968946286, \"timestamp\": 1452793716 }, \"json\": \"{\\n \\\"major_version\\\": 1, \\n \\\"minor_version\\\": 2, \\n \\\"timestamp\\\": 1452793716, \\n \\\"prev_id\\\": \\\"b61c58b2e0be53fad5ef9d9731a55e8a81d972b8d90ed07c04fd37ca6403ff78\\\", \\n \\\"nonce\\\": 1646, \\n \\\"miner_tx\\\": {\\n \\\"version\\\": 1, \\n \\\"unlock_time\\\": 912405, \\n \\\"vin\\\": [ {\\n \\\"gen\\\": {\\n \\\"height\\\": 912345\\n }\\n }\\n ], \\n \\\"vout\\\": [ {\\n \\\"amount\\\": 8968946286, \\n \\\"target\\\": {\\n \\\"key\\\": \\\"378b043c1724c92c69d923d266fe86477d3a5ddd21145062e148c64c57677008\\\"\\n }\\n }, {\\n \\\"amount\\\": 80000000000, \\n \\\"target\\\": {\\n \\\"key\\\": \\\"73733cbd6e6218bda671596462a4b062f95cfe5e1dbb5b990dacb30e827d02f2\\\"\\n }\\n }, {\\n \\\"amount\\\": 300000000000, \\n \\\"target\\\": {\\n \\\"key\\\": \\\"47a5dab669770da69a860acde21616a119818e1a489bb3c4b1b6b3c50547bc0c\\\"\\n }\\n }, {\\n \\\"amount\\\": 7000000000000, \\n \\\"target\\\": {\\n \\\"key\\\": \\\"1f7e4762b8b755e3e3c72b8610cc87b9bc25d1f0a87c0c816ebb952e4f8aff3d\\\"\\n }\\n }\\n ], \\n \\\"extra\\\": [ 1, 253, 10, 119, 137, 87, 244, 243, 16, 58, 131, 138, 253, 164, 136, 195, 205, 173, 242, 105, 123, 61, 52, 173, 113, 35, 66, 130, 178, 250, 217, 16, 14, 2, 8, 0, 0, 0, 11, 223, 194, 193, 108\\n ], \\n \\\"signatures\\\": [ ]\\n }, \\n \\\"tx_hashes\\\": [ ]\\n}\", \"miner_tx_hash\": \"c7da3965f25c19b8eb7dd8db48dcd4e7c885e2491db77e289f0609bf8e08ec30\", \"status\": \"OK\", \"untrusted\": false } } Look up by hash: In the following example, block 993056 is looked up by its hash. Note that block 993056 has 3 non-coinbase transactions: $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_block\",\"params\":{\"hash\":\"510ee3c4e14330a7b96e883c323a60ebd1b5556ac1262d0bc03c24a3b785516f\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"blob\": \"0102a3978cb7050ea4af6547c05c965afc8df6d31509ff3105dc7ae6b10172521d77e09711fd6df407000001dcce3c01ffa0ce3c049da8bece070259e9d685b3484886bc7b47c133e6099ecdf212d5eaa16ce19cd58e8c3c1e590a80d88ee16f024c5e2f542d25513c46b9e3b7d40140a22d0ae5314bfcae492ad9f56fff8185f080d0b8e1981a0213dd8ffdac9e6a2f71e327dad65328198dc879a492d145eae72677c0703a351580c0f9decfae010262bda00341681dccbc066757862da593734395745bdfe1fdc89b5948c86a5d4c2b01b691851cf057b9c302a3dbca879e1cba4cc45061ca55aaa6e03cdc67ab9e455002080000000c617fdf160379c6b9f00db027bde151705aafe85c495883aae2597d5cb8e1adb2e0f3ae1d07d715db73331abc3ec588ef07c7bb195786a4724b08dff431b51ffa32a4ce899bb197066426c0ed89f0b431fe171f7fd62bc95dd29943daa7cf3585cf1fdfc99d\", \"block_header\": { \"block_size\": 3981, \"depth\": 569068, \"difficulty\": 964985344, \"hash\": \"510ee3c4e14330a7b96e883c323a60ebd1b5556ac1262d0bc03c24a3b785516f\", \"height\": 993056, \"major_version\": 1, \"minor_version\": 2, \"nonce\": 2036, \"num_txes\": 3, \"orphan_status\": false, \"prev_hash\": \"0ea4af6547c05c965afc8df6d31509ff3105dc7ae6b10172521d77e09711fd6d\", \"reward\": 6932043647005, \"timestamp\": 1457720227 }, \"json\": \"{\\n \\\"major_version\\\": 1, \\n \\\"minor_version\\\": 2, \\n \\\"timestamp\\\": 1457720227, \\n \\\"prev_id\\\": \\\"0ea4af6547c05c965afc8df6d31509ff3105dc7ae6b10172521d77e09711fd6d\\\", \\n \\\"nonce\\\": 2036, \\n \\\"miner_tx\\\": {\\n \\\"version\\\": 1, \\n \\\"unlock_time\\\": 993116, \\n \\\"vin\\\": [ {\\n \\\"gen\\\": {\\n \\\"height\\\": 993056\\n }\\n }\\n ], \\n \\\"vout\\\": [ {\\n \\\"amount\\\": 2043647005, \\n \\\"target\\\": {\\n \\\"key\\\": \\\"59e9d685b3484886bc7b47c133e6099ecdf212d5eaa16ce19cd58e8c3c1e590a\\\"\\n }\\n }, {\\n \\\"amount\\\": 30000000000, \\n \\\"target\\\": {\\n \\\"key\\\": \\\"4c5e2f542d25513c46b9e3b7d40140a22d0ae5314bfcae492ad9f56fff8185f0\\\"\\n }\\n }, {\\n \\\"amount\\\": 900000000000, \\n \\\"target\\\": {\\n \\\"key\\\": \\\"13dd8ffdac9e6a2f71e327dad65328198dc879a492d145eae72677c0703a3515\\\"\\n }\\n }, {\\n \\\"amount\\\": 6000000000000, \\n \\\"target\\\": {\\n \\\"key\\\": \\\"62bda00341681dccbc066757862da593734395745bdfe1fdc89b5948c86a5d4c\\\"\\n }\\n }\\n ], \\n \\\"extra\\\": [ 1, 182, 145, 133, 28, 240, 87, 185, 195, 2, 163, 219, 202, 135, 158, 28, 186, 76, 196, 80, 97, 202, 85, 170, 166, 224, 60, 220, 103, 171, 158, 69, 80, 2, 8, 0, 0, 0, 12, 97, 127, 223, 22\\n ], \\n \\\"signatures\\\": [ ]\\n }, \\n \\\"tx_hashes\\\": [ \\\"79c6b9f00db027bde151705aafe85c495883aae2597d5cb8e1adb2e0f3ae1d07\\\", \\\"d715db73331abc3ec588ef07c7bb195786a4724b08dff431b51ffa32a4ce899b\\\", \\\"b197066426c0ed89f0b431fe171f7fd62bc95dd29943daa7cf3585cf1fdfc99d\\\"\\n ]\\n}\", \"miner_tx_hash\": \"372395aeac5e5ad2c40b4c546b0bad00c4242fb2bd88e2e25f4e43231876f81e\", \"status\": \"OK\", \"tx_hashes\": [\"79c6b9f00db027bde151705aafe85c495883aae2597d5cb8e1adb2e0f3ae1d07\",\"d715db73331abc3ec588ef07c7bb195786a4724b08dff431b51ffa32a4ce899b\",\"b197066426c0ed89f0b431fe171f7fd62bc95dd29943daa7cf3585cf1fdfc99d\"], \"untrusted\": false } }","title":"get_block"},{"location":"Developer/DaemonRPCGuide/#get_connections","text":"Retrieve information about incoming and outgoing connections to your node. Alias: None . Inputs: None . Outputs: connections - List of all connections and their info: address - string; The peer's address, actually IPv4 & port avg_download - unsigned int; Average bytes of data downloaded by node. avg_upload - unsigned int; Average bytes of data uploaded by node. connection_id - string; The connection ID current_download - unsigned int; Current bytes downloaded by node. current_upload - unsigned int; Current bytes uploaded by node. height - unsigned int; The peer height host - string; The peer host incoming - boolean; Is the node getting information from your node? ip - string; The node's IP address. live_time - unsigned int local_ip - boolean localhost - boolean peer_id - string; The node's ID on the network. port - string; The port that the node is using to connect to the network. recv_count - unsigned int recv_idle_time - unsigned int send_count - unsigned int send_idle_time - unsigned int state - string support_flags - unsigned int Following is an example of get_connections and it's return: $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_connections\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"connections\": [{ \"address\": \"173.90.69.136:62950\", \"avg_download\": 0, \"avg_upload\": 2, \"connection_id\": \"083c301a3030329a487adb12ad981d2c\", \"current_download\": 0, \"current_upload\": 2, \"height\": 1562127, \"host\": \"173.90.69.136\", \"incoming\": true, \"ip\": \"173.90.69.136\", \"live_time\": 8, \"local_ip\": false, \"localhost\": false, \"peer_id\": \"c959fbfbed9e44fb\", \"port\": \"62950\", \"recv_count\": 259, \"recv_idle_time\": 8, \"send_count\": 24342, \"send_idle_time\": 8, \"state\": \"state_normal\", \"support_flags\": 0 },{ ... }], \"status\": \"OK\" } }","title":"get_connections"},{"location":"Developer/DaemonRPCGuide/#get_info","text":"Retrieve general information about the state of your node and the network. Alias: /get_info /getinfo See other RPC Methods /get_info (not JSON) Inputs: None . Outputs: alt_blocks_count - unsigned int; Number of alternative blocks to main chain. block_size_limit - unsigned int; Maximum allowed block size block_size_median - unsigned int; Median block size of latest 100 blocks bootstrap_daemon_address - string; bootstrap node to give immediate usability to wallets while syncing by proxying RPC to it. (Note: the replies may be untrustworthy). cumulative_difficulty - unsigned int; Cumulative difficulty of all blocks in the blockchain. difficulty - unsigned int; Network difficulty (analogous to the strength of the network) free_space - unsigned int; Available disk space on the node. grey_peerlist_size - unsigned int; Grey Peerlist Size height - unsigned int; Current length of longest chain known to daemon. height_without_bootstrap - unsigned int; Current length of the local chain of the daemon. incoming_connections_count - unsigned int; Number of peers connected to and pulling from your node. mainnet - boolean; States if the node is on the mainnet ( true ) or not ( false ). offline - boolean; States if the node is offline ( true ) or online ( false ). outgoing_connections_count - unsigned int; Number of peers that you are connected to and getting information from. rpc_connections_count - unsigned int; Number of RPC client connected to the daemon (Including this RPC request). stagenet - boolean; States if the node is on the stagenet ( true ) or not ( false ). start_time - unsigned int; Start time of the daemon, as UNIX time. status - string; General RPC error code. \"OK\" means everything looks good. target - unsigned int; Current target for next proof of work. target_height - unsigned int; The height of the next block in the chain. testnet - boolean; States if the node is on the testnet ( true ) or not ( false ). top_block_hash - string; Hash of the highest block in the chain. tx_count - unsigned int; Total number of non-coinbase transaction in the chain. tx_pool_size - unsigned int; Number of transactions that have been broadcast but not included in a block. untrusted - boolean; States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). was_bootstrap_ever_used - boolean; States if a bootstrap node has ever been used since the daemon started. white_peerlist_size - unsigned int; White Peerlist Size Following is an example get_info call and its return: $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_info\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"alt_blocks_count\": 6, \"block_size_limit\": 600000, \"block_size_median\": 129017, \"bootstrap_daemon_address\": \"\", \"cumulative_difficulty\": 14121125493385685, \"difficulty\": 60580751777, \"free_space\": 138758750208, \"grey_peerlist_size\": 4998, \"height\": 1562168, \"height_without_bootstrap\": 1562168, \"incoming_connections_count\": 2, \"mainnet\": true, \"offline\": false, \"outgoing_connections_count\": 8, \"rpc_connections_count\": 2, \"stagenet\": false, \"start_time\": 1524751757, \"status\": \"OK\", \"target\": 120, \"target_height\": 1562063, \"testnet\": false, \"top_block_hash\": \"7a7ba647080844073fdd8e3a069e00554c773d6e6863354dba1dec45a43f5592\", \"tx_count\": 2759894, \"tx_pool_size\": 755, \"untrusted\": false, \"was_bootstrap_ever_used\": false, \"white_peerlist_size\": 1000 } }","title":"get_info"},{"location":"Developer/DaemonRPCGuide/#hard_fork_info","text":"Look up information regarding hard fork voting and readiness. Alias: None . Inputs: None . Outputs: earliest_height - unsigned int; Block height at which hard fork would be enabled if voted in. enabled - boolean; Tells if hard fork is enforced. state - unsigned int; Current hard fork state: 0 (There is likely a hard fork), 1 (An update is needed to fork properly), or 2 (Everything looks good). status - string; General RPC error code. \"OK\" means everything looks good. threshold - unsigned int; Minimum percent of votes to trigger hard fork. Default is 80. version - unsigned int; The major block version for the fork. votes - unsigned int; Number of votes towards hard fork. voting - unsigned int; Hard fork voting status. window - unsigned int; Number of blocks over which current votes are cast. Default is 10080 blocks. Example: $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"hard_fork_info\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"earliest_height\": 1009827, \"enabled\": false, \"state\": 2, \"status\": \"OK\", \"threshold\": 0, \"version\": 1, \"votes\": 7277, \"voting\": 2, \"window\": 10080 } }","title":"hard_fork_info"},{"location":"Developer/DaemonRPCGuide/#set_bans","text":"Ban another node by IP. Alias: None . Inputs: bans - A list of nodes to ban: host - string; Host to ban (IP in A.B.C.D form - will support I2P address in the future). ip - unsigned int; IP address to ban, in Int format. ban - boolean; Set true to ban. seconds - unsigned int; Number of seconds to ban node. Outputs: status - string; General RPC error code. \"OK\" means everything looks good. Examples: banning by host In the following example, host is banned with its IP address string-formatted as A.B.C.D: $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"set_bans\",\"params\":{\"bans\":[{\"host\":\"192.168.1.51\",\"ban\":true,\"seconds\":30}]}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"status\": \"OK\" } } banning by ip In the following example, integer-formatted IP is banned: $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"set_bans\",\"params\":{\"bans\":[{\"ip\":838969536,\"ban\":true,\"seconds\":30}]}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"status\": \"OK\" } }","title":"set_bans"},{"location":"Developer/DaemonRPCGuide/#get_bans","text":"Get list of banned IPs. Alias: None . Inputs: None . Outputs: bans - List of banned nodes: host - string; Banned host (IP in A.B.C.D form). ip - unsigned int; Banned IP address, in Int format. seconds - unsigned int; Local Unix time that IP is banned until. status - string; General RPC error code. \"OK\" means everything looks good. Example: $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_bans\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"bans\": [{ \"host\": \"102.168.1.51\", \"ip\": 855746662, \"seconds\": 22 },{ \"host\": \"192.168.1.50\", \"ip\": 838969536, \"seconds\": 28 }], \"status\": \"OK\" } }","title":"get_bans"},{"location":"Developer/DaemonRPCGuide/#flush_txpool","text":"Flush tx ids from transaction pool Alias: None . Inputs: txids - array of strings; Optional, list of transactions IDs to flush from pool (all tx ids flushed if empty). Outputs: status - string; General RPC error code. \"OK\" means everything looks good. Example: $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"flush_txpool\",\"params\":{\"txids\":[\"dc16fa8eaffe1484ca9014ea050e13131d3acf23b419f33bb4cc0b32b6c49308\",\"\"]}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"status\": \"OK\" } }","title":"flush_txpool"},{"location":"Developer/DaemonRPCGuide/#get_output_histogram","text":"Get a histogram of output amounts. For all amounts (possibly filtered by parameters), gives the number of outputs on the chain for that amount. RingCT outputs counts as 0 amount. Inputs: amounts - list of unsigned int min_count - unsigned int max_count - unsigned int unlocked - boolean recent_cutoff - unsigned int Outputs: histogram - list of histogram entries, in the following structure: amount - unsigned int; Output amount in atomic units total_instances - unsigned int; unlocked_instances - unsigned int; recent_instances - unsigned int; status - string; General RPC error code. \"OK\" means everything looks good. untrusted - boolean; States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). Example: $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_output_histogram\",\"params\":{\"amounts\":[20000000000]}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"histogram\": [{ \"amount\": 20000000000, \"recent_instances\": 0, \"total_instances\": 381458, \"unlocked_instances\": 0 }], \"status\": \"OK\", \"untrusted\": false } }","title":"get_output_histogram"},{"location":"Developer/DaemonRPCGuide/#get_coinbase_tx_sum","text":"Get the coinbase ammount and the fees ammount for n last blocks starting at particular height Alias: None . Inputs: height - unsigned int; Block height from which getting the amounts count - unsigned int; number of blocks to include in the sum Outputs: emission_amount - unsigned int; amount of coinbase reward in atomic units fee_amount - unsigned int; amount of fees in atomic units status - string; General RPC error code. \"OK\" means everything looks good. Example: $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_coinbase_tx_sum\",\"params\":{\"height\":1563078,\"count\":2}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"emission_amount\": 9387854817320, \"fee_amount\": 83981380000, \"status\": \"OK\" } }","title":"get_coinbase_tx_sum"},{"location":"Developer/DaemonRPCGuide/#get_version","text":"Give the node current version Alias: None . Inputs: None . Outputs: status - string; General RPC error code. \"OK\" means everything looks good. untrusted - boolean; States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). version - unsigned int; Example: $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_version\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"status\": \"OK\", \"untrusted\": false, \"version\": 65555 } }","title":"get_version"},{"location":"Developer/DaemonRPCGuide/#get_fee_estimate","text":"Gives an estimation on fees per kB. Alias: None . Inputs: grace_blocks - unsigned int; Optional Outputs: fee - unsigned int; Amount of fees estimated per kB in atomic units status - string; General RPC error code. \"OK\" means everything looks good. untrusted - boolean; States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). Example: $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_fee_estimate\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"fee\": 187610000, \"status\": \"OK\", \"untrusted\": false } }","title":"get_fee_estimate"},{"location":"Developer/DaemonRPCGuide/#get_alternate_chains","text":"Display alternative chains seen by the node. Alias: None . Inputs: None . Outputs: chains - array of chains, the following structure: block_hash - string; the block hash of the first diverging block of this alternative chain. difficulty - unsigned int; the cumulative difficulty of all blocks in the alternative chain. height - unsigned int; the block height of the first diverging block of this alternative chain. length - unsigned int; the length in blocks of this alternative chain, after divergence. status - string; General RPC error code. \"OK\" means everything looks good. Example: $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_alternate_chains\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"chains\": [{ \"block_hash\": \"697cf03c89a9b118f7bdf11b1b3a6a028d7b3617d2d0ed91322c5709acf75625\", \"difficulty\": 14114729638300280, \"height\": 1562062, \"length\": 2 }], \"status\": \"OK\" } }","title":"get_alternate_chains"},{"location":"Developer/DaemonRPCGuide/#relay_tx","text":"Relay a list of transaction IDs. Alias: None . Inputs: txids - array of string; list of transaction IDs to relay Outputs: status - string; General RPC error code. \"OK\" means everything looks good. Example: $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"relay_tx\",\"params\":{\"txids\":[9fd75c429cbe52da9a52f2ffc5fbd107fe7fd2099c0d8de274dc8a67e0c98613]}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"status\": \"OK\" } }","title":"relay_tx"},{"location":"Developer/DaemonRPCGuide/#sync_info","text":"Get synchronisation informations Alias: None . Inputs: None . Outputs: height - unsigned int; peers - array of peer structure, defined as follows: info - structure of connection info, as defined in get_connections spans - array of span structure, defined as follows (optional, absent if node is fully synced): connection_id - string; Id of connection nblocks - unsigned int; number of blocks in that span rate - unsigned int; connection rate remote_address - string; peer address the node is downloading (or has downloaded) than span from size - unsigned int; total number of bytes in that span's blocks (including txes) speed - unsigned int; connection speed start_block_height - unsigned int; block height of the first block in that span status - string; General RPC error code. \"OK\" means everything looks good. target_height - unsigned int; target height the node is syncing from (optional, absent if node is fully synced) Example: $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"sync_info\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"height\": 1563543, \"peers\": [{ \"info\": { \"address\": \"70.109.53.128:60064\", \"avg_download\": 0, \"avg_upload\": 5, \"connection_id\": \"204067223b9b3415c265dd25ad29ee48\", \"current_download\": 0, \"current_upload\": 1, \"height\": 1559975, \"host\": \"70.109.53.128\", \"incoming\": true, \"ip\": \"70.109.53.128\", \"live_time\": 38, \"local_ip\": false, \"localhost\": false, \"peer_id\": \"96b8545dbc7a8866\", \"port\": \"60064\", \"recv_count\": 1580, \"recv_idle_time\": 28, \"send_count\": 203603, \"send_idle_time\": 8, \"state\": \"state_normal\", \"support_flags\": 1 } },{ \"info\": { ... } },{ ... },{ ... },{ ... }], \"status\": \"OK\", \"target_height\": 1564067 } }","title":"sync_info"},{"location":"Developer/DaemonRPCGuide/#get_txpool_backlog","text":"Get all transaction pool backlog Alias: None . Inputs: None . Outputs: backlog : array of structures tx_backlog_entry (in binary form): blob_size - unsigned int (in binary form) fee - unsigned int (in binary form) time_in_pool - unsigned int (in binary form) status - string; General RPC error code. \"OK\" means everything looks good. untrusted - boolean; States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). Example: $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_txpool_backlog\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"backlog\": \"...Binary...\", \"status\": \"OK\", \"untrusted\": false } }","title":"get_txpool_backlog"},{"location":"Developer/DaemonRPCGuide/#get_output_distribution","text":"Alias: None . Inputs: amounts - array of unsigned int; amounts to look for cumulative - boolean; (optional, default is false ) States if the result should be cumulative ( true ) or not ( false ) from_height - unsigned int; (optional, default is 0) starting height to check from to_height - unsigned int; (optional, default is 0) ending height to check up to Outputs: distributions - array of structure distribution as follows: amount - unsigned int base - unsigned int distribution - array of unsigned int start_height - unsigned int status - string; General RPC error code. \"OK\" means everything looks good. Example: $ curl -X POST http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_output_distribution\",\"params\":{\"amounts\":[628780000],\"from_height\":1462078}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"distributions\": [{ \"amount\": 2628780000, \"base\": 0, \"distribution\": \"\", \"start_height\": 1462078 }], \"status\": \"OK\" } }","title":"get_output_distribution"},{"location":"Developer/DaemonRPCGuide/#other-daemon-rpc-calls","text":"Not all daemon RPC calls use the JSON_RPC interface. This section gives examples of these calls. The data structure for these calls is different than the JSON RPC calls. Whereas the JSON RPC methods were called using the /json_rpc extension and specifying a method, these methods are called at their own extensions. For example: IP=127.0.0.1 PORT=18081 METHOD='gettransactions' PARAMS='{\"txs_hashes\":[\"d6e48158472848e6687173a91ae6eebfa3e1d778e65252ee99d7515d63090408\"]}' curl \\ -X POST http://$IP:$PORT/$METHOD \\ -d $PARAMS \\ -H 'Content-Type: application/json' Note: It is recommended to use JSON RPC where such alternatives exist, rather than the following methods. For example, the recommended way to get a node's height is via the JSON RPC methods get_info or get_last_block_header , rather than getheight below. For calls that end with .bin , the data is exchanged in the form of binary, serialized objects, as defined in the Core RPC Server.","title":"Other Daemon RPC Calls"},{"location":"Developer/DaemonRPCGuide/#get_height","text":"Get the node's current height. Alias: /getheight . Inputs: None . Outputs: height - unsigned int; Current length of longest chain known to daemon. status - string; General RPC error code. \"OK\" means everything looks good. untrusted - boolean; States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). $ curl -X POST http://127.0.0.1:18081/get_height -H 'Content-Type: application/json' { \"height\": 1564055, \"status\": \"OK\", \"untrusted\": false }","title":"/get_height"},{"location":"Developer/DaemonRPCGuide/#get_blocksbin","text":"Get all blocks info. Binary request. Alias: /getblocks.bin . Inputs: block_ids - binary array of hashes; first 10 blocks id goes sequential, next goes in pow(2,n) offset, like 2, 4, 8, 16, 32, 64 and so on, and the last one is always genesis block start_height - unsigned int prune - boolean Outputs: blocks - array of block complete entries current_height - unsigned int output_indices - structure as follows: indices - array of tx output indices, structure as follows: indices - array of unsigned int start_height - unsigned int status - string; General RPC error code. \"OK\" means everything looks good. untrusted - boolean; States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ).","title":"/get_blocks.bin"},{"location":"Developer/DaemonRPCGuide/#get_blocks_by_heightbin","text":"Get blocks by height. Binary request. Alias: /getblocks_by_height.bin . Inputs: heights - array of unsigned int; list of block heights Outputs: blocks - array of block complete entries status - string; General RPC error code. \"OK\" means everything looks good. untrusted - boolean; States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ).","title":"/get_blocks_by_height.bin"},{"location":"Developer/DaemonRPCGuide/#get_hashesbin","text":"Get hashes. Binary request. Alias: /gethashes.bin . Inputs: block_ids - binary array of hashes; first 10 blocks id goes sequential, next goes in pow(2,n) offset, like 2, 4, 8, 16, 32, 64 and so on, and the last one is always genesis block start_height - unsigned int Outputs: current_height - unsigned int m_block_ids - binary array of hashes; see block_ids above. start_height - unsigned int status - string; General RPC error code. \"OK\" means everything looks good. untrusted - boolean; States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ).","title":"/get_hashes.bin"},{"location":"Developer/DaemonRPCGuide/#get_o_indexesbin","text":"Get global outputs of transactions. Binary request. Alias: None . Inputs: txid - binary txid Outputs: o_indexes - array of unsigned int; List of output indexes status - string; General RPC error code. \"OK\" means everything looks good. untrusted - boolean; States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ).","title":"/get_o_indexes.bin"},{"location":"Developer/DaemonRPCGuide/#get_outsbin","text":"Get outputs. Binary request. Alias: None . Inputs: outputs - array of structure get_outputs_out as follows: amount - unsigned int; index - unsigned int; Outputs: outs - array of structure outkey as follows: amount - unsigned int; height - unsigned int; block height of the output key - the public key of the output mask txid - transaction id unlocked - boolean; States if output is locked ( false ) or not ( true ) status - string; General RPC error code. \"OK\" means everything looks good. untrusted - boolean; States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ).","title":"/get_outs.bin"},{"location":"Developer/DaemonRPCGuide/#get_transactions","text":"Look up one or more transactions by hash. Alias: /gettransactions . Inputs: txs_hashes - string list; List of transaction hashes to look up. decode_as_json - boolean; Optional ( false by default). If set true , the returned transaction information will be decoded rather than binary. prune - boolean; Optional ( false by default). Outputs: missed_tx - array of strings. (Optional - returned if not empty) Transaction hashes that could not be found. status - General RPC error code. \"OK\" means everything looks good. txs - array of structure entry as follows: as_hex - string; Full transaction information as a hex string. as_json - json string; List of transaction info: version - Transaction version unlock_time - If not 0, this tells when a transaction output is spendable. vin - List of inputs into transaction: key - The public key of the previous output spent in this transaction. amount - The amount of the input, in atomic units. key_offsets - A list of integer offets to the input. k_image - The key image for the given input vout - List of outputs from transaction: amount - Amount of transaction output, in atomic units. target - Output destination information: key - The stealth public key of the receiver. Whoever owns the private key associated with this key controls this transaction output. extra - Usually called the \"payment ID\" but can be used to include any random 32 bytes. signatures - List of signatures used in ring signature to hide the true origin of the transaction. block_height - unsigned int; block height including the transaction block_timestamp - unsigned int; Unix time at chich the block has been added to the blockchain double_spend_seen - boolean; States if the transaction is a double-spend ( true ) or not ( false ) in_pool - boolean; States if the transaction is in pool ( true ) or included in a block ( false ) output_indices - array of unsigned int; transaction indexes tx_hash - string; transaction hash txs_as_hex - string; Full transaction information as a hex string (old compatibility parameter) txs_as_json - json string; (Optional - returned if set in inputs. Old compatibility parameter) List of transaction as in as_json above: Example 1: Return transaction information in binary format. $ curl -X POST http://127.0.0.1:18081/get_transactions -d '{\"txs_hashes\":[\"d6e48158472848e6687173a91ae6eebfa3e1d778e65252ee99d7515d63090408\"]}' -H 'Content-Type: application/json' { \"status\": \"OK\", \"txs\": [{ \"as_hex\": \"...\", \"as_json\": \"\", \"block_height\": 993442, \"block_timestamp\": 1457749396, \"double_spend_seen\": false, \"in_pool\": false, \"output_indices\": [198769,418598,176616,50345,509], \"tx_hash\": \"d6e48158472848e6687173a91ae6eebfa3e1d778e65252ee99d7515d63090408\" }], \"txs_as_hex\": [\"...\"], \"untrusted\": false } Example 2: Decode returned transaction information in JSON format. Note: the \"vin\", \"vout\" and \"signatures\" list have been truncated in the displayed return for space considerations. $ curl -X POST http://127.0.0.1:18081/get_transactions -d '{\"txs_hashes\":[\"d6e48158472848e6687173a91ae6eebfa3e1d778e65252ee99d7515d63090408\"],\"decode_as_json\":true}' -H 'Content-Type: application/json' { \"status\": \"OK\", \"txs\": [{ \"as_hex\": \"...\", \"as_json\": \"{\\n \\\"version\\\": 1, \\n \\\"unlock_time\\\": 0, \\n \\\"vin\\\": [ {\\n \\\"key\\\": {\\n \\\"amount\\\": 9999999999, \\n \\\"key_offsets\\\": [ 691\\n ], \\n \\\"k_image\\\": \\\"6ebee1b651a8da723462b4891d471b990ddc226049a0866d3029b8e2f75b7012\\\"\\n }\\n }, {\\n \\\"key\\\": {\\n \\\"amount\\\": 9000000000000, \\n \\\"key_offsets\\\": [ 175760\\n ], \\n \\\"k_image\\\": \\\"200bd02b70ee707441a8863c5279b4e4d9f376dc97a140b1e5bc7d72bc508069\\\"\\n }\\n }, ... \\n ], \\n \\\"vout\\\": [ {\\n \\\"amount\\\": 60000000000, \\n \\\"target\\\": {\\n \\\"key\\\": \\\"8c792dea94dab48160e067fb681edd6247ba375281fbcfedc03cb970f3b98e2d\\\"\\n }\\n }, {\\n \\\"amount\\\": 700000000000, \\n \\\"target\\\": {\\n \\\"key\\\": \\\"1ab33e69737e157d23e33274c42793be06a8711670e73fa10ecebc604f87cc71\\\"\\n }\\n }, ... \\n ], \\n \\\"extra\\\": [ 1, 3, 140, 109, 156, 205, 47, 148, 153, 9, 17, 93, 83, 33, 162, 110, 152, 1, 139, 70, 121, 19, 138, 10, 44, 6, 55, 140, 242, 124, 143, 219, 172\\n ], \\n \\\"signatures\\\": [ \\\"fd82214a59c99d9251fa00126d353f9cf502a80d8993a6c223e3c802a40ab405555637f495903d3ba558312881e586d452e6e95826d8e128345f6c0a8f9f350e\\\", \\\"8c04ef50cf34afa3a9ec19c457143496f8cf7045ed869b581f9efa2f1d65e30f1cec5272b00e9c61a34bdd3c78cf82ae8ef4df3132f70861391069b9c255cd08\\\", ... ]\\n}\", \"block_height\": 993442, \"block_timestamp\": 1457749396, \"double_spend_seen\": false, \"in_pool\": false, \"output_indices\": [198769,418598,176616,50345,509], \"tx_hash\": \"d6e48158472848e6687173a91ae6eebfa3e1d778e65252ee99d7515d63090408\" }], \"txs_as_hex\": [\"...\"], \"txs_as_json\": [\"{\\n \\\"version\\\": 1, \\n \\\"unlock_time\\\": 0, \\n \\\"vin\\\": [ {\\n \\\"key\\\": {\\n \\\"amount\\\": 9999999999, \\n \\\"key_offsets\\\": [ 691\\n ], \\n \\\"k_image\\\": \\\"6ebee1b651a8da723462b4891d471b990ddc226049a0866d3029b8e2f75b7012\\\"\\n }\\n }, {\\n \\\"key\\\": {\\n \\\"amount\\\": 9000000000000, \\n \\\"key_offsets\\\": [ 175760\\n ], \\n \\\"k_image\\\": \\\"200bd02b70ee707441a8863c5279b4e4d9f376dc97a140b1e5bc7d72bc508069\\\"\\n }\\n }, ... \\n ], \\n \\\"vout\\\": [ {\\n \\\"amount\\\": 60000000000, \\n \\\"target\\\": {\\n \\\"key\\\": \\\"8c792dea94dab48160e067fb681edd6247ba375281fbcfedc03cb970f3b98e2d\\\"\\n }\\n }, {\\n \\\"amount\\\": 700000000000, \\n \\\"target\\\": {\\n \\\"key\\\": \\\"1ab33e69737e157d23e33274c42793be06a8711670e73fa10ecebc604f87cc71\\\"\\n }\\n }, ... \\n ], \\n \\\"extra\\\": [ 1, 3, 140, 109, 156, 205, 47, 148, 153, 9, 17, 93, 83, 33, 162, 110, 152, 1, 139, 70, 121, 19, 138, 10, 44, 6, 55, 140, 242, 124, 143, 219, 172\\n ], \\n \\\"signatures\\\": [ \\\"fd82214a59c99d9251fa00126d353f9cf502a80d8993a6c223e3c802a40ab405555637f495903d3ba558312881e586d452e6e95826d8e128345f6c0a8f9f350e\\\", \\\"8c04ef50cf34afa3a9ec19c457143496f8cf7045ed869b581f9efa2f1d65e30f1cec5272b00e9c61a34bdd3c78cf82ae8ef4df3132f70861391069b9c255cd08\\\", ... ]\\n}\"], \"untrusted\": false } Example 3: Returned a missed (unexisting) transaction. curl -X POST http://127.0.0.1:18081/get_transactions -d '{\"txs_hashes\":[\"d6e48158472848e6687173a91ae6eebfa3e1d778e65252ee99d7515d63090409\"]}' -H 'Content-Type: application/json' { \"missed_tx\": [\"d6e48158472848e6687173a91ae6eebfa3e1d778e65252ee99d7515d63090409\"], \"status\": \"OK\", \"untrusted\": false }","title":"/get_transactions"},{"location":"Developer/DaemonRPCGuide/#get_alt_blocks_hashes","text":"Get the known blocks hashes which are not on the main chain. Alias: None . Inputs: None Outputs: blks_hashes - array of strings; list of alternative blocks hashes to main chain status - string; General RPC error code. \"OK\" means everything looks good. untrusted - boolean; States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). Example: $ curl -X POST http://127.0.0.1:18081/get_alt_blocks_hashes -H 'Content-Type: application/json' { \"blks_hashes\": [\"9c2277c5470234be8b32382cdf8094a103aba4fcd5e875a6fc159dc2ec00e011\",\"637c0e0f0558e284493f38a5fcca3615db59458d90d3a5eff0a18ff59b83f46f\",\"6f3adc174a2e8082819ebb965c96a095e3e8b63929ad9be2d705ad9c086a6b1c\",\"697cf03c89a9b118f7bdf11b1b3a6a028d7b3617d2d0ed91322c5709acf75625\",\"d99b3cf3ac6f17157ac7526782a3c3b9537f89d07e069f9ce7821d74bd9cad0e\",\"e97b62109a6303233dcd697fa8545c9fcbc0bf8ed2268fede57ddfc36d8c939c\",\"70ff822066a53ad64b04885c89bbe5ce3e537cdc1f7fa0dc55317986f01d1788\",\"b0d36b209bd0d4442b55ea2f66b5c633f522401f921f5a85ea6f113fd2988866\"], \"status\": \"OK\", \"untrusted\": false }","title":"/get_alt_blocks_hashes"},{"location":"Developer/DaemonRPCGuide/#is_key_image_spent","text":"Check if outputs have been spent using the key image associated with the output. Alias: None . Inputs: key_images - string list; List of key image hex strings to check. Outputs: spent_status - unsigned int list; List of statuses for each image checked. Statuses are follows: 0 = unspent, 1 = spent in blockchain, 2 = spent in transaction pool status - string; General RPC error code. \"OK\" means everything looks good. untrusted - boolean; States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). Example: $ curl -X POST http://127.0.0.1:18081/is_key_image_spent -d '{\"key_images\":[\"8d1bd8181bf7d857bdb281e0153d84cd55a3fcaa57c3e570f4a49f935850b5e3\",\"7319134bfc50668251f5b899c66b005805ee255c136f0e1cecbb0f3a912e09d4\"]}' -H 'Content-Type: application/json' { \"spent_status\": [1,2], \"status\": \"OK\" \"untrusted\": false }","title":"/is_key_image_spent"},{"location":"Developer/DaemonRPCGuide/#send_raw_transaction","text":"Broadcast a raw transaction to the network. Alias: /sendrawtransaction . Inputs: tx_as_hex - string; Full transaction information as hexidecimal string. do_not_relay - boolean; Stop relaying transaction to other nodes (default is false ). Outputs: double_spend - boolean; Transaction is a double spend ( true ) or not ( false ). fee_too_low - boolean; Fee is too low ( true ) or OK ( false ). invalid_input - boolean; Input is invalid ( true ) or valid ( false ). invalid_output - boolean; Output is invalid ( true ) or valid ( false ). low_mixin - boolean; Mixin count is too low ( true ) or OK ( false ). not_rct - boolean; Transaction is a standard ring transaction ( true ) or a ring confidential transaction ( false ). not_relayed - boolean; Transaction was not relayed ( true ) or relayed ( false ). overspend - boolean; Transaction uses more money than available ( true ) or not ( false ). reason - string; Additional information. Currently empty or \"Not relayed\" if transaction was accepted but not relayed. status - string; General RPC error code. \"OK\" means everything looks good. Any other value means that something went wrong. too_big - boolean; Transaction size is too big ( true ) or OK ( false ). untrusted - boolean; States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). Example (No return information included here.): $ curl -X POST http://127.0.0.1:18081/send_raw_transaction -d '{\"tx_as_hex\":\"de6a3...\", \"do_not_relay\":false}' -H 'Content-Type: application/json'","title":"/send_raw_transaction"},{"location":"Developer/DaemonRPCGuide/#start_mining","text":"Start mining on the daemon. Alias: None . Inputs: do_background_mining - boolean; States if the mining should run in background ( true ) or foreground ( false ). ignore_battery - boolean; States if batery state (on laptop) should be ignored ( true ) or not ( false ). miner_address - string; Account address to mine to. threads_count - unsigned int; Number of mining thread to run. Outputs: status - string; General RPC error code. \"OK\" means everything looks good. Any other value means that something went wrong. Example: $ curl -X POST http://127.0.0.1:18081/start_mining -d '{\"do_background_mining\":false,\"ignore_battery\":true,\"miner_address\":\"47xu3gQpF569au9C2ajo5SSMrWji6xnoE5vhr94EzFRaKAGw6hEGFXYAwVADKuRpzsjiU1PtmaVgcjUJF89ghGPhUXkndHc\",\"threads_count\":1}' -H 'Content-Type: application/json' { \"status\": \"OK\" }","title":"/start_mining"},{"location":"Developer/DaemonRPCGuide/#stop_mining","text":"Stop mining on the daemon. Alias: None . Inputs: None . Outputs: status - string; General RPC error code. \"OK\" means everything looks good. Any other value means that something went wrong. Example: $ curl -X POST http://127.0.0.1:18081/stop_mining -H 'Content-Type: application/json' { \"status\": \"OK\" }","title":"/stop_mining"},{"location":"Developer/DaemonRPCGuide/#mining_status","text":"Get the mining status of the daemon. Alias: None . Inputs: None . Outputs: active - boolean; States if mining is enabled ( true ) or disabled ( false ). address - string; Account address daemon is mining to. Empty if not mining. is_background_mining_enabled - boolean; States if the mining is running in background ( true ) or foreground ( false ). speed - unsigned int; Mining power in hashes per seconds. status - string; General RPC error code. \"OK\" means everything looks good. Any other value means that something went wrong. threads_count - unsigned int; Number of running mining threads. Example while mining: $ curl -X POST http://127.0.0.1:18081/mining_status -H 'Content-Type: application/json' { \"active\": true, \"address\": \"47xu3gQpF569au9C2ajo5SSMrWji6xnoE5vhr94EzFRaKAGw6hEGFXYAwVADKuRpzsjiU1PtmaVgcjUJF89ghGPhUXkndHc\", \"is_background_mining_enabled\": false, \"speed\": 20, \"status\": \"OK\", \"threads_count\": 1 } Example while not mining: $ curl -X POST http://127.0.0.1:18081/mining_status -H 'Content-Type: application/json' { \"active\": false, \"address\": \"\", \"is_background_mining_enabled\": false, \"speed\": 0, \"status\": \"OK\", \"threads_count\": 0 }","title":"/mining_status"},{"location":"Developer/DaemonRPCGuide/#save_bc","text":"Save the blockchain. The blockchain does not need saving and is always saved when modified, however it does a sync to flush the filesystem cache onto the disk for safety purposes against Operating System or Harware crashes. Alias: None . Inputs: None . Outputs: status - string; General RPC error code. \"OK\" means everything looks good. Any other value means that something went wrong. Example: $ curl -X POST http://127.0.0.1:18081/save_bc -H 'Content-Type: application/json' { \"status\": \"OK\" }","title":"/save_bc"},{"location":"Developer/DaemonRPCGuide/#get_peer_list","text":"Get the known peers list. Alias: None . Inputs: None . Outputs: gray_list - array of offline peer structure as follows: host - unsigned int; IP address in integer format id - string; Peer id ip - unsigned int; IP address in integer format last_seen - unsigned int; unix time at which the peer has been seen for the last time port - unsigned int; TCP port the peer is using to connect to loki network. status - string; General RPC error code. \"OK\" means everything looks good. Any other value means that something went wrong. white_list - array of online peer structure, as above. Example (truncated lists): $ curl -X POST http://127.0.0.1:18081/get_peer_list -H 'Content-Type: application/json' { \"gray_list\": [{ \"host\": \"640304833\", \"id\": 5345237316225602120, \"ip\": 640304833, \"last_seen\": 1525540510, \"port\": 18080 },{ \"host\": \"2183731038\", \"id\": 14955030573998424430, \"ip\": 2183731038, \"last_seen\": 1525540499, \"port\": 28080 }, ... ], \"status\": \"OK\", \"white_list\": [{ \"host\": \"1221637955\", \"id\": 10354694710033118926, \"ip\": 1221637955, \"last_seen\": 1525540511, \"port\": 18080 },{ \"host\": \"1780407354\", \"id\": 17193661050352240890, \"ip\": 1780407354, \"last_seen\": 1525540510, \"port\": 18080 }, ... ] }","title":"/get_peer_list"},{"location":"Developer/DaemonRPCGuide/#set_log_hash_rate","text":"Set the log hash rate display mode. Alias: None . Inputs: visible - boolean; States if hash rate logs should be visible ( true ) or hidden ( false ) Outputs: status - string; General RPC error code. \"OK\" means everything looks good. Any other value means that something went wrong. Example while mining: $ curl -X POST http://127.0.0.1:18081/set_log_hash_rate -d '{\"visible\":true}' -H 'Content-Type: application/json' { \"status\": \"OK\" } Error while not mining: $ curl -X POST http://127.0.0.1:18081/set_log_hash_rate -d '{\"visible\":true}' -H 'Content-Type: application/json' { \"status\": \"NOT MINING\" }","title":"/set_log_hash_rate"},{"location":"Developer/DaemonRPCGuide/#set_log_level","text":"Set the daemon log level. By default, log level is set to 0 . Alias: None . Inputs: level - integer; daemon log level to set from 0 (less verbose) to 4 (most verbose) Outputs: status - string; General RPC error code. \"OK\" means everything looks good. Any other value means that something went wrong. Example: $ curl -X POST http://127.0.0.1:18081/set_log_level -d '{\"level\":1}' -H 'Content-Type: application/json' { \"status\": \"OK\" }","title":"/set_log_level"},{"location":"Developer/DaemonRPCGuide/#set_log_categories","text":"Set the daemon log categories. Categories are represented as a comma separated list of <Category>:<level> (similarly to syslog standard <Facility>:<Severity-level> ), where: Category is one of the following: * - All facilities default net net.http net.p2p logging net.throttle blockchain.db blockchain.db.lmdb bcutil checkpoints net.dns net.dl i18n perf stacktrace updates account cn difficulty hardfork miner blockchain txpool cn.block_queue net.cn daemon debugtools.deserialize debugtools.objectsizes device.ledger wallet.gen_multisig multisig bulletproofs ringct daemon.rpc wallet.simplewallet WalletAPI wallet.ringdb wallet.wallet2 wallet.rpc tests.core Level is one of the following: FATAL - higher level ERROR WARNING INFO DEBUG TRACE - lower level A level automatically includes higher level. By default, categories are set to *:WARNING,net:FATAL,net.p2p:FATAL,net.cn:FATAL,global:INFO,verify:FATAL,stacktrace:INFO,logging:INFO,msgwriter:INFO . Setting the categories to \"\" prevent any logs to be outputed. Alias: None . Inputs: categories - string; Optional, daemon log categories to enable Outputs: categories - string; daemon log enabled categories status - string; General RPC error code. \"OK\" means everything looks good. Any other value means that something went wrong. Example to set all facilities to Security Level Info : $ curl -X POST http://127.0.0.1:18081/set_log_categories -d '{\"categories\": \"*:INFO\"}' -H 'Content-Type: application/json' { \"categories\": \"*:INFO\", \"status\": \"OK\" } Example without input to set the default categories: $ curl -X POST http://127.0.0.1:18081/set_log_categories -H 'Content-Type: application/json' { \"categories\": \"*:WARNING,net:FATAL,net.p2p:FATAL,net.cn:FATAL,global:INFO,verify:FATAL,stacktrace:INFO,logging:INFO,msgwriter:INFO\", \"status\": \"OK\" }","title":"/set_log_categories"},{"location":"Developer/DaemonRPCGuide/#get_transaction_pool","text":"Show information about valid transactions seen by the node but not yet mined into a block, as well as spent key image information for the txpool in the node's memory. Alias: None . Inputs: None . Outputs: spent_key_images - List of spent output key images: id_hash - string; Key image. txs_hashes - string list; tx hashes of the txes (usually one) spending that key image. status - string; General RPC error code. \"OK\" means everything looks good. transactions - List of transactions in the mempool are not in a block on the main chain at the moment: blob_size - unsigned int; The size of the full transaction blob. double_spend_seen - boolean; States if this transaction has been seen as double spend. do_not_relay ; boolean; States if this transaction should not be relayed fee - unsigned int; The amount of the mining fee included in the transaction, in atomic units. id_hash - string; The transaction ID hash. kept_by_block - boolean; States if the tx was included in a block at least once ( true ) or not ( false ). last_failed_height - unsigned int; If the transaction validation has previously failed, this tells at what height that occured. last_failed_id_hash - string; Like the previous, this tells the previous transaction ID hash. last_relayed_time - unsigned int; Last unix time at which the transaction has been relayed. max_used_block_height - unsigned int; Tells the height of the most recent block with an output used in this transaction. max_used_block_hash - string; Tells the hash of the most recent block with an output used in this transaction. receive_time - unsigned int; The Unix time that the transaction was first seen on the network by the node. relayed - boolean; States if this transaction has been relayed tx_blob - unsigned int; Hexadecimal blob represnting the transaction. tx_json - json string; JSON structure of all information in the transaction: version - Transaction version unlock_time - If not 0, this tells when a transaction output is spendable. vin - List of inputs into transaction: key - The public key of the previous output spent in this transaction. amount - The amount of the input, in atomic units. key_offsets - A list of integer offets to the input. k_image - The key image for the given input vout - List of outputs from transaction: amount - Amount of transaction output, in atomic units. target - Output destination information: key - The stealth public key of the receiver. Whoever owns the private key associated with this key controls this transaction output. extra - Usually called the \"transaction ID\" but can be used to include any random 32 bytes. rct_signatures - Ring signatures: type txnFee ecdhInfo - array of Diffie Helman Elipctic curves structures as follows: mask - String amount - String outPk rctsig_prunable rangeSigs - array of structures as follows: asig Ci MGs - array of structures as follows: ss - array of arrays of two strings. cc - String Example (Note: Some lists in the returned information have been truncated for display reasons): $ curl -X POST http://127.0.0.1:18081/get_transaction_pool -H 'Content-Type: application/json' { \"spent_key_images\": [{ \"id_hash\": \"a2af919609db4ff5ab8d4ba18502e647d521760e1cbc30288f06fa87bf9a0c1c\", \"txs_hashes\": [\"1ee6a4873b638711795fc3b0b73fc7146505a09a7f4749534fd408d571a273cf\"] },{ \"id_hash\": \"02d5f6559e9bca5ae5a335130aeeb05df2db518ab9837fa64ebbab276c100792\", \"txs_hashes\": [\"531aacc0ceb8514cdde5f104285202ccc3e969c77584e3c6fa614c987c583965\"] }, ...], \"status\": \"OK\", \"transactions\": [{ \"blob_size\": 13193, \"do_not_relay\": false, \"double_spend_seen\": false, \"fee\": 9694360000, \"id_hash\": \"f8fb875cfc9e2e59bcf96a42474c79e01d50b69e6548d445d45984f7db66e50f\", \"kept_by_block\": false, \"last_failed_height\": 0, \"last_failed_id_hash\": \"0000000000000000000000000000000000000000000000000000000000000000\", \"last_relayed_time\": 1525615049, \"max_used_block_height\": 1564924, \"max_used_block_id_hash\": \"4bae7856979f46c7de31f3fb58cac36d4dfd2765bf33f876edf33d0e05ebb4a7\", \"receive_time\": 1525615049, \"relayed\": true, \"tx_blob\": \" ... \", \"tx_json\": \"{\\n \\\"version\\\": 2, \\n \\\"unlock_time\\\": 0, \\n \\\"vin\\\": [ {\\n \\\"key\\\": {\\n \\\"amount\\\": 0, \\n \\\"key_offsets\\\": [ 2630347, 594429, 1047509, 758973, 464501, 61971, 22268\\n ], \\n \\\"k_image\\\": \\\"0731363c58dd4492f031fa20c82fe6ddcb9cc070d73938afe8a5f7f77897f8b4\\\"\\n }\\n }\\n ], \\n \\\"vout\\\": [ {\\n \\\"amount\\\": 0, \\n \\\"target\\\": {\\n \\\"key\\\": \\\"f3b3dd09483616e343b9866eed50a0ce01d5c0d0f2612ce2c4d0e9cce5c218cd\\\"\\n }\\n }, {\\n \\\"amount\\\": 0, \\n \\\"target\\\": {\\n \\\"key\\\": \\\"9796f2d477a696b6282bf3cb1a41cefba0c4604eedcc2e7a44904d7033643e0e\\\"\\n }\\n }\\n ], \\n \\\"extra\\\": [ 1, 25, 228, 80, 5, 214, 117, 150, 9, 125, 98, 17, 113, 208, 89, 223, 242, 227, 188, 197, 141, 190, 135, 140, 152, 117, 240, 150, 21, 93, 62, 108, 124\\n ], \\n \\\"rct_signatures\\\": {\\n \\\"type\\\": 1, \\n \\\"txnFee\\\": 9694360000, \\n \\\"ecdhInfo\\\": [ {\\n \\\"mask\\\": \\\"645f06a2816aecf83d5041c3320eb31092b994fb2733bb74c8c47e288d452c04\\\", \\n \\\"amount\\\": \\\"3908f14d39dcb3831331cb255eeadc5b0aea0143645b9cd3034abf613995740d\\\"\\n }, {\\n \\\"mask\\\": \\\"0785b5df0a994b14d59da810503a022721d8f629720f526e15bd848ad3c2c509\\\", \\n \\\"amount\\\": \\\"fbd81cf2368dcd742905ded5287457030467aaf5bc9939e13f1d6bf8d4c8ca09\\\"\\n }], \\n \\\"outPk\\\": [ \\\"c19f5fa052859126e0eed0e3c860aadab049677b2b3dd14cc74d02f92f1d013f\\\", \\\"1581ef6368de1608ea366566b88272db220479cf215f6d88d7b60ec221d11e0a\\\"]\\n }, \\n \\\"rctsig_prunable\\\": {\\n \\\"rangeSigs\\\": [ {\\n \\\"asig\\\": \\\" ... \\\", \\n \\\"Ci\\\": \\\" .. \\\"\\n }, {\\n \\\"asig\\\": \\\" ... \\\", \\n \\\"Ci\\\": \\\" ... \\\"\\n }], \\n \\\"MGs\\\": [ {\\n \\\"ss\\\": [ [ \\\"218a10a29e0f66e5a324af67b7734708a8a4cc8f16b28acd8cda538aaa495a02\\\", \\\"b368b4e956df5808c5c257f0dc3f7eff8c28463d0bb20759d19977fa02d6f205\\\"], [ \\\"f741d2c96bc23b362b4155a03fb6f1351ab5bf4445a43b3e52ba776f526af305\\\", \\\"a10ad1ee80dce3f311dd3dc141803daeecaa4d2a25a390cd9c35e4161b7c9e0c\\\"], ...], \\n \\\"cc\\\": \\\"e93801b707261ca76e146fdf2085abae71ad9203a00edc843c74f4ead8a39601\\\"\\n }]\\n }\\n}\" }, ...] }","title":"/get_transaction_pool"},{"location":"Developer/DaemonRPCGuide/#get_transaction_pool_hashesbin","text":"Get hashes from transaction pool. Binary request. Alias: None . Inputs: None . Outputs: status - string; General RPC error code. \"OK\" means everything looks good. tx_hashes - binary array of transaction hashes. untrusted - boolean; States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). Example: $ curl -X POST http://127.0.0.1:18081/get_transaction_pool_hashes.bin -H 'Content-Type: application/json' { \"status\": \"OK\", \"tx_hashes\": \" ... \", \"untrusted\": false }","title":"/get_transaction_pool_hashes.bin"},{"location":"Developer/DaemonRPCGuide/#get_transaction_pool_stats","text":"Get the transaction pool statistics. Alias: None . Inputs: None . Outputs: pool_stats - Structure as follows: bytes_max - unsigned int; Max transaction size in pool bytes_med - unsigned int; Median transaction size in pool bytes_min - unsigned int; Min transaction size in pool bytes_total - unsigned int; total size of all transactions in pool histo - structure txpool_histo as follows: txs - unsigned int; number of transactions bytes - unsigned int; size in bytes. histo_98pc unsigned int; the time 98% of txes are \"younger\" than num_10m unsigned int; number of transactions in pool for more than 10 minutes num_double_spends unsigned int; number of double spend transactions num_failing unsigned int; number of failing transactions num_not_relayed unsigned int; number of non-relayed transactions oldest unsigned int; unix time of the oldest transaction in the pool txs_total unsigned int; total number of transactions. status - string; General RPC error code. \"OK\" means everything looks good. untrusted - boolean; States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). Example: $ curl -X POST http://127.0.0.1:18081/get_transaction_pool_stats -H 'Content-Type: application/json' { \"pool_stats\": { \"bytes_max\": 47222, \"bytes_med\": 13290, \"bytes_min\": 13092, \"bytes_total\": 449511, \"fee_total\": 289715320000, \"histo\": \"\\t\u2592'\u25925\u25924\u2592\\/\u2592\u2592\u2592$3\", \"histo_98pc\": 0, \"num_10m\": 18, \"num_double_spends\": 1, \"num_failing\": 17, \"num_not_relayed\": 0, \"oldest\": 1525457001, \"txs_total\": 26 }, \"status\": \"OK\", \"untrusted\": false }","title":"/get_transaction_pool_stats"},{"location":"Developer/DaemonRPCGuide/#stop_daemon","text":"Send a command to the daemon to safely disconnect and shut down. Alias: None . Inputs: None . Outputs: status - string; General RPC error code. \"OK\" means everything looks good. Example: $ curl -X POST http://127.0.0.1:18081/stop_daemon -H 'Content-Type: application/json' { \"status\": \"OK\" }","title":"/stop_daemon"},{"location":"Developer/DaemonRPCGuide/#get_info-not-json","text":"This method is a convenient backward support and should not be used anymore. See get_info JSON RPC for details. Alias: /getinfo get_info","title":"/get_info (not JSON)"},{"location":"Developer/DaemonRPCGuide/#get_limit","text":"Get daemon bandwidth limits. Alias: None . Inputs: None . Outputs: limit_down - unsigned int; Download limit in kBytes per second limit_up - unsigned int; Upload limit in kBytes per second status - string; General RPC error code. \"OK\" means everything looks good. untrusted - boolean; States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ). Example: $ curl -X POST http://127.0.0.1:18081/get_limit -H 'Content-Type: application/json' { \"limit_down\": 8192, \"limit_up\": 128, \"status\": \"OK\", \"untrusted\": false }","title":"/get_limit"},{"location":"Developer/DaemonRPCGuide/#set_limit","text":"Set daemon bandwidth limits. Alias: None . Inputs: limit_down - signed int; Download limit in kBytes per second (-1 reset to default, 0 don't change the current limit) limit_up - signed int; Upload limit in kBytes per second (-1 reset to default, 0 don't change the current limit) Outputs: limit_down - unsigned int; Download limit in kBytes per second limit_up - unsigned int; Upload limit in kBytes per second status - string; General RPC error code. \"OK\" means everything looks good. Example: $ curl -X POST http://127.0.0.1:18081/set_limit -d '{\"limit_down\": 1024}' -H 'Content-Type: application/json' { \"limit_down\": 1024, \"limit_up\": 128, \"status\": \"OK\" }","title":"/set_limit"},{"location":"Developer/DaemonRPCGuide/#out_peers","text":"Limit number of Outgoing peers. Alias: None . Inputs: out_peers - unsigned int; Max number of outgoing peers Outputs: status - string; General RPC error code. \"OK\" means everything looks good. Example: $ curl -X POST http://127.0.0.1:18081/out_peers -d '{\"out_peers\": 3232235535}' -H 'Content-Type: application/json' { \"status\": \"OK\" }","title":"/out_peers"},{"location":"Developer/DaemonRPCGuide/#in_peers","text":"Limit number of Incoming peers. Alias: None . Inputs: in_peers - unsigned int; Max number of incoming peers Outputs: status - string; General RPC error code. \"OK\" means everything looks good. Example: $ curl -X POST http://127.0.0.1:18081/out_peers -d '{\"in_peers\": 3232235535}' -H 'Content-Type: application/json' { \"status\": \"OK\" }","title":"/in_peers"},{"location":"Developer/DaemonRPCGuide/#start_save_graph","text":"Obsolete. Conserved here for reference. Alias: None . Inputs: None . Outputs: status - string; General RPC error code. \"OK\" means everything looks good. Example: $ curl -X POST http://127.0.0.1:18081/start_save_graph -H 'Content-Type: application/json' { \"status\": \"OK\" }","title":"/start_save_graph"},{"location":"Developer/DaemonRPCGuide/#stop_save_graph","text":"Obsolete. Conserved here for reference. Alias: None . Inputs: None . Outputs: status - string; General RPC error code. \"OK\" means everything looks good. Example: $ curl -X POST http://127.0.0.1:18081/stop_save_graph -H 'Content-Type: application/json' { \"status\": \"OK\" }","title":"/stop_save_graph"},{"location":"Developer/DaemonRPCGuide/#get_outs","text":"Get outputs. Alias: None . Inputs: outputs array of get_outputs_out structure as follows: amount - unsigned int; index - unsigned int; Outputs: outs - array of structure outkey as follows: height - unsigned int; block height of the output key - String; the public key of the output mask - String txid - String; transaction id unlocked - boolean; States if output is locked ( false ) or not ( true ) status - string; General RPC error code. \"OK\" means everything looks good. untrusted - boolean; States if the result is obtained using the bootstrap mode, and is therefore not trusted ( true ), or when the daemon is fully synced ( false ).","title":"/get_outs"},{"location":"Developer/DaemonRPCGuide/#update","text":"Update daemon. Alias: None . Inputs: command - String; command to use, either check or download path - String; Optional, path where to download the update. Outputs: auto_uri - string; hash - string; path - String; path to download the update status - string; General RPC error code. \"OK\" means everything looks good. update - boolean; States if an update is available to download ( true ) or not ( false ) user_uri - string; version - string; Version available for download. Example: $ curl -X POST http://127.0.0.1:18081/update -d '{\"command\":\"check\"}' -H 'Content-Type: application/json' { \"auto_uri\": \"\", \"hash\": \"\", \"path\": \"\", \"status\": \"OK\", \"update\": false, \"user_uri\": \"\", \"version\": \"\" }","title":"/update"},{"location":"Developer/DaemonRPCGuide/#sources","text":"Reworked from GetMonero.org RPC calls for Loki under their copyright license .","title":"Sources:"},{"location":"Developer/FAQ/","text":"FAQ \u00b6 Hardfork Version 10: Bulletproofs \u00b6 get_block_template Updates \u00b6 Due to batching of Governance rewards the calculation of rewards has been updated in Loki. As a side effect of this, in the get_block_template json response, expected_reward now returns only the miner reward instead of the entire block reward. For example, pre-hardfork 9, if the block reward was 100, expected_reward returned 100, even though ~50% of the reward was sent to the service node. Post Bulletproofs hardfork, expected_reward now returns 50, which is the exact amount the miner would receive. A real example of this is on the testnet, for block 63056. Calling get_block_template on block 63056 curl -X POST http://127.0.0.1:38157/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_block_template\",\"params\":{\"wallet_address\":\"T6TBLkrPd7KQubsczrfHCEi5T4prNEH5Sax9phVicLp9H5s2xAvnJaYWs26xL2s2wy838FXdmgds2TDX5f75wnLt1Zxmiq3rm\",\"reserve_size\":60}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"blockhashing_blob\": \"0a0ad9e3c6e0050e34f22aeb5fc6ef48e99f9b7e87f3c72666a944c0e5e8c13659e09c934708dd00000000add4d0b6d74e9d17d4e65a64e2f6f47959a3fa60cd92af0f9ac0a771a31920ec01\", \"blocktemplate_blob\": \"0a0ad9e3c6e0050e34f22aeb5fc6ef48e99f9b7e87f3c72666a944c0e5e8c13659e09c934708dd000000000302eeec03eeec0300eeec0301ffd0ec0302fea381ab840102eea98077132617bdf7c78c211674e704a73a82b5e6fb2361e9f08c20403b301dd2d28f85930102cee0e4e9534167d66200577aa84b73c318ea494538b1a0af5521e90500835651a101019a58d937a55a6a7b6df6c42aba6d6790be8f5b1b2bfecdb8658ba0836e285912023c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000101dda172e3c0d0da4381557e1d65319d0cfb0da9f6d83b716de5b8e127ddd7f572fcb147715be4f8f3cd5d25aae839e217bda00bb7bb02c21b00cdd5a18cd38aba0000\", \"difficulty\": 11367, \"expected_reward\": 35523678718, \"height\": 63056, \"prev_hash\": \"0e34f22aeb5fc6ef48e99f9b7e87f3c72666a944c0e5e8c13659e09c934708dd\", \"reserved_offset\": 176, \"status\": \"OK\", \"untrusted\": false } } Calling get_block on block 63056 { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"blob\": \"0a0ae7e3c6e0050e34f22aeb5fc6ef48e99f9b7e87f3c72666a944c0e5e8c13659e09c934708ddd43bd8000302eeec03eeec0300eeec0301ffd0ec0302fea381ab840102ee55cf39cb6f15d22454101cccf6b7d41f1fdb5588e463404eca4b56cbd5bbc3d2d28f85930102cee0e4e9534167d66200577aa84b73c318ea494538b1a0af5521e9050083565163014e8a0d6c156a927b0f10a790d4cacede2cb2cd3b6f3fc3ed98664c303c08b97b0101dda172e3c0d0da4381557e1d65319d0cfb0da9f6d83b716de5b8e127ddd7f572fcb147715be4f8f3cd5d25aae839e217bda00bb7bb02c21b00cdd5a18cd38aba0000\", \"block_header\": { \"block_size\": 197, \"block_weight\": 197, \"cumulative_difficulty\": 607871777, \"depth\": 1, \"difficulty\": 11367, \"hash\": \"737da055d2fb78f07200a7f3ee0acbf9b00ec3536ab27920a656dd75a253fab6\", \"height\": 63056, \"major_version\": 10, \"minor_version\": 10, \"nonce\": 14171092, \"num_txes\": 0, \"orphan_status\": false, \"pow_hash\": \"\", \"prev_hash\": \"0e34f22aeb5fc6ef48e99f9b7e87f3c72666a944c0e5e8c13659e09c934708dd\", \"reward\": 74994432848, \"timestamp\": 1544663527 }, \"json\": { \"major_version\": 10, \"minor_version\": 10, \"timestamp\": 1544663527, \"prev_id\": \"0e34f22aeb5fc6ef48e99f9b7e87f3c72666a944c0e5e8c13659e09c934708dd\", \"nonce\": 14171092, \"miner_tx\": { \"version\": 3, \"output_unlock_times\": [ 63086, 63086 ], \"is_deregister\": \"00\", \"unlock_time\": 63086, \"vin\": [ { \"gen\": { \"height\": 63056 } } ], \"vout\": [ { \"amount\": 35523678718, \"target\": { \"key\": \"ee55cf39cb6f15d22454101cccf6b7d41f1fdb5588e463404eca4b56cbd5bbc3\" } }, { \"amount\": 39470754130, \"target\": { \"key\": \"cee0e4e9534167d66200577aa84b73c318ea494538b1a0af5521e90500835651\" } } ], \"extra\": [ 1, 78, 138, 13, 108, 21, 106, 146, 123, 15, 16, 167, 144, 212, 202, 206, 222, 44, 178, 205, 59, 111, 63, 195, 237, 152, 102, 76, 48, 60, 8, 185, 123, 1, 1, 221, 161, 114, 227, 192, 208, 218, 67, 129, 85, 126, 29, 101, 49, 157, 12, 251, 13, 169, 246, 216, 59, 113, 109, 229, 184, 225, 39, 221, 215, 245, 114, 252, 177, 71, 113, 91, 228, 248, 243, 205, 93, 37, 170, 232, 57, 226, 23, 189, 160, 11, 183, 187, 2, 194, 27, 0, 205, 213, 161, 140, 211, 138, 186 ], \"rct_signatures\": { \"type\": 0 } }, \"tx_hashes\": [] }, \"miner_tx_hash\": \"6993f786d3bcf50a2ae242d245b4de519c38903c062d59f8a30ed2af1f80934b\", \"status\": \"OK\", \"untrusted\": false } } Of importance, from get_block_template ... \"expected_reward\": 35523678718, ... And get_block ... \"vout\": [ { \"amount\": 35523678718, \"target\": { \"key\": \"ee55cf39cb6f15d22454101cccf6b7d41f1fdb5588e463404eca4b56cbd5bbc3\" } }, { \"amount\": 39470754130, \"target\": { \"key\": \"cee0e4e9534167d66200577aa84b73c318ea494538b1a0af5521e90500835651\" } } ], ... The expected_reward is the same amount as the 1st vout amount in get_block which is the miner output (the 2nd being the Service Node Output). In summary, the expected_reward returned by get_block_template is exactly the reward the miner will receive. Extracting Reward Amounts from Block Outputs \u00b6 In the Bulletproofs hardfork, batching of Governance rewards was introduced and removes the governance output from most miner transactions. This means, for most blocks the outputs will only include the Miner reward and the Service Node reward. The Governance reward is paid out every GOVERNANCE_REWARD_INTERVAL number of blocks, in code this is checked as (block_height % GOVERNANCE_REWARD_INTERVAL == 0) . Block Outputs [ 0] Miner Reward [ ..] Service Node Reward [ N] [N+1] Governance Reward (Appears every GOVERNANCE_REWARD_INTERVAL blocks) An example miner transaction JSON output with the Governance reward { \"version\" : 3 , \"output_unlock_times\" : [ 49030 , 49030 , 49030 , 49030 , 49030 ], \"is_deregister\" : \"00\" , \"unlock_time\" : 49030 , \"vin\" : [ { \"gen\" : { \"height\" : 49000 } } ], \"vout\" : [ { \"amount\" : 39242919169 , \"target\" : { \"key\" : \"1b318acc5674f71997c69710e2de96baa4d1776f19e5938381fa6f12d2d80eb8\" } }, { \"amount\" : 22237654195 , \"target\" : { \"key\" : \"4bb2511f0e46de56b07dfec51499feb027cb2f8ea6eff4ed93b176ef0d3de534\" } }, { \"amount\" : 10682794662 , \"target\" : { \"key\" : \"77446399029849e67ebd1df7728241920b7fa16c48c7794bf9dc15605b5d35f9\" } }, { \"amount\" : 10682794662 , \"target\" : { \"key\" : \"0fe5af8f07c09f07291d7e9b13ec45f35d2535a04e1ca710a1acad4c6f1a6665\" } }, { \"amount\" : 4376229747993 , \"target\" : { \"key\" : \"f1a6a802c4708a1c6eb083078290087d3974ce6ea72251821cd47c64325cf98f\" } } ], \"extra\" : [ 1 , 51 , 91 , 83 , 33 , 151 , 51 , 186 , 159 , 157 , 22 , 207 , 125 , 106 , 249 , 180 , 78 , 209 , 115 , 87 , 137 , 148 , 111 , 194 , 29 , 183 , 127 , 195 , 221 , 207 , 112 , 147 , 96 , 1 , 15 , 153 , 186 , 200 , 221 , 217 , 236 , 119 , 34 , 82 , 16 , 3 , 88 , 68 , 231 , 87 , 37 , 85 , 215 , 211 , 227 , 140 , 211 , 75 , 139 , 67 , 116 , 190 , 86 , 79 , 78 , 243 , 114 , 163 , 227 , 143 , 84 , 151 , 173 , 48 , 235 , 64 , 252 , 86 , 154 , 104 , 127 , 82 , 18 , 101 , 176 , 99 , 196 , 186 , 255 , 191 , 85 , 34 , 135 , 248 , 100 , 29 , 238 , 82 , 80 ], \"rct_signatures\" : { \"type\" : 0 } } An example miner transaction JSON output without the Governance reward { \"version\" : 3 , \"output_unlock_times\" : [ 49029 , 49029 ], \"is_deregister\" : \"00\" , \"unlock_time\" : 49029 , \"vin\" : [ { \"gen\" : { \"height\" : 48999 } } ], \"vout\" : [ { \"amount\" : 39243204162 , \"target\" : { \"key\" : \"f57b08e200dc36a27b4cfe7ad4276103951c832153a46e3ba0fa613493dcd989\" } }, { \"amount\" : 43603560179 , \"target\" : { \"key\" : \"6d5e496c1171ca87345f43203ca14bbd09928368322372b621c9d56ee5c04816\" } } ], \"extra\" : [ 1 , 111 , 176 , 48 , 118 , 238 , 20 , 185 , 147 , 73 , 50 , 237 , 56 , 244 , 35 , 100 , 209 , 18 , 212 , 20 , 86 , 198 , 62 , 67 , 138 , 81 , 80 , 191 , 70 , 208 , 1 , 245 , 91 , 1 , 11 , 40 , 147 , 97 , 124 , 226 , 43 , 104 , 88 , 49 , 95 , 19 , 238 , 240 , 167 , 62 , 187 , 128 , 112 , 79 , 25 , 145 , 98 , 176 , 162 , 207 , 79 , 7 , 2 , 59 , 216 , 8 , 114 , 86 , 239 , 115 , 20 , 49 , 190 , 232 , 248 , 253 , 178 , 163 , 240 , 56 , 147 , 237 , 152 , 185 , 252 , 116 , 154 , 225 , 95 , 58 , 159 , 122 , 64 , 249 , 51 , 183 , 239 , 255 , 227 ], \"rct_signatures\" : { \"type\" : 0 } } Hardfork Version 9: Service Nodes \u00b6 Extracting Reward Amounts from Block Outputs \u00b6 This hardfork introduces Service Node rewards to the outputs of the miner transaction. Service Nodes can split the given reward with up to 4 participants. Then, at most the miner transaction can have a maximum of 6 outputs, 1 reserved for the miner, 1 for governance, up to 4 for service node participants. Transaction Outputs [ 0] Miner Reward [ ..] Service Node Reward [ N] [N+1] Governance Reward An example miner transaction JSON output with 4 service node participants looks like { \"version\" : 3 , \"output_unlock_times\" : [ 155552 , 155552 , 155552 , 155552 , 155552 , 155552 ], \"is_deregister\" : \"00\" , \"unlock_time\" : 155552 , \"vin\" : [ { \"gen\" : { \"height\" : 155522 } } ], \"vout\" : [ { \"amount\" : 21165158143 , \"target\" : { \"key\" : \"8e0870425ad7f7709d6a4125a7088f0dd284e5b0415248b4b8556678ad4f3a3d\" } }, { \"amount\" : 6221340556 , \"target\" : { \"key\" : \"03491d83a076a74df6c6d726aeffd2cc4c59ae56107c730a195ee329d838e088\" } }, { \"amount\" : 6607995571 , \"target\" : { \"key\" : \"a54619d6b0b68c8d824445336d5dd246338aa7482546118f48d32f5d92a3aad8\" } }, { \"amount\" : 6874654507 , \"target\" : { \"key\" : \"3941327ebcb42c3fa78fa450e0d7d1cf40b501832f0b4d9cc7a4654b4c1f685b\" } }, { \"amount\" : 3769035241 , \"target\" : { \"key\" : \"a8184d530cb7180590c04a19c38ba52c055d6ffcdfdad2fb62b8802477f11117\" } }, { \"amount\" : 2347302587 , \"target\" : { \"key\" : \"554f16bd4a06364b27edf898b5358b4e3f5c1218f3dc415d48eb2bff4707cf42\" } } ], \"extra\" : [ 1 , 183 , 139 , 12 , 51 , 196 , 162 , 46 , 137 , 28 , 148 , 226 , 122 , 234 , 40 , 128 , 33 , 255 , 251 , 170 , 208 , 13 , 80 , 26 , 17 , 125 , 130 , 59 , 48 , 77 , 47 , 141 , 124 , 2 , 48 , 57 , 48 , 48 , 49 , 0 , 5 , 0 , 0 , 0 , 35 , 179 , 201 , 210 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 175 , 103 , 128 , 158 , 243 , 146 , 164 , 73 , 129 , 26 , 30 , 121 , 232 , 11 , 191 , 215 , 180 , 172 , 163 , 109 , 3 , 24 , 155 , 215 , 12 , 91 , 205 , 228 , 207 , 230 , 98 , 195 , 114 , 42 , 113 , 8 , 57 , 98 , 253 , 18 , 228 , 209 , 176 , 148 , 179 , 127 , 111 , 216 , 201 , 220 , 3 , 125 , 188 , 119 , 29 , 34 , 140 , 51 , 224 , 211 , 10 , 53 , 119 , 58 , 1 ], \"rct_signatures\" : { \"type\" : 0 } }","title":"Developer FAQ"},{"location":"Developer/FAQ/#faq","text":"","title":"FAQ"},{"location":"Developer/FAQ/#hardfork-version-10-bulletproofs","text":"","title":"Hardfork Version 10: Bulletproofs"},{"location":"Developer/FAQ/#get_block_template-updates","text":"Due to batching of Governance rewards the calculation of rewards has been updated in Loki. As a side effect of this, in the get_block_template json response, expected_reward now returns only the miner reward instead of the entire block reward. For example, pre-hardfork 9, if the block reward was 100, expected_reward returned 100, even though ~50% of the reward was sent to the service node. Post Bulletproofs hardfork, expected_reward now returns 50, which is the exact amount the miner would receive. A real example of this is on the testnet, for block 63056. Calling get_block_template on block 63056 curl -X POST http://127.0.0.1:38157/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_block_template\",\"params\":{\"wallet_address\":\"T6TBLkrPd7KQubsczrfHCEi5T4prNEH5Sax9phVicLp9H5s2xAvnJaYWs26xL2s2wy838FXdmgds2TDX5f75wnLt1Zxmiq3rm\",\"reserve_size\":60}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"blockhashing_blob\": \"0a0ad9e3c6e0050e34f22aeb5fc6ef48e99f9b7e87f3c72666a944c0e5e8c13659e09c934708dd00000000add4d0b6d74e9d17d4e65a64e2f6f47959a3fa60cd92af0f9ac0a771a31920ec01\", \"blocktemplate_blob\": \"0a0ad9e3c6e0050e34f22aeb5fc6ef48e99f9b7e87f3c72666a944c0e5e8c13659e09c934708dd000000000302eeec03eeec0300eeec0301ffd0ec0302fea381ab840102eea98077132617bdf7c78c211674e704a73a82b5e6fb2361e9f08c20403b301dd2d28f85930102cee0e4e9534167d66200577aa84b73c318ea494538b1a0af5521e90500835651a101019a58d937a55a6a7b6df6c42aba6d6790be8f5b1b2bfecdb8658ba0836e285912023c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000101dda172e3c0d0da4381557e1d65319d0cfb0da9f6d83b716de5b8e127ddd7f572fcb147715be4f8f3cd5d25aae839e217bda00bb7bb02c21b00cdd5a18cd38aba0000\", \"difficulty\": 11367, \"expected_reward\": 35523678718, \"height\": 63056, \"prev_hash\": \"0e34f22aeb5fc6ef48e99f9b7e87f3c72666a944c0e5e8c13659e09c934708dd\", \"reserved_offset\": 176, \"status\": \"OK\", \"untrusted\": false } } Calling get_block on block 63056 { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"blob\": \"0a0ae7e3c6e0050e34f22aeb5fc6ef48e99f9b7e87f3c72666a944c0e5e8c13659e09c934708ddd43bd8000302eeec03eeec0300eeec0301ffd0ec0302fea381ab840102ee55cf39cb6f15d22454101cccf6b7d41f1fdb5588e463404eca4b56cbd5bbc3d2d28f85930102cee0e4e9534167d66200577aa84b73c318ea494538b1a0af5521e9050083565163014e8a0d6c156a927b0f10a790d4cacede2cb2cd3b6f3fc3ed98664c303c08b97b0101dda172e3c0d0da4381557e1d65319d0cfb0da9f6d83b716de5b8e127ddd7f572fcb147715be4f8f3cd5d25aae839e217bda00bb7bb02c21b00cdd5a18cd38aba0000\", \"block_header\": { \"block_size\": 197, \"block_weight\": 197, \"cumulative_difficulty\": 607871777, \"depth\": 1, \"difficulty\": 11367, \"hash\": \"737da055d2fb78f07200a7f3ee0acbf9b00ec3536ab27920a656dd75a253fab6\", \"height\": 63056, \"major_version\": 10, \"minor_version\": 10, \"nonce\": 14171092, \"num_txes\": 0, \"orphan_status\": false, \"pow_hash\": \"\", \"prev_hash\": \"0e34f22aeb5fc6ef48e99f9b7e87f3c72666a944c0e5e8c13659e09c934708dd\", \"reward\": 74994432848, \"timestamp\": 1544663527 }, \"json\": { \"major_version\": 10, \"minor_version\": 10, \"timestamp\": 1544663527, \"prev_id\": \"0e34f22aeb5fc6ef48e99f9b7e87f3c72666a944c0e5e8c13659e09c934708dd\", \"nonce\": 14171092, \"miner_tx\": { \"version\": 3, \"output_unlock_times\": [ 63086, 63086 ], \"is_deregister\": \"00\", \"unlock_time\": 63086, \"vin\": [ { \"gen\": { \"height\": 63056 } } ], \"vout\": [ { \"amount\": 35523678718, \"target\": { \"key\": \"ee55cf39cb6f15d22454101cccf6b7d41f1fdb5588e463404eca4b56cbd5bbc3\" } }, { \"amount\": 39470754130, \"target\": { \"key\": \"cee0e4e9534167d66200577aa84b73c318ea494538b1a0af5521e90500835651\" } } ], \"extra\": [ 1, 78, 138, 13, 108, 21, 106, 146, 123, 15, 16, 167, 144, 212, 202, 206, 222, 44, 178, 205, 59, 111, 63, 195, 237, 152, 102, 76, 48, 60, 8, 185, 123, 1, 1, 221, 161, 114, 227, 192, 208, 218, 67, 129, 85, 126, 29, 101, 49, 157, 12, 251, 13, 169, 246, 216, 59, 113, 109, 229, 184, 225, 39, 221, 215, 245, 114, 252, 177, 71, 113, 91, 228, 248, 243, 205, 93, 37, 170, 232, 57, 226, 23, 189, 160, 11, 183, 187, 2, 194, 27, 0, 205, 213, 161, 140, 211, 138, 186 ], \"rct_signatures\": { \"type\": 0 } }, \"tx_hashes\": [] }, \"miner_tx_hash\": \"6993f786d3bcf50a2ae242d245b4de519c38903c062d59f8a30ed2af1f80934b\", \"status\": \"OK\", \"untrusted\": false } } Of importance, from get_block_template ... \"expected_reward\": 35523678718, ... And get_block ... \"vout\": [ { \"amount\": 35523678718, \"target\": { \"key\": \"ee55cf39cb6f15d22454101cccf6b7d41f1fdb5588e463404eca4b56cbd5bbc3\" } }, { \"amount\": 39470754130, \"target\": { \"key\": \"cee0e4e9534167d66200577aa84b73c318ea494538b1a0af5521e90500835651\" } } ], ... The expected_reward is the same amount as the 1st vout amount in get_block which is the miner output (the 2nd being the Service Node Output). In summary, the expected_reward returned by get_block_template is exactly the reward the miner will receive.","title":"get_block_template Updates"},{"location":"Developer/FAQ/#extracting-reward-amounts-from-block-outputs","text":"In the Bulletproofs hardfork, batching of Governance rewards was introduced and removes the governance output from most miner transactions. This means, for most blocks the outputs will only include the Miner reward and the Service Node reward. The Governance reward is paid out every GOVERNANCE_REWARD_INTERVAL number of blocks, in code this is checked as (block_height % GOVERNANCE_REWARD_INTERVAL == 0) . Block Outputs [ 0] Miner Reward [ ..] Service Node Reward [ N] [N+1] Governance Reward (Appears every GOVERNANCE_REWARD_INTERVAL blocks) An example miner transaction JSON output with the Governance reward { \"version\" : 3 , \"output_unlock_times\" : [ 49030 , 49030 , 49030 , 49030 , 49030 ], \"is_deregister\" : \"00\" , \"unlock_time\" : 49030 , \"vin\" : [ { \"gen\" : { \"height\" : 49000 } } ], \"vout\" : [ { \"amount\" : 39242919169 , \"target\" : { \"key\" : \"1b318acc5674f71997c69710e2de96baa4d1776f19e5938381fa6f12d2d80eb8\" } }, { \"amount\" : 22237654195 , \"target\" : { \"key\" : \"4bb2511f0e46de56b07dfec51499feb027cb2f8ea6eff4ed93b176ef0d3de534\" } }, { \"amount\" : 10682794662 , \"target\" : { \"key\" : \"77446399029849e67ebd1df7728241920b7fa16c48c7794bf9dc15605b5d35f9\" } }, { \"amount\" : 10682794662 , \"target\" : { \"key\" : \"0fe5af8f07c09f07291d7e9b13ec45f35d2535a04e1ca710a1acad4c6f1a6665\" } }, { \"amount\" : 4376229747993 , \"target\" : { \"key\" : \"f1a6a802c4708a1c6eb083078290087d3974ce6ea72251821cd47c64325cf98f\" } } ], \"extra\" : [ 1 , 51 , 91 , 83 , 33 , 151 , 51 , 186 , 159 , 157 , 22 , 207 , 125 , 106 , 249 , 180 , 78 , 209 , 115 , 87 , 137 , 148 , 111 , 194 , 29 , 183 , 127 , 195 , 221 , 207 , 112 , 147 , 96 , 1 , 15 , 153 , 186 , 200 , 221 , 217 , 236 , 119 , 34 , 82 , 16 , 3 , 88 , 68 , 231 , 87 , 37 , 85 , 215 , 211 , 227 , 140 , 211 , 75 , 139 , 67 , 116 , 190 , 86 , 79 , 78 , 243 , 114 , 163 , 227 , 143 , 84 , 151 , 173 , 48 , 235 , 64 , 252 , 86 , 154 , 104 , 127 , 82 , 18 , 101 , 176 , 99 , 196 , 186 , 255 , 191 , 85 , 34 , 135 , 248 , 100 , 29 , 238 , 82 , 80 ], \"rct_signatures\" : { \"type\" : 0 } } An example miner transaction JSON output without the Governance reward { \"version\" : 3 , \"output_unlock_times\" : [ 49029 , 49029 ], \"is_deregister\" : \"00\" , \"unlock_time\" : 49029 , \"vin\" : [ { \"gen\" : { \"height\" : 48999 } } ], \"vout\" : [ { \"amount\" : 39243204162 , \"target\" : { \"key\" : \"f57b08e200dc36a27b4cfe7ad4276103951c832153a46e3ba0fa613493dcd989\" } }, { \"amount\" : 43603560179 , \"target\" : { \"key\" : \"6d5e496c1171ca87345f43203ca14bbd09928368322372b621c9d56ee5c04816\" } } ], \"extra\" : [ 1 , 111 , 176 , 48 , 118 , 238 , 20 , 185 , 147 , 73 , 50 , 237 , 56 , 244 , 35 , 100 , 209 , 18 , 212 , 20 , 86 , 198 , 62 , 67 , 138 , 81 , 80 , 191 , 70 , 208 , 1 , 245 , 91 , 1 , 11 , 40 , 147 , 97 , 124 , 226 , 43 , 104 , 88 , 49 , 95 , 19 , 238 , 240 , 167 , 62 , 187 , 128 , 112 , 79 , 25 , 145 , 98 , 176 , 162 , 207 , 79 , 7 , 2 , 59 , 216 , 8 , 114 , 86 , 239 , 115 , 20 , 49 , 190 , 232 , 248 , 253 , 178 , 163 , 240 , 56 , 147 , 237 , 152 , 185 , 252 , 116 , 154 , 225 , 95 , 58 , 159 , 122 , 64 , 249 , 51 , 183 , 239 , 255 , 227 ], \"rct_signatures\" : { \"type\" : 0 } }","title":"Extracting Reward Amounts from Block Outputs"},{"location":"Developer/FAQ/#hardfork-version-9-service-nodes","text":"","title":"Hardfork Version 9: Service Nodes"},{"location":"Developer/FAQ/#extracting-reward-amounts-from-block-outputs_1","text":"This hardfork introduces Service Node rewards to the outputs of the miner transaction. Service Nodes can split the given reward with up to 4 participants. Then, at most the miner transaction can have a maximum of 6 outputs, 1 reserved for the miner, 1 for governance, up to 4 for service node participants. Transaction Outputs [ 0] Miner Reward [ ..] Service Node Reward [ N] [N+1] Governance Reward An example miner transaction JSON output with 4 service node participants looks like { \"version\" : 3 , \"output_unlock_times\" : [ 155552 , 155552 , 155552 , 155552 , 155552 , 155552 ], \"is_deregister\" : \"00\" , \"unlock_time\" : 155552 , \"vin\" : [ { \"gen\" : { \"height\" : 155522 } } ], \"vout\" : [ { \"amount\" : 21165158143 , \"target\" : { \"key\" : \"8e0870425ad7f7709d6a4125a7088f0dd284e5b0415248b4b8556678ad4f3a3d\" } }, { \"amount\" : 6221340556 , \"target\" : { \"key\" : \"03491d83a076a74df6c6d726aeffd2cc4c59ae56107c730a195ee329d838e088\" } }, { \"amount\" : 6607995571 , \"target\" : { \"key\" : \"a54619d6b0b68c8d824445336d5dd246338aa7482546118f48d32f5d92a3aad8\" } }, { \"amount\" : 6874654507 , \"target\" : { \"key\" : \"3941327ebcb42c3fa78fa450e0d7d1cf40b501832f0b4d9cc7a4654b4c1f685b\" } }, { \"amount\" : 3769035241 , \"target\" : { \"key\" : \"a8184d530cb7180590c04a19c38ba52c055d6ffcdfdad2fb62b8802477f11117\" } }, { \"amount\" : 2347302587 , \"target\" : { \"key\" : \"554f16bd4a06364b27edf898b5358b4e3f5c1218f3dc415d48eb2bff4707cf42\" } } ], \"extra\" : [ 1 , 183 , 139 , 12 , 51 , 196 , 162 , 46 , 137 , 28 , 148 , 226 , 122 , 234 , 40 , 128 , 33 , 255 , 251 , 170 , 208 , 13 , 80 , 26 , 17 , 125 , 130 , 59 , 48 , 77 , 47 , 141 , 124 , 2 , 48 , 57 , 48 , 48 , 49 , 0 , 5 , 0 , 0 , 0 , 35 , 179 , 201 , 210 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 175 , 103 , 128 , 158 , 243 , 146 , 164 , 73 , 129 , 26 , 30 , 121 , 232 , 11 , 191 , 215 , 180 , 172 , 163 , 109 , 3 , 24 , 155 , 215 , 12 , 91 , 205 , 228 , 207 , 230 , 98 , 195 , 114 , 42 , 113 , 8 , 57 , 98 , 253 , 18 , 228 , 209 , 176 , 148 , 179 , 127 , 111 , 216 , 201 , 220 , 3 , 125 , 188 , 119 , 29 , 34 , 140 , 51 , 224 , 211 , 10 , 53 , 119 , 58 , 1 ], \"rct_signatures\" : { \"type\" : 0 } }","title":"Extracting Reward Amounts from Block Outputs"},{"location":"Developer/SNRPCGuide/","text":"Service Nodes Guide \u00b6 JSON 2.0 RPC Calls \u00b6 get_quorum_state \u00b6 Get the quorum state which is the list of public keys of the nodes who are voting, and the list of public keys of the nodes who are being tested. Testnet Example \u00b6 curl -X POST http://127.0.0.1:38157/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_quorum_state\", \"params\": {\"height\": 200}}' -H 'Content-Type: application/json' Result \u00b6 { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"nodes_to_test\": [\"578e5ee53150a3276dd3c411cb6313324a63b530cf3651f5c15e3d0ca58ceddd\", \u2026 \"c917034e9fcd0e9b0d423638664bbfc36eb8a2eeb68a1ff8bed8be5f699bc3c0\"], \"quorum_nodes\": [\"fc86a737756b6ed9f81233d22da3baee32537f3087901c3e94384be85ca1a9ee\", \u2026 \"ee597c5c7bbf1452e689a785f1133fc1355889b4111955d54cb5ed826cd35a32\"], \"status\": \"OK\", \"untrusted\": false } } Nodes have been omitted with \u201c...\u201d for brevity in nodes_to_test and quorum_nodes. Inputs \u00b6 Int height The height to query the quorum state for Outputs \u00b6 String[] nodes_to_test An array of public keys identifying service nodes which are being tested for the queried height. String[] quorum_state An array of public keys identifying service nodes which are responsible for voting on the queried height. get_staking_requirement \u00b6 Get the required amount of Loki to become a Service Node at the queried height. For stagenet and testnet values, ensure the daemon is started with the --stagenet or --testnet flags respectively. Testnet Example \u00b6 curl -X POST http://127.0.0.1:38157/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_staking_requirement\", \"params\": {\u201cheight\u201d: 111111}}' -H 'Content-Type: application/json' Result \u00b6 { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"staking_requirement\": 100000000000, \"status\": \"OK\" } } Inputs \u00b6 Int height The height to query the staking requirement for Outputs \u00b6 Uint64 staking_requirement The staking requirement in Loki atomic units for the queried height get_service_node_key \u00b6 Get the service node public key of the queried daemon. The daemon must be started in --service-node mode otherwise this RPC command will fail. Testnet Example \u00b6 curl -X POST http://127.0.0.1:38157/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_service_node_key\"}' -H 'Content-Type: application/json' Result \u00b6 { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"service_node_pubkey\": \"8d56c1fa0304884e612ee2efe763b2c50991a66329418fd084a3f23c75399f34\", \"status\": \"OK\" } } Inputs \u00b6 N/A Outputs \u00b6 String service_node_pubkey The public key identifying the queried service node get_service_nodes \u00b6 Get the metadata currently associated with the queried service node public keys such as, registration height and contributors, etc. If no public key is specified, this returns all the metadata for every service node the queried daemon currently knows about. Testnet Example \u00b6 curl -X POST http://127.0.0.1:38157/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_service_nodes\", \u201cparams\u201d: {\u201cservice_node_pubkeys\u201d: []}}' -H 'Content-Type: application/json' Result \u00b6 { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"service_node_states\": [{ \"contributors\": [{ \"address\": \"T6T6kZfTEf5JGw2SgLrGuxRNFxRTf51fvbbcCYW949RsKjX75JMA1B1d8CT4VbwfGR8uf3f3AJSTaBHGpN3QRG2N2LyiksWVg\", \"amount\": 100000000000, \"reserved\": 100000000000 }], \"last_reward_block_height\": 2968, \"last_reward_transaction_index\": 4294967295, \"last_uptime_proof\": 0, \"operator_address\": \"T6T6kZfTEf5JGw2SgLrGuxRNFxRTf51fvbbcCYW949RsKjX75JMA1B1d8CT4VbwfGR8uf3f3AJSTaBHGpN3QRG2N2LyiksWVg\", \"portions_for_operator\": 18446744073709551612, \"registration_height\": 1860, \"service_node_pubkey\": \"3afa36a4855a429f5eac1b2f8e7e77657a2e862999ab4d59e473826f9b15f2da\", \"staking_requirement\": 100000000000, \"total_contributed\": 100000000000, \"total_reserved\": 100000000000 }], \"status\": \"OK\" } } Inputs \u00b6 String[] service_node_pubkeys An array of service node public keys in strings that you wish to query metadata for. If an empty array is given, this RPC command returns all service nodes it knows about. Outputs \u00b6 Entry[] service_node_states The array of metadata for the queried service node(s) String service_node_pubkey The queried service node\u2019s identifying public key Uint64 registration_height The height at which the registration transaction arrived on the blockchain Uint64 last_reward_block_height The last block height this service node received a reward. Rewards are sent to service nodes whom have been waiting longest since their last reward and are then sent to the back of the queue. Uint64 last_reward_transaction_index The position in the queue to receive a reward for the service nodes grouped in the last_reward_block_height. Uint64 last_uptime_proof Unix epoch timestamp of the last time this daemon has received a ping from the queried service node. Contribution[] contributors An array consisting of all the addresses that have contributed to the queried service node. Uint64 Contribution.amount The amount of Loki in atomic units the contributor has staked. Uint64 Contribution.reserved The amount of Loki in atomic units the contributor has reserved and must fulfill to completely contribute their part to the service node. Amount is equal to reserved once the contributor has fully contributed their part. String Contribution.address The Loki address that funds must come from to fulfill the contribution requirement. Uint64 total_contributed The total Loki currently contributed going towards the staking requirement. Uint64 total_reserved The total Loki that has been reserved by all contributors. The remaining Loki is open for other contributors to increase their stake towards the service node. Uint64 portions_for_operator The operator cut expressed as a value from 0 -> STAKING_PORTIONS (defined in loki/src/cryptonote_config.h) which is the fee taken from the service node reward and given to the operator address before rewards are distributed to the contributors. Uint64 operator_address The wallet address which is the primary owner of the service node and also the address which the operator cut is sent to.","title":"Service Node RPC Guide"},{"location":"Developer/SNRPCGuide/#service-nodes-guide","text":"","title":"Service Nodes Guide"},{"location":"Developer/SNRPCGuide/#json-20-rpc-calls","text":"","title":"JSON 2.0 RPC Calls"},{"location":"Developer/SNRPCGuide/#get95quorum95state","text":"Get the quorum state which is the list of public keys of the nodes who are voting, and the list of public keys of the nodes who are being tested.","title":"get_quorum_state"},{"location":"Developer/SNRPCGuide/#testnet-example","text":"curl -X POST http://127.0.0.1:38157/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_quorum_state\", \"params\": {\"height\": 200}}' -H 'Content-Type: application/json'","title":"Testnet Example"},{"location":"Developer/SNRPCGuide/#result","text":"{ \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"nodes_to_test\": [\"578e5ee53150a3276dd3c411cb6313324a63b530cf3651f5c15e3d0ca58ceddd\", \u2026 \"c917034e9fcd0e9b0d423638664bbfc36eb8a2eeb68a1ff8bed8be5f699bc3c0\"], \"quorum_nodes\": [\"fc86a737756b6ed9f81233d22da3baee32537f3087901c3e94384be85ca1a9ee\", \u2026 \"ee597c5c7bbf1452e689a785f1133fc1355889b4111955d54cb5ed826cd35a32\"], \"status\": \"OK\", \"untrusted\": false } } Nodes have been omitted with \u201c...\u201d for brevity in nodes_to_test and quorum_nodes.","title":"Result"},{"location":"Developer/SNRPCGuide/#inputs","text":"Int height The height to query the quorum state for","title":"Inputs"},{"location":"Developer/SNRPCGuide/#outputs","text":"String[] nodes_to_test An array of public keys identifying service nodes which are being tested for the queried height. String[] quorum_state An array of public keys identifying service nodes which are responsible for voting on the queried height.","title":"Outputs"},{"location":"Developer/SNRPCGuide/#get95staking95requirement","text":"Get the required amount of Loki to become a Service Node at the queried height. For stagenet and testnet values, ensure the daemon is started with the --stagenet or --testnet flags respectively.","title":"get_staking_requirement"},{"location":"Developer/SNRPCGuide/#testnet-example_1","text":"curl -X POST http://127.0.0.1:38157/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_staking_requirement\", \"params\": {\u201cheight\u201d: 111111}}' -H 'Content-Type: application/json'","title":"Testnet Example"},{"location":"Developer/SNRPCGuide/#result_1","text":"{ \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"staking_requirement\": 100000000000, \"status\": \"OK\" } }","title":"Result"},{"location":"Developer/SNRPCGuide/#inputs_1","text":"Int height The height to query the staking requirement for","title":"Inputs"},{"location":"Developer/SNRPCGuide/#outputs_1","text":"Uint64 staking_requirement The staking requirement in Loki atomic units for the queried height","title":"Outputs"},{"location":"Developer/SNRPCGuide/#get95service95node95key","text":"Get the service node public key of the queried daemon. The daemon must be started in --service-node mode otherwise this RPC command will fail.","title":"get_service_node_key"},{"location":"Developer/SNRPCGuide/#testnet-example_2","text":"curl -X POST http://127.0.0.1:38157/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_service_node_key\"}' -H 'Content-Type: application/json'","title":"Testnet Example"},{"location":"Developer/SNRPCGuide/#result_2","text":"{ \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"service_node_pubkey\": \"8d56c1fa0304884e612ee2efe763b2c50991a66329418fd084a3f23c75399f34\", \"status\": \"OK\" } }","title":"Result"},{"location":"Developer/SNRPCGuide/#inputs_2","text":"N/A","title":"Inputs"},{"location":"Developer/SNRPCGuide/#outputs_2","text":"String service_node_pubkey The public key identifying the queried service node","title":"Outputs"},{"location":"Developer/SNRPCGuide/#get95service95nodes","text":"Get the metadata currently associated with the queried service node public keys such as, registration height and contributors, etc. If no public key is specified, this returns all the metadata for every service node the queried daemon currently knows about.","title":"get_service_nodes"},{"location":"Developer/SNRPCGuide/#testnet-example_3","text":"curl -X POST http://127.0.0.1:38157/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_service_nodes\", \u201cparams\u201d: {\u201cservice_node_pubkeys\u201d: []}}' -H 'Content-Type: application/json'","title":"Testnet Example"},{"location":"Developer/SNRPCGuide/#result_3","text":"{ \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"service_node_states\": [{ \"contributors\": [{ \"address\": \"T6T6kZfTEf5JGw2SgLrGuxRNFxRTf51fvbbcCYW949RsKjX75JMA1B1d8CT4VbwfGR8uf3f3AJSTaBHGpN3QRG2N2LyiksWVg\", \"amount\": 100000000000, \"reserved\": 100000000000 }], \"last_reward_block_height\": 2968, \"last_reward_transaction_index\": 4294967295, \"last_uptime_proof\": 0, \"operator_address\": \"T6T6kZfTEf5JGw2SgLrGuxRNFxRTf51fvbbcCYW949RsKjX75JMA1B1d8CT4VbwfGR8uf3f3AJSTaBHGpN3QRG2N2LyiksWVg\", \"portions_for_operator\": 18446744073709551612, \"registration_height\": 1860, \"service_node_pubkey\": \"3afa36a4855a429f5eac1b2f8e7e77657a2e862999ab4d59e473826f9b15f2da\", \"staking_requirement\": 100000000000, \"total_contributed\": 100000000000, \"total_reserved\": 100000000000 }], \"status\": \"OK\" } }","title":"Result"},{"location":"Developer/SNRPCGuide/#inputs_3","text":"String[] service_node_pubkeys An array of service node public keys in strings that you wish to query metadata for. If an empty array is given, this RPC command returns all service nodes it knows about.","title":"Inputs"},{"location":"Developer/SNRPCGuide/#outputs_3","text":"Entry[] service_node_states The array of metadata for the queried service node(s) String service_node_pubkey The queried service node\u2019s identifying public key Uint64 registration_height The height at which the registration transaction arrived on the blockchain Uint64 last_reward_block_height The last block height this service node received a reward. Rewards are sent to service nodes whom have been waiting longest since their last reward and are then sent to the back of the queue. Uint64 last_reward_transaction_index The position in the queue to receive a reward for the service nodes grouped in the last_reward_block_height. Uint64 last_uptime_proof Unix epoch timestamp of the last time this daemon has received a ping from the queried service node. Contribution[] contributors An array consisting of all the addresses that have contributed to the queried service node. Uint64 Contribution.amount The amount of Loki in atomic units the contributor has staked. Uint64 Contribution.reserved The amount of Loki in atomic units the contributor has reserved and must fulfill to completely contribute their part to the service node. Amount is equal to reserved once the contributor has fully contributed their part. String Contribution.address The Loki address that funds must come from to fulfill the contribution requirement. Uint64 total_contributed The total Loki currently contributed going towards the staking requirement. Uint64 total_reserved The total Loki that has been reserved by all contributors. The remaining Loki is open for other contributors to increase their stake towards the service node. Uint64 portions_for_operator The operator cut expressed as a value from 0 -> STAKING_PORTIONS (defined in loki/src/cryptonote_config.h) which is the fee taken from the service node reward and given to the operator address before rewards are distributed to the contributors. Uint64 operator_address The wallet address which is the primary owner of the service node and also the address which the operator cut is sent to.","title":"Outputs"},{"location":"Developer/WalletRPCBeta/","text":"Introduction \u00b6 This is a list of the RPC calls, their inputs and outputs, and examples of each. This list is autogenerated and was last generated on: 2020-05-13 Many RPC calls use the JSON RPC interface while others use their own interfaces, as demonstrated below. Note: \"atomic units\" refer to the smallest fraction of 1 LOKI which is 1e9 atomic units. JSON \u00b6 COMMAND_RPC_ADD_ADDRESS_BOOK_ENTRY COMMAND_RPC_AUTO_REFRESH COMMAND_RPC_CAN_REQUEST_STAKE_UNLOCK COMMAND_RPC_CHANGE_WALLET_PASSWORD COMMAND_RPC_CHECK_RESERVE_PROOF COMMAND_RPC_CHECK_SPEND_PROOF COMMAND_RPC_CHECK_TX_KEY COMMAND_RPC_CHECK_TX_PROOF COMMAND_RPC_CLOSE_WALLET COMMAND_RPC_CREATE_ACCOUNT COMMAND_RPC_CREATE_ADDRESS COMMAND_RPC_CREATE_WALLET COMMAND_RPC_DELETE_ADDRESS_BOOK_ENTRY COMMAND_RPC_DESCRIBE_TRANSFER COMMAND_RPC_EXCHANGE_MULTISIG_KEYS COMMAND_RPC_EXPORT_KEY_IMAGES COMMAND_RPC_EXPORT_MULTISIG COMMAND_RPC_EXPORT_OUTPUTS COMMAND_RPC_FINALIZE_MULTISIG COMMAND_RPC_GENERATE_FROM_KEYS COMMAND_RPC_GET_ACCOUNTS COMMAND_RPC_GET_ACCOUNT_TAGS COMMAND_RPC_GET_ADDRESS COMMAND_RPC_GET_ADDRESS_BOOK_ENTRY COMMAND_RPC_GET_ADDRESS_INDEX COMMAND_RPC_GET_ATTRIBUTE COMMAND_RPC_GET_BALANCE COMMAND_RPC_GET_BULK_PAYMENTS COMMAND_RPC_GET_HEIGHT COMMAND_RPC_GET_LANGUAGES COMMAND_RPC_GET_PAYMENTS COMMAND_RPC_GET_RESERVE_PROOF COMMAND_RPC_GET_SPEND_PROOF COMMAND_RPC_GET_TRANSFERS COMMAND_RPC_GET_TRANSFERS_CSV COMMAND_RPC_GET_TRANSFER_BY_TXID COMMAND_RPC_GET_TX_KEY COMMAND_RPC_GET_TX_NOTES COMMAND_RPC_GET_TX_PROOF COMMAND_RPC_GET_VERSION COMMAND_RPC_IMPORT_KEY_IMAGES COMMAND_RPC_IMPORT_MULTISIG COMMAND_RPC_IMPORT_OUTPUTS COMMAND_RPC_INCOMING_TRANSFERS COMMAND_RPC_IS_MULTISIG COMMAND_RPC_LABEL_ACCOUNT COMMAND_RPC_LABEL_ADDRESS COMMAND_RPC_LNS_BUY_MAPPING COMMAND_RPC_LNS_DECRYPT_VALUE COMMAND_RPC_LNS_HASH_NAME COMMAND_RPC_LNS_MAKE_UPDATE_SIGNATURE COMMAND_RPC_LNS_UPDATE_MAPPING COMMAND_RPC_MAKE_INTEGRATED_ADDRESS COMMAND_RPC_MAKE_MULTISIG COMMAND_RPC_MAKE_URI COMMAND_RPC_OPEN_WALLET COMMAND_RPC_PARSE_URI COMMAND_RPC_PREPARE_MULTISIG COMMAND_RPC_QUERY_KEY COMMAND_RPC_REFRESH COMMAND_RPC_REGISTER_SERVICE_NODE COMMAND_RPC_RELAY_TX COMMAND_RPC_REQUEST_STAKE_UNLOCK COMMAND_RPC_RESCAN_BLOCKCHAIN COMMAND_RPC_RESCAN_SPENT COMMAND_RPC_RESTORE_DETERMINISTIC_WALLET COMMAND_RPC_SET_ACCOUNT_TAG_DESCRIPTION COMMAND_RPC_SET_ATTRIBUTE COMMAND_RPC_SET_DAEMON COMMAND_RPC_SET_LOG_CATEGORIES COMMAND_RPC_SET_LOG_LEVEL COMMAND_RPC_SET_TX_NOTES COMMAND_RPC_SIGN COMMAND_RPC_SIGN_MULTISIG COMMAND_RPC_SIGN_TRANSFER COMMAND_RPC_SPLIT_INTEGRATED_ADDRESS COMMAND_RPC_STAKE COMMAND_RPC_START_MINING COMMAND_RPC_STOP_MINING COMMAND_RPC_STOP_WALLET COMMAND_RPC_STORE COMMAND_RPC_SUBMIT_MULTISIG COMMAND_RPC_SUBMIT_TRANSFER COMMAND_RPC_SWEEP_ALL COMMAND_RPC_SWEEP_DUST COMMAND_RPC_SWEEP_SINGLE COMMAND_RPC_TAG_ACCOUNTS COMMAND_RPC_TRANSFER COMMAND_RPC_TRANSFER_SPLIT COMMAND_RPC_UNTAG_ACCOUNTS COMMAND_RPC_VALIDATE_ADDRESS COMMAND_RPC_VERIFY JSON \u00b6 COMMAND_RPC_ADD_ADDRESS_BOOK_ENTRY \u00b6 Back to top Add an entry to the address book. Endpoints: add_address_book Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"add_address_book\", \"params\": { \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"payment_id\": \"f378710e54eeeb8d\", \"description\": \"My account description\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"index\": 123 } Inputs: address - string : Public address of the entry. payment_id - string : (Optional), defaults to \"0000000000000000000000000000000000000000000000000000000000000000\". description - string : (Optional), defaults to \"\". Outputs: index - uint64 : The index of the address book entry. COMMAND_RPC_AUTO_REFRESH \u00b6 Back to top Endpoints: auto_refresh Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"auto_refresh\", \"params\": { \"enable\": true, \"period\": 2130706433 } } EOF Inputs: enable - bool period - uint32 : seconds COMMAND_RPC_CAN_REQUEST_STAKE_UNLOCK \u00b6 Back to top Check if Service Node can unlock it's stake. Endpoints: can_request_stake_unlock Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"can_request_stake_unlock\", \"params\": { \"service_node_key\": \"4a8c30cea9e729b06c91132295cce32d2a8e6e5bcf7b74a998e2ee1b3ed590b3\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"can_unlock\": true, \"msg\": \"Message returned by the sender (wallet/daemon)\" } } Inputs: service_node_key - string : Service node public address. Outputs: can_unlock - bool : States if the stake can be locked. msg - string : Information on the unlocking process. COMMAND_RPC_CHANGE_WALLET_PASSWORD \u00b6 Back to top Change a wallet password. Endpoints: change_wallet_password Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"change_wallet_password\", \"params\": { \"old_password\": \"TODO(loki): Write example string\", \"new_password\": \"TODO(loki): Write example string\" } } EOF Inputs: old_password - string : (Optional) Current wallet password, if defined. new_password - string : (Optional) New wallet password, if not blank. COMMAND_RPC_CHECK_RESERVE_PROOF \u00b6 Back to top Proves a wallet has a disposable reserve using a signature. Endpoints: check_reserve_proof Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"check_reserve_proof\", \"params\": { \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"message\": \"User assigned note describing something\", \"signature\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"good\": true, \"total\": 123, \"spent\": 123 } } Inputs: address - string : Public address of the wallet. message - string : (Optional) Should be the same message used in get_reserve_proof. signature - string : Reserve signature to confirm. Outputs: good - bool : States if the inputs proves the reserve. total - uint64 spent - uint64 COMMAND_RPC_CHECK_SPEND_PROOF \u00b6 Back to top Prove a spend using a signature. Unlike proving a transaction, it does not requires the destination public address. Endpoints: check_spend_proof Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"check_spend_proof\", \"params\": { \"txid\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"message\": \"User assigned note describing something\", \"signature\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"good\": true } Inputs: txid - string : Transaction id. message - string : (Optional) Should be the same message used in get_spend_proof . signature - string : Spend signature to confirm. Outputs: good - bool : States if the inputs proves the spend. COMMAND_RPC_CHECK_TX_KEY \u00b6 Back to top Check a transaction in the blockchain with its secret key. Endpoints: check_tx_key Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"check_tx_key\", \"params\": { \"txid\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"tx_key\": \"1982e99c69d8acc993cfc94ce59ff8f113d23482d9a25c892a3fc01c77dd8c4c\", \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"received\": 123, \"in_pool\": true, \"confirmations\": 123 } } Inputs: txid - string : Transaction id. tx_key - string : Transaction secret key. address - string : Destination public address of the transaction. Outputs: received - uint64 : Amount of the transaction. in_pool - bool : States if the transaction is still in pool or has been added to a block. confirmations - uint64 : Number of block mined after the one with the transaction. COMMAND_RPC_CHECK_TX_PROOF \u00b6 Back to top Prove a transaction by checking its signature. Endpoints: check_tx_proof Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"check_tx_proof\", \"params\": { \"txid\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"message\": \"User assigned note describing something\", \"signature\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"good\": true, \"received\": 123, \"in_pool\": true, \"confirmations\": 123 } } Inputs: txid - string : Transaction id. address - string : Destination public address of the transaction. message - string : (Optional) Should be the same message used in get_tx_proof . signature - string : Transaction signature to confirm. Outputs: good - bool : States if the inputs proves the transaction. received - uint64 : Amount of the transaction. in_pool - bool : States if the transaction is still in pool or has been added to a block. confirmations - uint64 : Number of block mined after the one with the transaction. COMMAND_RPC_CLOSE_WALLET \u00b6 Back to top Close the currently opened wallet, after trying to save it. Endpoints: close_wallet Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"close_wallet\", \"params\": { \"autosave_current\": true } } EOF Inputs: autosave_current - bool : Save the wallet state on close COMMAND_RPC_CREATE_ACCOUNT \u00b6 Back to top Create a new account with an optional label. Endpoints: create_account Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"create_account\", \"params\": { \"label\": \"My label\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"account_index\": 0, \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\" } } Inputs: label - string : (Optional) Label for the account. Outputs: account_index - uint32 : Index of the new account. address - string : The primary address of the new account. COMMAND_RPC_CREATE_ADDRESS \u00b6 Back to top Create a new address for an account. Optionally, label the new address. Endpoints: create_address Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"create_address\", \"params\": { \"account_index\": 0, \"label\": \"My label\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"address_index\": 0 } } Inputs: account_index - uint32 : Create a new subaddress for this account. label - string : (Optional) Label for the new subaddress. Outputs: address - string : The newly requested address. address_index - uint32 : Index of the new address in the requested account index. COMMAND_RPC_CREATE_WALLET \u00b6 Back to top Create a new wallet. You need to have set the argument \"'\u2013wallet-dir\" when launching loki-wallet-rpc to make this work. Endpoints: create_wallet Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"create_wallet\", \"params\": { \"filename\": \"Doyles_Cool_Wallet\", \"password\": \"not_a_secure_password\", \"language\": \"english\" } } EOF Inputs: filename - string : Set the wallet file name. password - string : (Optional) Set the password to protect the wallet. language - string : Language for your wallets' seed. COMMAND_RPC_DELETE_ADDRESS_BOOK_ENTRY \u00b6 Back to top Delete an entry from the address book. Endpoints: delete_address_book Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"delete_address_book\", \"params\": { \"index\": 123 } } EOF Inputs: index - uint64 : The index of the address book entry. COMMAND_RPC_DESCRIBE_TRANSFER \u00b6 Back to top Endpoints: describe_transfer Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"describe_transfer\", \"params\": { \"unsigned_txset\": \"TODO(loki): Write example string\", \"multisig_txset\": \"TODO(loki): Write example string\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"desc\": [{ \"amount_in\": 123, \"amount_out\": 123, \"ring_size\": 2130706433, \"unlock_time\": 123, \"recipients\": [{ \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"amount\": 26734261552878 }], \"payment_id\": \"f378710e54eeeb8d\", \"change_amount\": 123, \"change_address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"fee\": 123, \"dummy_outputs\": 2130706433, \"extra\": \"01008e5729d9329320444666d9d9d9dc602a3ae585de91ab2ca125665e3a363610021100000001839fdb0000000000000000000001200408d5ad7ab79d9b05c94033c2029f4902a98ec51f5175564f6978467dbb28723f929cf806d4ee1c781d7771183a93a1fd74f0827bddee9baac7e3083ab2b584\" }] } Inputs: unsigned_txset - string : Set of unsigned tx returned by \"transfer\" or \"transfer_split\" methods. multisig_txset - string : Set of unsigned multisig txes returned by \"transfer\" or \"transfer_split\" methods Outputs: desc - transfer_description[] : List of information of transfers. amount_in - uint64 : Amount in, in atomic units. amount_out - uint64 : amount out, in atomic units. ring_size - uint32 : Ring size of transfer. unlock_time - uint64 : Number of blocks before the loki can be spent (0 represents the default network lock time). recipients - recipient[] : List of addresses and amounts. address - string : Destination public address. amount - uint64 : Amount in atomic units. payment_id - string : Payment ID matching the input parameter. change_amount - uint64 : Change received from transaction in atomic units. change_address - string : Address the change was sent to. fee - uint64 : Fee of the transaction in atomic units. dummy_outputs - uint32 extra - string : Data stored in the tx extra represented in hex. COMMAND_RPC_EXCHANGE_MULTISIG_KEYS \u00b6 Back to top Endpoints: exchange_multisig_keys Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"exchange_multisig_keys\", \"params\": { \"password\": \"not_a_secure_password\", \"multisig_info\": [\"TODO(loki): Write example string\"] } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"multisig_info\": \"TODO(loki): Write example string\" } } Inputs: password - string : Wallet password. multisig_info - string[] : List of multisig string from peers. Outputs: address - string : Multisig wallet address. multisig_info - string : Multisig string to share with peers to create the multisig wallet. COMMAND_RPC_EXPORT_KEY_IMAGES \u00b6 Back to top Export a signed set of key images. Endpoints: export_key_images Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"export_key_images\", \"params\": { \"requested_only\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"offset\": 2130706433, \"signed_key_images\": [{ \"key_image\": \"8d1bd8181bf7d857bdb281e0153d84cd55a3fcaa57c3e570f4a49f935850b5e3\", \"signature\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\" }] } } Inputs: requested_only - bool : Default false . Outputs: offset - uint32 signed_key_images - signed_key_image[] key_image - string signature - string COMMAND_RPC_EXPORT_MULTISIG \u00b6 Back to top Export multisig info for other participants. Endpoints: export_multisig_info Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"export_multisig_info\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"info\": \"TODO(loki): Write example string\" } Outputs: info - string : Multisig info in hex format for other participants. COMMAND_RPC_EXPORT_OUTPUTS \u00b6 Back to top Export all outputs in hex format. Endpoints: export_outputs Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"export_outputs\", \"params\": { \"all\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"outputs_data_hex\": \"TODO(loki): Write example string\" } Inputs: all - bool Outputs: outputs_data_hex - string : Wallet outputs in hex format. COMMAND_RPC_FINALIZE_MULTISIG \u00b6 Back to top Turn this wallet into a multisig wallet, extra step for N-1/N wallets. Endpoints: finalize_multisig Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"finalize_multisig\", \"params\": { \"password\": \"not_a_secure_password\", \"multisig_info\": [\"TODO(loki): Write example string\"] } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\" } Inputs: password - string : Wallet password. multisig_info - string[] : List of multisig string from peers. Outputs: address - string : Multisig wallet address. COMMAND_RPC_GENERATE_FROM_KEYS \u00b6 Back to top Restore a wallet using the private spend key, view key and public address. Endpoints: generate_from_keys Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"generate_from_keys\", \"params\": { \"restore_height\": 123, \"filename\": \"Doyles_Cool_Wallet\", \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"spendkey\": \"1de25fd280b9b08da62f06a5521c735fd94b7ecf237ca7409748295e75b48104\", \"viewkey\": \"1de25fd280b9b08da62f06a5521c735fd94b7ecf237ca7409748295e75b48104\", \"password\": \"not_a_secure_password\", \"autosave_current\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"info\": \"TODO(loki): Write example string\" } } Inputs: restore_height - uint64 : (Optional: Default 0) Height in which to start scanning the blockchain for transactions into and out of this Wallet. filename - string : Set the name of the wallet. address - string : The public address of the wallet. spendkey - string : The private spend key of the wallet viewkey - string : The private view key of the wallet. password - string : Set password for Wallet. autosave_current - bool : (Optional: Default true): If a pre-existing wallet is open, save to disk before opening the new wallet. Outputs: address - string info - string COMMAND_RPC_GET_ACCOUNTS \u00b6 Back to top Get all accounts for a wallet. Optionally filter accounts by tag. Endpoints: get_accounts Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_accounts\", \"params\": { \"tag\": \"My tag\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"total_balance\": 123, \"total_unlocked_balance\": 123, \"subaddress_accounts\": [{ \"account_index\": 0, \"base_address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"balance\": 123, \"unlocked_balance\": 123, \"label\": \"My label\", \"tag\": \"My tag\" }] } } Inputs: tag - string : (Optional) Tag for filtering accounts. All accounts if empty, otherwise those accounts with this tag Outputs: total_balance - uint64 : Total balance of the selected accounts (locked or unlocked). total_unlocked_balance - uint64 : Total unlocked balance of the selected accounts. subaddress_accounts - subaddress_account_info[] : Account information. account_index - uint32 : Index of the account. base_address - string : The first address of the account (i.e. the primary address). balance - uint64 : Balance of the account (locked or unlocked). unlocked_balance - uint64 : Unlocked balance for the account. label - string : (Optional) Label of the account. tag - string : (Optional) Tag for filtering accounts. COMMAND_RPC_GET_ACCOUNT_TAGS \u00b6 Back to top Get a list of user-defined account tags. Endpoints: get_account_tags Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_account_tags\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"account_tags\": [{ \"tag\": \"My tag\", \"label\": \"My label\", \"accounts\": [2130706433] }] } Outputs: account_tags - account_tag_info[] : Account tag information: tag - string : Filter tag. label - string : Label for the tag. accounts - uint32[] : List of tagged account indices. COMMAND_RPC_GET_ADDRESS \u00b6 Back to top Return the wallet's addresses for an account. Optionally filter for specific set of subaddresses. Endpoints: get_address Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_address\", \"params\": { \"account_index\": 0, \"address_index\": [0] } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"addresses\": [{ \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"label\": \"My label\", \"address_index\": 0, \"used\": true }] } } Inputs: account_index - uint32 : Get the wallet addresses for the specified account. address_index - uint32[] : (Optional) List of subaddresses to return from the aforementioned account. Outputs: address - string : (Deprecated) Remains to be compatible with older RPC format addresses - address_info[] : Addresses informations. address - string : The (sub)address string. label - string : Label of the (sub)address. address_index - uint32 : Index of the subaddress used - bool : True if the (sub)address has received funds before. COMMAND_RPC_GET_ADDRESS_BOOK_ENTRY \u00b6 Back to top Retrieves entries from the address book. Endpoints: get_address_book Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_address_book\", \"params\": { \"entries\": [123] } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"entries\": [{ \"index\": 123, \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"payment_id\": \"f378710e54eeeb8d\", \"description\": \"My account description\" }] } Inputs: entries - uint64[] : Indices of the requested address book entries. Outputs: entries - entry[] : List of address book entries information. index - uint64 : Index of entry. address - string : Public address of the entry payment_id - string : (Optional) 64-character hex string to identify a transaction. description - string : Description of this address entry. COMMAND_RPC_GET_ADDRESS_INDEX \u00b6 Back to top Get account and address indexes from a specific (sub)address. Endpoints: get_address_index Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_address_index\", \"params\": { \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"index\": { \"major\": 2130706433, \"minor\": 2130706433 } } Inputs: address - string : (Sub)address to look for. Outputs: index - cryptonote::subaddress_index : Account index followed by the subaddress index. major - uint32 : The account index, major index minor - uint32 : The subaddress index, minor index COMMAND_RPC_GET_ATTRIBUTE \u00b6 Back to top Get attribute value by name. Endpoints: get_attribute Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_attribute\", \"params\": { \"key\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"value\": \"TODO(loki): Write example string\" } Inputs: key - string : Attribute name. Outputs: value - string : Attribute value. COMMAND_RPC_GET_BALANCE \u00b6 Back to top Return the wallet's balance. Endpoints: get_balance Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_balance\", \"params\": { \"account_index\": 0, \"address_indices\": [0], \"all_accounts\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"balance\": 123, \"unlocked_balance\": 123, \"multisig_import_needed\": true, \"per_subaddress\": [{ \"account_index\": 0, \"address_index\": 0, \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"balance\": 123, \"unlocked_balance\": 123, \"label\": \"My label\", \"num_unspent_outputs\": 123, \"blocks_to_unlock\": 123 }], \"blocks_to_unlock\": 123 } } Inputs: account_index - uint32 : Return balance for this account. address_indices - uint32[] : (Optional) Return balance detail for those subaddresses. all_accounts - bool : If true, return balance for all accounts, subaddr_indices and account_index are ignored Outputs: balance - uint64 : The total balance (atomic units) of the currently opened wallet. unlocked_balance - uint64 : Unlocked funds are those funds that are sufficiently deep enough in the loki blockchain to be considered safe to spend. multisig_import_needed - bool : True if importing multisig data is needed for returning a correct balance. per_subaddress - per_subaddress_info[] : Balance information for each subaddress in an account. account_index - uint32 : Index of the account in the wallet. address_index - uint32 : Index of the subaddress in the account. address - string : Address at this index. Base58 representation of the public keys. balance - uint64 : Balance for the subaddress (locked or unlocked). unlocked_balance - uint64 : Unlocked funds are those funds that are sufficiently deep enough in the loki blockchain to be considered safe to spend. label - string : Label for the subaddress. num_unspent_outputs - uint64 : Number of unspent outputs available for the subaddress. blocks_to_unlock - uint64 : The number of blocks remaining for the balance to unlock blocks_to_unlock - uint64 : The number of blocks remaining for the balance to unlock COMMAND_RPC_GET_BULK_PAYMENTS \u00b6 Back to top Get a list of incoming payments using a given payment id, or a list of payments ids, from a given height. This method is the preferred method over get_paymentsbecause it has the same functionality but is more extendable. Either is fine for looking up transactions by a single payment ID. Endpoints: get_bulk_payments Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_bulk_payments\", \"params\": { \"payment_ids\": [\"TODO(loki): Write example string\"], \"min_block_height\": 123 } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"payments\": [{ \"payment_id\": \"f378710e54eeeb8d\", \"tx_hash\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"amount\": 26734261552878, \"block_height\": 123, \"unlock_time\": 123, \"subaddr_index\": { \"major\": 2130706433, \"minor\": 2130706433 }, \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\" }] } Inputs: payment_ids - string[] : Payment IDs used to find the payments (16 characters hex). min_block_height - uint64 : The block height at which to start looking for payments. Outputs: payments - payment_details[] : List of payment details: payment_id - string : Payment ID matching the input parameter. tx_hash - string : Transaction hash used as the transaction ID. amount - uint64 : Amount for this payment. block_height - uint64 : Height of the block that first confirmed this payment. unlock_time - uint64 : Time (in block height) until this payment is safe to spend. subaddr_index - cryptonote::subaddress_index : Major & minor index, account and subaddress index respectively. major - uint32 : The account index, major index minor - uint32 : The subaddress index, minor index address - string : Address receiving the payment. COMMAND_RPC_GET_HEIGHT \u00b6 Back to top Returns the wallet's current block height and blockchain immutable height Endpoints: get_height Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_height\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"height\": 234767, \"immutable_height\": 123 } } Outputs: height - uint64 : The current wallet's blockchain height. If the wallet has been offline for a long time, it may need to catch up with the daemon. immutable_height - uint64 : The latest height in the blockchain that can not be reorganized from (backed by atleast 2 Service Node, or 1 hardcoded checkpoint, 0 if N/A). COMMAND_RPC_GET_LANGUAGES \u00b6 Back to top Get a list of available languages for your wallet's seed. Endpoints: get_languages Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_languages\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"languages\": [\"TODO(loki): Write example string\"], \"languages_local\": [\"TODO(loki): Write example string\"] } } Outputs: languages - string[] : List of available languages. languages_local - string[] : List of available languages in the native language COMMAND_RPC_GET_PAYMENTS \u00b6 Back to top Get a list of incoming payments using a given payment id. Endpoints: get_payments Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_payments\", \"params\": { \"payment_id\": \"f378710e54eeeb8d\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"payments\": [{ \"payment_id\": \"f378710e54eeeb8d\", \"tx_hash\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"amount\": 26734261552878, \"block_height\": 123, \"unlock_time\": 123, \"subaddr_index\": { \"major\": 2130706433, \"minor\": 2130706433 }, \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\" }] } Inputs: payment_id - string : Payment ID used to find the payments (16 characters hex). Outputs: payments - payment_details[] : List of payment details: payment_id - string : Payment ID matching the input parameter. tx_hash - string : Transaction hash used as the transaction ID. amount - uint64 : Amount for this payment. block_height - uint64 : Height of the block that first confirmed this payment. unlock_time - uint64 : Time (in block height) until this payment is safe to spend. subaddr_index - cryptonote::subaddress_index : Major & minor index, account and subaddress index respectively. major - uint32 : The account index, major index minor - uint32 : The subaddress index, minor index address - string : Address receiving the payment. COMMAND_RPC_GET_RESERVE_PROOF \u00b6 Back to top Generate a signature to prove of an available amount in a wallet. Endpoints: get_reserve_proof Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_reserve_proof\", \"params\": { \"all\": true, \"account_index\": 0, \"amount\": 26734261552878, \"message\": \"User assigned note describing something\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"signature\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\" } Inputs: all - bool : Proves all wallet balance to be disposable. account_index - uint32 : Specify the account from witch to prove reserve. (ignored if all is set to true) amount - uint64 : Amount (in atomic units) to prove the account has for reserve. (ignored if all is set to true) message - string : (Optional) add a message to the signature to further authenticate the prooving process. Outputs: signature - string : Reserve signature. COMMAND_RPC_GET_SPEND_PROOF \u00b6 Back to top Generate a signature to prove a spend. Unlike proving a transaction, it does not requires the destination public address. Endpoints: get_spend_proof Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_spend_proof\", \"params\": { \"txid\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"message\": \"User assigned note describing something\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"signature\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\" } Inputs: txid - string : Transaction id. message - string : (Optional) add a message to the signature to further authenticate the prooving process. Outputs: signature - string : Spend signature. COMMAND_RPC_GET_TRANSFERS \u00b6 Back to top Returns a list of transfers, by default all transfer types are included. If all requested type fields are false, then all transfers will be queried. Endpoints: get_transfers Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_transfers\", \"params\": { \"in\": true, \"out\": true, \"stake\": true, \"pending\": true, \"failed\": true, \"pool\": true, \"coinbase\": true, \"filter_by_height\": true, \"min_height\": 123, \"max_height\": 123, \"account_index\": 0, \"subaddr_indices\": [0], \"all_accounts\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"in\": [{ \"txid\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"payment_id\": \"f378710e54eeeb8d\", \"height\": 234767, \"timestamp\": 123, \"amount\": 26734261552878, \"fee\": 123, \"note\": \"User assigned note describing something\", \"destinations\": [{ \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"amount\": 26734261552878 }], \"type\": \"TODO(loki): Write example string\", \"unlock_time\": 123, \"subaddr_index\": { \"major\": 2130706433, \"minor\": 2130706433 }, \"subaddr_indices\": [{ \"major\": 2130706433, \"minor\": 2130706433 }], \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"double_spend_seen\": true, \"confirmations\": 123, \"suggested_confirmations_threshold\": 123, \"checkpointed\": 1, \"blink_mempool\": true, \"was_blink\": true }], \"out\": [{ \"txid\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"payment_id\": \"f378710e54eeeb8d\", \"height\": 234767, \"timestamp\": 123, \"amount\": 26734261552878, \"fee\": 123, \"note\": \"User assigned note describing something\", \"destinations\": [{ \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"amount\": 26734261552878 }], \"type\": \"TODO(loki): Write example string\", \"unlock_time\": 123, \"subaddr_index\": { \"major\": 2130706433, \"minor\": 2130706433 }, \"subaddr_indices\": [{ \"major\": 2130706433, \"minor\": 2130706433 }], \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"double_spend_seen\": true, \"confirmations\": 123, \"suggested_confirmations_threshold\": 123, \"checkpointed\": 1, \"blink_mempool\": true, \"was_blink\": true }], \"pending\": [{ \"txid\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"payment_id\": \"f378710e54eeeb8d\", \"height\": 234767, \"timestamp\": 123, \"amount\": 26734261552878, \"fee\": 123, \"note\": \"User assigned note describing something\", \"destinations\": [{ \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"amount\": 26734261552878 }], \"type\": \"TODO(loki): Write example string\", \"unlock_time\": 123, \"subaddr_index\": { \"major\": 2130706433, \"minor\": 2130706433 }, \"subaddr_indices\": [{ \"major\": 2130706433, \"minor\": 2130706433 }], \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"double_spend_seen\": true, \"confirmations\": 123, \"suggested_confirmations_threshold\": 123, \"checkpointed\": 1, \"blink_mempool\": true, \"was_blink\": true }], \"failed\": [{ \"txid\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"payment_id\": \"f378710e54eeeb8d\", \"height\": 234767, \"timestamp\": 123, \"amount\": 26734261552878, \"fee\": 123, \"note\": \"User assigned note describing something\", \"destinations\": [{ \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"amount\": 26734261552878 }], \"type\": \"TODO(loki): Write example string\", \"unlock_time\": 123, \"subaddr_index\": { \"major\": 2130706433, \"minor\": 2130706433 }, \"subaddr_indices\": [{ \"major\": 2130706433, \"minor\": 2130706433 }], \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"double_spend_seen\": true, \"confirmations\": 123, \"suggested_confirmations_threshold\": 123, \"checkpointed\": 1, \"blink_mempool\": true, \"was_blink\": true }], \"pool\": [{ \"txid\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"payment_id\": \"f378710e54eeeb8d\", \"height\": 234767, \"timestamp\": 123, \"amount\": 26734261552878, \"fee\": 123, \"note\": \"User assigned note describing something\", \"destinations\": [{ \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"amount\": 26734261552878 }], \"type\": \"TODO(loki): Write example string\", \"unlock_time\": 123, \"subaddr_index\": { \"major\": 2130706433, \"minor\": 2130706433 }, \"subaddr_indices\": [{ \"major\": 2130706433, \"minor\": 2130706433 }], \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"double_spend_seen\": true, \"confirmations\": 123, \"suggested_confirmations_threshold\": 123, \"checkpointed\": 1, \"blink_mempool\": true, \"was_blink\": true }] } } Inputs: in - bool : (Optional) Include incoming transfers. out - bool : (Optional) Include outgoing transfers. stake - bool : (Optional) Include outgoing stakes. pending - bool : (Optional) Include pending transfers. failed - bool : (Optional) Include failed transfers. pool - bool : (Optional) Include transfers from the daemon's transaction pool. coinbase - bool : (Optional) Include transfers from the daemon's transaction pool. filter_by_height - bool : (Optional) Filter transfers by block height. min_height - uint64 : (Optional) Minimum block height to scan for transfers, if filtering by height is enabled. max_height - uint64 : (Optional) Maximum block height to scan for transfers, if filtering by height is enabled (defaults to max block height). account_index - uint32 : (Optional) Index of the account to query for transfers. (defaults to 0) subaddr_indices - uint32[] : (Optional) List of subaddress indices to query for transfers. (defaults to 0) all_accounts - bool : If true, return transfers for all accounts, subaddr_indices and account_index are ignored Outputs: in - transfer_view[] txid - string : Transaction ID for this transfer. payment_id - string : Payment ID for this transfer. height - uint64 : Height of the first block that confirmed this transfer (0 if not mined yet). timestamp - uint64 : UNIX timestamp for when this transfer was first confirmed in a block (or timestamp submission if not mined yet). amount - uint64 : Amount transferred. fee - uint64 : Transaction fee for this transfer. note - string : Note about this transfer. destinations - transfer_destination[] : Array of transfer destinations. address - string : Destination public address. amount - uint64 : Amount to send to each destination, in atomic units. type - string : Type of transfer, one of the following: \"in\", \"out\", \"stake\", \"miner\", \"snode\", \"gov\", \"pending\", \"failed\", \"pool\". unlock_time - uint64 : Number of blocks until transfer is safely spendable. subaddr_index - cryptonote::subaddress_index : Major & minor index, account and subaddress index respectively. major - uint32 : The account index, major index minor - uint32 : The subaddress index, minor index subaddr_indices - cryptonote::subaddress_index[] major - uint32 : The account index, major index minor - uint32 : The subaddress index, minor index address - string : Address that transferred the funds. double_spend_seen - bool : True if the key image(s) for the transfer have been seen before. confirmations - uint64 : Number of block mined since the block containing this transaction (or block height at which the transaction should be added to a block if not yet confirmed). suggested_confirmations_threshold - uint64 : Estimation of the confirmations needed for the transaction to be included in a block. checkpointed - uint64 : If transfer is backed by atleast 2 Service Node Checkpoints, 0 if it is not, see immutable_height in the daemon rpc call get_info blink_mempool - bool : True if this is an approved blink tx in the mempool was_blink - bool : True if we saw this as an approved blink (either in the mempool or a recent, uncheckpointed block). Note that if we didn't see it while an active blink this won't be set. out - transfer_view[] txid - string : Transaction ID for this transfer. payment_id - string : Payment ID for this transfer. height - uint64 : Height of the first block that confirmed this transfer (0 if not mined yet). timestamp - uint64 : UNIX timestamp for when this transfer was first confirmed in a block (or timestamp submission if not mined yet). amount - uint64 : Amount transferred. fee - uint64 : Transaction fee for this transfer. note - string : Note about this transfer. destinations - transfer_destination[] : Array of transfer destinations. address - string : Destination public address. amount - uint64 : Amount to send to each destination, in atomic units. type - string : Type of transfer, one of the following: \"in\", \"out\", \"stake\", \"miner\", \"snode\", \"gov\", \"pending\", \"failed\", \"pool\". unlock_time - uint64 : Number of blocks until transfer is safely spendable. subaddr_index - cryptonote::subaddress_index : Major & minor index, account and subaddress index respectively. major - uint32 : The account index, major index minor - uint32 : The subaddress index, minor index subaddr_indices - cryptonote::subaddress_index[] major - uint32 : The account index, major index minor - uint32 : The subaddress index, minor index address - string : Address that transferred the funds. double_spend_seen - bool : True if the key image(s) for the transfer have been seen before. confirmations - uint64 : Number of block mined since the block containing this transaction (or block height at which the transaction should be added to a block if not yet confirmed). suggested_confirmations_threshold - uint64 : Estimation of the confirmations needed for the transaction to be included in a block. checkpointed - uint64 : If transfer is backed by atleast 2 Service Node Checkpoints, 0 if it is not, see immutable_height in the daemon rpc call get_info blink_mempool - bool : True if this is an approved blink tx in the mempool was_blink - bool : True if we saw this as an approved blink (either in the mempool or a recent, uncheckpointed block). Note that if we didn't see it while an active blink this won't be set. pending - transfer_view[] txid - string : Transaction ID for this transfer. payment_id - string : Payment ID for this transfer. height - uint64 : Height of the first block that confirmed this transfer (0 if not mined yet). timestamp - uint64 : UNIX timestamp for when this transfer was first confirmed in a block (or timestamp submission if not mined yet). amount - uint64 : Amount transferred. fee - uint64 : Transaction fee for this transfer. note - string : Note about this transfer. destinations - transfer_destination[] : Array of transfer destinations. address - string : Destination public address. amount - uint64 : Amount to send to each destination, in atomic units. type - string : Type of transfer, one of the following: \"in\", \"out\", \"stake\", \"miner\", \"snode\", \"gov\", \"pending\", \"failed\", \"pool\". unlock_time - uint64 : Number of blocks until transfer is safely spendable. subaddr_index - cryptonote::subaddress_index : Major & minor index, account and subaddress index respectively. major - uint32 : The account index, major index minor - uint32 : The subaddress index, minor index subaddr_indices - cryptonote::subaddress_index[] major - uint32 : The account index, major index minor - uint32 : The subaddress index, minor index address - string : Address that transferred the funds. double_spend_seen - bool : True if the key image(s) for the transfer have been seen before. confirmations - uint64 : Number of block mined since the block containing this transaction (or block height at which the transaction should be added to a block if not yet confirmed). suggested_confirmations_threshold - uint64 : Estimation of the confirmations needed for the transaction to be included in a block. checkpointed - uint64 : If transfer is backed by atleast 2 Service Node Checkpoints, 0 if it is not, see immutable_height in the daemon rpc call get_info blink_mempool - bool : True if this is an approved blink tx in the mempool was_blink - bool : True if we saw this as an approved blink (either in the mempool or a recent, uncheckpointed block). Note that if we didn't see it while an active blink this won't be set. failed - transfer_view[] txid - string : Transaction ID for this transfer. payment_id - string : Payment ID for this transfer. height - uint64 : Height of the first block that confirmed this transfer (0 if not mined yet). timestamp - uint64 : UNIX timestamp for when this transfer was first confirmed in a block (or timestamp submission if not mined yet). amount - uint64 : Amount transferred. fee - uint64 : Transaction fee for this transfer. note - string : Note about this transfer. destinations - transfer_destination[] : Array of transfer destinations. address - string : Destination public address. amount - uint64 : Amount to send to each destination, in atomic units. type - string : Type of transfer, one of the following: \"in\", \"out\", \"stake\", \"miner\", \"snode\", \"gov\", \"pending\", \"failed\", \"pool\". unlock_time - uint64 : Number of blocks until transfer is safely spendable. subaddr_index - cryptonote::subaddress_index : Major & minor index, account and subaddress index respectively. major - uint32 : The account index, major index minor - uint32 : The subaddress index, minor index subaddr_indices - cryptonote::subaddress_index[] major - uint32 : The account index, major index minor - uint32 : The subaddress index, minor index address - string : Address that transferred the funds. double_spend_seen - bool : True if the key image(s) for the transfer have been seen before. confirmations - uint64 : Number of block mined since the block containing this transaction (or block height at which the transaction should be added to a block if not yet confirmed). suggested_confirmations_threshold - uint64 : Estimation of the confirmations needed for the transaction to be included in a block. checkpointed - uint64 : If transfer is backed by atleast 2 Service Node Checkpoints, 0 if it is not, see immutable_height in the daemon rpc call get_info blink_mempool - bool : True if this is an approved blink tx in the mempool was_blink - bool : True if we saw this as an approved blink (either in the mempool or a recent, uncheckpointed block). Note that if we didn't see it while an active blink this won't be set. pool - transfer_view[] txid - string : Transaction ID for this transfer. payment_id - string : Payment ID for this transfer. height - uint64 : Height of the first block that confirmed this transfer (0 if not mined yet). timestamp - uint64 : UNIX timestamp for when this transfer was first confirmed in a block (or timestamp submission if not mined yet). amount - uint64 : Amount transferred. fee - uint64 : Transaction fee for this transfer. note - string : Note about this transfer. destinations - transfer_destination[] : Array of transfer destinations. address - string : Destination public address. amount - uint64 : Amount to send to each destination, in atomic units. type - string : Type of transfer, one of the following: \"in\", \"out\", \"stake\", \"miner\", \"snode\", \"gov\", \"pending\", \"failed\", \"pool\". unlock_time - uint64 : Number of blocks until transfer is safely spendable. subaddr_index - cryptonote::subaddress_index : Major & minor index, account and subaddress index respectively. major - uint32 : The account index, major index minor - uint32 : The subaddress index, minor index subaddr_indices - cryptonote::subaddress_index[] major - uint32 : The account index, major index minor - uint32 : The subaddress index, minor index address - string : Address that transferred the funds. double_spend_seen - bool : True if the key image(s) for the transfer have been seen before. confirmations - uint64 : Number of block mined since the block containing this transaction (or block height at which the transaction should be added to a block if not yet confirmed). suggested_confirmations_threshold - uint64 : Estimation of the confirmations needed for the transaction to be included in a block. checkpointed - uint64 : If transfer is backed by atleast 2 Service Node Checkpoints, 0 if it is not, see immutable_height in the daemon rpc call get_info blink_mempool - bool : True if this is an approved blink tx in the mempool was_blink - bool : True if we saw this as an approved blink (either in the mempool or a recent, uncheckpointed block). Note that if we didn't see it while an active blink this won't be set. COMMAND_RPC_GET_TRANSFERS_CSV \u00b6 Back to top Returns a string with the transfers formatted as csv Endpoints: get_transfers_csv Constants: * `request - COMMAND_RPC_GET_TRANSFERS::request` Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_transfers_csv\", \"params\": { \"in\": true, \"out\": true, \"stake\": true, \"pending\": true, \"failed\": true, \"pool\": true, \"coinbase\": true, \"filter_by_height\": true, \"min_height\": 123, \"max_height\": 123, \"account_index\": 0, \"subaddr_indices\": [0], \"all_accounts\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"csv\": \"TODO(loki): Write example string\" } Inputs: in - bool : (Optional) Include incoming transfers. out - bool : (Optional) Include outgoing transfers. stake - bool : (Optional) Include outgoing stakes. pending - bool : (Optional) Include pending transfers. failed - bool : (Optional) Include failed transfers. pool - bool : (Optional) Include transfers from the daemon's transaction pool. coinbase - bool : (Optional) Include transfers from the daemon's transaction pool. filter_by_height - bool : (Optional) Filter transfers by block height. min_height - uint64 : (Optional) Minimum block height to scan for transfers, if filtering by height is enabled. max_height - uint64 : (Optional) Maximum block height to scan for transfers, if filtering by height is enabled (defaults to max block height). account_index - uint32 : (Optional) Index of the account to query for transfers. (defaults to 0) subaddr_indices - uint32[] : (Optional) List of subaddress indices to query for transfers. (defaults to 0) all_accounts - bool : If true, return transfers for all accounts, subaddr_indices and account_index are ignored Outputs: csv - string COMMAND_RPC_GET_TRANSFER_BY_TXID \u00b6 Back to top Show information about a transfer to/from this address. Endpoints: get_transfer_by_txid Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_transfer_by_txid\", \"params\": { \"txid\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"account_index\": 0 } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"transfer\": { \"txid\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"payment_id\": \"f378710e54eeeb8d\", \"height\": 234767, \"timestamp\": 123, \"amount\": 26734261552878, \"fee\": 123, \"note\": \"User assigned note describing something\", \"destinations\": [{ \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"amount\": 26734261552878 }], \"type\": \"TODO(loki): Write example string\", \"unlock_time\": 123, \"subaddr_index\": { \"major\": 2130706433, \"minor\": 2130706433 }, \"subaddr_indices\": [{ \"major\": 2130706433, \"minor\": 2130706433 }], \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"double_spend_seen\": true, \"confirmations\": 123, \"suggested_confirmations_threshold\": 123, \"checkpointed\": 1, \"blink_mempool\": true, \"was_blink\": true }, \"transfers\": [{ \"txid\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"payment_id\": \"f378710e54eeeb8d\", \"height\": 234767, \"timestamp\": 123, \"amount\": 26734261552878, \"fee\": 123, \"note\": \"User assigned note describing something\", \"destinations\": [{ \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"amount\": 26734261552878 }], \"type\": \"TODO(loki): Write example string\", \"unlock_time\": 123, \"subaddr_index\": { \"major\": 2130706433, \"minor\": 2130706433 }, \"subaddr_indices\": [{ \"major\": 2130706433, \"minor\": 2130706433 }], \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"double_spend_seen\": true, \"confirmations\": 123, \"suggested_confirmations_threshold\": 123, \"checkpointed\": 1, \"blink_mempool\": true, \"was_blink\": true }] } } Inputs: txid - string : Transaction ID used to find the transfer. account_index - uint32 : (Optional) Index of the account to query for the transfer. Outputs: transfer - transfer_view txid - string : Transaction ID for this transfer. payment_id - string : Payment ID for this transfer. height - uint64 : Height of the first block that confirmed this transfer (0 if not mined yet). timestamp - uint64 : UNIX timestamp for when this transfer was first confirmed in a block (or timestamp submission if not mined yet). amount - uint64 : Amount transferred. fee - uint64 : Transaction fee for this transfer. note - string : Note about this transfer. destinations - transfer_destination[] : Array of transfer destinations. address - string : Destination public address. amount - uint64 : Amount to send to each destination, in atomic units. type - string : Type of transfer, one of the following: \"in\", \"out\", \"stake\", \"miner\", \"snode\", \"gov\", \"pending\", \"failed\", \"pool\". unlock_time - uint64 : Number of blocks until transfer is safely spendable. subaddr_index - cryptonote::subaddress_index : Major & minor index, account and subaddress index respectively. major - uint32 : The account index, major index minor - uint32 : The subaddress index, minor index subaddr_indices - cryptonote::subaddress_index[] major - uint32 : The account index, major index minor - uint32 : The subaddress index, minor index address - string : Address that transferred the funds. double_spend_seen - bool : True if the key image(s) for the transfer have been seen before. confirmations - uint64 : Number of block mined since the block containing this transaction (or block height at which the transaction should be added to a block if not yet confirmed). suggested_confirmations_threshold - uint64 : Estimation of the confirmations needed for the transaction to be included in a block. checkpointed - uint64 : If transfer is backed by atleast 2 Service Node Checkpoints, 0 if it is not, see immutable_height in the daemon rpc call get_info blink_mempool - bool : True if this is an approved blink tx in the mempool was_blink - bool : True if we saw this as an approved blink (either in the mempool or a recent, uncheckpointed block). Note that if we didn't see it while an active blink this won't be set. transfers - transfer_view[] txid - string : Transaction ID for this transfer. payment_id - string : Payment ID for this transfer. height - uint64 : Height of the first block that confirmed this transfer (0 if not mined yet). timestamp - uint64 : UNIX timestamp for when this transfer was first confirmed in a block (or timestamp submission if not mined yet). amount - uint64 : Amount transferred. fee - uint64 : Transaction fee for this transfer. note - string : Note about this transfer. destinations - transfer_destination[] : Array of transfer destinations. address - string : Destination public address. amount - uint64 : Amount to send to each destination, in atomic units. type - string : Type of transfer, one of the following: \"in\", \"out\", \"stake\", \"miner\", \"snode\", \"gov\", \"pending\", \"failed\", \"pool\". unlock_time - uint64 : Number of blocks until transfer is safely spendable. subaddr_index - cryptonote::subaddress_index : Major & minor index, account and subaddress index respectively. major - uint32 : The account index, major index minor - uint32 : The subaddress index, minor index subaddr_indices - cryptonote::subaddress_index[] major - uint32 : The account index, major index minor - uint32 : The subaddress index, minor index address - string : Address that transferred the funds. double_spend_seen - bool : True if the key image(s) for the transfer have been seen before. confirmations - uint64 : Number of block mined since the block containing this transaction (or block height at which the transaction should be added to a block if not yet confirmed). suggested_confirmations_threshold - uint64 : Estimation of the confirmations needed for the transaction to be included in a block. checkpointed - uint64 : If transfer is backed by atleast 2 Service Node Checkpoints, 0 if it is not, see immutable_height in the daemon rpc call get_info blink_mempool - bool : True if this is an approved blink tx in the mempool was_blink - bool : True if we saw this as an approved blink (either in the mempool or a recent, uncheckpointed block). Note that if we didn't see it while an active blink this won't be set. COMMAND_RPC_GET_TX_KEY \u00b6 Back to top Get transaction secret key from transaction id. Endpoints: get_tx_key Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_tx_key\", \"params\": { \"txid\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"tx_key\": \"1982e99c69d8acc993cfc94ce59ff8f113d23482d9a25c892a3fc01c77dd8c4c\" } Inputs: txid - string : Transaction id. Outputs: tx_key - string : Transaction secret key. COMMAND_RPC_GET_TX_NOTES \u00b6 Back to top Get string notes for transactions. Endpoints: get_tx_notes Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_tx_notes\", \"params\": { \"txids\": [\"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\"] } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"notes\": [\"TODO(loki): Write example string\"] } Inputs: txids - string[] : Transaction ids. Outputs: notes - string[] : Notes for the transactions. COMMAND_RPC_GET_TX_PROOF \u00b6 Back to top Get transaction signature to prove it. Endpoints: get_tx_proof Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_tx_proof\", \"params\": { \"txid\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"message\": \"User assigned note describing something\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"signature\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\" } Inputs: txid - string : Transaction id. address - string : Destination public address of the transaction. message - string : (Optional) add a message to the signature to further authenticate the prooving process. Outputs: signature - string : Transaction signature. COMMAND_RPC_GET_VERSION \u00b6 Back to top Get RPC version Major & Minor integer-format, where Major is the first 16 bits and Minor the last 16 bits. Endpoints: get_version Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_version\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"version\": 2130706433 } Outputs: version - uint32 : RPC version, formatted with Major * 2^16 + Minor(Major encoded over the first 16 bits, and Minor over the last 16 bits). COMMAND_RPC_IMPORT_KEY_IMAGES \u00b6 Back to top Import signed key images list and verify their spent status. Endpoints: import_key_images Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"import_key_images\", \"params\": { \"offset\": 2130706433, \"signed_key_images\": [{ \"key_image\": \"8d1bd8181bf7d857bdb281e0153d84cd55a3fcaa57c3e570f4a49f935850b5e3\", \"signature\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\" }] } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"height\": 234767, \"spent\": 123, \"unspent\": 123 } } Inputs: offset - uint32 signed_key_images - signed_key_image[] key_image - string : Key image of specific output signature - string : Transaction signature. Outputs: height - uint64 spent - uint64 : Amount (in atomic units) spent from those key images. unspent - uint64 : Amount (in atomic units) still available from those key images. COMMAND_RPC_IMPORT_MULTISIG \u00b6 Back to top Import multisig info from other participants. Endpoints: import_multisig_info Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"import_multisig_info\", \"params\": { \"info\": [\"TODO(loki): Write example string\"] } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"n_outputs\": 123 } Inputs: info - string[] : List of multisig info in hex format from other participants. Outputs: n_outputs - uint64 : Number of outputs signed with those multisig info. COMMAND_RPC_IMPORT_OUTPUTS \u00b6 Back to top Import outputs in hex format. Endpoints: import_outputs Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"import_outputs\", \"params\": { \"outputs_data_hex\": \"TODO(loki): Write example string\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"num_imported\": 123 } Inputs: outputs_data_hex - string : Wallet outputs in hex format. Outputs: num_imported - uint64 : Number of outputs imported. COMMAND_RPC_INCOMING_TRANSFERS \u00b6 Back to top Return a list of incoming transfers to the wallet. Endpoints: incoming_transfers Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"incoming_transfers\", \"params\": { \"transfer_type\": \"all\", \"account_index\": 0, \"subaddr_indices\": [0] } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"transfers\": [{ \"amount\": 26734261552878, \"spent\": true, \"global_index\": 123, \"tx_hash\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"subaddr_index\": { \"major\": 2130706433, \"minor\": 2130706433 }, \"key_image\": \"8d1bd8181bf7d857bdb281e0153d84cd55a3fcaa57c3e570f4a49f935850b5e3\", \"block_height\": 123, \"frozen\": true, \"unlocked\": true }] } Inputs: transfer_type - string : \"all\": all the transfers, \"available\": only transfers which are not yet spent, OR \"unavailable\": only transfers which are already spent. account_index - uint32 : (Optional) Return transfers for this account. (defaults to 0) subaddr_indices - uint32[] : (Optional) Return transfers sent to these subaddresses. Outputs: transfers - transfer_details[] : List of information of the transfers details. amount - uint64 : Amount of this transfer. spent - bool : Indicates if this transfer has been spent. global_index - uint64 : The index into the global list of transactions grouped by amount in the Loki network. tx_hash - string : Several incoming transfers may share the same hash if they were in the same transaction. subaddr_index - cryptonote::subaddress_index : Major & minor index, account and subaddress index respectively. major - uint32 : The account index, major index minor - uint32 : The subaddress index, minor index key_image - string : Key image for the incoming transfer's unspent output (empty unless verbose is true). block_height - uint64 : Block height the transfer occurred on frozen - bool : If the output has been intentionally frozen by the user, i.e. unspendable. unlocked - bool : If the TX is spendable yet COMMAND_RPC_IS_MULTISIG \u00b6 Back to top Check if a wallet is a multisig one. Endpoints: is_multisig Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"is_multisig\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"multisig\": true, \"ready\": true, \"threshold\": 2130706433, \"total\": 2130706433 } } Outputs: multisig - bool : States if the wallet is multisig. ready - bool threshold - uint32 : Amount of signature needed to sign a transfer. total - uint32 : Total amount of signature in the multisig wallet. COMMAND_RPC_LABEL_ACCOUNT \u00b6 Back to top Label an account. Endpoints: label_account Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"label_account\", \"params\": { \"account_index\": 0, \"label\": \"My label\" } } EOF Inputs: account_index - uint32 : Account index to set the label for. label - string : Label for the account. COMMAND_RPC_LABEL_ADDRESS \u00b6 Back to top Label an address. Endpoints: label_address Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"label_address\", \"params\": { \"index\": { \"major\": 2130706433, \"minor\": 2130706433 }, \"label\": \"My label\" } } EOF Inputs: index - cryptonote::subaddress_index : Major & minor address index major - uint32 : The account index, major index minor - uint32 : The subaddress index, minor index label - string : Label for the address. COMMAND_RPC_LNS_BUY_MAPPING \u00b6 Back to top Endpoints: lns_buy_mapping Constants: * `R - char *description =` Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"lns_buy_mapping\", \"params\": { \"type\": session, \"owner\": \"L8ssYFtxi1HTFQdbmG9Lt71tyudgageDgBqBLcgLnw5XBiJ1NQLFYNAAfYpYS3jHaSe8UsFYjSgKadKhC7edTSQB15s6T7g\", \"backup_owner\": \"L8PYYYTh6yEewvuPmF75uhjDn9fBzKXp8CeMuwKNZBvZT8wAoe9hJ4favnZMvTTkNdT56DMNDcdWyheb3icfk4MS3udsP4R\", \"name\": \"My_Lns_Name\", \"value\": \"059f5a1ac2d04d0c09daa21b08699e8e2e0fd8d6fbe119207e5f241043cf77c30d\", \"account_index\": 0, \"subaddr_indices\": [0], \"priority\": 0, \"get_tx_key\": true, \"do_not_relay\": true, \"get_tx_hex\": true, \"get_tx_metadata\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"tx_hash\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"tx_key\": \"1982e99c69d8acc993cfc94ce59ff8f113d23482d9a25c892a3fc01c77dd8c4c\", \"amount\": 26734261552878, \"fee\": 123, \"tx_blob\": \"0402f78b05f78b05f78b0501ffd98b0502b888ddcf730229f056f5594cfcfd8d44f8033c9fda22450693d1694038e1cecaaaac25a8fc12af8992bc800102534df00c14ead3b3dedea9e7bdcf71c44803349b5e9aee2f73e22d5385ac147b7601008e5729d9329320444666d9d9d9dc602a3ae585de91ab2ca125665e3a363610021100000001839fdb0000000000000000000001200408d5ad7ab79d9b05c94033c2029f4902a98ec51f5175564f6978467dbb28723f929cf806d4ee1c781d7771183a93a1fd74f0827bddee9baac7e3083ab2b5840000\", \"tx_metadata\": \"TODO(loki): Write example string\", \"multisig_txset\": \"TODO(loki): Write example string\", \"unsigned_txset\": \"TODO(loki): Write example string\" } } Inputs: type - string : The mapping type, currently we only support \"session\". In future \"lokinet\" and \"blockchain\" mappings will be available. owner - string : (Optional): The ed25519 public key or wallet address that has authority to update the mapping. backup_owner - string : (Optional): The secondary, backup public key that has authority to update the mapping. name - string : The name to purchase via Loki Name Service value - string : The value that the name maps to via Loki Name Service, (i.e. For Session: [display name->session public key]. In future, for wallets: [name->wallet address], for Lokinet: [name->domain name]). account_index - uint32 : (Optional) Transfer from this account index. (Defaults to 0) subaddr_indices - uint32[] : (Optional) Transfer from this set of subaddresses. (Defaults to 0) priority - uint32 : Set a priority for the transaction. Accepted values are: or 0-4 for: default, unimportant, normal, elevated, priority. get_tx_key - bool : (Optional) Return the transaction key after sending. do_not_relay - bool : (Optional) If true, the newly created transaction will not be relayed to the loki network. (Defaults to false) get_tx_hex - bool : Return the transaction as hex string after sending (Defaults to false) get_tx_metadata - bool : Return the metadata needed to relay the transaction. (Defaults to false) Outputs: tx_hash - string : Publically searchable transaction hash. tx_key - string : Transaction key if get_tx_key is true , otherwise, blank string. amount - uint64 : Amount transferred for the transaction in atomic units. fee - uint64 : Value in atomic units of the fee charged for the tx. tx_blob - string : Raw transaction represented as hex string, if get_tx_hex is true. tx_metadata - string : Set of transaction metadata needed to relay this transfer later, if get_tx_metadata is true . multisig_txset - string : Set of multisig transactions in the process of being signed (empty for non-multisig). unsigned_txset - string : Set of unsigned tx for cold-signing purposes. COMMAND_RPC_LNS_DECRYPT_VALUE \u00b6 Back to top Takes a LNS encrypted value and decrypts the mapping value. Endpoints: lns_decrypt_value Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"lns_decrypt_value\", \"params\": { \"name\": \"TODO(loki): Write example string\", \"type\": \"TODO(loki): Write example string\", \"encrypted_value\": \"TODO(loki): Write example string\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"value\": \"TODO(loki): Write example string\" } Inputs: name - string : The desired name to hash type - string : The mapping type, currently we only support \"session\". In future \"lokinet\" and \"blockchain\" mappings will be available. encrypted_value - string : The encrypted value represented in hex Outputs: value - string : The value decrypted COMMAND_RPC_LNS_HASH_NAME \u00b6 Back to top Takes a LNS name, upon validating it, generates the hash and returns the base64 representation of the hash suitable for use in the daemon LNS name queries. Endpoints: lns_hash_name Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"lns_hash_name\", \"params\": { \"type\": \"TODO(loki): Write example string\", \"name\": \"TODO(loki): Write example string\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"name\": \"TODO(loki): Write example string\" } Inputs: type - string : The mapping type, currently we only support \"session\". In future \"lokinet\" and \"blockchain\" mappings will be available. name - string : The desired name to hash Outputs: name - string : The name hashed and represented in base64 COMMAND_RPC_LNS_MAKE_UPDATE_SIGNATURE \u00b6 Back to top Endpoints: lns_make_update_mapping_signature Constants: * `R - char *description =` Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"lns_make_update_mapping_signature\", \"params\": { \"type\": session, \"name\": \"My_Lns_Name\", \"value\": \"059f5a1ac2d04d0c09daa21b08699e8e2e0fd8d6fbe119207e5f241043cf77c30d\", \"owner\": \"L8ssYFtxi1HTFQdbmG9Lt71tyudgageDgBqBLcgLnw5XBiJ1NQLFYNAAfYpYS3jHaSe8UsFYjSgKadKhC7edTSQB15s6T7g\", \"backup_owner\": \"L8PYYYTh6yEewvuPmF75uhjDn9fBzKXp8CeMuwKNZBvZT8wAoe9hJ4favnZMvTTkNdT56DMNDcdWyheb3icfk4MS3udsP4R\", \"account_index\": 0 } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"signature\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\" } Inputs: type - string : The mapping type, currently we only support \"session\". In future \"lokinet\" and \"blockchain\" mappings will be available. name - string : The desired name to update via Loki Name Service value - string : (Optional): The new value that the name maps to via Loki Name Service. If not specified or given the empty string \"\", then the mapping's value remains unchanged. owner - string : (Optional): The new owner of the mapping. If not specified or given the empty string \"\", then the mapping's owner remains unchanged. backup_owner - string : (Optional): The new backup owner of the mapping. If not specified or given the empty string \"\", then the mapping's backup owner remains unchanged. account_index - uint32 : (Optional) Use this wallet's subaddress account for generating the signature Outputs: signature - string : A signature valid for using in LNS to update an underlying mapping. COMMAND_RPC_LNS_UPDATE_MAPPING \u00b6 Back to top Update the underlying value in the name->value mapping via Loki Name Service. Endpoints: lns_update_mapping Constants: * `R - char *description =` Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"lns_update_mapping\", \"params\": { \"type\": session, \"name\": \"My_Lns_Name\", \"value\": \"059f5a1ac2d04d0c09daa21b08699e8e2e0fd8d6fbe119207e5f241043cf77c30d\", \"owner\": \"L8ssYFtxi1HTFQdbmG9Lt71tyudgageDgBqBLcgLnw5XBiJ1NQLFYNAAfYpYS3jHaSe8UsFYjSgKadKhC7edTSQB15s6T7g\", \"backup_owner\": \"L8PYYYTh6yEewvuPmF75uhjDn9fBzKXp8CeMuwKNZBvZT8wAoe9hJ4favnZMvTTkNdT56DMNDcdWyheb3icfk4MS3udsP4R\", \"signature\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"account_index\": 0, \"subaddr_indices\": [0], \"priority\": 0, \"get_tx_key\": true, \"do_not_relay\": true, \"get_tx_hex\": true, \"get_tx_metadata\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"tx_hash\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"tx_key\": \"1982e99c69d8acc993cfc94ce59ff8f113d23482d9a25c892a3fc01c77dd8c4c\", \"amount\": 26734261552878, \"fee\": 123, \"tx_blob\": \"0402f78b05f78b05f78b0501ffd98b0502b888ddcf730229f056f5594cfcfd8d44f8033c9fda22450693d1694038e1cecaaaac25a8fc12af8992bc800102534df00c14ead3b3dedea9e7bdcf71c44803349b5e9aee2f73e22d5385ac147b7601008e5729d9329320444666d9d9d9dc602a3ae585de91ab2ca125665e3a363610021100000001839fdb0000000000000000000001200408d5ad7ab79d9b05c94033c2029f4902a98ec51f5175564f6978467dbb28723f929cf806d4ee1c781d7771183a93a1fd74f0827bddee9baac7e3083ab2b5840000\", \"tx_metadata\": \"TODO(loki): Write example string\", \"multisig_txset\": \"TODO(loki): Write example string\", \"unsigned_txset\": \"TODO(loki): Write example string\" } } Inputs: type - string : The mapping type, currently we only support \"session\". In future \"lokinet\" and \"blockchain\" mappings will be available. name - string : The name to update via Loki Name Service value - string : (Optional): The new value that the name maps to via Loki Name Service. If not specified or given the empty string \"\", then the mapping's value remains unchanged. owner - string : (Optional): The new owner of the mapping. If not specified or given the empty string \"\", then the mapping's owner remains unchanged. backup_owner - string : (Optional): The new backup owner of the mapping. If not specified or given the empty string \"\", then the mapping's backup owner remains unchanged. signature - string : (Optional): Signature derived using libsodium generichash on {current txid blob, new value blob} of the mapping to update. By default the hash is signed using the wallet's spend key as an ed25519 keypair, if signature is specified. account_index - uint32 : (Optional) Transfer from this account index. (Defaults to 0) subaddr_indices - uint32[] : (Optional) Transfer from this set of subaddresses. (Defaults to 0) priority - uint32 : Set a priority for the transaction. Accepted values are: 0-4 for: default, unimportant, normal, elevated, priority. get_tx_key - bool : (Optional) Return the transaction key after sending. do_not_relay - bool : (Optional) If true, the newly created transaction will not be relayed to the loki network. (Defaults to false) get_tx_hex - bool : Return the transaction as hex string after sending (Defaults to false) get_tx_metadata - bool : Return the metadata needed to relay the transaction. (Defaults to false) Outputs: tx_hash - string : Publically searchable transaction hash. tx_key - string : Transaction key if get_tx_key is true , otherwise, blank string. amount - uint64 : Amount transferred for the transaction in atomic units. fee - uint64 : Value in atomic units of the fee charged for the tx. tx_blob - string : Raw transaction represented as hex string, if get_tx_hex is true. tx_metadata - string : Set of transaction metadata needed to relay this transfer later, if get_tx_metadata is true . multisig_txset - string : Set of multisig transactions in the process of being signed (empty for non-multisig). unsigned_txset - string : Set of unsigned tx for cold-signing purposes. COMMAND_RPC_MAKE_INTEGRATED_ADDRESS \u00b6 Back to top Make an integrated address from the wallet address and a payment id. Endpoints: make_integrated_address Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"make_integrated_address\", \"params\": { \"standard_address\": \"TODO(loki): Write example string\", \"payment_id\": \"f378710e54eeeb8d\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"integrated_address\": \"TODO(loki): Write example string\", \"payment_id\": \"f378710e54eeeb8d\" } } Inputs: standard_address - string : (Optional, defaults to primary address) Destination public address. payment_id - string : (Optional, defaults to a random ID) 16 characters hex encoded. Outputs: integrated_address - string payment_id - string : Hex encoded. COMMAND_RPC_MAKE_MULTISIG \u00b6 Back to top Make a wallet multisig by importing peers multisig string. Endpoints: make_multisig Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"make_multisig\", \"params\": { \"multisig_info\": [\"TODO(loki): Write example string\"], \"threshold\": 2130706433, \"password\": \"not_a_secure_password\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"multisig_info\": \"TODO(loki): Write example string\" } } Inputs: multisig_info - string[] : List of multisig string from peers. threshold - uint32 : Amount of signatures needed to sign a transfer. Must be less or equal than the amount of signature in multisig_info . password - string : Wallet password. Outputs: address - string : Multisig wallet address. multisig_info - string : Multisig string to share with peers to create the multisig wallet (extra step for N-1/N wallets). COMMAND_RPC_MAKE_URI \u00b6 Back to top Create a payment URI using the official URI spec. Endpoints: make_uri Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"make_uri\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"uri\": \"TODO(loki): Write example string\" } Inputs: address - string : Wallet address. payment_id - string : (Optional) 16 or 64 character hexadecimal payment id. amount - uint64 : (Optional) the integer amount to receive, in atomic units. tx_description - string : (Optional) Description of the reason for the tx. recipient_name - string : (Optional) name of the payment recipient. Outputs: uri - string : This contains all the payment input information as a properly formatted payment URI. COMMAND_RPC_OPEN_WALLET \u00b6 Back to top Open a wallet. You need to have set the argument \"\u2013-wallet-dir\" when launching loki-wallet-rpc to make this work. The wallet rpc executable may only open wallet files within the same directory as wallet-dir, otherwise use the \"--wallet-file\" flag to open specific wallets. Endpoints: open_wallet Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"open_wallet\", \"params\": { \"filename\": \"Doyles_Cool_Wallet\", \"password\": \"not_a_secure_password\", \"autosave_current\": true } } EOF Inputs: filename - string : Wallet name stored in \"\u2013-wallet-dir\". password - string : The wallet password, set as \"\" if there's no password autosave_current - bool : (Optional: Default true): If a pre-existing wallet is open, save to disk before opening the new wallet. COMMAND_RPC_PARSE_URI \u00b6 Back to top Parse a payment URI to get payment information. Endpoints: parse_uri Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"parse_uri\", \"params\": { \"uri\": \"TODO(loki): Write example string\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"uri\": { \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"payment_id\": \"f378710e54eeeb8d\", \"amount\": 26734261552878, \"tx_description\": \"User assigned note describing something\", \"recipient_name\": \"Thor\" }, \"unknown_parameters\": [\"TODO(loki): Write example string\"] } } Inputs: uri - string : This contains all the payment input information as a properly formatted payment URI. Outputs: uri - uri_spec : JSON object containing payment information: address - string : Wallet address. payment_id - string : (Optional) 16 or 64 character hexadecimal payment id. amount - uint64 : (Optional) the integer amount to receive, in atomic units. tx_description - string : (Optional) Description of the reason for the tx. recipient_name - string : (Optional) name of the payment recipient. unknown_parameters - string[] COMMAND_RPC_PREPARE_MULTISIG \u00b6 Back to top Prepare a wallet for multisig by generating a multisig string to share with peers. Endpoints: prepare_multisig Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"prepare_multisig\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"multisig_info\": \"TODO(loki): Write example string\" } Outputs: multisig_info - string : Multisig string to share with peers to create the multisig wallet. COMMAND_RPC_QUERY_KEY \u00b6 Back to top Return the spend or view private key. Endpoints: query_key Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"query_key\", \"params\": { \"key_type\": \"TODO(loki): Write example string\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"key\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\" } Inputs: key_type - string : Which key to retrieve: \"mnemonic\" - the mnemonic seed (older wallets do not have one) OR \"view_key\" - the view key Outputs: key - string : The view key will be hex encoded, while the mnemonic will be a string of words. COMMAND_RPC_REFRESH \u00b6 Back to top Refresh a wallet after openning. Endpoints: refresh Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"refresh\", \"params\": { \"start_height\": 123 } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"blocks_fetched\": 123, \"received_money\": true } } Inputs: start_height - uint64 : (Optional) The block height from which to start refreshing. Outputs: blocks_fetched - uint64 : Number of new blocks scanned. received_money - bool : States if transactions to the wallet have been found in the blocks. COMMAND_RPC_REGISTER_SERVICE_NODE \u00b6 Back to top Register Service Node. Endpoints: register_service_node Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"register_service_node\", \"params\": { \"register_service_node_str\": \"TODO(loki): Write example string\", \"get_tx_key\": true, \"do_not_relay\": true, \"get_tx_hex\": true, \"get_tx_metadata\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"tx_hash\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"tx_key\": \"1982e99c69d8acc993cfc94ce59ff8f113d23482d9a25c892a3fc01c77dd8c4c\", \"amount\": 26734261552878, \"fee\": 123, \"tx_blob\": \"0402f78b05f78b05f78b0501ffd98b0502b888ddcf730229f056f5594cfcfd8d44f8033c9fda22450693d1694038e1cecaaaac25a8fc12af8992bc800102534df00c14ead3b3dedea9e7bdcf71c44803349b5e9aee2f73e22d5385ac147b7601008e5729d9329320444666d9d9d9dc602a3ae585de91ab2ca125665e3a363610021100000001839fdb0000000000000000000001200408d5ad7ab79d9b05c94033c2029f4902a98ec51f5175564f6978467dbb28723f929cf806d4ee1c781d7771183a93a1fd74f0827bddee9baac7e3083ab2b5840000\", \"tx_metadata\": \"TODO(loki): Write example string\", \"multisig_txset\": \"TODO(loki): Write example string\", \"unsigned_txset\": \"TODO(loki): Write example string\" } } Inputs: register_service_node_str - string : String supplied by the prepare_registration command. get_tx_key - bool : (Optional) Return the transaction key after sending. do_not_relay - bool : (Optional) If true, the newly created transaction will not be relayed to the loki network. (Defaults to false) get_tx_hex - bool : Return the transaction as hex string after sending (Defaults to false) get_tx_metadata - bool : Return the metadata needed to relay the transaction. (Defaults to false) Outputs: tx_hash - string : Publically searchable transaction hash. tx_key - string : Transaction key if get_tx_key is true, otherwise, blank string. amount - uint64 : Amount transferred for the transaction in atomic units. fee - uint64 : Value in atomic units of the fee charged for the tx. tx_blob - string : Raw transaction represented as hex string, if get_tx_hex is true. tx_metadata - string : Set of transaction metadata needed to relay this transfer later, if get_tx_metadata is true . multisig_txset - string : Set of multisig transactions in the process of being signed (empty for non-multisig). unsigned_txset - string : Set of unsigned tx for cold-signing purposes. COMMAND_RPC_RELAY_TX \u00b6 Back to top Relay transaction metadata to the daemon Endpoints: relay_tx Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"relay_tx\", \"params\": { \"hex\": \"TODO(loki): Write example string\", \"blink\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"tx_hash\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\" } Inputs: hex - string : Transaction metadata returned from a transfer method with get_tx_metadata set to true. blink - bool : (Optional): True if this tx was constructed with a blink priority and should be submitted to the blink quorum Outputs: tx_hash - string : String for the publically searchable transaction hash. COMMAND_RPC_REQUEST_STAKE_UNLOCK \u00b6 Back to top Request to unlock stake by deregistering Service Node. Endpoints: request_stake_unlock Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"request_stake_unlock\", \"params\": { \"service_node_key\": \"4a8c30cea9e729b06c91132295cce32d2a8e6e5bcf7b74a998e2ee1b3ed590b3\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"unlocked\": true, \"msg\": \"Message returned by the sender (wallet/daemon)\" } } Inputs: service_node_key - string : Service Node Public Key. Outputs: unlocked - bool : States if stake has been unlocked. msg - string : Information on the unlocking process. COMMAND_RPC_RESCAN_BLOCKCHAIN \u00b6 Back to top Rescan the blockchain from scratch, losing any information which can not be recovered from the blockchain itself. This includes destination addresses, tx secret keys, tx notes, etc. Warning: This blocks the Wallet RPC executable until rescanning is complete. Endpoints: rescan_blockchain Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"rescan_blockchain\", \"params\": { \"hard\": true } } EOF Inputs: hard - bool COMMAND_RPC_RESCAN_SPENT \u00b6 Back to top Rescan the blockchain for spent outputs. Endpoints: rescan_spent Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"rescan_spent\" } EOF COMMAND_RPC_RESTORE_DETERMINISTIC_WALLET \u00b6 Back to top Restore a wallet using the seed words. Endpoints: restore_deterministic_wallet Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"restore_deterministic_wallet\", \"params\": { \"restore_height\": 123, \"filename\": \"Doyles_Cool_Wallet\", \"seed\": \"TODO(loki): Write example string\", \"seed_offset\": \"TODO(loki): Write example string\", \"password\": \"not_a_secure_password\", \"language\": \"english\", \"autosave_current\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"seed\": \"TODO(loki): Write example string\", \"info\": \"TODO(loki): Write example string\", \"was_deprecated\": true } } Inputs: restore_height - uint64 : Height in which to start scanning the blockchain for transactions into and out of this Wallet. filename - string : Set the name of the Wallet. seed - string : Mnemonic seed of wallet (25 words). seed_offset - string password - string : Set password for Wallet. language - string : Set language for the wallet. autosave_current - bool : (Optional: Default true): If a pre-existing wallet is open, save to disk before opening the new wallet. Outputs: address - string : Public address of wallet. seed - string : Seed of wallet. info - string : Wallet information. was_deprecated - bool COMMAND_RPC_SET_ACCOUNT_TAG_DESCRIPTION \u00b6 Back to top Set description for an account tag. Endpoints: set_account_tag_description Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"set_account_tag_description\", \"params\": { \"tag\": \"My tag\", \"description\": \"My account description\" } } EOF Inputs: tag - string : Set a description for this tag. description - string : Description for the tag. COMMAND_RPC_SET_ATTRIBUTE \u00b6 Back to top Set arbitrary attribute. Endpoints: set_attribute Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"set_attribute\", \"params\": { \"key\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"value\": \"TODO(loki): Write example string\" } } EOF Inputs: key - string : Attribute name. value - string : Attribute value. COMMAND_RPC_SET_DAEMON \u00b6 Back to top Endpoints: set_daemon Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"set_daemon\", \"params\": { \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"trusted\": true, \"ssl_support\": \"TODO(loki): Write example string\", \"ssl_private_key_path\": \"TODO(loki): Write example string\", \"ssl_certificate_path\": \"TODO(loki): Write example string\", \"ssl_ca_file\": \"TODO(loki): Write example string\", \"ssl_allowed_fingerprints\": [\"TODO(loki): Write example string\"], \"ssl_allow_any_cert\": true } } EOF Inputs: address - string : The remote address of the daemon trusted - bool : When true, allow the usage of commands that may compromise privacy ssl_support - string : disabled, enabled, autodetect ssl_private_key_path - string ssl_certificate_path - string ssl_ca_file - string ssl_allowed_fingerprints - string[] ssl_allow_any_cert - bool COMMAND_RPC_SET_LOG_CATEGORIES \u00b6 Back to top Endpoints: set_log_categories Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"set_log_categories\", \"params\": { \"categories\": \"TODO(loki): Write example string\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"categories\": \"TODO(loki): Write example string\" } Inputs: categories - string Outputs: categories - string COMMAND_RPC_SET_LOG_LEVEL \u00b6 Back to top Endpoints: set_log_level Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"set_log_level\", \"params\": { \"level\": 8 } } EOF Inputs: level - int8 COMMAND_RPC_SET_TX_NOTES \u00b6 Back to top Set arbitrary string notes for transactions. Endpoints: set_tx_notes Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"set_tx_notes\", \"params\": { \"txids\": [\"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\"], \"notes\": [\"TODO(loki): Write example string\"] } } EOF Inputs: txids - string[] : Transaction ids. notes - string[] : Notes for the transactions. COMMAND_RPC_SIGN \u00b6 Back to top Sign a string. Endpoints: sign Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"sign\", \"params\": { \"data\": \"TODO(loki): Write example string\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"signature\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\" } Inputs: data - string : Anything you need to sign. Outputs: signature - string : Signature generated against the \"data\" and the account public address. COMMAND_RPC_SIGN_MULTISIG \u00b6 Back to top Sign a transaction in multisig. Endpoints: sign_multisig Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"sign_multisig\", \"params\": { \"tx_data_hex\": \"TODO(loki): Write example string\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"tx_data_hex\": \"TODO(loki): Write example string\", \"tx_hash_list\": [\"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\"] } } Inputs: tx_data_hex - string : Multisig transaction in hex format, as returned by transfer under multisig_txset . Outputs: tx_data_hex - string : Multisig transaction in hex format. tx_hash_list - string[] : List of transaction Hash. COMMAND_RPC_SIGN_TRANSFER \u00b6 Back to top Sign a transaction created on a read-only wallet (in cold-signing process). Endpoints: sign_transfer Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"sign_transfer\", \"params\": { \"unsigned_txset\": \"TODO(loki): Write example string\", \"export_raw\": true, \"get_tx_keys\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"signed_txset\": \"TODO(loki): Write example string\", \"tx_hash_list\": [\"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\"], \"tx_raw_list\": [\"TODO(loki): Write example string\"], \"tx_key_list\": [\"1982e99c69d8acc993cfc94ce59ff8f113d23482d9a25c892a3fc01c77dd8c4c\"] } } Inputs: unsigned_txset - string : Set of unsigned tx returned by \"transfer\" or \"transfer_split\" methods. export_raw - bool : (Optional) If true, return the raw transaction data. (Defaults to false) get_tx_keys - bool : (Optional) Return the transaction keys after sending. Outputs: signed_txset - string : Set of signed tx to be used for submitting transfer. tx_hash_list - string[] : The tx hashes of every transaction. tx_raw_list - string[] : The tx raw data of every transaction. tx_key_list - string[] : The tx key data of every transaction. COMMAND_RPC_SPLIT_INTEGRATED_ADDRESS \u00b6 Back to top Retrieve the standard address and payment id corresponding to an integrated address. Endpoints: split_integrated_address Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"split_integrated_address\", \"params\": { \"integrated_address\": \"TODO(loki): Write example string\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"standard_address\": \"TODO(loki): Write example string\", \"payment_id\": \"f378710e54eeeb8d\", \"is_subaddress\": true } } Inputs: integrated_address - string Outputs: standard_address - string payment_id - string is_subaddress - bool COMMAND_RPC_STAKE \u00b6 Back to top Stake for Service Node. Endpoints: stake Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"stake\", \"params\": { \"destination\": \"L8ssYFtxi1HTFQdbmG9Lt71tyudgageDgBqBLcgLnw5XBiJ1NQLFYNAAfYpYS3jHaSe8UsFYjSgKadKhC7edTSQB15s6T7g\", \"amount\": 26734261552878, \"subaddr_indices\": [0], \"service_node_key\": \"4a8c30cea9e729b06c91132295cce32d2a8e6e5bcf7b74a998e2ee1b3ed590b3\", \"priority\": 0, \"get_tx_key\": true, \"do_not_relay\": true, \"get_tx_hex\": true, \"get_tx_metadata\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"tx_hash\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"tx_key\": \"1982e99c69d8acc993cfc94ce59ff8f113d23482d9a25c892a3fc01c77dd8c4c\", \"amount\": 26734261552878, \"fee\": 123, \"tx_blob\": \"0402f78b05f78b05f78b0501ffd98b0502b888ddcf730229f056f5594cfcfd8d44f8033c9fda22450693d1694038e1cecaaaac25a8fc12af8992bc800102534df00c14ead3b3dedea9e7bdcf71c44803349b5e9aee2f73e22d5385ac147b7601008e5729d9329320444666d9d9d9dc602a3ae585de91ab2ca125665e3a363610021100000001839fdb0000000000000000000001200408d5ad7ab79d9b05c94033c2029f4902a98ec51f5175564f6978467dbb28723f929cf806d4ee1c781d7771183a93a1fd74f0827bddee9baac7e3083ab2b5840000\", \"tx_metadata\": \"TODO(loki): Write example string\", \"multisig_txset\": \"TODO(loki): Write example string\", \"unsigned_txset\": \"TODO(loki): Write example string\" } } Inputs: destination - string : Primary Public address that the rewards will go to. amount - uint64 : Amount of Loki to stake in atomic units. subaddr_indices - uint32[] : (Optional) Transfer from this set of subaddresses. (Defaults to 0) service_node_key - string : Service Node Public Address. priority - uint32 : Set a priority for the transaction. Accepted values are: or 0-4 for: default, unimportant, normal, elevated, priority. get_tx_key - bool : (Optional) Return the transaction key after sending. do_not_relay - bool : (Optional) If true, the newly created transaction will not be relayed to the loki network. (Defaults to false) get_tx_hex - bool : Return the transaction as hex string after sending (Defaults to false) get_tx_metadata - bool : Return the metadata needed to relay the transaction. (Defaults to false) Outputs: tx_hash - string : Publically searchable transaction hash. tx_key - string : Transaction key if get_tx_key is true , otherwise, blank string. amount - uint64 : Amount transferred for the transaction in atomic units. fee - uint64 : Value in atomic units of the fee charged for the tx. tx_blob - string : Raw transaction represented as hex string, if get_tx_hex is true. tx_metadata - string : Set of transaction metadata needed to relay this transfer later, if get_tx_metadata is true . multisig_txset - string : Set of multisig transactions in the process of being signed (empty for non-multisig). unsigned_txset - string : Set of unsigned tx for cold-signing purposes. COMMAND_RPC_START_MINING \u00b6 Back to top Start mining in the loki daemon. Endpoints: start_mining Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"start_mining\", \"params\": { \"threads_count\": 123 } } EOF Inputs: threads_count - uint64 : Number of threads created for mining. COMMAND_RPC_STOP_MINING \u00b6 Back to top Stop mining in the loki daemon. Endpoints: stop_mining Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"stop_mining\" } EOF COMMAND_RPC_STOP_WALLET \u00b6 Back to top Stops the wallet, storing the current state. Endpoints: stop_wallet Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"stop_wallet\" } EOF COMMAND_RPC_STORE \u00b6 Back to top Save the wallet file. Endpoints: store Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"store\" } EOF COMMAND_RPC_SUBMIT_MULTISIG \u00b6 Back to top Submit a signed multisig transaction. Endpoints: submit_multisig Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"submit_multisig\", \"params\": { \"tx_data_hex\": \"TODO(loki): Write example string\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"tx_hash_list\": [\"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\"] } Inputs: tx_data_hex - string : Multisig transaction in hex format, as returned by sign_multisig under tx_data_hex. Outputs: tx_hash_list - string[] : List of transaction hash. COMMAND_RPC_SUBMIT_TRANSFER \u00b6 Back to top Submit a previously signed transaction on a read-only wallet (in cold-signing process). Endpoints: submit_transfer Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"submit_transfer\", \"params\": { \"tx_data_hex\": \"TODO(loki): Write example string\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"tx_hash_list\": [\"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\"] } Inputs: tx_data_hex - string : Set of signed tx returned by \"sign_transfer\". Outputs: tx_hash_list - string[] : The tx hashes of every transaction. COMMAND_RPC_SWEEP_ALL \u00b6 Back to top Send all unlocked balance to an address. Endpoints: sweep_all Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"sweep_all\", \"params\": { \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"account_index\": 0, \"subaddr_indices\": [0], \"priority\": 0, \"blink\": true, \"outputs\": 10, \"unlock_time\": 123, \"payment_id\": \"f378710e54eeeb8d\", \"get_tx_keys\": true, \"below_amount\": 123, \"do_not_relay\": true, \"get_tx_hex\": true, \"get_tx_metadata\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"tx_hash_list\": [\"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\"], \"tx_key_list\": [\"1982e99c69d8acc993cfc94ce59ff8f113d23482d9a25c892a3fc01c77dd8c4c\"], \"amount_list\": [123], \"fee_list\": [123], \"tx_blob_list\": [\"0402f78b05f78b05f78b0501ffd98b0502b888ddcf730229f056f5594cfcfd8d44f8033c9fda22450693d1694038e1cecaaaac25a8fc12af8992bc800102534df00c14ead3b3dedea9e7bdcf71c44803349b5e9aee2f73e22d5385ac147b7601008e5729d9329320444666d9d9d9dc602a3ae585de91ab2ca125665e3a363610021100000001839fdb0000000000000000000001200408d5ad7ab79d9b05c94033c2029f4902a98ec51f5175564f6978467dbb28723f929cf806d4ee1c781d7771183a93a1fd74f0827bddee9baac7e3083ab2b5840000\"], \"tx_metadata_list\": [\"TODO(loki): Write example string\"], \"multisig_txset\": \"TODO(loki): Write example string\", \"unsigned_txset\": \"TODO(loki): Write example string\" } } Inputs: address - string : Destination public address. account_index - uint32 : Sweep transactions from this account. subaddr_indices - uint32[] : (Optional) Sweep from this set of subaddresses in the account. priority - uint32 : Set a priority for the transaction. Accepted values are: 1 for unimportant or 5 for blink. (0 and 2-4 are accepted for backwards compatibility and are equivalent to 5) blink - bool : (Deprecated) Set priority to 5 for blink, field is deprecated: specifies that the tx should be blinked ( priority will be ignored). outputs - uint64 unlock_time - uint64 : Number of blocks before the loki can be spent (0 to not add a lock). payment_id - string : (Optional) 64-character hex string to identify a transaction. get_tx_keys - bool : (Optional) Return the transaction keys after sending. below_amount - uint64 : (Optional) Include outputs below this amount. do_not_relay - bool : (Optional) If true, do not relay this sweep transfer. (Defaults to false) get_tx_hex - bool : (Optional) return the transactions as hex encoded string. (Defaults to false) get_tx_metadata - bool : (Optional) return the transaction metadata as a string. (Defaults to false) Outputs: tx_hash_list - string[] : The tx hashes of every transaction. tx_key_list - string[] : The transaction keys for every transaction. amount_list - uint64[] : The amount transferred for every transaction. fee_list - uint64[] : The amount of fees paid for every transaction. tx_blob_list - string[] : The tx as hex string for every transaction. tx_metadata_list - string[] : List of transaction metadata needed to relay the transactions later. multisig_txset - string : The set of signing keys used in a multisig transaction (empty for non-multisig). unsigned_txset - string : Set of unsigned tx for cold-signing purposes. COMMAND_RPC_SWEEP_DUST \u00b6 Back to top Send all dust outputs back to the wallet's, to make them easier to spend (and mix). Endpoints: sweep_dust Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"sweep_dust\", \"params\": { \"get_tx_keys\": true, \"do_not_relay\": true, \"get_tx_hex\": true, \"get_tx_metadata\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"tx_hash_list\": [\"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\"], \"tx_key_list\": [\"1982e99c69d8acc993cfc94ce59ff8f113d23482d9a25c892a3fc01c77dd8c4c\"], \"amount_list\": [123], \"fee_list\": [123], \"tx_blob_list\": [\"0402f78b05f78b05f78b0501ffd98b0502b888ddcf730229f056f5594cfcfd8d44f8033c9fda22450693d1694038e1cecaaaac25a8fc12af8992bc800102534df00c14ead3b3dedea9e7bdcf71c44803349b5e9aee2f73e22d5385ac147b7601008e5729d9329320444666d9d9d9dc602a3ae585de91ab2ca125665e3a363610021100000001839fdb0000000000000000000001200408d5ad7ab79d9b05c94033c2029f4902a98ec51f5175564f6978467dbb28723f929cf806d4ee1c781d7771183a93a1fd74f0827bddee9baac7e3083ab2b5840000\"], \"tx_metadata_list\": [\"TODO(loki): Write example string\"], \"multisig_txset\": \"TODO(loki): Write example string\", \"unsigned_txset\": \"TODO(loki): Write example string\" } } Inputs: get_tx_keys - bool : (Optional) Return the transaction keys after sending. do_not_relay - bool : (Optional) If true, the newly created transaction will not be relayed to the loki network. (Defaults to false) get_tx_hex - bool : (Optional) Return the transactions as hex string after sending. (Defaults to false) get_tx_metadata - bool : (Optional) Return list of transaction metadata needed to relay the transfer later. (Defaults to false) Outputs: tx_hash_list - string[] : The tx hashes of every transaction. tx_key_list - string[] : The transaction keys for every transaction. amount_list - uint64[] : The amount transferred for every transaction. fee_list - uint64[] : The amount of fees paid for every transaction. tx_blob_list - string[] : The tx as hex string for every transaction. tx_metadata_list - string[] : List of transaction metadata needed to relay the transactions later. multisig_txset - string : The set of signing keys used in a multisig transaction (empty for non-multisig). unsigned_txset - string : Set of unsigned tx for cold-signing purposes. COMMAND_RPC_SWEEP_SINGLE \u00b6 Back to top Send all of a specific unlocked output to an address. Endpoints: sweep_single Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"sweep_single\", \"params\": { \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"priority\": 0, \"blink\": true, \"outputs\": 10, \"unlock_time\": 123, \"payment_id\": \"f378710e54eeeb8d\", \"get_tx_key\": true, \"key_image\": \"8d1bd8181bf7d857bdb281e0153d84cd55a3fcaa57c3e570f4a49f935850b5e3\", \"do_not_relay\": true, \"get_tx_hex\": true, \"get_tx_metadata\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"tx_hash\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"tx_key\": \"1982e99c69d8acc993cfc94ce59ff8f113d23482d9a25c892a3fc01c77dd8c4c\", \"amount\": 26734261552878, \"fee\": 123, \"tx_blob\": \"0402f78b05f78b05f78b0501ffd98b0502b888ddcf730229f056f5594cfcfd8d44f8033c9fda22450693d1694038e1cecaaaac25a8fc12af8992bc800102534df00c14ead3b3dedea9e7bdcf71c44803349b5e9aee2f73e22d5385ac147b7601008e5729d9329320444666d9d9d9dc602a3ae585de91ab2ca125665e3a363610021100000001839fdb0000000000000000000001200408d5ad7ab79d9b05c94033c2029f4902a98ec51f5175564f6978467dbb28723f929cf806d4ee1c781d7771183a93a1fd74f0827bddee9baac7e3083ab2b5840000\", \"tx_metadata\": \"TODO(loki): Write example string\", \"multisig_txset\": \"TODO(loki): Write example string\", \"unsigned_txset\": \"TODO(loki): Write example string\" } } Inputs: address - string : Destination public address. priority - uint32 : Set a priority for the transaction. Accepted values are: 1 for unimportant or 5 for blink. (0 and 2-4 are accepted for backwards compatibility and are equivalent to 5) blink - bool : (Deprecated) Set priority to 5 for blink, field is deprecated: specifies that the tx should be blinked ( priority will be ignored). outputs - uint64 unlock_time - uint64 : Number of blocks before the loki can be spent (0 to not add a lock). payment_id - string : (Optional) 64-character hex string to identify a transaction. get_tx_key - bool : (Optional) Return the transaction keys after sending. key_image - string : Key image of specific output to sweep. do_not_relay - bool : (Optional) If true, do not relay this sweep transfer. (Defaults to false) get_tx_hex - bool : (Optional) return the transactions as hex encoded string. (Defaults to false) get_tx_metadata - bool : (Optional) return the transaction metadata as a string. (Defaults to false) Outputs: tx_hash - string : The tx hashes of the transaction. tx_key - string : The tx key of the transaction. amount - uint64 : The amount transfered in atomic units. fee - uint64 : The fee paid in atomic units. tx_blob - string : The tx as hex string. tx_metadata - string : Transaction metadata needed to relay the transaction later. multisig_txset - string : The set of signing keys used in a multisig transaction (empty for non-multisig). unsigned_txset - string : Set of unsigned tx for cold-signing purposes. COMMAND_RPC_TAG_ACCOUNTS \u00b6 Back to top Apply a filtering tag to a list of accounts. Endpoints: tag_accounts Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"tag_accounts\", \"params\": { \"tag\": \"My tag\", \"accounts\": [2130706433] } } EOF Inputs: tag - string : Tag for the accounts. accounts - uint32[] : Tag this list of accounts. COMMAND_RPC_TRANSFER \u00b6 Back to top Send loki to a number of recipients. To preview the transaction fee, set do_not_relay to true and get_tx_metadata to true. Submit the response using the data in get_tx_metadata in the RPC call, relay_tx. Endpoints: transfer Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"transfer\", \"params\": { \"destinations\": [{ \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"amount\": 26734261552878 }], \"account_index\": 0, \"subaddr_indices\": [0], \"priority\": 0, \"blink\": true, \"unlock_time\": 123, \"payment_id\": \"f378710e54eeeb8d\", \"get_tx_key\": true, \"do_not_relay\": true, \"get_tx_hex\": true, \"get_tx_metadata\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"tx_hash\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"tx_key\": \"1982e99c69d8acc993cfc94ce59ff8f113d23482d9a25c892a3fc01c77dd8c4c\", \"amount\": 26734261552878, \"fee\": 123, \"tx_blob\": \"0402f78b05f78b05f78b0501ffd98b0502b888ddcf730229f056f5594cfcfd8d44f8033c9fda22450693d1694038e1cecaaaac25a8fc12af8992bc800102534df00c14ead3b3dedea9e7bdcf71c44803349b5e9aee2f73e22d5385ac147b7601008e5729d9329320444666d9d9d9dc602a3ae585de91ab2ca125665e3a363610021100000001839fdb0000000000000000000001200408d5ad7ab79d9b05c94033c2029f4902a98ec51f5175564f6978467dbb28723f929cf806d4ee1c781d7771183a93a1fd74f0827bddee9baac7e3083ab2b5840000\", \"tx_metadata\": \"TODO(loki): Write example string\", \"multisig_txset\": \"TODO(loki): Write example string\", \"unsigned_txset\": \"TODO(loki): Write example string\" } } Inputs: destinations - transfer_destination[] : Array of destinations to receive LOKI. address - string : Destination public address. amount - uint64 : Amount to send to each destination, in atomic units. account_index - uint32 : (Optional) Transfer from this account index. (Defaults to 0) subaddr_indices - uint32[] : (Optional) Transfer from this set of subaddresses. (Defaults to 0) priority - uint32 : Set a priority for the transaction. Accepted values are: 1 for unimportant or 5 for blink. (0 and 2-4 are accepted for backwards compatibility and are equivalent to 5) blink - bool : (Deprecated) Set priority to 5 for blink, field is deprecated: specifies that the tx should be blinked ( priority will be ignored). unlock_time - uint64 : Number of blocks before the loki can be spent (0 to use the default lock time). payment_id - string : (Optional) Random 64-character hex string to identify a transaction. get_tx_key - bool : (Optional) Return the transaction key after sending. do_not_relay - bool : (Optional) If true, the newly created transaction will not be relayed to the loki network. (Defaults to false) get_tx_hex - bool : Return the transaction as hex string after sending. (Defaults to false) get_tx_metadata - bool : Return the metadata needed to relay the transaction. (Defaults to false) Outputs: tx_hash - string : Publically searchable transaction hash. tx_key - string : Transaction key if get_tx_key is true, otherwise, blank string. amount - uint64 : Amount transferred for the transaction. fee - uint64 : Fee charged for the txn. tx_blob - string : Raw transaction represented as hex string, if get_tx_hex is true. tx_metadata - string : Set of transaction metadata needed to relay this transfer later, if get_tx_metadata is true. multisig_txset - string : Set of multisig transactions in the process of being signed (empty for non-multisig). unsigned_txset - string : Set of unsigned tx for cold-signing purposes. COMMAND_RPC_TRANSFER_SPLIT \u00b6 Back to top Same as transfer, but can split into more than one tx if necessary. Endpoints: transfer_split Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"transfer_split\", \"params\": { \"destinations\": [{ \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"amount\": 26734261552878 }], \"account_index\": 0, \"subaddr_indices\": [0], \"priority\": 0, \"blink\": true, \"unlock_time\": 123, \"payment_id\": \"f378710e54eeeb8d\", \"get_tx_keys\": true, \"do_not_relay\": true, \"get_tx_hex\": true, \"get_tx_metadata\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"tx_hash_list\": [\"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\"], \"tx_key_list\": [\"1982e99c69d8acc993cfc94ce59ff8f113d23482d9a25c892a3fc01c77dd8c4c\"], \"amount_list\": [123], \"fee_list\": [123], \"tx_blob_list\": [\"0402f78b05f78b05f78b0501ffd98b0502b888ddcf730229f056f5594cfcfd8d44f8033c9fda22450693d1694038e1cecaaaac25a8fc12af8992bc800102534df00c14ead3b3dedea9e7bdcf71c44803349b5e9aee2f73e22d5385ac147b7601008e5729d9329320444666d9d9d9dc602a3ae585de91ab2ca125665e3a363610021100000001839fdb0000000000000000000001200408d5ad7ab79d9b05c94033c2029f4902a98ec51f5175564f6978467dbb28723f929cf806d4ee1c781d7771183a93a1fd74f0827bddee9baac7e3083ab2b5840000\"], \"tx_metadata_list\": [\"TODO(loki): Write example string\"], \"multisig_txset\": \"TODO(loki): Write example string\", \"unsigned_txset\": \"TODO(loki): Write example string\" } } Inputs: destinations - transfer_destination[] : Array of destinations to receive LOKI: address - string : Destination public address. amount - uint64 : Amount to send to each destination, in atomic units. account_index - uint32 : (Optional) Transfer from this account index. (Defaults to 0) subaddr_indices - uint32[] : (Optional) Transfer from this set of subaddresses. (Defaults to 0) priority - uint32 : Set a priority for the transaction. Accepted values are: 1 for unimportant or 5 for blink. (0 and 2-4 are accepted for backwards compatibility and are equivalent to 5) blink - bool : (Deprecated) Set priority to 5 for blink, field is deprecated: specifies that the tx should be blinked ( priority will be ignored). unlock_time - uint64 : Number of blocks before the loki can be spent (0 to not add a lock). payment_id - string : (Optional) Random 32-byte/64-character hex string to identify a transaction. get_tx_keys - bool : (Optional) Return the transaction keys after sending. do_not_relay - bool : (Optional) If true, the newly created transaction will not be relayed to the loki network. (Defaults to false) get_tx_hex - bool : Return the transactions as hex string after sending. get_tx_metadata - bool : Return list of transaction metadata needed to relay the transfer later. Outputs: tx_hash_list - string[] : The tx hashes of every transaction. tx_key_list - string[] : The transaction keys for every transaction. amount_list - uint64[] : The amount transferred for every transaction. fee_list - uint64[] : The amount of fees paid for every transaction. tx_blob_list - string[] : The tx as hex string for every transaction. tx_metadata_list - string[] : List of transaction metadata needed to relay the transactions later. multisig_txset - string : The set of signing keys used in a multisig transaction (empty for non-multisig). unsigned_txset - string : Set of unsigned tx for cold-signing purposes. COMMAND_RPC_UNTAG_ACCOUNTS \u00b6 Back to top Remove filtering tag from a list of accounts. Endpoints: untag_accounts Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"untag_accounts\", \"params\": { \"accounts\": [2130706433] } } EOF Inputs: accounts - uint32[] : Remove tag from this list of accounts. COMMAND_RPC_VALIDATE_ADDRESS \u00b6 Back to top Parse an address to validate if it's a valid Loki address. Endpoints: validate_address Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"validate_address\", \"params\": { \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"any_net_type\": true, \"allow_openalias\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"valid\": true, \"integrated\": true, \"subaddress\": true, \"nettype\": \"MAINNET\", \"openalias_address\": \"TODO(loki): Write example string\" } } Inputs: address - string : Address to check. any_net_type - bool allow_openalias - bool Outputs: valid - bool : States if it is a valid Loki address. integrated - bool : States if it is an integrated address. subaddress - bool : States if it is a subaddress. nettype - string : States if the nettype is mainet, testnet, stagenet. openalias_address - string COMMAND_RPC_VERIFY \u00b6 Back to top Verify a signature on a string. Endpoints: verify Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"verify\", \"params\": { \"data\": \"TODO(loki): Write example string\", \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"signature\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"good\": true } Inputs: data - string : What should have been signed. address - string : Public address of the wallet used to sign the data. signature - string : Signature generated by sign method. Outputs: good - bool","title":"Wallet RPC Guide - Beta"},{"location":"Developer/WalletRPCBeta/#introduction","text":"This is a list of the RPC calls, their inputs and outputs, and examples of each. This list is autogenerated and was last generated on: 2020-05-13 Many RPC calls use the JSON RPC interface while others use their own interfaces, as demonstrated below. Note: \"atomic units\" refer to the smallest fraction of 1 LOKI which is 1e9 atomic units.","title":"Introduction"},{"location":"Developer/WalletRPCBeta/#json","text":"COMMAND_RPC_ADD_ADDRESS_BOOK_ENTRY COMMAND_RPC_AUTO_REFRESH COMMAND_RPC_CAN_REQUEST_STAKE_UNLOCK COMMAND_RPC_CHANGE_WALLET_PASSWORD COMMAND_RPC_CHECK_RESERVE_PROOF COMMAND_RPC_CHECK_SPEND_PROOF COMMAND_RPC_CHECK_TX_KEY COMMAND_RPC_CHECK_TX_PROOF COMMAND_RPC_CLOSE_WALLET COMMAND_RPC_CREATE_ACCOUNT COMMAND_RPC_CREATE_ADDRESS COMMAND_RPC_CREATE_WALLET COMMAND_RPC_DELETE_ADDRESS_BOOK_ENTRY COMMAND_RPC_DESCRIBE_TRANSFER COMMAND_RPC_EXCHANGE_MULTISIG_KEYS COMMAND_RPC_EXPORT_KEY_IMAGES COMMAND_RPC_EXPORT_MULTISIG COMMAND_RPC_EXPORT_OUTPUTS COMMAND_RPC_FINALIZE_MULTISIG COMMAND_RPC_GENERATE_FROM_KEYS COMMAND_RPC_GET_ACCOUNTS COMMAND_RPC_GET_ACCOUNT_TAGS COMMAND_RPC_GET_ADDRESS COMMAND_RPC_GET_ADDRESS_BOOK_ENTRY COMMAND_RPC_GET_ADDRESS_INDEX COMMAND_RPC_GET_ATTRIBUTE COMMAND_RPC_GET_BALANCE COMMAND_RPC_GET_BULK_PAYMENTS COMMAND_RPC_GET_HEIGHT COMMAND_RPC_GET_LANGUAGES COMMAND_RPC_GET_PAYMENTS COMMAND_RPC_GET_RESERVE_PROOF COMMAND_RPC_GET_SPEND_PROOF COMMAND_RPC_GET_TRANSFERS COMMAND_RPC_GET_TRANSFERS_CSV COMMAND_RPC_GET_TRANSFER_BY_TXID COMMAND_RPC_GET_TX_KEY COMMAND_RPC_GET_TX_NOTES COMMAND_RPC_GET_TX_PROOF COMMAND_RPC_GET_VERSION COMMAND_RPC_IMPORT_KEY_IMAGES COMMAND_RPC_IMPORT_MULTISIG COMMAND_RPC_IMPORT_OUTPUTS COMMAND_RPC_INCOMING_TRANSFERS COMMAND_RPC_IS_MULTISIG COMMAND_RPC_LABEL_ACCOUNT COMMAND_RPC_LABEL_ADDRESS COMMAND_RPC_LNS_BUY_MAPPING COMMAND_RPC_LNS_DECRYPT_VALUE COMMAND_RPC_LNS_HASH_NAME COMMAND_RPC_LNS_MAKE_UPDATE_SIGNATURE COMMAND_RPC_LNS_UPDATE_MAPPING COMMAND_RPC_MAKE_INTEGRATED_ADDRESS COMMAND_RPC_MAKE_MULTISIG COMMAND_RPC_MAKE_URI COMMAND_RPC_OPEN_WALLET COMMAND_RPC_PARSE_URI COMMAND_RPC_PREPARE_MULTISIG COMMAND_RPC_QUERY_KEY COMMAND_RPC_REFRESH COMMAND_RPC_REGISTER_SERVICE_NODE COMMAND_RPC_RELAY_TX COMMAND_RPC_REQUEST_STAKE_UNLOCK COMMAND_RPC_RESCAN_BLOCKCHAIN COMMAND_RPC_RESCAN_SPENT COMMAND_RPC_RESTORE_DETERMINISTIC_WALLET COMMAND_RPC_SET_ACCOUNT_TAG_DESCRIPTION COMMAND_RPC_SET_ATTRIBUTE COMMAND_RPC_SET_DAEMON COMMAND_RPC_SET_LOG_CATEGORIES COMMAND_RPC_SET_LOG_LEVEL COMMAND_RPC_SET_TX_NOTES COMMAND_RPC_SIGN COMMAND_RPC_SIGN_MULTISIG COMMAND_RPC_SIGN_TRANSFER COMMAND_RPC_SPLIT_INTEGRATED_ADDRESS COMMAND_RPC_STAKE COMMAND_RPC_START_MINING COMMAND_RPC_STOP_MINING COMMAND_RPC_STOP_WALLET COMMAND_RPC_STORE COMMAND_RPC_SUBMIT_MULTISIG COMMAND_RPC_SUBMIT_TRANSFER COMMAND_RPC_SWEEP_ALL COMMAND_RPC_SWEEP_DUST COMMAND_RPC_SWEEP_SINGLE COMMAND_RPC_TAG_ACCOUNTS COMMAND_RPC_TRANSFER COMMAND_RPC_TRANSFER_SPLIT COMMAND_RPC_UNTAG_ACCOUNTS COMMAND_RPC_VALIDATE_ADDRESS COMMAND_RPC_VERIFY","title":"JSON"},{"location":"Developer/WalletRPCBeta/#json_1","text":"","title":"JSON"},{"location":"Developer/WalletRPCBeta/#command_rpc_add_address_book_entry","text":"Back to top Add an entry to the address book. Endpoints: add_address_book Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"add_address_book\", \"params\": { \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"payment_id\": \"f378710e54eeeb8d\", \"description\": \"My account description\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"index\": 123 } Inputs: address - string : Public address of the entry. payment_id - string : (Optional), defaults to \"0000000000000000000000000000000000000000000000000000000000000000\". description - string : (Optional), defaults to \"\". Outputs: index - uint64 : The index of the address book entry.","title":"COMMAND_RPC_ADD_ADDRESS_BOOK_ENTRY"},{"location":"Developer/WalletRPCBeta/#command_rpc_auto_refresh","text":"Back to top Endpoints: auto_refresh Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"auto_refresh\", \"params\": { \"enable\": true, \"period\": 2130706433 } } EOF Inputs: enable - bool period - uint32 : seconds","title":"COMMAND_RPC_AUTO_REFRESH"},{"location":"Developer/WalletRPCBeta/#command_rpc_can_request_stake_unlock","text":"Back to top Check if Service Node can unlock it's stake. Endpoints: can_request_stake_unlock Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"can_request_stake_unlock\", \"params\": { \"service_node_key\": \"4a8c30cea9e729b06c91132295cce32d2a8e6e5bcf7b74a998e2ee1b3ed590b3\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"can_unlock\": true, \"msg\": \"Message returned by the sender (wallet/daemon)\" } } Inputs: service_node_key - string : Service node public address. Outputs: can_unlock - bool : States if the stake can be locked. msg - string : Information on the unlocking process.","title":"COMMAND_RPC_CAN_REQUEST_STAKE_UNLOCK"},{"location":"Developer/WalletRPCBeta/#command_rpc_change_wallet_password","text":"Back to top Change a wallet password. Endpoints: change_wallet_password Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"change_wallet_password\", \"params\": { \"old_password\": \"TODO(loki): Write example string\", \"new_password\": \"TODO(loki): Write example string\" } } EOF Inputs: old_password - string : (Optional) Current wallet password, if defined. new_password - string : (Optional) New wallet password, if not blank.","title":"COMMAND_RPC_CHANGE_WALLET_PASSWORD"},{"location":"Developer/WalletRPCBeta/#command_rpc_check_reserve_proof","text":"Back to top Proves a wallet has a disposable reserve using a signature. Endpoints: check_reserve_proof Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"check_reserve_proof\", \"params\": { \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"message\": \"User assigned note describing something\", \"signature\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"good\": true, \"total\": 123, \"spent\": 123 } } Inputs: address - string : Public address of the wallet. message - string : (Optional) Should be the same message used in get_reserve_proof. signature - string : Reserve signature to confirm. Outputs: good - bool : States if the inputs proves the reserve. total - uint64 spent - uint64","title":"COMMAND_RPC_CHECK_RESERVE_PROOF"},{"location":"Developer/WalletRPCBeta/#command_rpc_check_spend_proof","text":"Back to top Prove a spend using a signature. Unlike proving a transaction, it does not requires the destination public address. Endpoints: check_spend_proof Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"check_spend_proof\", \"params\": { \"txid\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"message\": \"User assigned note describing something\", \"signature\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"good\": true } Inputs: txid - string : Transaction id. message - string : (Optional) Should be the same message used in get_spend_proof . signature - string : Spend signature to confirm. Outputs: good - bool : States if the inputs proves the spend.","title":"COMMAND_RPC_CHECK_SPEND_PROOF"},{"location":"Developer/WalletRPCBeta/#command_rpc_check_tx_key","text":"Back to top Check a transaction in the blockchain with its secret key. Endpoints: check_tx_key Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"check_tx_key\", \"params\": { \"txid\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"tx_key\": \"1982e99c69d8acc993cfc94ce59ff8f113d23482d9a25c892a3fc01c77dd8c4c\", \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"received\": 123, \"in_pool\": true, \"confirmations\": 123 } } Inputs: txid - string : Transaction id. tx_key - string : Transaction secret key. address - string : Destination public address of the transaction. Outputs: received - uint64 : Amount of the transaction. in_pool - bool : States if the transaction is still in pool or has been added to a block. confirmations - uint64 : Number of block mined after the one with the transaction.","title":"COMMAND_RPC_CHECK_TX_KEY"},{"location":"Developer/WalletRPCBeta/#command_rpc_check_tx_proof","text":"Back to top Prove a transaction by checking its signature. Endpoints: check_tx_proof Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"check_tx_proof\", \"params\": { \"txid\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"message\": \"User assigned note describing something\", \"signature\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"good\": true, \"received\": 123, \"in_pool\": true, \"confirmations\": 123 } } Inputs: txid - string : Transaction id. address - string : Destination public address of the transaction. message - string : (Optional) Should be the same message used in get_tx_proof . signature - string : Transaction signature to confirm. Outputs: good - bool : States if the inputs proves the transaction. received - uint64 : Amount of the transaction. in_pool - bool : States if the transaction is still in pool or has been added to a block. confirmations - uint64 : Number of block mined after the one with the transaction.","title":"COMMAND_RPC_CHECK_TX_PROOF"},{"location":"Developer/WalletRPCBeta/#command_rpc_close_wallet","text":"Back to top Close the currently opened wallet, after trying to save it. Endpoints: close_wallet Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"close_wallet\", \"params\": { \"autosave_current\": true } } EOF Inputs: autosave_current - bool : Save the wallet state on close","title":"COMMAND_RPC_CLOSE_WALLET"},{"location":"Developer/WalletRPCBeta/#command_rpc_create_account","text":"Back to top Create a new account with an optional label. Endpoints: create_account Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"create_account\", \"params\": { \"label\": \"My label\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"account_index\": 0, \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\" } } Inputs: label - string : (Optional) Label for the account. Outputs: account_index - uint32 : Index of the new account. address - string : The primary address of the new account.","title":"COMMAND_RPC_CREATE_ACCOUNT"},{"location":"Developer/WalletRPCBeta/#command_rpc_create_address","text":"Back to top Create a new address for an account. Optionally, label the new address. Endpoints: create_address Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"create_address\", \"params\": { \"account_index\": 0, \"label\": \"My label\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"address_index\": 0 } } Inputs: account_index - uint32 : Create a new subaddress for this account. label - string : (Optional) Label for the new subaddress. Outputs: address - string : The newly requested address. address_index - uint32 : Index of the new address in the requested account index.","title":"COMMAND_RPC_CREATE_ADDRESS"},{"location":"Developer/WalletRPCBeta/#command_rpc_create_wallet","text":"Back to top Create a new wallet. You need to have set the argument \"'\u2013wallet-dir\" when launching loki-wallet-rpc to make this work. Endpoints: create_wallet Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"create_wallet\", \"params\": { \"filename\": \"Doyles_Cool_Wallet\", \"password\": \"not_a_secure_password\", \"language\": \"english\" } } EOF Inputs: filename - string : Set the wallet file name. password - string : (Optional) Set the password to protect the wallet. language - string : Language for your wallets' seed.","title":"COMMAND_RPC_CREATE_WALLET"},{"location":"Developer/WalletRPCBeta/#command_rpc_delete_address_book_entry","text":"Back to top Delete an entry from the address book. Endpoints: delete_address_book Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"delete_address_book\", \"params\": { \"index\": 123 } } EOF Inputs: index - uint64 : The index of the address book entry.","title":"COMMAND_RPC_DELETE_ADDRESS_BOOK_ENTRY"},{"location":"Developer/WalletRPCBeta/#command_rpc_describe_transfer","text":"Back to top Endpoints: describe_transfer Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"describe_transfer\", \"params\": { \"unsigned_txset\": \"TODO(loki): Write example string\", \"multisig_txset\": \"TODO(loki): Write example string\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"desc\": [{ \"amount_in\": 123, \"amount_out\": 123, \"ring_size\": 2130706433, \"unlock_time\": 123, \"recipients\": [{ \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"amount\": 26734261552878 }], \"payment_id\": \"f378710e54eeeb8d\", \"change_amount\": 123, \"change_address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"fee\": 123, \"dummy_outputs\": 2130706433, \"extra\": \"01008e5729d9329320444666d9d9d9dc602a3ae585de91ab2ca125665e3a363610021100000001839fdb0000000000000000000001200408d5ad7ab79d9b05c94033c2029f4902a98ec51f5175564f6978467dbb28723f929cf806d4ee1c781d7771183a93a1fd74f0827bddee9baac7e3083ab2b584\" }] } Inputs: unsigned_txset - string : Set of unsigned tx returned by \"transfer\" or \"transfer_split\" methods. multisig_txset - string : Set of unsigned multisig txes returned by \"transfer\" or \"transfer_split\" methods Outputs: desc - transfer_description[] : List of information of transfers. amount_in - uint64 : Amount in, in atomic units. amount_out - uint64 : amount out, in atomic units. ring_size - uint32 : Ring size of transfer. unlock_time - uint64 : Number of blocks before the loki can be spent (0 represents the default network lock time). recipients - recipient[] : List of addresses and amounts. address - string : Destination public address. amount - uint64 : Amount in atomic units. payment_id - string : Payment ID matching the input parameter. change_amount - uint64 : Change received from transaction in atomic units. change_address - string : Address the change was sent to. fee - uint64 : Fee of the transaction in atomic units. dummy_outputs - uint32 extra - string : Data stored in the tx extra represented in hex.","title":"COMMAND_RPC_DESCRIBE_TRANSFER"},{"location":"Developer/WalletRPCBeta/#command_rpc_exchange_multisig_keys","text":"Back to top Endpoints: exchange_multisig_keys Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"exchange_multisig_keys\", \"params\": { \"password\": \"not_a_secure_password\", \"multisig_info\": [\"TODO(loki): Write example string\"] } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"multisig_info\": \"TODO(loki): Write example string\" } } Inputs: password - string : Wallet password. multisig_info - string[] : List of multisig string from peers. Outputs: address - string : Multisig wallet address. multisig_info - string : Multisig string to share with peers to create the multisig wallet.","title":"COMMAND_RPC_EXCHANGE_MULTISIG_KEYS"},{"location":"Developer/WalletRPCBeta/#command_rpc_export_key_images","text":"Back to top Export a signed set of key images. Endpoints: export_key_images Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"export_key_images\", \"params\": { \"requested_only\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"offset\": 2130706433, \"signed_key_images\": [{ \"key_image\": \"8d1bd8181bf7d857bdb281e0153d84cd55a3fcaa57c3e570f4a49f935850b5e3\", \"signature\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\" }] } } Inputs: requested_only - bool : Default false . Outputs: offset - uint32 signed_key_images - signed_key_image[] key_image - string signature - string","title":"COMMAND_RPC_EXPORT_KEY_IMAGES"},{"location":"Developer/WalletRPCBeta/#command_rpc_export_multisig","text":"Back to top Export multisig info for other participants. Endpoints: export_multisig_info Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"export_multisig_info\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"info\": \"TODO(loki): Write example string\" } Outputs: info - string : Multisig info in hex format for other participants.","title":"COMMAND_RPC_EXPORT_MULTISIG"},{"location":"Developer/WalletRPCBeta/#command_rpc_export_outputs","text":"Back to top Export all outputs in hex format. Endpoints: export_outputs Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"export_outputs\", \"params\": { \"all\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"outputs_data_hex\": \"TODO(loki): Write example string\" } Inputs: all - bool Outputs: outputs_data_hex - string : Wallet outputs in hex format.","title":"COMMAND_RPC_EXPORT_OUTPUTS"},{"location":"Developer/WalletRPCBeta/#command_rpc_finalize_multisig","text":"Back to top Turn this wallet into a multisig wallet, extra step for N-1/N wallets. Endpoints: finalize_multisig Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"finalize_multisig\", \"params\": { \"password\": \"not_a_secure_password\", \"multisig_info\": [\"TODO(loki): Write example string\"] } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\" } Inputs: password - string : Wallet password. multisig_info - string[] : List of multisig string from peers. Outputs: address - string : Multisig wallet address.","title":"COMMAND_RPC_FINALIZE_MULTISIG"},{"location":"Developer/WalletRPCBeta/#command_rpc_generate_from_keys","text":"Back to top Restore a wallet using the private spend key, view key and public address. Endpoints: generate_from_keys Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"generate_from_keys\", \"params\": { \"restore_height\": 123, \"filename\": \"Doyles_Cool_Wallet\", \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"spendkey\": \"1de25fd280b9b08da62f06a5521c735fd94b7ecf237ca7409748295e75b48104\", \"viewkey\": \"1de25fd280b9b08da62f06a5521c735fd94b7ecf237ca7409748295e75b48104\", \"password\": \"not_a_secure_password\", \"autosave_current\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"info\": \"TODO(loki): Write example string\" } } Inputs: restore_height - uint64 : (Optional: Default 0) Height in which to start scanning the blockchain for transactions into and out of this Wallet. filename - string : Set the name of the wallet. address - string : The public address of the wallet. spendkey - string : The private spend key of the wallet viewkey - string : The private view key of the wallet. password - string : Set password for Wallet. autosave_current - bool : (Optional: Default true): If a pre-existing wallet is open, save to disk before opening the new wallet. Outputs: address - string info - string","title":"COMMAND_RPC_GENERATE_FROM_KEYS"},{"location":"Developer/WalletRPCBeta/#command_rpc_get_accounts","text":"Back to top Get all accounts for a wallet. Optionally filter accounts by tag. Endpoints: get_accounts Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_accounts\", \"params\": { \"tag\": \"My tag\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"total_balance\": 123, \"total_unlocked_balance\": 123, \"subaddress_accounts\": [{ \"account_index\": 0, \"base_address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"balance\": 123, \"unlocked_balance\": 123, \"label\": \"My label\", \"tag\": \"My tag\" }] } } Inputs: tag - string : (Optional) Tag for filtering accounts. All accounts if empty, otherwise those accounts with this tag Outputs: total_balance - uint64 : Total balance of the selected accounts (locked or unlocked). total_unlocked_balance - uint64 : Total unlocked balance of the selected accounts. subaddress_accounts - subaddress_account_info[] : Account information. account_index - uint32 : Index of the account. base_address - string : The first address of the account (i.e. the primary address). balance - uint64 : Balance of the account (locked or unlocked). unlocked_balance - uint64 : Unlocked balance for the account. label - string : (Optional) Label of the account. tag - string : (Optional) Tag for filtering accounts.","title":"COMMAND_RPC_GET_ACCOUNTS"},{"location":"Developer/WalletRPCBeta/#command_rpc_get_account_tags","text":"Back to top Get a list of user-defined account tags. Endpoints: get_account_tags Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_account_tags\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"account_tags\": [{ \"tag\": \"My tag\", \"label\": \"My label\", \"accounts\": [2130706433] }] } Outputs: account_tags - account_tag_info[] : Account tag information: tag - string : Filter tag. label - string : Label for the tag. accounts - uint32[] : List of tagged account indices.","title":"COMMAND_RPC_GET_ACCOUNT_TAGS"},{"location":"Developer/WalletRPCBeta/#command_rpc_get_address","text":"Back to top Return the wallet's addresses for an account. Optionally filter for specific set of subaddresses. Endpoints: get_address Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_address\", \"params\": { \"account_index\": 0, \"address_index\": [0] } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"addresses\": [{ \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"label\": \"My label\", \"address_index\": 0, \"used\": true }] } } Inputs: account_index - uint32 : Get the wallet addresses for the specified account. address_index - uint32[] : (Optional) List of subaddresses to return from the aforementioned account. Outputs: address - string : (Deprecated) Remains to be compatible with older RPC format addresses - address_info[] : Addresses informations. address - string : The (sub)address string. label - string : Label of the (sub)address. address_index - uint32 : Index of the subaddress used - bool : True if the (sub)address has received funds before.","title":"COMMAND_RPC_GET_ADDRESS"},{"location":"Developer/WalletRPCBeta/#command_rpc_get_address_book_entry","text":"Back to top Retrieves entries from the address book. Endpoints: get_address_book Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_address_book\", \"params\": { \"entries\": [123] } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"entries\": [{ \"index\": 123, \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"payment_id\": \"f378710e54eeeb8d\", \"description\": \"My account description\" }] } Inputs: entries - uint64[] : Indices of the requested address book entries. Outputs: entries - entry[] : List of address book entries information. index - uint64 : Index of entry. address - string : Public address of the entry payment_id - string : (Optional) 64-character hex string to identify a transaction. description - string : Description of this address entry.","title":"COMMAND_RPC_GET_ADDRESS_BOOK_ENTRY"},{"location":"Developer/WalletRPCBeta/#command_rpc_get_address_index","text":"Back to top Get account and address indexes from a specific (sub)address. Endpoints: get_address_index Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_address_index\", \"params\": { \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"index\": { \"major\": 2130706433, \"minor\": 2130706433 } } Inputs: address - string : (Sub)address to look for. Outputs: index - cryptonote::subaddress_index : Account index followed by the subaddress index. major - uint32 : The account index, major index minor - uint32 : The subaddress index, minor index","title":"COMMAND_RPC_GET_ADDRESS_INDEX"},{"location":"Developer/WalletRPCBeta/#command_rpc_get_attribute","text":"Back to top Get attribute value by name. Endpoints: get_attribute Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_attribute\", \"params\": { \"key\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"value\": \"TODO(loki): Write example string\" } Inputs: key - string : Attribute name. Outputs: value - string : Attribute value.","title":"COMMAND_RPC_GET_ATTRIBUTE"},{"location":"Developer/WalletRPCBeta/#command_rpc_get_balance","text":"Back to top Return the wallet's balance. Endpoints: get_balance Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_balance\", \"params\": { \"account_index\": 0, \"address_indices\": [0], \"all_accounts\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"balance\": 123, \"unlocked_balance\": 123, \"multisig_import_needed\": true, \"per_subaddress\": [{ \"account_index\": 0, \"address_index\": 0, \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"balance\": 123, \"unlocked_balance\": 123, \"label\": \"My label\", \"num_unspent_outputs\": 123, \"blocks_to_unlock\": 123 }], \"blocks_to_unlock\": 123 } } Inputs: account_index - uint32 : Return balance for this account. address_indices - uint32[] : (Optional) Return balance detail for those subaddresses. all_accounts - bool : If true, return balance for all accounts, subaddr_indices and account_index are ignored Outputs: balance - uint64 : The total balance (atomic units) of the currently opened wallet. unlocked_balance - uint64 : Unlocked funds are those funds that are sufficiently deep enough in the loki blockchain to be considered safe to spend. multisig_import_needed - bool : True if importing multisig data is needed for returning a correct balance. per_subaddress - per_subaddress_info[] : Balance information for each subaddress in an account. account_index - uint32 : Index of the account in the wallet. address_index - uint32 : Index of the subaddress in the account. address - string : Address at this index. Base58 representation of the public keys. balance - uint64 : Balance for the subaddress (locked or unlocked). unlocked_balance - uint64 : Unlocked funds are those funds that are sufficiently deep enough in the loki blockchain to be considered safe to spend. label - string : Label for the subaddress. num_unspent_outputs - uint64 : Number of unspent outputs available for the subaddress. blocks_to_unlock - uint64 : The number of blocks remaining for the balance to unlock blocks_to_unlock - uint64 : The number of blocks remaining for the balance to unlock","title":"COMMAND_RPC_GET_BALANCE"},{"location":"Developer/WalletRPCBeta/#command_rpc_get_bulk_payments","text":"Back to top Get a list of incoming payments using a given payment id, or a list of payments ids, from a given height. This method is the preferred method over get_paymentsbecause it has the same functionality but is more extendable. Either is fine for looking up transactions by a single payment ID. Endpoints: get_bulk_payments Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_bulk_payments\", \"params\": { \"payment_ids\": [\"TODO(loki): Write example string\"], \"min_block_height\": 123 } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"payments\": [{ \"payment_id\": \"f378710e54eeeb8d\", \"tx_hash\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"amount\": 26734261552878, \"block_height\": 123, \"unlock_time\": 123, \"subaddr_index\": { \"major\": 2130706433, \"minor\": 2130706433 }, \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\" }] } Inputs: payment_ids - string[] : Payment IDs used to find the payments (16 characters hex). min_block_height - uint64 : The block height at which to start looking for payments. Outputs: payments - payment_details[] : List of payment details: payment_id - string : Payment ID matching the input parameter. tx_hash - string : Transaction hash used as the transaction ID. amount - uint64 : Amount for this payment. block_height - uint64 : Height of the block that first confirmed this payment. unlock_time - uint64 : Time (in block height) until this payment is safe to spend. subaddr_index - cryptonote::subaddress_index : Major & minor index, account and subaddress index respectively. major - uint32 : The account index, major index minor - uint32 : The subaddress index, minor index address - string : Address receiving the payment.","title":"COMMAND_RPC_GET_BULK_PAYMENTS"},{"location":"Developer/WalletRPCBeta/#command_rpc_get_height","text":"Back to top Returns the wallet's current block height and blockchain immutable height Endpoints: get_height Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_height\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"height\": 234767, \"immutable_height\": 123 } } Outputs: height - uint64 : The current wallet's blockchain height. If the wallet has been offline for a long time, it may need to catch up with the daemon. immutable_height - uint64 : The latest height in the blockchain that can not be reorganized from (backed by atleast 2 Service Node, or 1 hardcoded checkpoint, 0 if N/A).","title":"COMMAND_RPC_GET_HEIGHT"},{"location":"Developer/WalletRPCBeta/#command_rpc_get_languages","text":"Back to top Get a list of available languages for your wallet's seed. Endpoints: get_languages Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_languages\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"languages\": [\"TODO(loki): Write example string\"], \"languages_local\": [\"TODO(loki): Write example string\"] } } Outputs: languages - string[] : List of available languages. languages_local - string[] : List of available languages in the native language","title":"COMMAND_RPC_GET_LANGUAGES"},{"location":"Developer/WalletRPCBeta/#command_rpc_get_payments","text":"Back to top Get a list of incoming payments using a given payment id. Endpoints: get_payments Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_payments\", \"params\": { \"payment_id\": \"f378710e54eeeb8d\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"payments\": [{ \"payment_id\": \"f378710e54eeeb8d\", \"tx_hash\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"amount\": 26734261552878, \"block_height\": 123, \"unlock_time\": 123, \"subaddr_index\": { \"major\": 2130706433, \"minor\": 2130706433 }, \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\" }] } Inputs: payment_id - string : Payment ID used to find the payments (16 characters hex). Outputs: payments - payment_details[] : List of payment details: payment_id - string : Payment ID matching the input parameter. tx_hash - string : Transaction hash used as the transaction ID. amount - uint64 : Amount for this payment. block_height - uint64 : Height of the block that first confirmed this payment. unlock_time - uint64 : Time (in block height) until this payment is safe to spend. subaddr_index - cryptonote::subaddress_index : Major & minor index, account and subaddress index respectively. major - uint32 : The account index, major index minor - uint32 : The subaddress index, minor index address - string : Address receiving the payment.","title":"COMMAND_RPC_GET_PAYMENTS"},{"location":"Developer/WalletRPCBeta/#command_rpc_get_reserve_proof","text":"Back to top Generate a signature to prove of an available amount in a wallet. Endpoints: get_reserve_proof Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_reserve_proof\", \"params\": { \"all\": true, \"account_index\": 0, \"amount\": 26734261552878, \"message\": \"User assigned note describing something\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"signature\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\" } Inputs: all - bool : Proves all wallet balance to be disposable. account_index - uint32 : Specify the account from witch to prove reserve. (ignored if all is set to true) amount - uint64 : Amount (in atomic units) to prove the account has for reserve. (ignored if all is set to true) message - string : (Optional) add a message to the signature to further authenticate the prooving process. Outputs: signature - string : Reserve signature.","title":"COMMAND_RPC_GET_RESERVE_PROOF"},{"location":"Developer/WalletRPCBeta/#command_rpc_get_spend_proof","text":"Back to top Generate a signature to prove a spend. Unlike proving a transaction, it does not requires the destination public address. Endpoints: get_spend_proof Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_spend_proof\", \"params\": { \"txid\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"message\": \"User assigned note describing something\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"signature\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\" } Inputs: txid - string : Transaction id. message - string : (Optional) add a message to the signature to further authenticate the prooving process. Outputs: signature - string : Spend signature.","title":"COMMAND_RPC_GET_SPEND_PROOF"},{"location":"Developer/WalletRPCBeta/#command_rpc_get_transfers","text":"Back to top Returns a list of transfers, by default all transfer types are included. If all requested type fields are false, then all transfers will be queried. Endpoints: get_transfers Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_transfers\", \"params\": { \"in\": true, \"out\": true, \"stake\": true, \"pending\": true, \"failed\": true, \"pool\": true, \"coinbase\": true, \"filter_by_height\": true, \"min_height\": 123, \"max_height\": 123, \"account_index\": 0, \"subaddr_indices\": [0], \"all_accounts\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"in\": [{ \"txid\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"payment_id\": \"f378710e54eeeb8d\", \"height\": 234767, \"timestamp\": 123, \"amount\": 26734261552878, \"fee\": 123, \"note\": \"User assigned note describing something\", \"destinations\": [{ \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"amount\": 26734261552878 }], \"type\": \"TODO(loki): Write example string\", \"unlock_time\": 123, \"subaddr_index\": { \"major\": 2130706433, \"minor\": 2130706433 }, \"subaddr_indices\": [{ \"major\": 2130706433, \"minor\": 2130706433 }], \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"double_spend_seen\": true, \"confirmations\": 123, \"suggested_confirmations_threshold\": 123, \"checkpointed\": 1, \"blink_mempool\": true, \"was_blink\": true }], \"out\": [{ \"txid\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"payment_id\": \"f378710e54eeeb8d\", \"height\": 234767, \"timestamp\": 123, \"amount\": 26734261552878, \"fee\": 123, \"note\": \"User assigned note describing something\", \"destinations\": [{ \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"amount\": 26734261552878 }], \"type\": \"TODO(loki): Write example string\", \"unlock_time\": 123, \"subaddr_index\": { \"major\": 2130706433, \"minor\": 2130706433 }, \"subaddr_indices\": [{ \"major\": 2130706433, \"minor\": 2130706433 }], \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"double_spend_seen\": true, \"confirmations\": 123, \"suggested_confirmations_threshold\": 123, \"checkpointed\": 1, \"blink_mempool\": true, \"was_blink\": true }], \"pending\": [{ \"txid\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"payment_id\": \"f378710e54eeeb8d\", \"height\": 234767, \"timestamp\": 123, \"amount\": 26734261552878, \"fee\": 123, \"note\": \"User assigned note describing something\", \"destinations\": [{ \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"amount\": 26734261552878 }], \"type\": \"TODO(loki): Write example string\", \"unlock_time\": 123, \"subaddr_index\": { \"major\": 2130706433, \"minor\": 2130706433 }, \"subaddr_indices\": [{ \"major\": 2130706433, \"minor\": 2130706433 }], \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"double_spend_seen\": true, \"confirmations\": 123, \"suggested_confirmations_threshold\": 123, \"checkpointed\": 1, \"blink_mempool\": true, \"was_blink\": true }], \"failed\": [{ \"txid\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"payment_id\": \"f378710e54eeeb8d\", \"height\": 234767, \"timestamp\": 123, \"amount\": 26734261552878, \"fee\": 123, \"note\": \"User assigned note describing something\", \"destinations\": [{ \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"amount\": 26734261552878 }], \"type\": \"TODO(loki): Write example string\", \"unlock_time\": 123, \"subaddr_index\": { \"major\": 2130706433, \"minor\": 2130706433 }, \"subaddr_indices\": [{ \"major\": 2130706433, \"minor\": 2130706433 }], \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"double_spend_seen\": true, \"confirmations\": 123, \"suggested_confirmations_threshold\": 123, \"checkpointed\": 1, \"blink_mempool\": true, \"was_blink\": true }], \"pool\": [{ \"txid\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"payment_id\": \"f378710e54eeeb8d\", \"height\": 234767, \"timestamp\": 123, \"amount\": 26734261552878, \"fee\": 123, \"note\": \"User assigned note describing something\", \"destinations\": [{ \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"amount\": 26734261552878 }], \"type\": \"TODO(loki): Write example string\", \"unlock_time\": 123, \"subaddr_index\": { \"major\": 2130706433, \"minor\": 2130706433 }, \"subaddr_indices\": [{ \"major\": 2130706433, \"minor\": 2130706433 }], \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"double_spend_seen\": true, \"confirmations\": 123, \"suggested_confirmations_threshold\": 123, \"checkpointed\": 1, \"blink_mempool\": true, \"was_blink\": true }] } } Inputs: in - bool : (Optional) Include incoming transfers. out - bool : (Optional) Include outgoing transfers. stake - bool : (Optional) Include outgoing stakes. pending - bool : (Optional) Include pending transfers. failed - bool : (Optional) Include failed transfers. pool - bool : (Optional) Include transfers from the daemon's transaction pool. coinbase - bool : (Optional) Include transfers from the daemon's transaction pool. filter_by_height - bool : (Optional) Filter transfers by block height. min_height - uint64 : (Optional) Minimum block height to scan for transfers, if filtering by height is enabled. max_height - uint64 : (Optional) Maximum block height to scan for transfers, if filtering by height is enabled (defaults to max block height). account_index - uint32 : (Optional) Index of the account to query for transfers. (defaults to 0) subaddr_indices - uint32[] : (Optional) List of subaddress indices to query for transfers. (defaults to 0) all_accounts - bool : If true, return transfers for all accounts, subaddr_indices and account_index are ignored Outputs: in - transfer_view[] txid - string : Transaction ID for this transfer. payment_id - string : Payment ID for this transfer. height - uint64 : Height of the first block that confirmed this transfer (0 if not mined yet). timestamp - uint64 : UNIX timestamp for when this transfer was first confirmed in a block (or timestamp submission if not mined yet). amount - uint64 : Amount transferred. fee - uint64 : Transaction fee for this transfer. note - string : Note about this transfer. destinations - transfer_destination[] : Array of transfer destinations. address - string : Destination public address. amount - uint64 : Amount to send to each destination, in atomic units. type - string : Type of transfer, one of the following: \"in\", \"out\", \"stake\", \"miner\", \"snode\", \"gov\", \"pending\", \"failed\", \"pool\". unlock_time - uint64 : Number of blocks until transfer is safely spendable. subaddr_index - cryptonote::subaddress_index : Major & minor index, account and subaddress index respectively. major - uint32 : The account index, major index minor - uint32 : The subaddress index, minor index subaddr_indices - cryptonote::subaddress_index[] major - uint32 : The account index, major index minor - uint32 : The subaddress index, minor index address - string : Address that transferred the funds. double_spend_seen - bool : True if the key image(s) for the transfer have been seen before. confirmations - uint64 : Number of block mined since the block containing this transaction (or block height at which the transaction should be added to a block if not yet confirmed). suggested_confirmations_threshold - uint64 : Estimation of the confirmations needed for the transaction to be included in a block. checkpointed - uint64 : If transfer is backed by atleast 2 Service Node Checkpoints, 0 if it is not, see immutable_height in the daemon rpc call get_info blink_mempool - bool : True if this is an approved blink tx in the mempool was_blink - bool : True if we saw this as an approved blink (either in the mempool or a recent, uncheckpointed block). Note that if we didn't see it while an active blink this won't be set. out - transfer_view[] txid - string : Transaction ID for this transfer. payment_id - string : Payment ID for this transfer. height - uint64 : Height of the first block that confirmed this transfer (0 if not mined yet). timestamp - uint64 : UNIX timestamp for when this transfer was first confirmed in a block (or timestamp submission if not mined yet). amount - uint64 : Amount transferred. fee - uint64 : Transaction fee for this transfer. note - string : Note about this transfer. destinations - transfer_destination[] : Array of transfer destinations. address - string : Destination public address. amount - uint64 : Amount to send to each destination, in atomic units. type - string : Type of transfer, one of the following: \"in\", \"out\", \"stake\", \"miner\", \"snode\", \"gov\", \"pending\", \"failed\", \"pool\". unlock_time - uint64 : Number of blocks until transfer is safely spendable. subaddr_index - cryptonote::subaddress_index : Major & minor index, account and subaddress index respectively. major - uint32 : The account index, major index minor - uint32 : The subaddress index, minor index subaddr_indices - cryptonote::subaddress_index[] major - uint32 : The account index, major index minor - uint32 : The subaddress index, minor index address - string : Address that transferred the funds. double_spend_seen - bool : True if the key image(s) for the transfer have been seen before. confirmations - uint64 : Number of block mined since the block containing this transaction (or block height at which the transaction should be added to a block if not yet confirmed). suggested_confirmations_threshold - uint64 : Estimation of the confirmations needed for the transaction to be included in a block. checkpointed - uint64 : If transfer is backed by atleast 2 Service Node Checkpoints, 0 if it is not, see immutable_height in the daemon rpc call get_info blink_mempool - bool : True if this is an approved blink tx in the mempool was_blink - bool : True if we saw this as an approved blink (either in the mempool or a recent, uncheckpointed block). Note that if we didn't see it while an active blink this won't be set. pending - transfer_view[] txid - string : Transaction ID for this transfer. payment_id - string : Payment ID for this transfer. height - uint64 : Height of the first block that confirmed this transfer (0 if not mined yet). timestamp - uint64 : UNIX timestamp for when this transfer was first confirmed in a block (or timestamp submission if not mined yet). amount - uint64 : Amount transferred. fee - uint64 : Transaction fee for this transfer. note - string : Note about this transfer. destinations - transfer_destination[] : Array of transfer destinations. address - string : Destination public address. amount - uint64 : Amount to send to each destination, in atomic units. type - string : Type of transfer, one of the following: \"in\", \"out\", \"stake\", \"miner\", \"snode\", \"gov\", \"pending\", \"failed\", \"pool\". unlock_time - uint64 : Number of blocks until transfer is safely spendable. subaddr_index - cryptonote::subaddress_index : Major & minor index, account and subaddress index respectively. major - uint32 : The account index, major index minor - uint32 : The subaddress index, minor index subaddr_indices - cryptonote::subaddress_index[] major - uint32 : The account index, major index minor - uint32 : The subaddress index, minor index address - string : Address that transferred the funds. double_spend_seen - bool : True if the key image(s) for the transfer have been seen before. confirmations - uint64 : Number of block mined since the block containing this transaction (or block height at which the transaction should be added to a block if not yet confirmed). suggested_confirmations_threshold - uint64 : Estimation of the confirmations needed for the transaction to be included in a block. checkpointed - uint64 : If transfer is backed by atleast 2 Service Node Checkpoints, 0 if it is not, see immutable_height in the daemon rpc call get_info blink_mempool - bool : True if this is an approved blink tx in the mempool was_blink - bool : True if we saw this as an approved blink (either in the mempool or a recent, uncheckpointed block). Note that if we didn't see it while an active blink this won't be set. failed - transfer_view[] txid - string : Transaction ID for this transfer. payment_id - string : Payment ID for this transfer. height - uint64 : Height of the first block that confirmed this transfer (0 if not mined yet). timestamp - uint64 : UNIX timestamp for when this transfer was first confirmed in a block (or timestamp submission if not mined yet). amount - uint64 : Amount transferred. fee - uint64 : Transaction fee for this transfer. note - string : Note about this transfer. destinations - transfer_destination[] : Array of transfer destinations. address - string : Destination public address. amount - uint64 : Amount to send to each destination, in atomic units. type - string : Type of transfer, one of the following: \"in\", \"out\", \"stake\", \"miner\", \"snode\", \"gov\", \"pending\", \"failed\", \"pool\". unlock_time - uint64 : Number of blocks until transfer is safely spendable. subaddr_index - cryptonote::subaddress_index : Major & minor index, account and subaddress index respectively. major - uint32 : The account index, major index minor - uint32 : The subaddress index, minor index subaddr_indices - cryptonote::subaddress_index[] major - uint32 : The account index, major index minor - uint32 : The subaddress index, minor index address - string : Address that transferred the funds. double_spend_seen - bool : True if the key image(s) for the transfer have been seen before. confirmations - uint64 : Number of block mined since the block containing this transaction (or block height at which the transaction should be added to a block if not yet confirmed). suggested_confirmations_threshold - uint64 : Estimation of the confirmations needed for the transaction to be included in a block. checkpointed - uint64 : If transfer is backed by atleast 2 Service Node Checkpoints, 0 if it is not, see immutable_height in the daemon rpc call get_info blink_mempool - bool : True if this is an approved blink tx in the mempool was_blink - bool : True if we saw this as an approved blink (either in the mempool or a recent, uncheckpointed block). Note that if we didn't see it while an active blink this won't be set. pool - transfer_view[] txid - string : Transaction ID for this transfer. payment_id - string : Payment ID for this transfer. height - uint64 : Height of the first block that confirmed this transfer (0 if not mined yet). timestamp - uint64 : UNIX timestamp for when this transfer was first confirmed in a block (or timestamp submission if not mined yet). amount - uint64 : Amount transferred. fee - uint64 : Transaction fee for this transfer. note - string : Note about this transfer. destinations - transfer_destination[] : Array of transfer destinations. address - string : Destination public address. amount - uint64 : Amount to send to each destination, in atomic units. type - string : Type of transfer, one of the following: \"in\", \"out\", \"stake\", \"miner\", \"snode\", \"gov\", \"pending\", \"failed\", \"pool\". unlock_time - uint64 : Number of blocks until transfer is safely spendable. subaddr_index - cryptonote::subaddress_index : Major & minor index, account and subaddress index respectively. major - uint32 : The account index, major index minor - uint32 : The subaddress index, minor index subaddr_indices - cryptonote::subaddress_index[] major - uint32 : The account index, major index minor - uint32 : The subaddress index, minor index address - string : Address that transferred the funds. double_spend_seen - bool : True if the key image(s) for the transfer have been seen before. confirmations - uint64 : Number of block mined since the block containing this transaction (or block height at which the transaction should be added to a block if not yet confirmed). suggested_confirmations_threshold - uint64 : Estimation of the confirmations needed for the transaction to be included in a block. checkpointed - uint64 : If transfer is backed by atleast 2 Service Node Checkpoints, 0 if it is not, see immutable_height in the daemon rpc call get_info blink_mempool - bool : True if this is an approved blink tx in the mempool was_blink - bool : True if we saw this as an approved blink (either in the mempool or a recent, uncheckpointed block). Note that if we didn't see it while an active blink this won't be set.","title":"COMMAND_RPC_GET_TRANSFERS"},{"location":"Developer/WalletRPCBeta/#command_rpc_get_transfers_csv","text":"Back to top Returns a string with the transfers formatted as csv Endpoints: get_transfers_csv Constants: * `request - COMMAND_RPC_GET_TRANSFERS::request` Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_transfers_csv\", \"params\": { \"in\": true, \"out\": true, \"stake\": true, \"pending\": true, \"failed\": true, \"pool\": true, \"coinbase\": true, \"filter_by_height\": true, \"min_height\": 123, \"max_height\": 123, \"account_index\": 0, \"subaddr_indices\": [0], \"all_accounts\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"csv\": \"TODO(loki): Write example string\" } Inputs: in - bool : (Optional) Include incoming transfers. out - bool : (Optional) Include outgoing transfers. stake - bool : (Optional) Include outgoing stakes. pending - bool : (Optional) Include pending transfers. failed - bool : (Optional) Include failed transfers. pool - bool : (Optional) Include transfers from the daemon's transaction pool. coinbase - bool : (Optional) Include transfers from the daemon's transaction pool. filter_by_height - bool : (Optional) Filter transfers by block height. min_height - uint64 : (Optional) Minimum block height to scan for transfers, if filtering by height is enabled. max_height - uint64 : (Optional) Maximum block height to scan for transfers, if filtering by height is enabled (defaults to max block height). account_index - uint32 : (Optional) Index of the account to query for transfers. (defaults to 0) subaddr_indices - uint32[] : (Optional) List of subaddress indices to query for transfers. (defaults to 0) all_accounts - bool : If true, return transfers for all accounts, subaddr_indices and account_index are ignored Outputs: csv - string","title":"COMMAND_RPC_GET_TRANSFERS_CSV"},{"location":"Developer/WalletRPCBeta/#command_rpc_get_transfer_by_txid","text":"Back to top Show information about a transfer to/from this address. Endpoints: get_transfer_by_txid Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_transfer_by_txid\", \"params\": { \"txid\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"account_index\": 0 } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"transfer\": { \"txid\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"payment_id\": \"f378710e54eeeb8d\", \"height\": 234767, \"timestamp\": 123, \"amount\": 26734261552878, \"fee\": 123, \"note\": \"User assigned note describing something\", \"destinations\": [{ \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"amount\": 26734261552878 }], \"type\": \"TODO(loki): Write example string\", \"unlock_time\": 123, \"subaddr_index\": { \"major\": 2130706433, \"minor\": 2130706433 }, \"subaddr_indices\": [{ \"major\": 2130706433, \"minor\": 2130706433 }], \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"double_spend_seen\": true, \"confirmations\": 123, \"suggested_confirmations_threshold\": 123, \"checkpointed\": 1, \"blink_mempool\": true, \"was_blink\": true }, \"transfers\": [{ \"txid\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"payment_id\": \"f378710e54eeeb8d\", \"height\": 234767, \"timestamp\": 123, \"amount\": 26734261552878, \"fee\": 123, \"note\": \"User assigned note describing something\", \"destinations\": [{ \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"amount\": 26734261552878 }], \"type\": \"TODO(loki): Write example string\", \"unlock_time\": 123, \"subaddr_index\": { \"major\": 2130706433, \"minor\": 2130706433 }, \"subaddr_indices\": [{ \"major\": 2130706433, \"minor\": 2130706433 }], \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"double_spend_seen\": true, \"confirmations\": 123, \"suggested_confirmations_threshold\": 123, \"checkpointed\": 1, \"blink_mempool\": true, \"was_blink\": true }] } } Inputs: txid - string : Transaction ID used to find the transfer. account_index - uint32 : (Optional) Index of the account to query for the transfer. Outputs: transfer - transfer_view txid - string : Transaction ID for this transfer. payment_id - string : Payment ID for this transfer. height - uint64 : Height of the first block that confirmed this transfer (0 if not mined yet). timestamp - uint64 : UNIX timestamp for when this transfer was first confirmed in a block (or timestamp submission if not mined yet). amount - uint64 : Amount transferred. fee - uint64 : Transaction fee for this transfer. note - string : Note about this transfer. destinations - transfer_destination[] : Array of transfer destinations. address - string : Destination public address. amount - uint64 : Amount to send to each destination, in atomic units. type - string : Type of transfer, one of the following: \"in\", \"out\", \"stake\", \"miner\", \"snode\", \"gov\", \"pending\", \"failed\", \"pool\". unlock_time - uint64 : Number of blocks until transfer is safely spendable. subaddr_index - cryptonote::subaddress_index : Major & minor index, account and subaddress index respectively. major - uint32 : The account index, major index minor - uint32 : The subaddress index, minor index subaddr_indices - cryptonote::subaddress_index[] major - uint32 : The account index, major index minor - uint32 : The subaddress index, minor index address - string : Address that transferred the funds. double_spend_seen - bool : True if the key image(s) for the transfer have been seen before. confirmations - uint64 : Number of block mined since the block containing this transaction (or block height at which the transaction should be added to a block if not yet confirmed). suggested_confirmations_threshold - uint64 : Estimation of the confirmations needed for the transaction to be included in a block. checkpointed - uint64 : If transfer is backed by atleast 2 Service Node Checkpoints, 0 if it is not, see immutable_height in the daemon rpc call get_info blink_mempool - bool : True if this is an approved blink tx in the mempool was_blink - bool : True if we saw this as an approved blink (either in the mempool or a recent, uncheckpointed block). Note that if we didn't see it while an active blink this won't be set. transfers - transfer_view[] txid - string : Transaction ID for this transfer. payment_id - string : Payment ID for this transfer. height - uint64 : Height of the first block that confirmed this transfer (0 if not mined yet). timestamp - uint64 : UNIX timestamp for when this transfer was first confirmed in a block (or timestamp submission if not mined yet). amount - uint64 : Amount transferred. fee - uint64 : Transaction fee for this transfer. note - string : Note about this transfer. destinations - transfer_destination[] : Array of transfer destinations. address - string : Destination public address. amount - uint64 : Amount to send to each destination, in atomic units. type - string : Type of transfer, one of the following: \"in\", \"out\", \"stake\", \"miner\", \"snode\", \"gov\", \"pending\", \"failed\", \"pool\". unlock_time - uint64 : Number of blocks until transfer is safely spendable. subaddr_index - cryptonote::subaddress_index : Major & minor index, account and subaddress index respectively. major - uint32 : The account index, major index minor - uint32 : The subaddress index, minor index subaddr_indices - cryptonote::subaddress_index[] major - uint32 : The account index, major index minor - uint32 : The subaddress index, minor index address - string : Address that transferred the funds. double_spend_seen - bool : True if the key image(s) for the transfer have been seen before. confirmations - uint64 : Number of block mined since the block containing this transaction (or block height at which the transaction should be added to a block if not yet confirmed). suggested_confirmations_threshold - uint64 : Estimation of the confirmations needed for the transaction to be included in a block. checkpointed - uint64 : If transfer is backed by atleast 2 Service Node Checkpoints, 0 if it is not, see immutable_height in the daemon rpc call get_info blink_mempool - bool : True if this is an approved blink tx in the mempool was_blink - bool : True if we saw this as an approved blink (either in the mempool or a recent, uncheckpointed block). Note that if we didn't see it while an active blink this won't be set.","title":"COMMAND_RPC_GET_TRANSFER_BY_TXID"},{"location":"Developer/WalletRPCBeta/#command_rpc_get_tx_key","text":"Back to top Get transaction secret key from transaction id. Endpoints: get_tx_key Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_tx_key\", \"params\": { \"txid\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"tx_key\": \"1982e99c69d8acc993cfc94ce59ff8f113d23482d9a25c892a3fc01c77dd8c4c\" } Inputs: txid - string : Transaction id. Outputs: tx_key - string : Transaction secret key.","title":"COMMAND_RPC_GET_TX_KEY"},{"location":"Developer/WalletRPCBeta/#command_rpc_get_tx_notes","text":"Back to top Get string notes for transactions. Endpoints: get_tx_notes Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_tx_notes\", \"params\": { \"txids\": [\"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\"] } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"notes\": [\"TODO(loki): Write example string\"] } Inputs: txids - string[] : Transaction ids. Outputs: notes - string[] : Notes for the transactions.","title":"COMMAND_RPC_GET_TX_NOTES"},{"location":"Developer/WalletRPCBeta/#command_rpc_get_tx_proof","text":"Back to top Get transaction signature to prove it. Endpoints: get_tx_proof Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_tx_proof\", \"params\": { \"txid\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"message\": \"User assigned note describing something\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"signature\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\" } Inputs: txid - string : Transaction id. address - string : Destination public address of the transaction. message - string : (Optional) add a message to the signature to further authenticate the prooving process. Outputs: signature - string : Transaction signature.","title":"COMMAND_RPC_GET_TX_PROOF"},{"location":"Developer/WalletRPCBeta/#command_rpc_get_version","text":"Back to top Get RPC version Major & Minor integer-format, where Major is the first 16 bits and Minor the last 16 bits. Endpoints: get_version Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"get_version\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"version\": 2130706433 } Outputs: version - uint32 : RPC version, formatted with Major * 2^16 + Minor(Major encoded over the first 16 bits, and Minor over the last 16 bits).","title":"COMMAND_RPC_GET_VERSION"},{"location":"Developer/WalletRPCBeta/#command_rpc_import_key_images","text":"Back to top Import signed key images list and verify their spent status. Endpoints: import_key_images Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"import_key_images\", \"params\": { \"offset\": 2130706433, \"signed_key_images\": [{ \"key_image\": \"8d1bd8181bf7d857bdb281e0153d84cd55a3fcaa57c3e570f4a49f935850b5e3\", \"signature\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\" }] } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"height\": 234767, \"spent\": 123, \"unspent\": 123 } } Inputs: offset - uint32 signed_key_images - signed_key_image[] key_image - string : Key image of specific output signature - string : Transaction signature. Outputs: height - uint64 spent - uint64 : Amount (in atomic units) spent from those key images. unspent - uint64 : Amount (in atomic units) still available from those key images.","title":"COMMAND_RPC_IMPORT_KEY_IMAGES"},{"location":"Developer/WalletRPCBeta/#command_rpc_import_multisig","text":"Back to top Import multisig info from other participants. Endpoints: import_multisig_info Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"import_multisig_info\", \"params\": { \"info\": [\"TODO(loki): Write example string\"] } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"n_outputs\": 123 } Inputs: info - string[] : List of multisig info in hex format from other participants. Outputs: n_outputs - uint64 : Number of outputs signed with those multisig info.","title":"COMMAND_RPC_IMPORT_MULTISIG"},{"location":"Developer/WalletRPCBeta/#command_rpc_import_outputs","text":"Back to top Import outputs in hex format. Endpoints: import_outputs Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"import_outputs\", \"params\": { \"outputs_data_hex\": \"TODO(loki): Write example string\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"num_imported\": 123 } Inputs: outputs_data_hex - string : Wallet outputs in hex format. Outputs: num_imported - uint64 : Number of outputs imported.","title":"COMMAND_RPC_IMPORT_OUTPUTS"},{"location":"Developer/WalletRPCBeta/#command_rpc_incoming_transfers","text":"Back to top Return a list of incoming transfers to the wallet. Endpoints: incoming_transfers Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"incoming_transfers\", \"params\": { \"transfer_type\": \"all\", \"account_index\": 0, \"subaddr_indices\": [0] } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"transfers\": [{ \"amount\": 26734261552878, \"spent\": true, \"global_index\": 123, \"tx_hash\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"subaddr_index\": { \"major\": 2130706433, \"minor\": 2130706433 }, \"key_image\": \"8d1bd8181bf7d857bdb281e0153d84cd55a3fcaa57c3e570f4a49f935850b5e3\", \"block_height\": 123, \"frozen\": true, \"unlocked\": true }] } Inputs: transfer_type - string : \"all\": all the transfers, \"available\": only transfers which are not yet spent, OR \"unavailable\": only transfers which are already spent. account_index - uint32 : (Optional) Return transfers for this account. (defaults to 0) subaddr_indices - uint32[] : (Optional) Return transfers sent to these subaddresses. Outputs: transfers - transfer_details[] : List of information of the transfers details. amount - uint64 : Amount of this transfer. spent - bool : Indicates if this transfer has been spent. global_index - uint64 : The index into the global list of transactions grouped by amount in the Loki network. tx_hash - string : Several incoming transfers may share the same hash if they were in the same transaction. subaddr_index - cryptonote::subaddress_index : Major & minor index, account and subaddress index respectively. major - uint32 : The account index, major index minor - uint32 : The subaddress index, minor index key_image - string : Key image for the incoming transfer's unspent output (empty unless verbose is true). block_height - uint64 : Block height the transfer occurred on frozen - bool : If the output has been intentionally frozen by the user, i.e. unspendable. unlocked - bool : If the TX is spendable yet","title":"COMMAND_RPC_INCOMING_TRANSFERS"},{"location":"Developer/WalletRPCBeta/#command_rpc_is_multisig","text":"Back to top Check if a wallet is a multisig one. Endpoints: is_multisig Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"is_multisig\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"multisig\": true, \"ready\": true, \"threshold\": 2130706433, \"total\": 2130706433 } } Outputs: multisig - bool : States if the wallet is multisig. ready - bool threshold - uint32 : Amount of signature needed to sign a transfer. total - uint32 : Total amount of signature in the multisig wallet.","title":"COMMAND_RPC_IS_MULTISIG"},{"location":"Developer/WalletRPCBeta/#command_rpc_label_account","text":"Back to top Label an account. Endpoints: label_account Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"label_account\", \"params\": { \"account_index\": 0, \"label\": \"My label\" } } EOF Inputs: account_index - uint32 : Account index to set the label for. label - string : Label for the account.","title":"COMMAND_RPC_LABEL_ACCOUNT"},{"location":"Developer/WalletRPCBeta/#command_rpc_label_address","text":"Back to top Label an address. Endpoints: label_address Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"label_address\", \"params\": { \"index\": { \"major\": 2130706433, \"minor\": 2130706433 }, \"label\": \"My label\" } } EOF Inputs: index - cryptonote::subaddress_index : Major & minor address index major - uint32 : The account index, major index minor - uint32 : The subaddress index, minor index label - string : Label for the address.","title":"COMMAND_RPC_LABEL_ADDRESS"},{"location":"Developer/WalletRPCBeta/#command_rpc_lns_buy_mapping","text":"Back to top Endpoints: lns_buy_mapping Constants: * `R - char *description =` Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"lns_buy_mapping\", \"params\": { \"type\": session, \"owner\": \"L8ssYFtxi1HTFQdbmG9Lt71tyudgageDgBqBLcgLnw5XBiJ1NQLFYNAAfYpYS3jHaSe8UsFYjSgKadKhC7edTSQB15s6T7g\", \"backup_owner\": \"L8PYYYTh6yEewvuPmF75uhjDn9fBzKXp8CeMuwKNZBvZT8wAoe9hJ4favnZMvTTkNdT56DMNDcdWyheb3icfk4MS3udsP4R\", \"name\": \"My_Lns_Name\", \"value\": \"059f5a1ac2d04d0c09daa21b08699e8e2e0fd8d6fbe119207e5f241043cf77c30d\", \"account_index\": 0, \"subaddr_indices\": [0], \"priority\": 0, \"get_tx_key\": true, \"do_not_relay\": true, \"get_tx_hex\": true, \"get_tx_metadata\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"tx_hash\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"tx_key\": \"1982e99c69d8acc993cfc94ce59ff8f113d23482d9a25c892a3fc01c77dd8c4c\", \"amount\": 26734261552878, \"fee\": 123, \"tx_blob\": \"0402f78b05f78b05f78b0501ffd98b0502b888ddcf730229f056f5594cfcfd8d44f8033c9fda22450693d1694038e1cecaaaac25a8fc12af8992bc800102534df00c14ead3b3dedea9e7bdcf71c44803349b5e9aee2f73e22d5385ac147b7601008e5729d9329320444666d9d9d9dc602a3ae585de91ab2ca125665e3a363610021100000001839fdb0000000000000000000001200408d5ad7ab79d9b05c94033c2029f4902a98ec51f5175564f6978467dbb28723f929cf806d4ee1c781d7771183a93a1fd74f0827bddee9baac7e3083ab2b5840000\", \"tx_metadata\": \"TODO(loki): Write example string\", \"multisig_txset\": \"TODO(loki): Write example string\", \"unsigned_txset\": \"TODO(loki): Write example string\" } } Inputs: type - string : The mapping type, currently we only support \"session\". In future \"lokinet\" and \"blockchain\" mappings will be available. owner - string : (Optional): The ed25519 public key or wallet address that has authority to update the mapping. backup_owner - string : (Optional): The secondary, backup public key that has authority to update the mapping. name - string : The name to purchase via Loki Name Service value - string : The value that the name maps to via Loki Name Service, (i.e. For Session: [display name->session public key]. In future, for wallets: [name->wallet address], for Lokinet: [name->domain name]). account_index - uint32 : (Optional) Transfer from this account index. (Defaults to 0) subaddr_indices - uint32[] : (Optional) Transfer from this set of subaddresses. (Defaults to 0) priority - uint32 : Set a priority for the transaction. Accepted values are: or 0-4 for: default, unimportant, normal, elevated, priority. get_tx_key - bool : (Optional) Return the transaction key after sending. do_not_relay - bool : (Optional) If true, the newly created transaction will not be relayed to the loki network. (Defaults to false) get_tx_hex - bool : Return the transaction as hex string after sending (Defaults to false) get_tx_metadata - bool : Return the metadata needed to relay the transaction. (Defaults to false) Outputs: tx_hash - string : Publically searchable transaction hash. tx_key - string : Transaction key if get_tx_key is true , otherwise, blank string. amount - uint64 : Amount transferred for the transaction in atomic units. fee - uint64 : Value in atomic units of the fee charged for the tx. tx_blob - string : Raw transaction represented as hex string, if get_tx_hex is true. tx_metadata - string : Set of transaction metadata needed to relay this transfer later, if get_tx_metadata is true . multisig_txset - string : Set of multisig transactions in the process of being signed (empty for non-multisig). unsigned_txset - string : Set of unsigned tx for cold-signing purposes.","title":"COMMAND_RPC_LNS_BUY_MAPPING"},{"location":"Developer/WalletRPCBeta/#command_rpc_lns_decrypt_value","text":"Back to top Takes a LNS encrypted value and decrypts the mapping value. Endpoints: lns_decrypt_value Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"lns_decrypt_value\", \"params\": { \"name\": \"TODO(loki): Write example string\", \"type\": \"TODO(loki): Write example string\", \"encrypted_value\": \"TODO(loki): Write example string\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"value\": \"TODO(loki): Write example string\" } Inputs: name - string : The desired name to hash type - string : The mapping type, currently we only support \"session\". In future \"lokinet\" and \"blockchain\" mappings will be available. encrypted_value - string : The encrypted value represented in hex Outputs: value - string : The value decrypted","title":"COMMAND_RPC_LNS_DECRYPT_VALUE"},{"location":"Developer/WalletRPCBeta/#command_rpc_lns_hash_name","text":"Back to top Takes a LNS name, upon validating it, generates the hash and returns the base64 representation of the hash suitable for use in the daemon LNS name queries. Endpoints: lns_hash_name Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"lns_hash_name\", \"params\": { \"type\": \"TODO(loki): Write example string\", \"name\": \"TODO(loki): Write example string\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"name\": \"TODO(loki): Write example string\" } Inputs: type - string : The mapping type, currently we only support \"session\". In future \"lokinet\" and \"blockchain\" mappings will be available. name - string : The desired name to hash Outputs: name - string : The name hashed and represented in base64","title":"COMMAND_RPC_LNS_HASH_NAME"},{"location":"Developer/WalletRPCBeta/#command_rpc_lns_make_update_signature","text":"Back to top Endpoints: lns_make_update_mapping_signature Constants: * `R - char *description =` Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"lns_make_update_mapping_signature\", \"params\": { \"type\": session, \"name\": \"My_Lns_Name\", \"value\": \"059f5a1ac2d04d0c09daa21b08699e8e2e0fd8d6fbe119207e5f241043cf77c30d\", \"owner\": \"L8ssYFtxi1HTFQdbmG9Lt71tyudgageDgBqBLcgLnw5XBiJ1NQLFYNAAfYpYS3jHaSe8UsFYjSgKadKhC7edTSQB15s6T7g\", \"backup_owner\": \"L8PYYYTh6yEewvuPmF75uhjDn9fBzKXp8CeMuwKNZBvZT8wAoe9hJ4favnZMvTTkNdT56DMNDcdWyheb3icfk4MS3udsP4R\", \"account_index\": 0 } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"signature\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\" } Inputs: type - string : The mapping type, currently we only support \"session\". In future \"lokinet\" and \"blockchain\" mappings will be available. name - string : The desired name to update via Loki Name Service value - string : (Optional): The new value that the name maps to via Loki Name Service. If not specified or given the empty string \"\", then the mapping's value remains unchanged. owner - string : (Optional): The new owner of the mapping. If not specified or given the empty string \"\", then the mapping's owner remains unchanged. backup_owner - string : (Optional): The new backup owner of the mapping. If not specified or given the empty string \"\", then the mapping's backup owner remains unchanged. account_index - uint32 : (Optional) Use this wallet's subaddress account for generating the signature Outputs: signature - string : A signature valid for using in LNS to update an underlying mapping.","title":"COMMAND_RPC_LNS_MAKE_UPDATE_SIGNATURE"},{"location":"Developer/WalletRPCBeta/#command_rpc_lns_update_mapping","text":"Back to top Update the underlying value in the name->value mapping via Loki Name Service. Endpoints: lns_update_mapping Constants: * `R - char *description =` Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"lns_update_mapping\", \"params\": { \"type\": session, \"name\": \"My_Lns_Name\", \"value\": \"059f5a1ac2d04d0c09daa21b08699e8e2e0fd8d6fbe119207e5f241043cf77c30d\", \"owner\": \"L8ssYFtxi1HTFQdbmG9Lt71tyudgageDgBqBLcgLnw5XBiJ1NQLFYNAAfYpYS3jHaSe8UsFYjSgKadKhC7edTSQB15s6T7g\", \"backup_owner\": \"L8PYYYTh6yEewvuPmF75uhjDn9fBzKXp8CeMuwKNZBvZT8wAoe9hJ4favnZMvTTkNdT56DMNDcdWyheb3icfk4MS3udsP4R\", \"signature\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"account_index\": 0, \"subaddr_indices\": [0], \"priority\": 0, \"get_tx_key\": true, \"do_not_relay\": true, \"get_tx_hex\": true, \"get_tx_metadata\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"tx_hash\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"tx_key\": \"1982e99c69d8acc993cfc94ce59ff8f113d23482d9a25c892a3fc01c77dd8c4c\", \"amount\": 26734261552878, \"fee\": 123, \"tx_blob\": \"0402f78b05f78b05f78b0501ffd98b0502b888ddcf730229f056f5594cfcfd8d44f8033c9fda22450693d1694038e1cecaaaac25a8fc12af8992bc800102534df00c14ead3b3dedea9e7bdcf71c44803349b5e9aee2f73e22d5385ac147b7601008e5729d9329320444666d9d9d9dc602a3ae585de91ab2ca125665e3a363610021100000001839fdb0000000000000000000001200408d5ad7ab79d9b05c94033c2029f4902a98ec51f5175564f6978467dbb28723f929cf806d4ee1c781d7771183a93a1fd74f0827bddee9baac7e3083ab2b5840000\", \"tx_metadata\": \"TODO(loki): Write example string\", \"multisig_txset\": \"TODO(loki): Write example string\", \"unsigned_txset\": \"TODO(loki): Write example string\" } } Inputs: type - string : The mapping type, currently we only support \"session\". In future \"lokinet\" and \"blockchain\" mappings will be available. name - string : The name to update via Loki Name Service value - string : (Optional): The new value that the name maps to via Loki Name Service. If not specified or given the empty string \"\", then the mapping's value remains unchanged. owner - string : (Optional): The new owner of the mapping. If not specified or given the empty string \"\", then the mapping's owner remains unchanged. backup_owner - string : (Optional): The new backup owner of the mapping. If not specified or given the empty string \"\", then the mapping's backup owner remains unchanged. signature - string : (Optional): Signature derived using libsodium generichash on {current txid blob, new value blob} of the mapping to update. By default the hash is signed using the wallet's spend key as an ed25519 keypair, if signature is specified. account_index - uint32 : (Optional) Transfer from this account index. (Defaults to 0) subaddr_indices - uint32[] : (Optional) Transfer from this set of subaddresses. (Defaults to 0) priority - uint32 : Set a priority for the transaction. Accepted values are: 0-4 for: default, unimportant, normal, elevated, priority. get_tx_key - bool : (Optional) Return the transaction key after sending. do_not_relay - bool : (Optional) If true, the newly created transaction will not be relayed to the loki network. (Defaults to false) get_tx_hex - bool : Return the transaction as hex string after sending (Defaults to false) get_tx_metadata - bool : Return the metadata needed to relay the transaction. (Defaults to false) Outputs: tx_hash - string : Publically searchable transaction hash. tx_key - string : Transaction key if get_tx_key is true , otherwise, blank string. amount - uint64 : Amount transferred for the transaction in atomic units. fee - uint64 : Value in atomic units of the fee charged for the tx. tx_blob - string : Raw transaction represented as hex string, if get_tx_hex is true. tx_metadata - string : Set of transaction metadata needed to relay this transfer later, if get_tx_metadata is true . multisig_txset - string : Set of multisig transactions in the process of being signed (empty for non-multisig). unsigned_txset - string : Set of unsigned tx for cold-signing purposes.","title":"COMMAND_RPC_LNS_UPDATE_MAPPING"},{"location":"Developer/WalletRPCBeta/#command_rpc_make_integrated_address","text":"Back to top Make an integrated address from the wallet address and a payment id. Endpoints: make_integrated_address Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"make_integrated_address\", \"params\": { \"standard_address\": \"TODO(loki): Write example string\", \"payment_id\": \"f378710e54eeeb8d\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"integrated_address\": \"TODO(loki): Write example string\", \"payment_id\": \"f378710e54eeeb8d\" } } Inputs: standard_address - string : (Optional, defaults to primary address) Destination public address. payment_id - string : (Optional, defaults to a random ID) 16 characters hex encoded. Outputs: integrated_address - string payment_id - string : Hex encoded.","title":"COMMAND_RPC_MAKE_INTEGRATED_ADDRESS"},{"location":"Developer/WalletRPCBeta/#command_rpc_make_multisig","text":"Back to top Make a wallet multisig by importing peers multisig string. Endpoints: make_multisig Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"make_multisig\", \"params\": { \"multisig_info\": [\"TODO(loki): Write example string\"], \"threshold\": 2130706433, \"password\": \"not_a_secure_password\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"multisig_info\": \"TODO(loki): Write example string\" } } Inputs: multisig_info - string[] : List of multisig string from peers. threshold - uint32 : Amount of signatures needed to sign a transfer. Must be less or equal than the amount of signature in multisig_info . password - string : Wallet password. Outputs: address - string : Multisig wallet address. multisig_info - string : Multisig string to share with peers to create the multisig wallet (extra step for N-1/N wallets).","title":"COMMAND_RPC_MAKE_MULTISIG"},{"location":"Developer/WalletRPCBeta/#command_rpc_make_uri","text":"Back to top Create a payment URI using the official URI spec. Endpoints: make_uri Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"make_uri\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"uri\": \"TODO(loki): Write example string\" } Inputs: address - string : Wallet address. payment_id - string : (Optional) 16 or 64 character hexadecimal payment id. amount - uint64 : (Optional) the integer amount to receive, in atomic units. tx_description - string : (Optional) Description of the reason for the tx. recipient_name - string : (Optional) name of the payment recipient. Outputs: uri - string : This contains all the payment input information as a properly formatted payment URI.","title":"COMMAND_RPC_MAKE_URI"},{"location":"Developer/WalletRPCBeta/#command_rpc_open_wallet","text":"Back to top Open a wallet. You need to have set the argument \"\u2013-wallet-dir\" when launching loki-wallet-rpc to make this work. The wallet rpc executable may only open wallet files within the same directory as wallet-dir, otherwise use the \"--wallet-file\" flag to open specific wallets. Endpoints: open_wallet Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"open_wallet\", \"params\": { \"filename\": \"Doyles_Cool_Wallet\", \"password\": \"not_a_secure_password\", \"autosave_current\": true } } EOF Inputs: filename - string : Wallet name stored in \"\u2013-wallet-dir\". password - string : The wallet password, set as \"\" if there's no password autosave_current - bool : (Optional: Default true): If a pre-existing wallet is open, save to disk before opening the new wallet.","title":"COMMAND_RPC_OPEN_WALLET"},{"location":"Developer/WalletRPCBeta/#command_rpc_parse_uri","text":"Back to top Parse a payment URI to get payment information. Endpoints: parse_uri Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"parse_uri\", \"params\": { \"uri\": \"TODO(loki): Write example string\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"uri\": { \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"payment_id\": \"f378710e54eeeb8d\", \"amount\": 26734261552878, \"tx_description\": \"User assigned note describing something\", \"recipient_name\": \"Thor\" }, \"unknown_parameters\": [\"TODO(loki): Write example string\"] } } Inputs: uri - string : This contains all the payment input information as a properly formatted payment URI. Outputs: uri - uri_spec : JSON object containing payment information: address - string : Wallet address. payment_id - string : (Optional) 16 or 64 character hexadecimal payment id. amount - uint64 : (Optional) the integer amount to receive, in atomic units. tx_description - string : (Optional) Description of the reason for the tx. recipient_name - string : (Optional) name of the payment recipient. unknown_parameters - string[]","title":"COMMAND_RPC_PARSE_URI"},{"location":"Developer/WalletRPCBeta/#command_rpc_prepare_multisig","text":"Back to top Prepare a wallet for multisig by generating a multisig string to share with peers. Endpoints: prepare_multisig Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"prepare_multisig\" } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"multisig_info\": \"TODO(loki): Write example string\" } Outputs: multisig_info - string : Multisig string to share with peers to create the multisig wallet.","title":"COMMAND_RPC_PREPARE_MULTISIG"},{"location":"Developer/WalletRPCBeta/#command_rpc_query_key","text":"Back to top Return the spend or view private key. Endpoints: query_key Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"query_key\", \"params\": { \"key_type\": \"TODO(loki): Write example string\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"key\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\" } Inputs: key_type - string : Which key to retrieve: \"mnemonic\" - the mnemonic seed (older wallets do not have one) OR \"view_key\" - the view key Outputs: key - string : The view key will be hex encoded, while the mnemonic will be a string of words.","title":"COMMAND_RPC_QUERY_KEY"},{"location":"Developer/WalletRPCBeta/#command_rpc_refresh","text":"Back to top Refresh a wallet after openning. Endpoints: refresh Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"refresh\", \"params\": { \"start_height\": 123 } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"blocks_fetched\": 123, \"received_money\": true } } Inputs: start_height - uint64 : (Optional) The block height from which to start refreshing. Outputs: blocks_fetched - uint64 : Number of new blocks scanned. received_money - bool : States if transactions to the wallet have been found in the blocks.","title":"COMMAND_RPC_REFRESH"},{"location":"Developer/WalletRPCBeta/#command_rpc_register_service_node","text":"Back to top Register Service Node. Endpoints: register_service_node Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"register_service_node\", \"params\": { \"register_service_node_str\": \"TODO(loki): Write example string\", \"get_tx_key\": true, \"do_not_relay\": true, \"get_tx_hex\": true, \"get_tx_metadata\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"tx_hash\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"tx_key\": \"1982e99c69d8acc993cfc94ce59ff8f113d23482d9a25c892a3fc01c77dd8c4c\", \"amount\": 26734261552878, \"fee\": 123, \"tx_blob\": \"0402f78b05f78b05f78b0501ffd98b0502b888ddcf730229f056f5594cfcfd8d44f8033c9fda22450693d1694038e1cecaaaac25a8fc12af8992bc800102534df00c14ead3b3dedea9e7bdcf71c44803349b5e9aee2f73e22d5385ac147b7601008e5729d9329320444666d9d9d9dc602a3ae585de91ab2ca125665e3a363610021100000001839fdb0000000000000000000001200408d5ad7ab79d9b05c94033c2029f4902a98ec51f5175564f6978467dbb28723f929cf806d4ee1c781d7771183a93a1fd74f0827bddee9baac7e3083ab2b5840000\", \"tx_metadata\": \"TODO(loki): Write example string\", \"multisig_txset\": \"TODO(loki): Write example string\", \"unsigned_txset\": \"TODO(loki): Write example string\" } } Inputs: register_service_node_str - string : String supplied by the prepare_registration command. get_tx_key - bool : (Optional) Return the transaction key after sending. do_not_relay - bool : (Optional) If true, the newly created transaction will not be relayed to the loki network. (Defaults to false) get_tx_hex - bool : Return the transaction as hex string after sending (Defaults to false) get_tx_metadata - bool : Return the metadata needed to relay the transaction. (Defaults to false) Outputs: tx_hash - string : Publically searchable transaction hash. tx_key - string : Transaction key if get_tx_key is true, otherwise, blank string. amount - uint64 : Amount transferred for the transaction in atomic units. fee - uint64 : Value in atomic units of the fee charged for the tx. tx_blob - string : Raw transaction represented as hex string, if get_tx_hex is true. tx_metadata - string : Set of transaction metadata needed to relay this transfer later, if get_tx_metadata is true . multisig_txset - string : Set of multisig transactions in the process of being signed (empty for non-multisig). unsigned_txset - string : Set of unsigned tx for cold-signing purposes.","title":"COMMAND_RPC_REGISTER_SERVICE_NODE"},{"location":"Developer/WalletRPCBeta/#command_rpc_relay_tx","text":"Back to top Relay transaction metadata to the daemon Endpoints: relay_tx Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"relay_tx\", \"params\": { \"hex\": \"TODO(loki): Write example string\", \"blink\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"tx_hash\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\" } Inputs: hex - string : Transaction metadata returned from a transfer method with get_tx_metadata set to true. blink - bool : (Optional): True if this tx was constructed with a blink priority and should be submitted to the blink quorum Outputs: tx_hash - string : String for the publically searchable transaction hash.","title":"COMMAND_RPC_RELAY_TX"},{"location":"Developer/WalletRPCBeta/#command_rpc_request_stake_unlock","text":"Back to top Request to unlock stake by deregistering Service Node. Endpoints: request_stake_unlock Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"request_stake_unlock\", \"params\": { \"service_node_key\": \"4a8c30cea9e729b06c91132295cce32d2a8e6e5bcf7b74a998e2ee1b3ed590b3\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"unlocked\": true, \"msg\": \"Message returned by the sender (wallet/daemon)\" } } Inputs: service_node_key - string : Service Node Public Key. Outputs: unlocked - bool : States if stake has been unlocked. msg - string : Information on the unlocking process.","title":"COMMAND_RPC_REQUEST_STAKE_UNLOCK"},{"location":"Developer/WalletRPCBeta/#command_rpc_rescan_blockchain","text":"Back to top Rescan the blockchain from scratch, losing any information which can not be recovered from the blockchain itself. This includes destination addresses, tx secret keys, tx notes, etc. Warning: This blocks the Wallet RPC executable until rescanning is complete. Endpoints: rescan_blockchain Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"rescan_blockchain\", \"params\": { \"hard\": true } } EOF Inputs: hard - bool","title":"COMMAND_RPC_RESCAN_BLOCKCHAIN"},{"location":"Developer/WalletRPCBeta/#command_rpc_rescan_spent","text":"Back to top Rescan the blockchain for spent outputs. Endpoints: rescan_spent Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"rescan_spent\" } EOF","title":"COMMAND_RPC_RESCAN_SPENT"},{"location":"Developer/WalletRPCBeta/#command_rpc_restore_deterministic_wallet","text":"Back to top Restore a wallet using the seed words. Endpoints: restore_deterministic_wallet Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"restore_deterministic_wallet\", \"params\": { \"restore_height\": 123, \"filename\": \"Doyles_Cool_Wallet\", \"seed\": \"TODO(loki): Write example string\", \"seed_offset\": \"TODO(loki): Write example string\", \"password\": \"not_a_secure_password\", \"language\": \"english\", \"autosave_current\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"seed\": \"TODO(loki): Write example string\", \"info\": \"TODO(loki): Write example string\", \"was_deprecated\": true } } Inputs: restore_height - uint64 : Height in which to start scanning the blockchain for transactions into and out of this Wallet. filename - string : Set the name of the Wallet. seed - string : Mnemonic seed of wallet (25 words). seed_offset - string password - string : Set password for Wallet. language - string : Set language for the wallet. autosave_current - bool : (Optional: Default true): If a pre-existing wallet is open, save to disk before opening the new wallet. Outputs: address - string : Public address of wallet. seed - string : Seed of wallet. info - string : Wallet information. was_deprecated - bool","title":"COMMAND_RPC_RESTORE_DETERMINISTIC_WALLET"},{"location":"Developer/WalletRPCBeta/#command_rpc_set_account_tag_description","text":"Back to top Set description for an account tag. Endpoints: set_account_tag_description Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"set_account_tag_description\", \"params\": { \"tag\": \"My tag\", \"description\": \"My account description\" } } EOF Inputs: tag - string : Set a description for this tag. description - string : Description for the tag.","title":"COMMAND_RPC_SET_ACCOUNT_TAG_DESCRIPTION"},{"location":"Developer/WalletRPCBeta/#command_rpc_set_attribute","text":"Back to top Set arbitrary attribute. Endpoints: set_attribute Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"set_attribute\", \"params\": { \"key\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\", \"value\": \"TODO(loki): Write example string\" } } EOF Inputs: key - string : Attribute name. value - string : Attribute value.","title":"COMMAND_RPC_SET_ATTRIBUTE"},{"location":"Developer/WalletRPCBeta/#command_rpc_set_daemon","text":"Back to top Endpoints: set_daemon Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"set_daemon\", \"params\": { \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"trusted\": true, \"ssl_support\": \"TODO(loki): Write example string\", \"ssl_private_key_path\": \"TODO(loki): Write example string\", \"ssl_certificate_path\": \"TODO(loki): Write example string\", \"ssl_ca_file\": \"TODO(loki): Write example string\", \"ssl_allowed_fingerprints\": [\"TODO(loki): Write example string\"], \"ssl_allow_any_cert\": true } } EOF Inputs: address - string : The remote address of the daemon trusted - bool : When true, allow the usage of commands that may compromise privacy ssl_support - string : disabled, enabled, autodetect ssl_private_key_path - string ssl_certificate_path - string ssl_ca_file - string ssl_allowed_fingerprints - string[] ssl_allow_any_cert - bool","title":"COMMAND_RPC_SET_DAEMON"},{"location":"Developer/WalletRPCBeta/#command_rpc_set_log_categories","text":"Back to top Endpoints: set_log_categories Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"set_log_categories\", \"params\": { \"categories\": \"TODO(loki): Write example string\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"categories\": \"TODO(loki): Write example string\" } Inputs: categories - string Outputs: categories - string","title":"COMMAND_RPC_SET_LOG_CATEGORIES"},{"location":"Developer/WalletRPCBeta/#command_rpc_set_log_level","text":"Back to top Endpoints: set_log_level Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"set_log_level\", \"params\": { \"level\": 8 } } EOF Inputs: level - int8","title":"COMMAND_RPC_SET_LOG_LEVEL"},{"location":"Developer/WalletRPCBeta/#command_rpc_set_tx_notes","text":"Back to top Set arbitrary string notes for transactions. Endpoints: set_tx_notes Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"set_tx_notes\", \"params\": { \"txids\": [\"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\"], \"notes\": [\"TODO(loki): Write example string\"] } } EOF Inputs: txids - string[] : Transaction ids. notes - string[] : Notes for the transactions.","title":"COMMAND_RPC_SET_TX_NOTES"},{"location":"Developer/WalletRPCBeta/#command_rpc_sign","text":"Back to top Sign a string. Endpoints: sign Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"sign\", \"params\": { \"data\": \"TODO(loki): Write example string\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"signature\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\" } Inputs: data - string : Anything you need to sign. Outputs: signature - string : Signature generated against the \"data\" and the account public address.","title":"COMMAND_RPC_SIGN"},{"location":"Developer/WalletRPCBeta/#command_rpc_sign_multisig","text":"Back to top Sign a transaction in multisig. Endpoints: sign_multisig Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"sign_multisig\", \"params\": { \"tx_data_hex\": \"TODO(loki): Write example string\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"tx_data_hex\": \"TODO(loki): Write example string\", \"tx_hash_list\": [\"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\"] } } Inputs: tx_data_hex - string : Multisig transaction in hex format, as returned by transfer under multisig_txset . Outputs: tx_data_hex - string : Multisig transaction in hex format. tx_hash_list - string[] : List of transaction Hash.","title":"COMMAND_RPC_SIGN_MULTISIG"},{"location":"Developer/WalletRPCBeta/#command_rpc_sign_transfer","text":"Back to top Sign a transaction created on a read-only wallet (in cold-signing process). Endpoints: sign_transfer Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"sign_transfer\", \"params\": { \"unsigned_txset\": \"TODO(loki): Write example string\", \"export_raw\": true, \"get_tx_keys\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"signed_txset\": \"TODO(loki): Write example string\", \"tx_hash_list\": [\"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\"], \"tx_raw_list\": [\"TODO(loki): Write example string\"], \"tx_key_list\": [\"1982e99c69d8acc993cfc94ce59ff8f113d23482d9a25c892a3fc01c77dd8c4c\"] } } Inputs: unsigned_txset - string : Set of unsigned tx returned by \"transfer\" or \"transfer_split\" methods. export_raw - bool : (Optional) If true, return the raw transaction data. (Defaults to false) get_tx_keys - bool : (Optional) Return the transaction keys after sending. Outputs: signed_txset - string : Set of signed tx to be used for submitting transfer. tx_hash_list - string[] : The tx hashes of every transaction. tx_raw_list - string[] : The tx raw data of every transaction. tx_key_list - string[] : The tx key data of every transaction.","title":"COMMAND_RPC_SIGN_TRANSFER"},{"location":"Developer/WalletRPCBeta/#command_rpc_split_integrated_address","text":"Back to top Retrieve the standard address and payment id corresponding to an integrated address. Endpoints: split_integrated_address Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"split_integrated_address\", \"params\": { \"integrated_address\": \"TODO(loki): Write example string\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"standard_address\": \"TODO(loki): Write example string\", \"payment_id\": \"f378710e54eeeb8d\", \"is_subaddress\": true } } Inputs: integrated_address - string Outputs: standard_address - string payment_id - string is_subaddress - bool","title":"COMMAND_RPC_SPLIT_INTEGRATED_ADDRESS"},{"location":"Developer/WalletRPCBeta/#command_rpc_stake","text":"Back to top Stake for Service Node. Endpoints: stake Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"stake\", \"params\": { \"destination\": \"L8ssYFtxi1HTFQdbmG9Lt71tyudgageDgBqBLcgLnw5XBiJ1NQLFYNAAfYpYS3jHaSe8UsFYjSgKadKhC7edTSQB15s6T7g\", \"amount\": 26734261552878, \"subaddr_indices\": [0], \"service_node_key\": \"4a8c30cea9e729b06c91132295cce32d2a8e6e5bcf7b74a998e2ee1b3ed590b3\", \"priority\": 0, \"get_tx_key\": true, \"do_not_relay\": true, \"get_tx_hex\": true, \"get_tx_metadata\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"tx_hash\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"tx_key\": \"1982e99c69d8acc993cfc94ce59ff8f113d23482d9a25c892a3fc01c77dd8c4c\", \"amount\": 26734261552878, \"fee\": 123, \"tx_blob\": \"0402f78b05f78b05f78b0501ffd98b0502b888ddcf730229f056f5594cfcfd8d44f8033c9fda22450693d1694038e1cecaaaac25a8fc12af8992bc800102534df00c14ead3b3dedea9e7bdcf71c44803349b5e9aee2f73e22d5385ac147b7601008e5729d9329320444666d9d9d9dc602a3ae585de91ab2ca125665e3a363610021100000001839fdb0000000000000000000001200408d5ad7ab79d9b05c94033c2029f4902a98ec51f5175564f6978467dbb28723f929cf806d4ee1c781d7771183a93a1fd74f0827bddee9baac7e3083ab2b5840000\", \"tx_metadata\": \"TODO(loki): Write example string\", \"multisig_txset\": \"TODO(loki): Write example string\", \"unsigned_txset\": \"TODO(loki): Write example string\" } } Inputs: destination - string : Primary Public address that the rewards will go to. amount - uint64 : Amount of Loki to stake in atomic units. subaddr_indices - uint32[] : (Optional) Transfer from this set of subaddresses. (Defaults to 0) service_node_key - string : Service Node Public Address. priority - uint32 : Set a priority for the transaction. Accepted values are: or 0-4 for: default, unimportant, normal, elevated, priority. get_tx_key - bool : (Optional) Return the transaction key after sending. do_not_relay - bool : (Optional) If true, the newly created transaction will not be relayed to the loki network. (Defaults to false) get_tx_hex - bool : Return the transaction as hex string after sending (Defaults to false) get_tx_metadata - bool : Return the metadata needed to relay the transaction. (Defaults to false) Outputs: tx_hash - string : Publically searchable transaction hash. tx_key - string : Transaction key if get_tx_key is true , otherwise, blank string. amount - uint64 : Amount transferred for the transaction in atomic units. fee - uint64 : Value in atomic units of the fee charged for the tx. tx_blob - string : Raw transaction represented as hex string, if get_tx_hex is true. tx_metadata - string : Set of transaction metadata needed to relay this transfer later, if get_tx_metadata is true . multisig_txset - string : Set of multisig transactions in the process of being signed (empty for non-multisig). unsigned_txset - string : Set of unsigned tx for cold-signing purposes.","title":"COMMAND_RPC_STAKE"},{"location":"Developer/WalletRPCBeta/#command_rpc_start_mining","text":"Back to top Start mining in the loki daemon. Endpoints: start_mining Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"start_mining\", \"params\": { \"threads_count\": 123 } } EOF Inputs: threads_count - uint64 : Number of threads created for mining.","title":"COMMAND_RPC_START_MINING"},{"location":"Developer/WalletRPCBeta/#command_rpc_stop_mining","text":"Back to top Stop mining in the loki daemon. Endpoints: stop_mining Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"stop_mining\" } EOF","title":"COMMAND_RPC_STOP_MINING"},{"location":"Developer/WalletRPCBeta/#command_rpc_stop_wallet","text":"Back to top Stops the wallet, storing the current state. Endpoints: stop_wallet Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"stop_wallet\" } EOF","title":"COMMAND_RPC_STOP_WALLET"},{"location":"Developer/WalletRPCBeta/#command_rpc_store","text":"Back to top Save the wallet file. Endpoints: store Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"store\" } EOF","title":"COMMAND_RPC_STORE"},{"location":"Developer/WalletRPCBeta/#command_rpc_submit_multisig","text":"Back to top Submit a signed multisig transaction. Endpoints: submit_multisig Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"submit_multisig\", \"params\": { \"tx_data_hex\": \"TODO(loki): Write example string\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"tx_hash_list\": [\"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\"] } Inputs: tx_data_hex - string : Multisig transaction in hex format, as returned by sign_multisig under tx_data_hex. Outputs: tx_hash_list - string[] : List of transaction hash.","title":"COMMAND_RPC_SUBMIT_MULTISIG"},{"location":"Developer/WalletRPCBeta/#command_rpc_submit_transfer","text":"Back to top Submit a previously signed transaction on a read-only wallet (in cold-signing process). Endpoints: submit_transfer Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"submit_transfer\", \"params\": { \"tx_data_hex\": \"TODO(loki): Write example string\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"tx_hash_list\": [\"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\"] } Inputs: tx_data_hex - string : Set of signed tx returned by \"sign_transfer\". Outputs: tx_hash_list - string[] : The tx hashes of every transaction.","title":"COMMAND_RPC_SUBMIT_TRANSFER"},{"location":"Developer/WalletRPCBeta/#command_rpc_sweep_all","text":"Back to top Send all unlocked balance to an address. Endpoints: sweep_all Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"sweep_all\", \"params\": { \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"account_index\": 0, \"subaddr_indices\": [0], \"priority\": 0, \"blink\": true, \"outputs\": 10, \"unlock_time\": 123, \"payment_id\": \"f378710e54eeeb8d\", \"get_tx_keys\": true, \"below_amount\": 123, \"do_not_relay\": true, \"get_tx_hex\": true, \"get_tx_metadata\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"tx_hash_list\": [\"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\"], \"tx_key_list\": [\"1982e99c69d8acc993cfc94ce59ff8f113d23482d9a25c892a3fc01c77dd8c4c\"], \"amount_list\": [123], \"fee_list\": [123], \"tx_blob_list\": [\"0402f78b05f78b05f78b0501ffd98b0502b888ddcf730229f056f5594cfcfd8d44f8033c9fda22450693d1694038e1cecaaaac25a8fc12af8992bc800102534df00c14ead3b3dedea9e7bdcf71c44803349b5e9aee2f73e22d5385ac147b7601008e5729d9329320444666d9d9d9dc602a3ae585de91ab2ca125665e3a363610021100000001839fdb0000000000000000000001200408d5ad7ab79d9b05c94033c2029f4902a98ec51f5175564f6978467dbb28723f929cf806d4ee1c781d7771183a93a1fd74f0827bddee9baac7e3083ab2b5840000\"], \"tx_metadata_list\": [\"TODO(loki): Write example string\"], \"multisig_txset\": \"TODO(loki): Write example string\", \"unsigned_txset\": \"TODO(loki): Write example string\" } } Inputs: address - string : Destination public address. account_index - uint32 : Sweep transactions from this account. subaddr_indices - uint32[] : (Optional) Sweep from this set of subaddresses in the account. priority - uint32 : Set a priority for the transaction. Accepted values are: 1 for unimportant or 5 for blink. (0 and 2-4 are accepted for backwards compatibility and are equivalent to 5) blink - bool : (Deprecated) Set priority to 5 for blink, field is deprecated: specifies that the tx should be blinked ( priority will be ignored). outputs - uint64 unlock_time - uint64 : Number of blocks before the loki can be spent (0 to not add a lock). payment_id - string : (Optional) 64-character hex string to identify a transaction. get_tx_keys - bool : (Optional) Return the transaction keys after sending. below_amount - uint64 : (Optional) Include outputs below this amount. do_not_relay - bool : (Optional) If true, do not relay this sweep transfer. (Defaults to false) get_tx_hex - bool : (Optional) return the transactions as hex encoded string. (Defaults to false) get_tx_metadata - bool : (Optional) return the transaction metadata as a string. (Defaults to false) Outputs: tx_hash_list - string[] : The tx hashes of every transaction. tx_key_list - string[] : The transaction keys for every transaction. amount_list - uint64[] : The amount transferred for every transaction. fee_list - uint64[] : The amount of fees paid for every transaction. tx_blob_list - string[] : The tx as hex string for every transaction. tx_metadata_list - string[] : List of transaction metadata needed to relay the transactions later. multisig_txset - string : The set of signing keys used in a multisig transaction (empty for non-multisig). unsigned_txset - string : Set of unsigned tx for cold-signing purposes.","title":"COMMAND_RPC_SWEEP_ALL"},{"location":"Developer/WalletRPCBeta/#command_rpc_sweep_dust","text":"Back to top Send all dust outputs back to the wallet's, to make them easier to spend (and mix). Endpoints: sweep_dust Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"sweep_dust\", \"params\": { \"get_tx_keys\": true, \"do_not_relay\": true, \"get_tx_hex\": true, \"get_tx_metadata\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"tx_hash_list\": [\"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\"], \"tx_key_list\": [\"1982e99c69d8acc993cfc94ce59ff8f113d23482d9a25c892a3fc01c77dd8c4c\"], \"amount_list\": [123], \"fee_list\": [123], \"tx_blob_list\": [\"0402f78b05f78b05f78b0501ffd98b0502b888ddcf730229f056f5594cfcfd8d44f8033c9fda22450693d1694038e1cecaaaac25a8fc12af8992bc800102534df00c14ead3b3dedea9e7bdcf71c44803349b5e9aee2f73e22d5385ac147b7601008e5729d9329320444666d9d9d9dc602a3ae585de91ab2ca125665e3a363610021100000001839fdb0000000000000000000001200408d5ad7ab79d9b05c94033c2029f4902a98ec51f5175564f6978467dbb28723f929cf806d4ee1c781d7771183a93a1fd74f0827bddee9baac7e3083ab2b5840000\"], \"tx_metadata_list\": [\"TODO(loki): Write example string\"], \"multisig_txset\": \"TODO(loki): Write example string\", \"unsigned_txset\": \"TODO(loki): Write example string\" } } Inputs: get_tx_keys - bool : (Optional) Return the transaction keys after sending. do_not_relay - bool : (Optional) If true, the newly created transaction will not be relayed to the loki network. (Defaults to false) get_tx_hex - bool : (Optional) Return the transactions as hex string after sending. (Defaults to false) get_tx_metadata - bool : (Optional) Return list of transaction metadata needed to relay the transfer later. (Defaults to false) Outputs: tx_hash_list - string[] : The tx hashes of every transaction. tx_key_list - string[] : The transaction keys for every transaction. amount_list - uint64[] : The amount transferred for every transaction. fee_list - uint64[] : The amount of fees paid for every transaction. tx_blob_list - string[] : The tx as hex string for every transaction. tx_metadata_list - string[] : List of transaction metadata needed to relay the transactions later. multisig_txset - string : The set of signing keys used in a multisig transaction (empty for non-multisig). unsigned_txset - string : Set of unsigned tx for cold-signing purposes.","title":"COMMAND_RPC_SWEEP_DUST"},{"location":"Developer/WalletRPCBeta/#command_rpc_sweep_single","text":"Back to top Send all of a specific unlocked output to an address. Endpoints: sweep_single Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"sweep_single\", \"params\": { \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"priority\": 0, \"blink\": true, \"outputs\": 10, \"unlock_time\": 123, \"payment_id\": \"f378710e54eeeb8d\", \"get_tx_key\": true, \"key_image\": \"8d1bd8181bf7d857bdb281e0153d84cd55a3fcaa57c3e570f4a49f935850b5e3\", \"do_not_relay\": true, \"get_tx_hex\": true, \"get_tx_metadata\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"tx_hash\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"tx_key\": \"1982e99c69d8acc993cfc94ce59ff8f113d23482d9a25c892a3fc01c77dd8c4c\", \"amount\": 26734261552878, \"fee\": 123, \"tx_blob\": \"0402f78b05f78b05f78b0501ffd98b0502b888ddcf730229f056f5594cfcfd8d44f8033c9fda22450693d1694038e1cecaaaac25a8fc12af8992bc800102534df00c14ead3b3dedea9e7bdcf71c44803349b5e9aee2f73e22d5385ac147b7601008e5729d9329320444666d9d9d9dc602a3ae585de91ab2ca125665e3a363610021100000001839fdb0000000000000000000001200408d5ad7ab79d9b05c94033c2029f4902a98ec51f5175564f6978467dbb28723f929cf806d4ee1c781d7771183a93a1fd74f0827bddee9baac7e3083ab2b5840000\", \"tx_metadata\": \"TODO(loki): Write example string\", \"multisig_txset\": \"TODO(loki): Write example string\", \"unsigned_txset\": \"TODO(loki): Write example string\" } } Inputs: address - string : Destination public address. priority - uint32 : Set a priority for the transaction. Accepted values are: 1 for unimportant or 5 for blink. (0 and 2-4 are accepted for backwards compatibility and are equivalent to 5) blink - bool : (Deprecated) Set priority to 5 for blink, field is deprecated: specifies that the tx should be blinked ( priority will be ignored). outputs - uint64 unlock_time - uint64 : Number of blocks before the loki can be spent (0 to not add a lock). payment_id - string : (Optional) 64-character hex string to identify a transaction. get_tx_key - bool : (Optional) Return the transaction keys after sending. key_image - string : Key image of specific output to sweep. do_not_relay - bool : (Optional) If true, do not relay this sweep transfer. (Defaults to false) get_tx_hex - bool : (Optional) return the transactions as hex encoded string. (Defaults to false) get_tx_metadata - bool : (Optional) return the transaction metadata as a string. (Defaults to false) Outputs: tx_hash - string : The tx hashes of the transaction. tx_key - string : The tx key of the transaction. amount - uint64 : The amount transfered in atomic units. fee - uint64 : The fee paid in atomic units. tx_blob - string : The tx as hex string. tx_metadata - string : Transaction metadata needed to relay the transaction later. multisig_txset - string : The set of signing keys used in a multisig transaction (empty for non-multisig). unsigned_txset - string : Set of unsigned tx for cold-signing purposes.","title":"COMMAND_RPC_SWEEP_SINGLE"},{"location":"Developer/WalletRPCBeta/#command_rpc_tag_accounts","text":"Back to top Apply a filtering tag to a list of accounts. Endpoints: tag_accounts Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"tag_accounts\", \"params\": { \"tag\": \"My tag\", \"accounts\": [2130706433] } } EOF Inputs: tag - string : Tag for the accounts. accounts - uint32[] : Tag this list of accounts.","title":"COMMAND_RPC_TAG_ACCOUNTS"},{"location":"Developer/WalletRPCBeta/#command_rpc_transfer","text":"Back to top Send loki to a number of recipients. To preview the transaction fee, set do_not_relay to true and get_tx_metadata to true. Submit the response using the data in get_tx_metadata in the RPC call, relay_tx. Endpoints: transfer Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"transfer\", \"params\": { \"destinations\": [{ \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"amount\": 26734261552878 }], \"account_index\": 0, \"subaddr_indices\": [0], \"priority\": 0, \"blink\": true, \"unlock_time\": 123, \"payment_id\": \"f378710e54eeeb8d\", \"get_tx_key\": true, \"do_not_relay\": true, \"get_tx_hex\": true, \"get_tx_metadata\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"tx_hash\": \"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\", \"tx_key\": \"1982e99c69d8acc993cfc94ce59ff8f113d23482d9a25c892a3fc01c77dd8c4c\", \"amount\": 26734261552878, \"fee\": 123, \"tx_blob\": \"0402f78b05f78b05f78b0501ffd98b0502b888ddcf730229f056f5594cfcfd8d44f8033c9fda22450693d1694038e1cecaaaac25a8fc12af8992bc800102534df00c14ead3b3dedea9e7bdcf71c44803349b5e9aee2f73e22d5385ac147b7601008e5729d9329320444666d9d9d9dc602a3ae585de91ab2ca125665e3a363610021100000001839fdb0000000000000000000001200408d5ad7ab79d9b05c94033c2029f4902a98ec51f5175564f6978467dbb28723f929cf806d4ee1c781d7771183a93a1fd74f0827bddee9baac7e3083ab2b5840000\", \"tx_metadata\": \"TODO(loki): Write example string\", \"multisig_txset\": \"TODO(loki): Write example string\", \"unsigned_txset\": \"TODO(loki): Write example string\" } } Inputs: destinations - transfer_destination[] : Array of destinations to receive LOKI. address - string : Destination public address. amount - uint64 : Amount to send to each destination, in atomic units. account_index - uint32 : (Optional) Transfer from this account index. (Defaults to 0) subaddr_indices - uint32[] : (Optional) Transfer from this set of subaddresses. (Defaults to 0) priority - uint32 : Set a priority for the transaction. Accepted values are: 1 for unimportant or 5 for blink. (0 and 2-4 are accepted for backwards compatibility and are equivalent to 5) blink - bool : (Deprecated) Set priority to 5 for blink, field is deprecated: specifies that the tx should be blinked ( priority will be ignored). unlock_time - uint64 : Number of blocks before the loki can be spent (0 to use the default lock time). payment_id - string : (Optional) Random 64-character hex string to identify a transaction. get_tx_key - bool : (Optional) Return the transaction key after sending. do_not_relay - bool : (Optional) If true, the newly created transaction will not be relayed to the loki network. (Defaults to false) get_tx_hex - bool : Return the transaction as hex string after sending. (Defaults to false) get_tx_metadata - bool : Return the metadata needed to relay the transaction. (Defaults to false) Outputs: tx_hash - string : Publically searchable transaction hash. tx_key - string : Transaction key if get_tx_key is true, otherwise, blank string. amount - uint64 : Amount transferred for the transaction. fee - uint64 : Fee charged for the txn. tx_blob - string : Raw transaction represented as hex string, if get_tx_hex is true. tx_metadata - string : Set of transaction metadata needed to relay this transfer later, if get_tx_metadata is true. multisig_txset - string : Set of multisig transactions in the process of being signed (empty for non-multisig). unsigned_txset - string : Set of unsigned tx for cold-signing purposes.","title":"COMMAND_RPC_TRANSFER"},{"location":"Developer/WalletRPCBeta/#command_rpc_transfer_split","text":"Back to top Same as transfer, but can split into more than one tx if necessary. Endpoints: transfer_split Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"transfer_split\", \"params\": { \"destinations\": [{ \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"amount\": 26734261552878 }], \"account_index\": 0, \"subaddr_indices\": [0], \"priority\": 0, \"blink\": true, \"unlock_time\": 123, \"payment_id\": \"f378710e54eeeb8d\", \"get_tx_keys\": true, \"do_not_relay\": true, \"get_tx_hex\": true, \"get_tx_metadata\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"tx_hash_list\": [\"b605cab7e3b9fe1f6d322e3167cd26e1e61c764afa9d733233ef716787786123\"], \"tx_key_list\": [\"1982e99c69d8acc993cfc94ce59ff8f113d23482d9a25c892a3fc01c77dd8c4c\"], \"amount_list\": [123], \"fee_list\": [123], \"tx_blob_list\": [\"0402f78b05f78b05f78b0501ffd98b0502b888ddcf730229f056f5594cfcfd8d44f8033c9fda22450693d1694038e1cecaaaac25a8fc12af8992bc800102534df00c14ead3b3dedea9e7bdcf71c44803349b5e9aee2f73e22d5385ac147b7601008e5729d9329320444666d9d9d9dc602a3ae585de91ab2ca125665e3a363610021100000001839fdb0000000000000000000001200408d5ad7ab79d9b05c94033c2029f4902a98ec51f5175564f6978467dbb28723f929cf806d4ee1c781d7771183a93a1fd74f0827bddee9baac7e3083ab2b5840000\"], \"tx_metadata_list\": [\"TODO(loki): Write example string\"], \"multisig_txset\": \"TODO(loki): Write example string\", \"unsigned_txset\": \"TODO(loki): Write example string\" } } Inputs: destinations - transfer_destination[] : Array of destinations to receive LOKI: address - string : Destination public address. amount - uint64 : Amount to send to each destination, in atomic units. account_index - uint32 : (Optional) Transfer from this account index. (Defaults to 0) subaddr_indices - uint32[] : (Optional) Transfer from this set of subaddresses. (Defaults to 0) priority - uint32 : Set a priority for the transaction. Accepted values are: 1 for unimportant or 5 for blink. (0 and 2-4 are accepted for backwards compatibility and are equivalent to 5) blink - bool : (Deprecated) Set priority to 5 for blink, field is deprecated: specifies that the tx should be blinked ( priority will be ignored). unlock_time - uint64 : Number of blocks before the loki can be spent (0 to not add a lock). payment_id - string : (Optional) Random 32-byte/64-character hex string to identify a transaction. get_tx_keys - bool : (Optional) Return the transaction keys after sending. do_not_relay - bool : (Optional) If true, the newly created transaction will not be relayed to the loki network. (Defaults to false) get_tx_hex - bool : Return the transactions as hex string after sending. get_tx_metadata - bool : Return list of transaction metadata needed to relay the transfer later. Outputs: tx_hash_list - string[] : The tx hashes of every transaction. tx_key_list - string[] : The transaction keys for every transaction. amount_list - uint64[] : The amount transferred for every transaction. fee_list - uint64[] : The amount of fees paid for every transaction. tx_blob_list - string[] : The tx as hex string for every transaction. tx_metadata_list - string[] : List of transaction metadata needed to relay the transactions later. multisig_txset - string : The set of signing keys used in a multisig transaction (empty for non-multisig). unsigned_txset - string : Set of unsigned tx for cold-signing purposes.","title":"COMMAND_RPC_TRANSFER_SPLIT"},{"location":"Developer/WalletRPCBeta/#command_rpc_untag_accounts","text":"Back to top Remove filtering tag from a list of accounts. Endpoints: untag_accounts Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"untag_accounts\", \"params\": { \"accounts\": [2130706433] } } EOF Inputs: accounts - uint32[] : Remove tag from this list of accounts.","title":"COMMAND_RPC_UNTAG_ACCOUNTS"},{"location":"Developer/WalletRPCBeta/#command_rpc_validate_address","text":"Back to top Parse an address to validate if it's a valid Loki address. Endpoints: validate_address Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"validate_address\", \"params\": { \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"any_net_type\": true, \"allow_openalias\": true } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"result\": { \"valid\": true, \"integrated\": true, \"subaddress\": true, \"nettype\": \"MAINNET\", \"openalias_address\": \"TODO(loki): Write example string\" } } Inputs: address - string : Address to check. any_net_type - bool allow_openalias - bool Outputs: valid - bool : States if it is a valid Loki address. integrated - bool : States if it is an integrated address. subaddress - bool : States if it is a subaddress. nettype - string : States if the nettype is mainet, testnet, stagenet. openalias_address - string","title":"COMMAND_RPC_VALIDATE_ADDRESS"},{"location":"Developer/WalletRPCBeta/#command_rpc_verify","text":"Back to top Verify a signature on a string. Endpoints: verify Example Request curl -X POST http://127.0.0.1:22023/json_rpc \\ -H 'Content-Type: application/json' \\ -d @- << EOF { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"method\": \"verify\", \"params\": { \"data\": \"TODO(loki): Write example string\", \"address\": \"L8KJf3nRQ53NTX1YLjtHryjegFRa3ZCEGLKmRxUfvkBWK19UteEacVpYqpYscSJ2q8WRuHPFdk7Q5W8pQB7Py5kvUs8vKSk\", \"signature\": \"bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70bf430a3279f576ed8a814be25193e5a1ec61d3ee5729e64f47d8480ce5a2da70\" } } EOF Example Response { \"jsonrpc\": \"2.0\", \"id\": \"0\", \"good\": true } Inputs: data - string : What should have been signed. address - string : Public address of the wallet used to sign the data. signature - string : Signature generated by sign method. Outputs: good - bool","title":"COMMAND_RPC_VERIFY"},{"location":"Developer/WalletRPCGuide/","text":"loki-wallet-rpc \u00b6 Introduction \u00b6 This is a list of the loki-wallet-rpc calls, their inputs and outputs, and examples of each. The program loki-wallet-rpc replaced the rpc interface that was in simplewallet and then loki-wallet-cli. All loki-wallet-rpc methods use the same JSON RPC interface. For example: IP=127.0.0.1 PORT=18082 METHOD=\"make_integrated_address\" PARAMS=\"{\\\"payment_id\\\":\\\"1234567890123456789012345678900012345678901234567890123456789000\\\"}\" curl \\ -X POST http://$IP:$PORT/json_rpc \\ -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"'$METHOD'\",\"params\":'\"$PARAMS\"'}' \\ -H 'Content-Type: application/json' If the loki-wallet-rpc was executed with the --rpc-login argument as username:password , then follow this example: IP=127.0.0.1 PORT=18082 METHOD=\"make_integrated_address\" PARAMS=\"{\\\"payment_id\\\":\\\"1234567890123456789012345678900012345678901234567890123456789000\\\"}\" curl \\ -u username:password --digest \\ -X POST http://$IP:$PORT/json_rpc \\ -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"'$METHOD'\",\"params\":'\"$PARAMS\"'}' \\ -H 'Content-Type: application/json' Note: \"atomic units\" refer to the smallest fraction of 1 LOKI according to the lokid implementation. 1 LOKI = 1e9 atomic units. Index of JSON RPC Methods: \u00b6 get_balance get_address get_address_index create_address label_address get_accounts create_account label_account get_account_tags tag_accounts untag_accounts set_account_tag_description get_height transfer transfer_split sign_transfer submit_transfer sweep_dust sweep_all sweep_single relay_tx store get_payments get_bulk_payments incoming_transfers query_key make_integrated_address split_integrated_address stop_wallet rescan_blockchain set_tx_notes get_tx_notes set_attribute get_attribute get_tx_key check_tx_key get_tx_proof check_tx_proof get_spend_proof check_spend_proof get_reserve_proof check_reserve_proof get_transfers get_transfer_by_txid sign verify export_outputs import_outputs export_key_images import_key_images make_uri parse_uri get_address_book add_address_book delete_address_book refresh rescan_spent start_mining stop_mining get_languages create_wallet open_wallet close_wallet change_wallet_password is_multisig prepare_multisig make_multisig export_multisig_info import_multisig_info finalize_multisig sign_multisig submit_multisig get_version JSON RPC Methods: \u00b6 get_balance \u00b6 Return the wallet's balance. Alias: getbalance . Inputs: account_index - unsigned int; Return balance for this account. address_indices - array of unsigned int; (Optional) Return balance detail for those subaddresses. Outputs: balance - unsigned int; The total balance of the current loki-wallet-rpc in session. unlocked_balance - unsigned int; Unlocked funds are those funds that are sufficiently deep enough in the loki blockchain to be considered safe to spend. multisig_import_needed - boolean; True if importing multisig data is needed for returning a correct balance. per_subaddress - array of subaddress information; Balance information for each subaddress in an account. address_index - unsigned int; Index of the subaddress in the account. address - string; Address at this index. Base58 representation of the public keys. balance - unsigned int; Balance for the subaddress (locked or unlocked). unlocked_balance - unsigned int; Unlocked balance for the subaddress. label - string; Label for the subaddress. num_unspent_outputs - unsigned int; Number of unspent outputs available for the subaddress. Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_balance\",\"params\":{\"account_index\":0,\"address_indices\":[0,1]}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"balance\": 157443303037455077, \"multisig_import_needed\": false, \"per_subaddress\": [{ \"address\": \"55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt\", \"address_index\": 0, \"balance\": 157360317826255077, \"label\": \"Primary account\", \"num_unspent_outputs\": 5281, \"unlocked_balance\": 157360317826255077 },{ \"address\": \"7BnERTpvL5MbCLtj5n9No7J5oE5hHiB3tVCK5cjSvCsYWD2WRJLFuWeKTLiXo5QJqt2ZwUaLy2Vh1Ad51K7FNgqcHgjW85o\", \"address_index\": 1, \"balance\": 59985211200000, \"label\": \"\", \"num_unspent_outputs\": 1, \"unlocked_balance\": 59985211200000 }], \"unlocked_balance\": 157443303037455077 } } get_address \u00b6 Return the wallet's addresses for an account. Optionally filter for specific set of subaddresses. Alias: getaddress . Inputs: account_index - unsigned int; Return subaddresses for this account. address_index - array of unsigned int; (Optional) List of subaddresses to return from an account. Outputs: address - string; The 95-character hex address string of the loki-wallet-rpc in session. addresses array of addresses informations address string; The 95-character hex (sub)address string. label string; Label of the (sub)address address_index unsigned int; index of the subaddress used boolean; states if the (sub)address has already received funds Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_address\",\"params\":{\"account_index\":0,\"address_index\":[0,1,4]}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"address\": \"55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt\", \"addresses\": [{ \"address\": \"55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt\", \"address_index\": 0, \"label\": \"Primary account\", \"used\": true },{ \"address\": \"7BnERTpvL5MbCLtj5n9No7J5oE5hHiB3tVCK5cjSvCsYWD2WRJLFuWeKTLiXo5QJqt2ZwUaLy2Vh1Ad51K7FNgqcHgjW85o\", \"address_index\": 1, \"label\": \"\", \"used\": true },{ \"address\": \"77xa6Dha7kzCQuvmd8iB5VYoMkdenwCNRU9khGhExXQ8KLL3z1N1ZATBD1sFPenyHWT9cm4fVFnCAUApY53peuoZFtwZiw5\", \"address_index\": 4, \"label\": \"test2\", \"used\": true }] } } get_address_index \u00b6 Get account and address indexes from a specific (sub)address Alias: None . Inputs: address - String; (sub)address to look for. Outputs: index - subaddress informations major unsigned int; Account index. minor unsigned int; Address index. Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_address_index\",\"params\":{\"address\":\"7BnERTpvL5MbCLtj5n9No7J5oE5hHiB3tVCK5cjSvCsYWD2WRJLFuWeKTLiXo5QJqt2ZwUaLy2Vh1Ad51K7FNgqcHgjW85o\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"index\": { \"major\": 0, \"minor\": 1 } } } create_address \u00b6 Create a new address for an account. Optionally, label the new address. Alias: None . Inputs: account_index - unsigned int; Create a new address for this account. label - string; (Optional) Label for the new address. Outputs: address - string; Newly created address. Base58 representation of the public keys. address_index - unsigned int; Index of the new address under the input account. Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"create_address\",\"params\":{\"account_index\":0,\"label\":\"new-sub\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"address\": \"7BG5jr9QS5sGMdpbBrZEwVLZjSKJGJBsXdZLt8wiXyhhLjy7x2LZxsrAnHTgD8oG46ZtLjUGic2pWc96GFkGNPQQDA3Dt7Q\", \"address_index\": 5 } } label_address \u00b6 Label an address. Alias: None . Inputs: index - subaddress index; JSON Object containing the major & minor address index: major - unsigned int; Account index for the subaddress. minor - unsigned int; Index of the subaddress in the account. label - string; Label for the address. Outputs: None . Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"label_address\",\"params\":{\"index\":{\"major\":0,\"minor\":5},\"label\":\"myLabel\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { } } get_accounts \u00b6 Get all accounts for a wallet. Optionally filter accounts by tag. Alias: None . Inputs: tag - string; (Optional) Tag for filtering accounts. Outputs: subaddress_accounts - array of subaddress account information: account_index - unsigned int; Index of the account. balance - unsigned int; Balance of the account (locked or unlocked). base_address - string; Base64 representation of the first subaddress in the account. label - string; (Optional) Label of the account. tag - string; (Optional) Tag for filtering accounts. unlocked_balance - unsigned int; Unlocked balance for the account. total_balance - unsigned int; Total balance of the selected accounts (locked or unlocked). total_unlocked_balance - unsigned int; Total unlocked balance of the selected accounts. Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_accounts\",\"params\":{\"tag\":\"myTag\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"subaddress_accounts\": [{ \"account_index\": 0, \"balance\": 157663195572433688, \"base_address\": \"55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt\", \"label\": \"Primary account\", \"tag\": \"myTag\", \"unlocked_balance\": 157443303037455077 },{ \"account_index\": 1, \"balance\": 0, \"base_address\": \"77Vx9cs1VPicFndSVgYUvTdLCJEZw9h81hXLMYsjBCXSJfUehLa9TDW3Ffh45SQa7xb6dUs18mpNxfUhQGqfwXPSMrvKhVp\", \"label\": \"Secondary account\", \"tag\": \"myTag\", \"unlocked_balance\": 0 }], \"total_balance\": 157663195572433688, \"total_unlocked_balance\": 157443303037455077 } } create_account \u00b6 Create a new account with an optional label. Alias: None . Inputs: label - string; (Optional) Label for the account. Outputs: account_index - unsigned int; Index of the new account. address - string; Address for this account. Base58 representation of the public keys. Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"create_account\",\"params\":{\"label\":\"Secondary account\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"account_index\": 1, \"address\": \"77Vx9cs1VPicFndSVgYUvTdLCJEZw9h81hXLMYsjBCXSJfUehLa9TDW3Ffh45SQa7xb6dUs18mpNxfUhQGqfwXPSMrvKhVp\" } } label_account \u00b6 Label an account. Alias: None . Inputs: account_index - unsigned int; Apply label to account at this index. label - string; Label for the account. Outputs: None . Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"label_account\",\"params\":{\"account_index\":0,\"label\":\"Primary account\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"account_tags\": [{ \"accounts\": [0,1], \"label\": \"\", \"tag\": \"myTag\" }] } } get_account_tags \u00b6 Get a list of user-defined account tags. Alias: None . Inputs: None . Outputs: account_tags - array of account tag information: tag - string; Filter tag. label - string; Label for the tag. accounts - array of int; List of tagged account indices. Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_account_tags\",\"params\":\"\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"account_tags\": [{ \"accounts\": [0], \"label\": \"Test tag\", \"tag\": \"myTag\" }] } } tag_accounts \u00b6 Apply a filtering tag to a list of accounts. Alias: None . Inputs: tag - string; Tag for the accounts. accounts - array of unsigned int; Tag this list of accounts. Outputs: None . Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"tag_accounts\",\"params\":{\"tag\":\"myTag\",\"accounts\":[0,1]}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { } } untag_accounts \u00b6 Remove filtering tag from a list of accounts. Alias: None . Inputs: accounts - array of unsigned int; Remove tag from this list of accounts. Outputs: None . Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"untag_accounts\",\"params\":{\"accounts\":[1]}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { } } set_account_tag_description \u00b6 Set description for an account tag. Alias: None . Inputs: tag - string; Set a description for this tag. description - string; Description for the tag. Outputs: None . Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"set_account_tag_description\",\"params\":{\"tag\":\"myTag\",\"description\":\"Test tag\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { } } get_height \u00b6 Returns the wallet's current block height. Alias: getheight . Inputs: None . Outputs: height - unsigned int; The current loki-wallet-rpc's blockchain height. If the wallet has been offline for a long time, it may need to catch up with the daemon. Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_height\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"height\": 145545 } } transfer \u00b6 Send loki to a number of recipients. Alias: None . Inputs: destinations - array of destinations to receive LOKI: amount - unsigned int; Amount to send to each destination, in atomic units. address - string; Destination public address. account_index - unsigned int; (Optional) Transfer from this account index. (Defaults to 0) subaddr_indices - array of unsigned int; (Optional) Transfer from this set of subaddresses. (Defaults to 0) priority - unsigned int; Set a priority for the transaction. Accepted Values are: 0-3 for: default, unimportant, normal, elevated, priority. mixin - unsigned int; Number of outputs from the blockchain to mix with (0 means no mixing). ring_size - unsigned int; Number of outputs to mix in the transaction (this output + N decoys from the blockchain). unlock_time - unsigned int; Number of blocks before the loki can be spent (0 to not add a lock). payment_id - string; (Optional) Random 32-byte/64-character hex string to identify a transaction. get_tx_key - boolean; (Optional) Return the transaction key after sending. do_not_relay - boolean; (Optional) If true, the newly created transaction will not be relayed to the loki network. (Defaults to false) get_tx_hex - boolean; Return the transaction as hex string after sending (Defaults to false) get_tx_metadata - boolean; Return the metadata needed to relay the transaction. (Defaults to false) Outputs: amount - Amount transferred for the transaction. fee - Integer value of the fee charged for the txn. multisig_txset - Set of multisig transactions in the process of being signed (empty for non-multisig). tx_blob - Raw transaction represented as hex string, if get_tx_hex is true. tx_hash - String for the publically searchable transaction hash. tx_key - String for the transaction key if get_tx_key is true, otherwise, blank string. tx_metadata - Set of transaction metadata needed to relay this transfer later, if get_tx_metadata is true. unsigned_txset - String. Set of unsigned tx for cold-signing purposes. Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"transfer\",\"params\":{\"destinations\":[{\"amount\":100000000000,\"address\":\"7BnERTpvL5MbCLtj5n9No7J5oE5hHiB3tVCK5cjSvCsYWD2WRJLFuWeKTLiXo5QJqt2ZwUaLy2Vh1Ad51K7FNgqcHgjW85o\"},{\"amount\":200000000000,\"address\":\"75sNpRwUtekcJGejMuLSGA71QFuK1qcCVLZnYRTfQLgFU5nJ7xiAHtR5ihioS53KMe8pBhH61moraZHyLoG4G7fMER8xkNv\"}],\"account_index\":0,\"subaddr_indices\":[0],\"priority\":0,\"ring_size\":7,\"get_tx_key\": true}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"amount\": 300000000000, \"fee\": 86897600000, \"multisig_txset\": \"\", \"tx_blob\": \"\", \"tx_hash\": \"7663438de4f72b25a0e395b770ea9ecf7108cd2f0c4b75be0b14a103d3362be9\", \"tx_key\": \"25c9d8ec20045c80c93d665c9d3684aab7335f8b2cd02e1ba2638485afd1c70e236c4bdd7a2f1cb511dbf466f13421bdf8df988b7b969c448ca6239d7251490e4bf1bbf9f6ffacffdcdc93b9d1648ec499eada4d6b4e02ce92d4a1c0452e5d009fbbbf15b549df8856205a4c7bda6338d82c823f911acd00cb75850b198c5803\", \"tx_metadata\": \"\", \"unsigned_txset\": \"\" } } transfer_split \u00b6 Same as transfer, but can split into more than one tx if necessary. Alias: None . Inputs: destinations - array of destinations to receive LOKI: amount - unsigned int; Amount to send to each destination, in atomic units. address - string; Destination public address. account_index - unsigned int; (Optional) Transfer from this account index. (Defaults to 0) subaddr_indices - array of unsigned int; (Optional) Transfer from this set of subaddresses. (Defaults to 0) mixin - unsigned int; Number of outputs from the blockchain to mix with (0 means no mixing). ring_size - unsigned int; Sets ringsize to n (mixin + 1). unlock_time - unsigned int; Number of blocks before the loki can be spent (0 to not add a lock). payment_id - string; (Optional) Random 32-byte/64-character hex string to identify a transaction. get_tx_keys - boolean; (Optional) Return the transaction keys after sending. priority - unsigned int; Set a priority for the transactions. Accepted Values are: 0-3 for: default, unimportant, normal, elevated, priority. do_not_relay - boolean; (Optional) If true, the newly created transaction will not be relayed to the loki network. (Defaults to false) get_tx_hex - boolean; Return the transactions as hex string after sending new_algorithm - boolean; True to use the new transaction construction algorithm, defaults to false. get_tx_metadata - boolean; Return list of transaction metadata needed to relay the transfer later. Outputs: tx_hash_list - array of: string. The tx hashes of every transaction. tx_key_list - array of: string. The transaction keys for every transaction. amount_list - array of: integer. The amount transferred for every transaction. fee_list - array of: integer. The amount of fees paid for every transaction. tx_blob_list - array of: string. The tx as hex string for every transaction. tx_metadata_list - array of: string. List of transaction metadata needed to relay the transactions later. multisig_txset - string. The set of signing keys used in a multisig transaction (empty for non-multisig). unsigned_txset - string. Set of unsigned tx for cold-signing purposes. Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"transfer_split\",\"params\":{\"destinations\":[{\"amount\":1000000000000,\"address\":\"7BnERTpvL5MbCLtj5n9No7J5oE5hHiB3tVCK5cjSvCsYWD2WRJLFuWeKTLiXo5QJqt2ZwUaLy2Vh1Ad51K7FNgqcHgjW85o\"},{\"amount\":2000000000000,\"address\":\"75sNpRwUtekcJGejMuLSGA71QFuK1qcCVLZnYRTfQLgFU5nJ7xiAHtR5ihioS53KMe8pBhH61moraZHyLoG4G7fMER8xkNv\"}],\"account_index\":0,\"subaddr_indices\":[0],\"priority\":0,\"ring_size\":7,\"get_tx_key\": true}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"amount_list\": [3000000000000], \"fee_list\": [85106400000], \"multisig_txset\": \"\", \"tx_hash_list\": [\"c8d815f48f27d53fdaf198a74b292a91bfaf87529a9a9a9ee66079a890b3b58b\"], \"unsigned_txset\": \"\" } } sign_transfer \u00b6 Sign a transaction created on a read-only wallet (in cold-signing process) Alias: None . Inputs: unsigned_txset - string. Set of unsigned tx returned by \"transfer\" or \"transfer_split\" methods. export_raw - boolean; (Optional) If true, return the raw transaction data. (Defaults to false) Outputs: signed_txset - string. Set of signed tx to be used for submitting transfer. tx_hash_list - array of: string. The tx hashes of every transaction. tx_raw_list - array of: string. The tx raw data of every transaction. In the example below, we first generate an unsigned_txset on a read only wallet before signing it: Generate unsigned_txset using the above \"transfer\" method on read-only wallet: curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"transfer\",\"params\":{\"destinations\":[{\"amount\":1000000000000,\"address\":\"7BnERTpvL5MbCLtj5n9No7J5oE5hHiB3tVCK5cjSvCsYWD2WRJLFuWeKTLiXo5QJqt2ZwUaLy2Vh1Ad51K7FNgqcHgjW85o\"}],\"account_index\":0,\"subaddr_indices\":[0],\"priority\":0,\"ring_size\":7,\"do_not_relay\":true,\"get_tx_hex\":true}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"amount\": 1000000000000, \"fee\": 15202740000, \"multisig_txset\": \"\", \"tx_blob\": \"...long_hex...\", \"tx_hash\": \"c648ba0a049e5ce4ec21361dbf6e4b21eac0f828eea9090215de86c76b31d0a4\", \"tx_key\": \"\", \"tx_metadata\": \"\", \"unsigned_txset\": \"...long_hex...\" } } Sign tx using the previously generated unsigned_txset $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"sign_transfer\",\"params\":{\"unsigned_txset\":...long_hex...\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"signed_txset\": \"...long_hex...\", \"tx_hash_list\": [\"ff2e2d49fbfb1c9a55754f786576e171c8bf21b463a74438df604b7fa6cebc6d\"] } } submit_transfer \u00b6 Submit a previously signed transaction on a read-only wallet (in cold-signing process). Alias: None . Inputs: tx_data_hex - string; Set of signed tx returned by \"sign_transfer\" Outputs: tx_hash_list - array of: string. The tx hashes of every transaction. In the example below, we submit the transfer using the signed_txset generated above: curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"submit_transfer\",\"params\":{\"tx_data_hex\":...long_hex...\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"tx_hash_list\": [\"40fad7c828bb383ac02648732f7afce9adc520ba5629e1f5d9c03f584ac53d74\"] } } sweep_dust \u00b6 Send all dust outputs back to the wallet's, to make them easier to spend (and mix). Alias: sweep_unmixable . Inputs: get_tx_keys - boolean; (Optional) Return the transaction keys after sending. do_not_relay - boolean; (Optional) If true, the newly created transaction will not be relayed to the loki network. (Defaults to false) get_tx_hex - boolean; (Optional) Return the transactions as hex string after sending. (Defaults to false) get_tx_metadata - boolean; (Optional) Return list of transaction metadata needed to relay the transfer later. (Defaults to false) Outputs: tx_hash_list - array of: string. The tx hashes of every transaction. tx_key_list - array of: string. The transaction keys for every transaction. amount_list - array of: integer. The amount transferred for every transaction. fee_list - array of: integer. The amount of fees paid for every transaction. tx_blob_list - array of: string. The tx as hex string for every transaction. tx_metadata_list - array of: string. List of transaction metadata needed to relay the transactions later. multisig_txset - string. The set of signing keys used in a multisig transaction (empty for non-multisig). unsigned_txset - string. Set of unsigned tx for cold-signing purposes. Example (In this example, sweep_dust returns nothing because there are no funds to sweep): $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"sweep_dust\",\"params\":{\"get_tx_keys\":true}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"multisig_txset\": \"\", \"unsigned_txset\": \"\" } } sweep_all \u00b6 Send all unlocked balance to an address. Alias: None . Inputs: address - string; Destination public address. account_index - unsigned int; Sweep transactions from this account. subaddr_indices - array of unsigned int; (Optional) Sweep from this set of subaddresses in the account. priority - unsigned int; (Optional) Priority for sending the sweep transfer, partially determines fee. mixin - unsigned int; Number of outputs from the blockchain to mix with (0 means no mixing). ring_size - unsigned int; Sets ringsize to n (mixin + 1). unlock_time - unsigned int; Number of blocks before the loki can be spent (0 to not add a lock). payment_id - string; (Optional) Random 32-byte/64-character hex string to identify a transaction. get_tx_keys - boolean; (Optional) Return the transaction keys after sending. below_amount - unsigned int; (Optional) Include outputs below this amount. do_not_relay - boolean; (Optional) If true, do not relay this sweep transfer. (Defaults to false) get_tx_hex - boolean; (Optional) return the transactions as hex encoded string. (Defaults to false) get_tx_metadata - boolean; (Optional) return the transaction metadata as a string. (Defaults to false) Outputs: tx_hash_list - array of: string. The tx hashes of every transaction. tx_key_list - array of: string. The transaction keys for every transaction. amount_list - array of: integer. The amount transferred for every transaction. fee_list - array of: integer. The amount of fees paid for every transaction. tx_blob_list - array of: string. The tx as hex string for every transaction. tx_metadata_list - array of: string. List of transaction metadata needed to relay the transactions later. multisig_txset - string. The set of signing keys used in a multisig transaction (empty for non-multisig). unsigned_txset - string. Set of unsigned tx for cold-signing purposes. Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"sweep_all\",\"params\":{\"address\":\"55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt\",\"subaddr_indices\":[4],\"ring_size\":7,\"unlock_time\":0,\"get_tx_keys\":true}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"amount_list\": [9985885770000], \"fee_list\": [14114230000], \"multisig_txset\": \"\", \"tx_hash_list\": [\"ab4b6b65cc8cd8c9dd317d0b90d97582d68d0aa1637b0065b05b61f9a66ea5c5\"], \"tx_key_list\": [\"b9b4b39d3bb3062ddb85ec0266d4df39058f4c86077d99309f218ce4d76af607\"], \"unsigned_txset\": \"\" } } sweep_single \u00b6 Send all of a specific unlocked output to an address. Alias: None . Inputs: address - string; Destination public address. account_index - unsigned int; Sweep transactions from this account. subaddr_indices - array of unsigned int; (Optional) Sweep from this set of subaddresses in the account. priority - unsigned int; (Optional) Priority for sending the sweep transfer, partially determines fee. mixin - unsigned int; Number of outputs from the blockchain to mix with (0 means no mixing). ring_size - unsigned int; Sets ringsize to n (mixin + 1). unlock_time - unsigned int; Number of blocks before the loki can be spent (0 to not add a lock). payment_id - string; (Optional) Random 32-byte/64-character hex string to identify a transaction. get_tx_keys - boolean; (Optional) Return the transaction keys after sending. key_image - string; Key image of specific output to sweep. below_amount - unsigned int; (Optional) Include outputs below this amount. do_not_relay - boolean; (Optional) If true, do not relay this sweep transfer. (Defaults to false) get_tx_hex - boolean; (Optional) return the transactions as hex encoded string. (Defaults to false) get_tx_metadata - boolean; (Optional) return the transaction metadata as a string. (Defaults to false) Outputs: tx_hash_list - array of: string. The tx hashes of every transaction. tx_key_list - array of: string. The transaction keys for every transaction. amount_list - array of: integer. The amount transferred for every transaction. fee_list - array of: integer. The amount of fees paid for every transaction. tx_blob_list - array of: string. The tx as hex string for every transaction. tx_metadata_list - array of: string. List of transaction metadata needed to relay the transactions later. multisig_txset - string. The set of signing keys used in a multisig transaction (empty for non-multisig). unsigned_txset - string. Set of unsigned tx for cold-signing purposes. Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"sweep_single\",\"params\":{\"address\":\"74Jsocx8xbpTBEjm3ncKE5LBQbiJouyCDaGhgSiebpvNDXZnTAbW2CmUR5SsBeae2pNk9WMVuz6jegkC4krUyqRjA6VjoLD\",\"ring_size\":7,\"unlock_time\":0,\"key_image\":\"a7834459ef795d2efb6f665d2fd758c8d9288989d8d4c712a68f8023f7804a5e\",\"get_tx_keys\":true}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"amount\": 27126892247503, \"fee\": 14111630000, \"multisig_txset\": \"\", \"tx_blob\": \"\", \"tx_hash\": \"106d4391a031e5b735ded555862fec63233e34e5fa4fc7edcfdbe461c275ae5b\", \"tx_key\": \"\", \"tx_metadata\": \"\", \"unsigned_txset\": \"\" } } relay_tx \u00b6 Relay a transaction previously created with \"do_not_relay\":true . Alias: None . Inputs: hex - string; transaction metadata returned from a transfer method with get_tx_metadata set to true . Outputs: tx_hash - String for the publically searchable transaction hash. Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"relay_tx\",\"params\":{\"hex\":\"...tx_metadata...\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"tx_hash\": \"1c42dcc5672bb09bccf33fb1e9ab4a498af59a6dbd33b3d0cfb289b9e0e25fa5\" } } store \u00b6 Save the wallet file. Alias: None . Inputs: None . Outputs: None . Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"store\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { } } get_payments \u00b6 Get a list of incoming payments using a given payment id. Alias: None . Inputs: payment_id - string; Payment ID used to find the payments (16 characters hex). Outputs: payments - list of: payment_id - string; Payment ID matching the input parameter. tx_hash - string; Transaction hash used as the transaction ID. amount - unsigned int; Amount for this payment. block_height - unsigned int; Height of the block that first confirmed this payment. unlock_time - unsigned int; Time (in block height) until this payment is safe to spend. subaddr_index - subaddress index: major - unsigned int; Account index for the subaddress. minor - unsigned int; Index of the subaddress in the account. address - string; Address receiving the payment; Base58 representation of the public keys. Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_payments\",\"params\":{\"payment_id\":\"60900e5603bf96e3\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"payments\": [{ \"address\": \"55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt\", \"amount\": 1000000000000, \"block_height\": 127606, \"payment_id\": \"60900e5603bf96e3\", \"subaddr_index\": { \"major\": 0, \"minor\": 0 }, \"tx_hash\": \"3292e83ad28fc1cc7bc26dbd38862308f4588680fbf93eae3e803cddd1bd614f\", \"unlock_time\": 0 }] } } get_bulk_payments \u00b6 Get a list of incoming payments using a given payment id, or a list of payments ids, from a given height. This method is the preferred method over get_payments because it has the same functionality but is more extendable. Either is fine for looking up transactions by a single payment ID. Alias: None . Inputs: payment_ids - array of: string; Payment IDs used to find the payments (16 characters hex). min_block_height - unsigned int; The block height at which to start looking for payments. Outputs: payments - list of: payment_id - string; Payment ID matching one of the input IDs. tx_hash - string; Transaction hash used as the transaction ID. amount - unsigned int; Amount for this payment. block_height - unsigned int; Height of the block that first confirmed this payment. unlock_time - unsigned int; Time (in block height) until this payment is safe to spend. subaddr_index - subaddress index: major - unsigned int; Account index for the subaddress. minor - unsigned int; Index of the subaddress in the account. address - string; Address receiving the payment; Base58 representation of the public keys. Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_bulk_payments\",\"params\":{\"payment_ids\":[\"60900e5603bf96e3\"],\"min_block_height\":\"120000\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"payments\": [{ \"address\": \"55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt\", \"amount\": 1000000000000, \"block_height\": 127606, \"payment_id\": \"60900e5603bf96e3\", \"subaddr_index\": { \"major\": 0, \"minor\": 0 }, \"tx_hash\": \"3292e83ad28fc1cc7bc26dbd38862308f4588680fbf93eae3e803cddd1bd614f\", \"unlock_time\": 0 }] } } incoming_transfers \u00b6 Return a list of incoming transfers to the wallet. Inputs: transfer_type - string; \"all\": all the transfers, \"available\": only transfers which are not yet spent, OR \"unavailable\": only transfers which are already spent. account_index - unsigned int; (Optional) Return transfers for this account. (defaults to 0) subaddr_indices - array of unsigned int; (Optional) Return transfers sent to these subaddresses. verbose - boolean; (Optional) Enable verbose output, return key image if true. Outputs: transfers - list of: amount - unsigned int; Amount of this transfer. global_index - unsigned int; Mostly internal use, can be ignored by most users. key_image - string; Key image for the incoming transfer's unspent output (empty unless verbose is true). spent - boolean; Indicates if this transfer has been spent. subaddr_index - unsigned int; Subaddress index for incoming transfer. tx_hash - string; Several incoming transfers may share the same hash if they were in the same transaction. tx_size - unsigned int; Size of transaction in bytes. Example, get all transfers: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"incoming_transfers\",\"params\":{\"transfer_type\":\"all\",\"account_index\":0,\"subaddr_indices\":[3],\"verbose\":true}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"transfers\": [{ \"amount\": 60000000000000, \"global_index\": 122405, \"key_image\": \"768f5144777eb23477ab7acf83562581d690abaf98ca897c03a9d2b900eb479b\", \"spent\": true, \"subaddr_index\": 3, \"tx_hash\": \"f53401f21c6a43e44d5dd7a90eba5cf580012ad0e15d050059136f8a0da34f6b\", \"tx_size\": 159 },{ \"amount\": 27126892247503, \"global_index\": 594994, \"key_image\": \"7e561394806afd1be61980cc3431f6ef3569fa9151cd8d234f8ec13aa145695e\", \"spent\": false, \"subaddr_index\": 3, \"tx_hash\": \"106d4391a031e5b735ded555862fec63233e34e5fa4fc7edcfdbe461c275ae5b\", \"tx_size\": 157 },{ \"amount\": 27169374733655, \"global_index\": 594997, \"key_image\": \"e76c0a3bfeaae35e4173712f782eb34011198e26b990225b71aa787c8ba8a157\", \"spent\": false, \"subaddr_index\": 3, \"tx_hash\": \"0bd959b59117ee1254bd8e5aa8e77ec04ef744144a1ffb2d5c1eb9380a719621\", \"tx_size\": 158 }] } } Example, get available transfers: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"incoming_transfers\",\"params\":{\"transfer_type\":\"available\",\"account_index\":0,\"subaddr_indices\":[3],\"verbose\":true}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"transfers\": [{ \"amount\": 27126892247503, \"global_index\": 594994, \"key_image\": \"7e561394806afd1be61980cc3431f6ef3569fa9151cd8d234f8ec13aa145695e\", \"spent\": false, \"subaddr_index\": 3, \"tx_hash\": \"106d4391a031e5b735ded555862fec63233e34e5fa4fc7edcfdbe461c275ae5b\", \"tx_size\": 157 },{ \"amount\": 27169374733655, \"global_index\": 594997, \"key_image\": \"e76c0a3bfeaae35e4173712f782eb34011198e26b990225b71aa787c8ba8a157\", \"spent\": false, \"subaddr_index\": 3, \"tx_hash\": \"0bd959b59117ee1254bd8e5aa8e77ec04ef744144a1ffb2d5c1eb9380a719621\", \"tx_size\": 158 }] } } Example, get unavailable transfers: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"incoming_transfers\",\"params\":{\"transfer_type\":\"unavailable\",\"account_index\":0,\"subaddr_indices\":[3],\"verbose\":true}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"transfers\": [{ \"amount\": 60000000000000, \"global_index\": 122405, \"key_image\": \"768f5144777eb23477ab7acf83562581d690abaf98ca897c03a9d2b900eb479b\", \"spent\": true, \"subaddr_index\": 3, \"tx_hash\": \"f53401f21c6a43e44d5dd7a90eba5cf580012ad0e15d050059136f8a0da34f6b\", \"tx_size\": 159 }] } } query_key \u00b6 Return the spend or view private key. Alias: None . Inputs: key_type - string; Which key to retrieve: \"mnemonic\" - the mnemonic seed (older wallets do not have one) OR \"view_key\" - the view key Outputs: key - string; The view key will be hex encoded, while the mnemonic will be a string of words. Example (Query view key): $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"query_key\",\"params\":{\"key_type\":\"view_key\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"key\": \"0a1a38f6d246e894600a3e27238a064bf5e8d91801df47a17107596b1378e501\" } } Example (Query mnemonic key): $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"query_key\",\"params\":{\"key_type\":\"mnemonic\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"key\": \"vocal either anvil films dolphin zeal bacon cuisine quote syndrome rejoices envy okay pancakes tulips lair greater petals organs enmity dedicated oust thwart tomorrow tomorrow\" } } make_integrated_address \u00b6 Make an integrated address from the wallet address and a payment id. Alias: None . Inputs: standard_address - string; (Optional, defaults to primary address) Destination public address. payment_id - string; (Optional, defaults to a random ID) 16 characters hex encoded. Outputs: integrated_address - string payment_id - string; hex encoded; Example (Payment ID is empty, use a random ID): $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"make_integrated_address\",\"params\":{\"standard_address\":\"55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"integrated_address\": \"5F38Rw9HKeaLQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZXCkbHUXdPHyiUeRyokn\", \"payment_id\": \"420fa29b2d9a49f5\" } } split_integrated_address \u00b6 Retrieve the standard address and payment id corresponding to an integrated address. Alias: None . Inputs: integrated_address - string Outputs: is_subaddress - boolean; States if the address is a subaddress payment - string; hex encoded standard_address - string Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"split_integrated_address\",\"params\":{\"integrated_address\": \"5F38Rw9HKeaLQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZXCkbHUXdPHyiUeRyokn\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"is_subaddress\": false, \"payment_id\": \"420fa29b2d9a49f5\", \"standard_address\": \"55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt\" } } stop_wallet \u00b6 Stops the wallet, storing the current state. Alias: None . Inputs: None . Outputs: None . Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"stop_wallet\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { } } rescan_blockchain \u00b6 Rescan the blockchain from scratch, losing any information which can not be recovered from the blockchain itself. This includes destination addresses, tx secret keys, tx notes, etc. Alias: None . Inputs: None . Outputs: None . Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"rescan_blockchain\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { } } set_tx_notes \u00b6 Set arbitrary string notes for transactions. Alias: None . Inputs: txids - array of string; transaction ids notes - array of string; notes for the transactions Outputs: None . Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"set_tx_notes\",\"params\":{\"txids\":[\"3292e83ad28fc1cc7bc26dbd38862308f4588680fbf93eae3e803cddd1bd614f\"],\"notes\":[\"This is an example\"]}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { } } get_tx_notes \u00b6 Get string notes for transactions. Alias: None . Inputs: txids - array of string; transaction ids Outputs: notes - array of string; notes for the transactions Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_tx_notes\",\"params\":{\"txids\":[\"3292e83ad28fc1cc7bc26dbd38862308f4588680fbf93eae3e803cddd1bd614f\"]}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"notes\": [\"This is an example\"] } } set_attribute \u00b6 Set arbitrary attribute. Alias: None . Inputs: key - string; attribute name value - string; attribute value Outputs: None . Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"set_attribute\",\"params\":{\"key\":\"my_attribute\",\"value\":\"my_value\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { } } get_attribute \u00b6 Get attribute value by name. Alias: None . Inputs: key - string; attribute name Outputs: value - string; attribute value Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_attribute\",\"params\":{\"key\":\"my_attribute\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"value\": \"my_value\" } } get_tx_key \u00b6 Get transaction secret key from transaction id. Alias: None . Inputs: txid - string; transaction id. Outputs: tx_key - string; transaction secret key. Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_tx_key\",\"params\":{\"txid\":\"19d5089f9469db3d90aca9024dfcb17ce94b948300101c8345a5e9f7257353be\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"tx_key\": \"feba662cf8fb6d0d0da18fc9b70ab28e01cc76311278fdd7fe7ab16360762b06\" } } check_tx_key \u00b6 Check a transaction in the blockchain with its secret key. Alias: None . Inputs: txid - string; transaction id. tx_key - string; transaction secret key. address - string; destination public address of the transaction. Outputs: confirmations - unsigned int; Number of block mined after the one with the transaction. in_pool - boolean; States if the transaction is still in pool or has been added to a block. received - unsigned int; Amount of the transaction. Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"check_tx_key\",\"params\":{\"txid\":\"19d5089f9469db3d90aca9024dfcb17ce94b948300101c8345a5e9f7257353be\",\"tx_key\":\"feba662cf8fb6d0d0da18fc9b70ab28e01cc76311278fdd7fe7ab16360762b06\",\"address\":\"7BnERTpvL5MbCLtj5n9No7J5oE5hHiB3tVCK5cjSvCsYWD2WRJLFuWeKTLiXo5QJqt2ZwUaLy2Vh1Ad51K7FNgqcHgjW85o\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"confirmations\": 0, \"in_pool\": false, \"received\": 1000000000000 } } get_tx_proof \u00b6 Get transaction signature to prove it. Alias: None . Inputs: txid - string; transaction id. address - string; destination public address of the transaction. message - string; (Optional) add a message to the signature to further authenticate the prooving process. Outputs: signature - string; transaction signature. Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_tx_proof\",\"params\":{\"txid\":\"19d5089f9469db3d90aca9024dfcb17ce94b948300101c8345a5e9f7257353be\",\"address\":\"7BnERTpvL5MbCLtj5n9No7J5oE5hHiB3tVCK5cjSvCsYWD2WRJLFuWeKTLiXo5QJqt2ZwUaLy2Vh1Ad51K7FNgqcHgjW85o\",\"message\":\"this is my transaction\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"signature\": \"InProofV13vqBCT6dpSAXkypZmSEMPGVnNRFDX2vscUYeVS4WnSVnV5BwLs31T9q6Etfj9Wts6tAxSAS4gkMeSYzzLS7Gt4vvCSQRh9niGJMUDJsB5hTzb2XJiCkUzWkkcjLFBBRVD5QZ\" } } check_tx_proof \u00b6 Prove a transaction by checking its signature. Alias: None . Inputs: txid - string; transaction id. address - string; destination public address of the transaction. message - string; (Optional) Should be the same message used in get_tx_proof . signature - string; transaction signature to confirm. Outputs: confirmations - unsigned int; Number of block mined after the one with the transaction. good - boolean; States if the inputs proves the transaction. in_pool - boolean; States if the transaction is still in pool or has been added to a block. received - unsigned int; Amount of the transaction. In the example below, the transaction has been proven: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"check_tx_proof\",\"params\":{\"txid\":\"19d5089f9469db3d90aca9024dfcb17ce94b948300101c8345a5e9f7257353be\",\"address\":\"7BnERTpvL5MbCLtj5n9No7J5oE5hHiB3tVCK5cjSvCsYWD2WRJLFuWeKTLiXo5QJqt2ZwUaLy2Vh1Ad51K7FNgqcHgjW85o\",\"message\":\"this is my transaction\",\"signature\":\"InProofV13vqBCT6dpSAXkypZmSEMPGVnNRFDX2vscUYeVS4WnSVnV5BwLs31T9q6Etfj9Wts6tAxSAS4gkMeSYzzLS7Gt4vvCSQRh9niGJMUDJsB5hTzb2XJiCkUzWkkcjLFBBRVD5QZ\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"confirmations\": 482, \"good\": true, \"in_pool\": false, \"received\": 1000000000000 } } In the example below, the wrong message is used, avoiding the transaction to be proved: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"check_tx_proof\",\"params\":{\"txid\":\"19d5089f9469db3d90aca9024dfcb17ce94b948300101c8345a5e9f7257353be\",\"address\":\"7BnERTpvL5MbCLtj5n9No7J5oE5hHiB3tVCK5cjSvCsYWD2WRJLFuWeKTLiXo5QJqt2ZwUaLy2Vh1Ad51K7FNgqcHgjW85o\",\"message\":\"wrong message\",\"signature\":\"InProofV13vqBCT6dpSAXkypZmSEMPGVnNRFDX2vscUYeVS4WnSVnV5BwLs31T9q6Etfj9Wts6tAxSAS4gkMeSYzzLS7Gt4vvCSQRh9niGJMUDJsB5hTzb2XJiCkUzWkkcjLFBBRVD5QZ\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"confirmations\": 0, \"good\": false, \"in_pool\": false, \"received\": 0 } } get_spend_proof \u00b6 Generate a signature to prove a spend. Unlike proving a transaction, it does not requires the destination public address. Alias: None . Inputs: txid - string; transaction id. message - string; (Optional) add a message to the signature to further authenticate the prooving process. Outputs: signature - string; spend signature. Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_spend_proof\",\"params\":{\"txid\":\"19d5089f9469db3d90aca9024dfcb17ce94b948300101c8345a5e9f7257353be\",\"message\":\"this is my transaction\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"signature\": \"SpendProofV1aSh8Todhk54736iXgV6vJAFP7egxByuMWZeyNDaN2JY737S95X5zz5mNMQSuCNSLjjhi5HJCsndpNWSNVsuThxwv285qy1KkUrLFRkxMSCjfL6bbycYN33ScZ5UB4Fzseceo1ndpL393T1q638VmcU3a56dhNHF1RPZFiGPS61FA78nXFSqE9uoKCCoHkEz83M1dQVhxZV5CEPF2P6VioGTKgprLCH9vvj9k1ivd4SX19L2VSMc3zD1u3mkR24ioETvxBoLeBSpxMoikyZ6inhuPm8yYo9YWyFtQK4XYfAV9mJ9knz5fUPXR8vvh7KJCAg4dqeJXTVb4mbMzYtsSZXHd6ouWoyCd6qMALdW8pKhgMCHcVYMWp9X9WHZuCo9rsRjRpg15sJUw7oJg1JoGiVgj8P4JeGDjnZHnmLVa5bpJhVCbMhyM7JLXNQJzFWTGC27TQBbthxCfQaKdusYnvZnKPDJWSeceYEFzepUnsWhQtyhbb73FzqgWC4eKEFKAZJqT2LuuSoxmihJ9acnFK7Ze23KTVYgDyMKY61VXADxmSrBvwUtxCaW4nQtnbMxiPMNnDMzeixqsFMBtN72j5UqhiLRY99k6SE7Qf5f29haNSBNSXCFFHChPKNTwJrehkofBdKUhh2VGPqZDNoefWUwfudeu83t85bmjv8Q3LrQSkFgFjRT5tLo8TMawNXoZCrQpyZrEvnodMDDUUNf3NL7rxyv3gM1KrTWjYaWXFU2RAsFee2Q2MTwUW7hR25cJvSFuB1BX2bfkoCbiMk923tHZGU2g7rSKF1GDDkXAc1EvFFD4iGbh1Q5t6hPRhBV8PEncdcCWGq5uAL5D4Bjr6VXG8uNeCy5oYWNgbZ5JRSfm7QEhPv8Fy9AKMgmCxDGMF9dVEaU6tw2BAnJavQdfrxChbDBeQXzCbCfep6oei6n2LZdE5Q84wp7eoQFE5Cwuo23tHkbJCaw2njFi3WGBbA7uGZaGHJPyB2rofTWBiSUXZnP2hiE9bjJghAcDm1M4LVLfWvhZmFEnyeru3VWMETnetz1BYLUC5MJGFXuhnHwWh7F6r74FDyhdswYop4eWPbyrXMXmUQEccTGd2NaT8g2VHADZ76gMC6BjWESvcnz2D4n8XwdmM7ZQ1jFwhuXrBfrb1dwRasyXxxHMGAC2onatNiExyeQ9G1W5LwqNLAh9hvcaNTGaYKYXoceVzLkgm6e5WMkLsCwuZXvB\" } } check_spend_proof \u00b6 Prove a spend using a signature. Unlike proving a transaction, it does not requires the destination public address. Alias: None . Inputs: txid - string; transaction id. message - string; (Optional) Should be the same message used in get_spend_proof . signature - string; spend signature to confirm. Outputs: good - boolean; States if the inputs proves the spend. In the example below, the spend has been proven: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"check_spend_proof\",\"params\":{\"txid\":\"19d5089f9469db3d90aca9024dfcb17ce94b948300101c8345a5e9f7257353be\",\"message\":\"this is my transaction\",\"signature\":\"SpendProofV1aSh8Todhk54736iXgV6vJAFP7egxByuMWZeyNDaN2JY737S95X5zz5mNMQSuCNSLjjhi5HJCsndpNWSNVsuThxwv285qy1KkUrLFRkxMSCjfL6bbycYN33ScZ5UB4Fzseceo1ndpL393T1q638VmcU3a56dhNHF1RPZFiGPS61FA78nXFSqE9uoKCCoHkEz83M1dQVhxZV5CEPF2P6VioGTKgprLCH9vvj9k1ivd4SX19L2VSMc3zD1u3mkR24ioETvxBoLeBSpxMoikyZ6inhuPm8yYo9YWyFtQK4XYfAV9mJ9knz5fUPXR8vvh7KJCAg4dqeJXTVb4mbMzYtsSZXHd6ouWoyCd6qMALdW8pKhgMCHcVYMWp9X9WHZuCo9rsRjRpg15sJUw7oJg1JoGiVgj8P4JeGDjnZHnmLVa5bpJhVCbMhyM7JLXNQJzFWTGC27TQBbthxCfQaKdusYnvZnKPDJWSeceYEFzepUnsWhQtyhbb73FzqgWC4eKEFKAZJqT2LuuSoxmihJ9acnFK7Ze23KTVYgDyMKY61VXADxmSrBvwUtxCaW4nQtnbMxiPMNnDMzeixqsFMBtN72j5UqhiLRY99k6SE7Qf5f29haNSBNSXCFFHChPKNTwJrehkofBdKUhh2VGPqZDNoefWUwfudeu83t85bmjv8Q3LrQSkFgFjRT5tLo8TMawNXoZCrQpyZrEvnodMDDUUNf3NL7rxyv3gM1KrTWjYaWXFU2RAsFee2Q2MTwUW7hR25cJvSFuB1BX2bfkoCbiMk923tHZGU2g7rSKF1GDDkXAc1EvFFD4iGbh1Q5t6hPRhBV8PEncdcCWGq5uAL5D4Bjr6VXG8uNeCy5oYWNgbZ5JRSfm7QEhPv8Fy9AKMgmCxDGMF9dVEaU6tw2BAnJavQdfrxChbDBeQXzCbCfep6oei6n2LZdE5Q84wp7eoQFE5Cwuo23tHkbJCaw2njFi3WGBbA7uGZaGHJPyB2rofTWBiSUXZnP2hiE9bjJghAcDm1M4LVLfWvhZmFEnyeru3VWMETnetz1BYLUC5MJGFXuhnHwWh7F6r74FDyhdswYop4eWPbyrXMXmUQEccTGd2NaT8g2VHADZ76gMC6BjWESvcnz2D4n8XwdmM7ZQ1jFwhuXrBfrb1dwRasyXxxHMGAC2onatNiExyeQ9G1W5LwqNLAh9hvcaNTGaYKYXoceVzLkgm6e5WMkLsCwuZXvB\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"good\": true } } In the example below, the wrong message is used, avoiding the spend to be proved: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"check_spend_proof\",\"params\":{\"txid\":\"19d5089f9469db3d90aca9024dfcb17ce94b948300101c8345a5e9f7257353be\",\"message\":\"wrong message\",\"signature\":\"SpendProofV1aSh8Todhk54736iXgV6vJAFP7egxByuMWZeyNDaN2JY737S95X5zz5mNMQSuCNSLjjhi5HJCsndpNWSNVsuThxwv285qy1KkUrLFRkxMSCjfL6bbycYN33ScZ5UB4Fzseceo1ndpL393T1q638VmcU3a56dhNHF1RPZFiGPS61FA78nXFSqE9uoKCCoHkEz83M1dQVhxZV5CEPF2P6VioGTKgprLCH9vvj9k1ivd4SX19L2VSMc3zD1u3mkR24ioETvxBoLeBSpxMoikyZ6inhuPm8yYo9YWyFtQK4XYfAV9mJ9knz5fUPXR8vvh7KJCAg4dqeJXTVb4mbMzYtsSZXHd6ouWoyCd6qMALdW8pKhgMCHcVYMWp9X9WHZuCo9rsRjRpg15sJUw7oJg1JoGiVgj8P4JeGDjnZHnmLVa5bpJhVCbMhyM7JLXNQJzFWTGC27TQBbthxCfQaKdusYnvZnKPDJWSeceYEFzepUnsWhQtyhbb73FzqgWC4eKEFKAZJqT2LuuSoxmihJ9acnFK7Ze23KTVYgDyMKY61VXADxmSrBvwUtxCaW4nQtnbMxiPMNnDMzeixqsFMBtN72j5UqhiLRY99k6SE7Qf5f29haNSBNSXCFFHChPKNTwJrehkofBdKUhh2VGPqZDNoefWUwfudeu83t85bmjv8Q3LrQSkFgFjRT5tLo8TMawNXoZCrQpyZrEvnodMDDUUNf3NL7rxyv3gM1KrTWjYaWXFU2RAsFee2Q2MTwUW7hR25cJvSFuB1BX2bfkoCbiMk923tHZGU2g7rSKF1GDDkXAc1EvFFD4iGbh1Q5t6hPRhBV8PEncdcCWGq5uAL5D4Bjr6VXG8uNeCy5oYWNgbZ5JRSfm7QEhPv8Fy9AKMgmCxDGMF9dVEaU6tw2BAnJavQdfrxChbDBeQXzCbCfep6oei6n2LZdE5Q84wp7eoQFE5Cwuo23tHkbJCaw2njFi3WGBbA7uGZaGHJPyB2rofTWBiSUXZnP2hiE9bjJghAcDm1M4LVLfWvhZmFEnyeru3VWMETnetz1BYLUC5MJGFXuhnHwWh7F6r74FDyhdswYop4eWPbyrXMXmUQEccTGd2NaT8g2VHADZ76gMC6BjWESvcnz2D4n8XwdmM7ZQ1jFwhuXrBfrb1dwRasyXxxHMGAC2onatNiExyeQ9G1W5LwqNLAh9hvcaNTGaYKYXoceVzLkgm6e5WMkLsCwuZXvB\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"good\": false } } get_reserve_proof \u00b6 Generate a signature to prove of an available amount in a wallet. Alias: None . Inputs: all - boolean; Proves all wallet balance to be disposable. account_index - unsigned int; Specify the account from witch to prove reserve. (ignored if all is set to true) amount - unsigned int; Amount (in atomic units) to prove the account has for reserve. (ignored if all is set to true) message - string; (Optional) add a message to the signature to further authenticate the prooving process. Outputs: signature - string; reserve signature. Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_reserve_proof\",\"params\":{\"all\":false,\"account_index\":0,\"amount\":100000000000}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"signature\": \"ReserveProofV11BZ23sBt9sZJeGccf84mzyAmNCP3KzYbE1111112VKmH111118NfCYJQjZ6c46gT2kXgcHCaSSZeL8sRdzqjqx7i1e7FQfQGu2o113UYFVdwzHQi3iENDPa76Kn1BvywbKz3bMkXdZkBEEhBSF4kjjGaiMJ1ucKb6wvMVC4A8sA4nZEdL2Mk3wBucJCYTZwKqA8i1M113kqakDkG25FrjiDqdQTCYz2wDBmfKxF3eQiV5FWzZ6HmAyxnqTWUiMWukP9A3Edy3ZXqjP1b23dhz7Mbj39bBxe3ZeDNu9HnTSqYvHNRyqCkeUMJpHyQweqjGUJ1DSfFYr33J1E7MkhMnEi1o7trqWjVix32XLetYfePG73yvHbS24837L7Q64i5n1LSpd9yMiQZ3Dyaysi5y6jPx7TpAvnSqBFtuCciKoNzaXoA3dqt9cuVFZTXzdXKqdt3cXcVJMNxY8RvKPVQHhUur94Lpo1nSpxf7BN5a5rHrbZFqoZszsZmiWikYPkLX72XUdw6NWjLrTBxSy7KuPYH86c6udPEXLo2xgN6XHMBMBJzt8FqqK7EcpNUBkuHm2AtpGkf9CABY3oSjDQoRF5n4vNLd3qUaxNsG4XJ12L9gJ7GrK273BxkfEA8fDdxPrb1gpespbgEnCTuZHqj1A\" } } check_reserve_proof \u00b6 Proves a wallet has a disposable reserve using a signature. Alias: None . Inputs: address - string; Public address of the wallet. message - string; (Optional) Should be the same message used in get_reserve_proof . signature - string; reserve signature to confirm. Outputs: good - boolean; States if the inputs proves the reserve. In the example below, the reserve has been proven: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"check_reserve_proof\",\"params\":{\"address\":\"55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt\",\"signature\":\"ReserveProofV11BZ23sBt9sZJeGccf84mzyAmNCP3KzYbE1111112VKmH111118NfCYJQjZ6c46gT2kXgcHCaSSZeL8sRdzqjqx7i1e7FQfQGu2o113UYFVdwzHQi3iENDPa76Kn1BvywbKz3bMkXdZkBEEhBSF4kjjGaiMJ1ucKb6wvMVC4A8sA4nZEdL2Mk3wBucJCYTZwKqA8i1M113kqakDkG25FrjiDqdQTCYz2wDBmfKxF3eQiV5FWzZ6HmAyxnqTWUiMWukP9A3Edy3ZXqjP1b23dhz7Mbj39bBxe3ZeDNu9HnTSqYvHNRyqCkeUMJpHyQweqjGUJ1DSfFYr33J1E7MkhMnEi1o7trqWjVix32XLetYfePG73yvHbS24837L7Q64i5n1LSpd9yMiQZ3Dyaysi5y6jPx7TpAvnSqBFtuCciKoNzaXoA3dqt9cuVFZTXzdXKqdt3cXcVJMNxY8RvKPVQHhUur94Lpo1nSpxf7BN5a5rHrbZFqoZszsZmiWikYPkLX72XUdw6NWjLrTBxSy7KuPYH86c6udPEXLo2xgN6XHMBMBJzt8FqqK7EcpNUBkuHm2AtpGkf9CABY3oSjDQoRF5n4vNLd3qUaxNsG4XJ12L9gJ7GrK273BxkfEA8fDdxPrb1gpespbgEnCTuZHqj1A\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"good\": true, \"spent\": 0, \"total\": 100000000000 } } In the example below, all wallet reserve has been proven: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"check_reserve_proof\",\"params\":{\"address\":\"55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt\",\"message\":\"I have 10 at least\",\"signature\":\"...signature...\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"good\": true, \"spent\": 0, \"total\": 164113855714662789 } } In the example below, the wrong message is used, avoiding the reserve to be proved: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"check_spend_proof\",\"params\":{\"txid\":\"19d5089f9469db3d90aca9024dfcb17ce94b948300101c8345a5e9f7257353be\",\"message\":\"wrong message\",\"signature\":\"SpendProofV1aSh8Todhk54736iXgV6vJAFP7egxByuMWZeyNDaN2JY737S95X5zz5mNMQSuCNSLjjhi5HJCsndpNWSNVsuThxwv285qy1KkUrLFRkxMSCjfL6bbycYN33ScZ5UB4Fzseceo1ndpL393T1q638VmcU3a56dhNHF1RPZFiGPS61FA78nXFSqE9uoKCCoHkEz83M1dQVhxZV5CEPF2P6VioGTKgprLCH9vvj9k1ivd4SX19L2VSMc3zD1u3mkR24ioETvxBoLeBSpxMoikyZ6inhuPm8yYo9YWyFtQK4XYfAV9mJ9knz5fUPXR8vvh7KJCAg4dqeJXTVb4mbMzYtsSZXHd6ouWoyCd6qMALdW8pKhgMCHcVYMWp9X9WHZuCo9rsRjRpg15sJUw7oJg1JoGiVgj8P4JeGDjnZHnmLVa5bpJhVCbMhyM7JLXNQJzFWTGC27TQBbthxCfQaKdusYnvZnKPDJWSeceYEFzepUnsWhQtyhbb73FzqgWC4eKEFKAZJqT2LuuSoxmihJ9acnFK7Ze23KTVYgDyMKY61VXADxmSrBvwUtxCaW4nQtnbMxiPMNnDMzeixqsFMBtN72j5UqhiLRY99k6SE7Qf5f29haNSBNSXCFFHChPKNTwJrehkofBdKUhh2VGPqZDNoefWUwfudeu83t85bmjv8Q3LrQSkFgFjRT5tLo8TMawNXoZCrQpyZrEvnodMDDUUNf3NL7rxyv3gM1KrTWjYaWXFU2RAsFee2Q2MTwUW7hR25cJvSFuB1BX2bfkoCbiMk923tHZGU2g7rSKF1GDDkXAc1EvFFD4iGbh1Q5t6hPRhBV8PEncdcCWGq5uAL5D4Bjr6VXG8uNeCy5oYWNgbZ5JRSfm7QEhPv8Fy9AKMgmCxDGMF9dVEaU6tw2BAnJavQdfrxChbDBeQXzCbCfep6oei6n2LZdE5Q84wp7eoQFE5Cwuo23tHkbJCaw2njFi3WGBbA7uGZaGHJPyB2rofTWBiSUXZnP2hiE9bjJghAcDm1M4LVLfWvhZmFEnyeru3VWMETnetz1BYLUC5MJGFXuhnHwWh7F6r74FDyhdswYop4eWPbyrXMXmUQEccTGd2NaT8g2VHADZ76gMC6BjWESvcnz2D4n8XwdmM7ZQ1jFwhuXrBfrb1dwRasyXxxHMGAC2onatNiExyeQ9G1W5LwqNLAh9hvcaNTGaYKYXoceVzLkgm6e5WMkLsCwuZXvB\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"good\": false } } get_transfers \u00b6 Returns a list of transfers. Alias: None . Inputs: in - boolean; (Optional) Include incoming transfers. out - boolean; (Optional) Include outgoing transfers. pending - boolean; (Optional) Include pending transfers. failed - boolean; (Optional) Include failed transfers. pool - boolean; (Optional) Include transfers from the daemon's transaction pool. filter_by_height - boolean; (Optional) Filter transfers by block height. min_height - unsigned int; (Optional) Minimum block height to scan for transfers, if filtering by height is enabled. max_height - unsigned int; (Opional) Maximum block height to scan for transfers, if filtering by height is enabled (defaults to max block height). account_index - unsigned int; (Optional) Index of the account to query for transfers. (defaults to 0) subaddr_indices - array of unsigned int; (Optional) List of subaddress indices to query for transfers. (defaults to 0) Outputs: in array of transfers: address - string; Public address of the transfer. amount - unsigned int; Amount transferred. confirmations - unsigned int; Number of block mined since the block containing this transaction (or block height at which the transaction should be added to a block if not yet confirmed). double_spend_seen - boolean; True if the key image(s) for the transfer have been seen before. fee - unsigned int; Transaction fee for this transfer. height - unsigned int; Height of the first block that confirmed this transfer (0 if not mined yet). note - string; Note about this transfer. payment_id - string; Payment ID for this transfer. subaddr_index - JSON object containing the major & minor subaddress index: major - unsigned int; Account index for the subaddress. minor - unsigned int; Index of the subaddress under the account. suggested_confirmations_threshold - unsigned int; Estimation of the confirmations needed for the transaction to be included in a block. timestamp - unsigned int; POSIX timestamp for when this transfer was first confirmed in a block (or timestamp submission if not mined yet). txid - string; Transaction ID for this transfer. type - string; Transfer type: \"in\" unlock_time - unsigned int; Number of blocks until transfer is safely spendable. out array of transfers (see above). pending array of transfers (see above). failed array of transfers (see above). pool array of transfers (see above). Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_transfers\",\"params\":{\"in\":true,\"account_index\":1}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"in\": [{ \"address\": \"77Vx9cs1VPicFndSVgYUvTdLCJEZw9h81hXLMYsjBCXSJfUehLa9TDW3Ffh45SQa7xb6dUs18mpNxfUhQGqfwXPSMrvKhVp\", \"amount\": 200000000000, \"confirmations\": 1, \"double_spend_seen\": false, \"fee\": 21650200000, \"height\": 153624, \"note\": \"\", \"payment_id\": \"0000000000000000\", \"subaddr_index\": { \"major\": 1, \"minor\": 0 }, \"suggested_confirmations_threshold\": 1, \"timestamp\": 1535918400, \"txid\": \"c36258a276018c3a4bc1f195a7fb530f50cd63a4fa765fb7c6f7f49fc051762a\", \"type\": \"in\", \"unlock_time\": 0 }] } } get_transfer_by_txid \u00b6 Show information about a transfer to/from this address. Alias: None . Inputs: txid - string; Transaction ID used to find the transfer. account_index - unsigned int; (Optional) Index of the account to query for the transfer. Outputs: transfer - JSON object containing payment information: address - string; Address that transferred the funds. Base58 representation of the public keys. amount - unsigned int; Amount of this transfer. confirmations - unsigned int; Number of block mined since the block containing this transaction (or block height at which the transaction should be added to a block if not yet confirmed). destinations - array of JSON objects containing transfer destinations: amount - unsigned int; Amount transferred to this destination. address - string; Address for this destination. Base58 representation of the public keys. double_spend_seen - boolean; True if the key image(s) for the transfer have been seen before. fee - unsigned int; Transaction fee for this transfer. height - unsigned int; Height of the first block that confirmed this transfer. note - string; Note about this transfer. payment_id - string; Payment ID for this transfer. subaddr_index - JSON object containing the major & minor subaddress index: major - unsigned int; Account index for the subaddress. minor - unsigned int; Index of the subaddress under the account. suggested_confirmations_threshold - unsigned int; Estimation of the confirmations needed for the transaction to be included in a block. timestamp - unsigned int; POSIX timestamp for the block that confirmed this transfer (or timestamp submission if not mined yet). txid - string; Transaction ID of this transfer (same as input TXID). type - string; Type of transfer, one of the following: \"in\", \"out\", \"pending\", \"failed\", \"pool\" unlock_time - unsigned int; Number of blocks until transfer is safely spendable. Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_transfer_by_txid\",\"params\":{\"txid\":\"c36258a276018c3a4bc1f195a7fb530f50cd63a4fa765fb7c6f7f49fc051762a\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"transfer\": { \"address\": \"55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt\", \"amount\": 300000000000, \"confirmations\": 1, \"destinations\": [{ \"address\": \"7BnERTpvL5MbCLtj5n9No7J5oE5hHiB3tVCK5cjSvCsYWD2WRJLFuWeKTLiXo5QJqt2ZwUaLy2Vh1Ad51K7FNgqcHgjW85o\", \"amount\": 100000000000 },{ \"address\": \"77Vx9cs1VPicFndSVgYUvTdLCJEZw9h81hXLMYsjBCXSJfUehLa9TDW3Ffh45SQa7xb6dUs18mpNxfUhQGqfwXPSMrvKhVp\", \"amount\": 200000000000 }], \"double_spend_seen\": false, \"fee\": 21650200000, \"height\": 153624, \"note\": \"\", \"payment_id\": \"0000000000000000\", \"subaddr_index\": { \"major\": 0, \"minor\": 0 }, \"suggested_confirmations_threshold\": 1, \"timestamp\": 1535918400, \"txid\": \"c36258a276018c3a4bc1f195a7fb530f50cd63a4fa765fb7c6f7f49fc051762a\", \"type\": \"out\", \"unlock_time\": 0 } } } sign \u00b6 Sign a string. Alias: None . Inputs: data - string; Anything you need to sign. Outputs: signature - string; Signature generated against the \"data\" and the account public address. Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"sign\",\"params\":{\"data\":\"This is sample data to be signed\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"signature\": \"SigV14K6G151gycjiGxjQ74tKX6A2LwwghvuHjcDeuRFQio5LS6Gb27BNxjYQY1dPuUvXkEbGQUkiHSVLPj4nJAHRrrw3\" } } verify \u00b6 Verify a signature on a string. Alias: None . Inputs: data - string; What should have been signed. address - string; Public address of the wallet used to sign the data. signature - string; signature generated by sign method. Outputs: good - boolean; Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"verify\",\"params\":{\"data\":\"This is sample data to be signed\",\"address\":\"55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt\",\"signature\":\"SigV14K6G151gycjiGxjQ74tKX6A2LwwghvuHjcDeuRFQio5LS6Gb27BNxjYQY1dPuUvXkEbGQUkiHSVLPj4nJAHRrrw3\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"good\": true } } export_outputs \u00b6 Export all outputs in hex format. Alias: None . Inputs: None . Outputs: outputs_data_hex - string; wallet outputs in hex format. Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"export_outputs\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"outputs_data_hex\": \"...outputs...\" } } import_outputs \u00b6 Import outputs in hex format. Alias: None . Inputs: outputs_data_hex - string; wallet outputs in hex format. Outputs: num_imported - unsigned int; number of outputs imported. Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"import_outputs\",\"params\":{\"outputs_data_hex\":\"...outputs...\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"num_imported\": 6400 } } export_key_images \u00b6 Export a signed set of key images. Alias: None . Inputs: None . Outputs: signed_key_images - array of signed key images: key_image - string; signature - string; Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"export_key_images\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"signed_key_images\": [{ \"key_image\": \"cd35239b72a35e26a57ed17400c0b66944a55de9d5bda0f21190fed17f8ea876\", \"signature\": \"c9d736869355da2538ab4af188279f84138c958edbae3c5caf388a63cd8e780b8c5a1aed850bd79657df659422c463608ea4e0c730ba9b662c906ae933816d00\" },{ \"key_image\": \"65158a8ee5a3b32009b85a307d85b375175870e560e08de313531c7dbbe6fc19\", \"signature\": \"c96e40d09dfc45cfc5ed0b76bfd7ca793469588bb0cf2b4d7b45ef23d40fd4036057b397828062e31700dc0c2da364f50cd142295a8405b9fe97418b4b745d0c\" },...] } } import_key_images \u00b6 Import signed key images list and verify their spent status. Alias: None . Inputs: signed_key_images - array of signed key images: key_image - string; signature - string; Outputs: height - unsigned int; spent - unsigned int; Amount (in atomic units) spent from those key images. unspent - unsigned int; Amount (in atomic units) still available from those key images. Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"import_key_images\", \"params\":{\"signed_key_images\":[{\"key_image\":\"cd35239b72a35e26a57ed17400c0b66944a55de9d5bda0f21190fed17f8ea876\",\"signature\":\"c9d736869355da2538ab4af188279f84138c958edbae3c5caf388a63cd8e780b8c5a1aed850bd79657df659422c463608ea4e0c730ba9b662c906ae933816d00\"},{\"key_image\":\"65158a8ee5a3b32009b85a307d85b375175870e560e08de313531c7dbbe6fc19\",\"signature\":\"c96e40d09dfc45cfc5ed0b76bfd7ca793469588bb0cf2b4d7b45ef23d40fd4036057b397828062e31700dc0c2da364f50cd142295a8405b9fe97418b4b745d0c\"}]}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"height\": 76428, \"spent\": 62708953408711, \"unspent\": 0 } } make_uri \u00b6 Create a payment URI using the official URI spec. Alias: None . Inputs: address - string; Wallet address amount - unsigned int; (optional) the integer amount to receive, in atomic units payment_id - string; (optional) 16 or 64 character hexadecimal payment id recipient_name - string; (optional) name of the payment recipient tx_description - string; (optional) Description of the reason for the tx Outputs: uri - string; This contains all the payment input information as a properly formatted payment URI Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"make_uri\",\"params\":{\"address\":\"55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt\",\"amount\":10,\"payment_id\":\"420fa29b2d9a49f5\",\"tx_description\":\"Testing out the make_uri function.\",\"recipient_name\":\"el00ruobuob Stagenet wallet\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"uri\": \"loki:55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt?tx_payment_id=420fa29b2d9a49f5&tx_amount=0.000000000010&recipient_name=el00ruobuob%20Stagenet%20wallet&tx_description=Testing%20out%20the%20make_uri%20function.\" } } parse_uri \u00b6 Parse a payment URI to get payment information. Alias: None . Inputs: uri - string; This contains all the payment input information as a properly formatted payment URI Outputs: uri - JSON object containing payment information: address - string; Wallet address amount - unsigned int; Decimal amount to receive, in coin units (0 if not provided) payment_id - string; 16 or 64 character hexadecimal payment id (empty if not provided) recipient_name - string; Name of the payment recipient (empty if not provided) tx_description - string; Description of the reason for the tx (empty if not provided) Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"parse_uri\",\"params\":{\"uri\":\"loki:55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt?tx_payment_id=420fa29b2d9a49f5&tx_amount=0.000000000010&recipient_name=el00ruobuob%20Stagenet%20wallet&tx_description=Testing%20out%20the%20make_uri%20function.\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"uri\": { \"address\": \"55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt\", \"amount\": 10, \"payment_id\": \"420fa29b2d9a49f5\", \"recipient_name\": \"el00ruobuob Stagenet wallet\", \"tx_description\": \"Testing out the make_uri function.\" } } } get_address_book \u00b6 Retrieves entries from the address book. Alias: None . Inputs: entries - array of unsigned int; indices of the requested address book entries Outputs: entries - array of entries: address - string; Public address of the entry description - string; Description of this address entry index - unsigned int; payment_id - string; Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_address_book\",\"params\":{\"entries\":[0,1]}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"entries\": [{ \"address\": \"77Vx9cs1VPicFndSVgYUvTdLCJEZw9h81hXLMYsjBCXSJfUehLa9TDW3Ffh45SQa7xb6dUs18mpNxfUhQGqfwXPSMrvKhVp\", \"description\": \"Second account\", \"index\": 0, \"payment_id\": \"0000000000000000000000000000000000000000000000000000000000000000\" },{ \"address\": \"78P16M3XmFRGcWFCcsgt1WcTntA1jzcq31seQX1Eg92j8VQ99NPivmdKam4J5CKNAD7KuNWcq5xUPgoWczChzdba5WLwQ4j\", \"description\": \"Third account\", \"index\": 1, \"payment_id\": \"0000000000000000000000000000000000000000000000000000000000000000\" }] } } add_address_book \u00b6 Add an entry to the address book. Alias: None . Inputs: address - string; payment_id - (optional) string, defaults to \"0000000000000000000000000000000000000000000000000000000000000000\"; description - (optional) string, defaults to \"\"; Outputs: index - unsigned int; The index of the address book entry. Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"add_address_book\",\"params\":{\"address\":\"78P16M3XmFRGcWFCcsgt1WcTntA1jzcq31seQX1Eg92j8VQ99NPivmdKam4J5CKNAD7KuNWcq5xUPgoWczChzdba5WLwQ4j\",\"description\":\"Third account\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"index\": 1 } } delete_address_book \u00b6 Delete an entry from the address book. Alias: None . Inputs: index - unsigned int; The index of the address book entry. Outputs: None . Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"delete_address_book\",\"params\":{\"index\":1}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { } } refresh \u00b6 Refresh a wallet after openning. Alias: None . Inputs: start_height - unsigned int; (Optional) The block height from which to start refreshing. Outputs: blocks_fetched - unsigned int; Number of new blocks scanned. received_money - boolean; States if transactions to the wallet have been found in the blocks. Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"refresh\",\"params\":{\"start_height\":100000}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"blocks_fetched\": 24, \"received_money\": true } } rescan_spent \u00b6 Rescan the blockchain for spent outputs. Alias: None . Inputs: None . Outputs: None . Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"rescan_spent\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { } } start_mining \u00b6 Start mining in the loki daemon. Alias: None . Inputs: threads_count - unsigned int; Number of threads created for mining. do_background_mining - boolean; Allow to start the miner in smart mining mode. ignore_battery - boolean; Ignore battery status (for smart mining only) Outputs: None . Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"start_mining\",\"params\":{\"threads_count\":1,\"do_background_mining\":true,\"ignore_battery\":false}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { } } stop_mining \u00b6 Stop mining in the loki daemon. Alias: None . Inputs: None . Outputs: None . Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"stop_mining\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { } } get_languages \u00b6 Get a list of available languages for your wallet's seed. Alias: None . Inputs: None . Outputs: languages - array of string; List of available languages Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_languages\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"languages\": [\"Deutsch\",\"English\",\"Espa\u00f1ol\",\"Fran\u00e7ais\",\"Italiano\",\"Nederlands\",\"Portugu\u00eas\",\"\u0440\u0443\u0441\u0441\u043a\u0438\u0439 \u044f\u0437\u044b\u043a\",\"\u65e5\u672c\u8a9e\",\"\u7b80\u4f53\u4e2d\u6587 (\u4e2d\u56fd)\",\"Esperanto\",\"Lojban\"] } } create_wallet \u00b6 Create a new wallet. You need to have set the argument \"\u2013wallet-dir\" when launching loki-wallet-rpc to make this work. Alias: None . Inputs: filename - string; Wallet file name. password - string; (Optional) password to protect the wallet. language - string; Language for your wallets' seed. Outputs: None . Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"create_wallet\",\"params\":{\"filename\":\"mytestwallet\",\"password\":\"mytestpassword\",\"language\":\"English\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { } } open_wallet \u00b6 Open a wallet. You need to have set the argument \"\u2013wallet-dir\" when launching loki-wallet-rpc to make this work. Alias: None . Inputs: filename - string; wallet name stored in \u2013wallet-dir. password - string; (Optional) only needed if the wallet has a password defined. Outputs: None . Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"open_wallet\",\"params\":{\"filename\":\"mytestwallet\",\"password\":\"mytestpassword\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { } } close_wallet \u00b6 Close the currently opened wallet, after trying to save it. Alias: None . Inputs: None . Outputs: None . Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"close_wallet\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { } } change_wallet_password \u00b6 Change a wallet password. Alias: None . Inputs: old_password - string; (Optional) Current wallet password, if defined. new_password - string; (Optional) New wallet password, if not blank. Outputs: None . Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"change_wallet_password\",\"params\":{\"old_password\":\"theCurrentSecretPassPhrase\",\"new_password\":\"theNewSecretPassPhrase\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { } } is_multisig \u00b6 Check if a wallet is a multisig one. Alias: None . Inputs: None . Outputs: multisig - boolean; States if the wallet is multisig ready - boolean; threshold - unsigned int; Amount of signature needed to sign a transfer. total - unsigned int; Total amount of signature in the multisig wallet. Example for a non-multisig wallet: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"is_multisig\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"multisig\": false, \"ready\": false, \"threshold\": 0, \"total\": 0 } } Example for a multisig wallet: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"is_multisig\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"multisig\": true, \"ready\": true, \"threshold\": 2, \"total\": 2 } } prepare_multisig \u00b6 Prepare a wallet for multisig by generating a multisig string to share with peers. Alias: None . Inputs: None . Outputs: multisig_info - string; Multisig string to share with peers to create the multisig wallet. Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"prepare_multisig\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"multisig_info\": \"MultisigV1BFdxQ653cQHB8wsj9WJQd2VdnjxK89g5M94dKPBNw22reJnyJYKrz6rJeXdjFwJ3Mz6n4qNQLd6eqUZKLiNzJFi3UPNVcTjtkG2aeSys9sYkvYYKMZ7chCxvoEXVgm74KKUcUu4V8xveCBFadFuZs8shnxBWHbcwFr5AziLr2mE7KHJT\" } } make_multisig \u00b6 Make a wallet multisig by importing peers multisig string. Alias: None . Inputs: multisig_info - array of string; List of multisig string from peers. threshold - unsigned int; Amount of signatures needed to sign a transfer. Must be less or equal than the amount of signature in multisig_info . password - string; Wallet password Outputs: address - string; multisig wallet address. multisig_info - string; Multisig string to share with peers to create the multisig wallet (extra step for N-1/N wallets). Example for 2/2 Multisig Wallet: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"make_multisig\",\"params\":{\"multisig_info\":[\"MultisigV1K4tGGe8QirZdHgTYoBZMumSug97fdDyM3Z63M3ZY5VXvAdoZvx16HJzPCP4Rp2ABMKUqLD2a74ugMdBfrVpKt4BwD8qCL5aZLrsYWoHiA7JJwDESuhsC3eF8QC9UMvxLXEMsMVh16o98GnKRYz1HCKXrAEWfcrCHyz3bLW1Pdggyowop\"],\"threshold\":2}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"address\": \"55SoZTKH7D39drxfgT62k8T4adVFjmDLUXnbzEKYf1MoYwnmTNKKaqGfxm4sqeKCHXQ5up7PVxrkoeRzXu83d8xYURouMod\", \"multisig_info\": \"\" } } Example for 2/3 Multisig Wallet: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"make_multisig\",\"params\":{\"multisig_info\":[\"MultisigV1MTVm4DZAdJw1PyVutpSy8Q4WisZBCFRAaZY7hhQnMwr5AZ4swzThyaSiVVQM5FHj1JQi3zPKhQ4k81BZkPSEaFjwRJtbfqfJcVvCqRnmBVcWVxhnihX5s8fZWBCjKrzT3CS95spG4dzNzJSUcjheAkLzCpVmSzGtgwMhAS3Vuz9Pas24\",\"MultisigV1TEx58ycKCd6ADCfxF8hALpcdSRAkhZTi1bu4Rs6FdRC98EdB1LY7TAkMxasM55khFgcxrSXivaSr5FCMyJGHmojm1eE4HpGWPeZKv6cgCTThRzC4u6bkkSoFQdbzWN92yn1XEjuP2XQrGHk81mG2LMeyB51MWKJAVF99Pg9mX2BpmYFj\"],\"threshold\":2}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"address\": \"51sLpF8fWaK1111111111111111111111111111111111ABVbHNf1JFWJyFp5YZgZRQ44RiviJi1sPHgLVMbckRsDkTRgKS\", \"multisig_info\": \"MultisigxV18jCaYAQQvzCMUJaAWMCaAbAoHpAD6WPmYDmLtBtazD654E8RWkLaGRf29fJ3stU471MELKxwufNYeigP7LoE4tn2Sscwn5g7PyCfcBc1V4ffRHY3Kxqq6VocSCUTncpVeUskaDKuTAWtdB9VTBGW7iG1cd7Zm1dYgur3CiemkGjRUAj9bL3xTEuyaKGYSDhtpFZFp99HQX57EawhiRHk3qq4hjWX\" } } export_multisig_info \u00b6 Export multisig info for other participants. Alias: None . Inputs: None . Outputs: info - string; Multisig info in hex format for other participants. Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"export_multisig_info\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"info\": \"4d6f6e65726f206d756c7469736967206578706f72740105cf6442b09b75f5eca9d846771fe1a879c9a97ab0553ffbcec64b1148eb7832b51e7898d7944c41cee000415c5a98f4f80dc0efdae379a98805bb6eacae743446f6f421cd03e129eb5b27d6e3b73eb6929201507c1ae706c1a9ecd26ac8601932415b0b6f49cbbfd712e47d01262c59980a8f9a8be776f2bf585f1477a6df63d6364614d941ecfdcb6e958a390eb9aa7c87f056673d73bc7c5f0ab1f74a682e902e48a3322c0413bb7f6fd67404f13fb8e313f70a0ce568c853206751a334ef490068d3c8ca0e\" } } import_multisig_info \u00b6 Import multisig info from other participants. Alias: None . Inputs: info - array of string; List of multisig info in hex format from other participants. Outputs: n_outputs - unsigned int; Number of outputs signed with those multisig info. Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"import_multisig_info\",\"params\":{\"info\":[\"...multisig_info...\"]}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"n_outputs\": 35 } } finalize_multisig \u00b6 Turn this wallet into a multisig wallet, extra step for N-1/N wallets. Alias: None . Inputs: multisig_info - array of string; List of multisig string from peers. password - string; Wallet password Outputs: address - string; multisig wallet address. Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"finalize_multisig\",\"params\":{\"multisig_info\":[\"MultisigxV1JNC6Ja2oBt5Sqea9LN2YEF7WYZCpHqr2EKvPG89Trf3X4E8RWkLaGRf29fJ3stU471MELKxwufNYeigP7LoE4tn2McPr4SbL9q15xNvZT5uwC9YRr7UwjXqSZHmTWN9PBuZEKVAQ4HPPyQciSCdNjgwsuFRBzrskMdMUwNMgKst1debYfm37i6PSzDoS2tk4kYTYj83kkAdR7kdshet1axQPd6HQ\",\"MultisigxV1Unma7Ko4zdd8Ps3Af4oZwtj2JdWKzwNfP6s2G9ZvXhMoSscwn5g7PyCfcBc1V4ffRHY3Kxqq6VocSCUTncpVeUskMcPr4SbL9q15xNvZT5uwC9YRr7UwjXqSZHmTWN9PBuZE1LTpWxLoC3vPMSrqVVcjnmL9LYfdCZz3fECjNZbCEDq3PHDiUuY5jurQTcNoGhDTio5WM9xaAdim9YByiS5KyqF4\"]}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"address\": \"5B9gZUTDuHTcGGuY3nL3t8K2tDnEHeRVHSBQgLZUTQxtFYVLnho5JJjWJyFp5YZgZRQ44RiviJi1sPHgLVMbckRsDqDx1gV\" } } sign_multisig \u00b6 Sign a transaction in multisig. Alias: None . Inputs: tx_data_hex - string; Multisig transaction in hex format, as returned by transfer under multisig_txset . Outputs: tx_data_hex - string; Multisig transaction in hex format. tx_hash_list - array of string; List of transaction Hash. Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"sign_multisig\",\"params\":{\"tx_data_hex\":\"...multisig_txset...\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"tx_data_hex\": \"...multisig_txset...\", \"tx_hash_list\": [\"4996091b61c1be112c1097fd5e97d8ff8b28f0e5e62e1137a8c831bacf034f2d\"] } } submit_multisig \u00b6 Submit a signed multisig transaction. Alias: None . Inputs: tx_data_hex - string; Multisig transaction in hex format, as returned by sign_multisig under tx_data_hex . Outputs: tx_hash_list - array of string; List of transaction Hash. Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"submit_multisig\",\"params\":{\"tx_data_hex\":\"...tx_data_hex...\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"tx_hash_list\": [\"4996091b61c1be112c1097fd5e97d8ff8b28f0e5e62e1137a8c831bacf034f2d\"] } } get_version \u00b6 Get RPC version Major & Minor integer-format, where Major is the first 16 bits and Minor the last 16 bits. Alias: None . Inputs: None . Outputs: version - unsigned int; RPC version, formatted with Major * 2^16 + Minor (Major encoded over the first 16 bits, and Minor over the last 16 bits). Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_version\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"version\": 65539 } } Sources: \u00b6 Reworked GetMonero.org RPC calls for Loki under their copyright license .","title":"Wallet RPC Guide - Old"},{"location":"Developer/WalletRPCGuide/#loki-wallet-rpc","text":"","title":"loki-wallet-rpc"},{"location":"Developer/WalletRPCGuide/#introduction","text":"This is a list of the loki-wallet-rpc calls, their inputs and outputs, and examples of each. The program loki-wallet-rpc replaced the rpc interface that was in simplewallet and then loki-wallet-cli. All loki-wallet-rpc methods use the same JSON RPC interface. For example: IP=127.0.0.1 PORT=18082 METHOD=\"make_integrated_address\" PARAMS=\"{\\\"payment_id\\\":\\\"1234567890123456789012345678900012345678901234567890123456789000\\\"}\" curl \\ -X POST http://$IP:$PORT/json_rpc \\ -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"'$METHOD'\",\"params\":'\"$PARAMS\"'}' \\ -H 'Content-Type: application/json' If the loki-wallet-rpc was executed with the --rpc-login argument as username:password , then follow this example: IP=127.0.0.1 PORT=18082 METHOD=\"make_integrated_address\" PARAMS=\"{\\\"payment_id\\\":\\\"1234567890123456789012345678900012345678901234567890123456789000\\\"}\" curl \\ -u username:password --digest \\ -X POST http://$IP:$PORT/json_rpc \\ -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"'$METHOD'\",\"params\":'\"$PARAMS\"'}' \\ -H 'Content-Type: application/json' Note: \"atomic units\" refer to the smallest fraction of 1 LOKI according to the lokid implementation. 1 LOKI = 1e9 atomic units.","title":"Introduction"},{"location":"Developer/WalletRPCGuide/#index-of-json-rpc-methods","text":"get_balance get_address get_address_index create_address label_address get_accounts create_account label_account get_account_tags tag_accounts untag_accounts set_account_tag_description get_height transfer transfer_split sign_transfer submit_transfer sweep_dust sweep_all sweep_single relay_tx store get_payments get_bulk_payments incoming_transfers query_key make_integrated_address split_integrated_address stop_wallet rescan_blockchain set_tx_notes get_tx_notes set_attribute get_attribute get_tx_key check_tx_key get_tx_proof check_tx_proof get_spend_proof check_spend_proof get_reserve_proof check_reserve_proof get_transfers get_transfer_by_txid sign verify export_outputs import_outputs export_key_images import_key_images make_uri parse_uri get_address_book add_address_book delete_address_book refresh rescan_spent start_mining stop_mining get_languages create_wallet open_wallet close_wallet change_wallet_password is_multisig prepare_multisig make_multisig export_multisig_info import_multisig_info finalize_multisig sign_multisig submit_multisig get_version","title":"Index of JSON RPC Methods:"},{"location":"Developer/WalletRPCGuide/#json-rpc-methods","text":"","title":"JSON RPC Methods:"},{"location":"Developer/WalletRPCGuide/#get_balance","text":"Return the wallet's balance. Alias: getbalance . Inputs: account_index - unsigned int; Return balance for this account. address_indices - array of unsigned int; (Optional) Return balance detail for those subaddresses. Outputs: balance - unsigned int; The total balance of the current loki-wallet-rpc in session. unlocked_balance - unsigned int; Unlocked funds are those funds that are sufficiently deep enough in the loki blockchain to be considered safe to spend. multisig_import_needed - boolean; True if importing multisig data is needed for returning a correct balance. per_subaddress - array of subaddress information; Balance information for each subaddress in an account. address_index - unsigned int; Index of the subaddress in the account. address - string; Address at this index. Base58 representation of the public keys. balance - unsigned int; Balance for the subaddress (locked or unlocked). unlocked_balance - unsigned int; Unlocked balance for the subaddress. label - string; Label for the subaddress. num_unspent_outputs - unsigned int; Number of unspent outputs available for the subaddress. Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_balance\",\"params\":{\"account_index\":0,\"address_indices\":[0,1]}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"balance\": 157443303037455077, \"multisig_import_needed\": false, \"per_subaddress\": [{ \"address\": \"55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt\", \"address_index\": 0, \"balance\": 157360317826255077, \"label\": \"Primary account\", \"num_unspent_outputs\": 5281, \"unlocked_balance\": 157360317826255077 },{ \"address\": \"7BnERTpvL5MbCLtj5n9No7J5oE5hHiB3tVCK5cjSvCsYWD2WRJLFuWeKTLiXo5QJqt2ZwUaLy2Vh1Ad51K7FNgqcHgjW85o\", \"address_index\": 1, \"balance\": 59985211200000, \"label\": \"\", \"num_unspent_outputs\": 1, \"unlocked_balance\": 59985211200000 }], \"unlocked_balance\": 157443303037455077 } }","title":"get_balance"},{"location":"Developer/WalletRPCGuide/#get_address","text":"Return the wallet's addresses for an account. Optionally filter for specific set of subaddresses. Alias: getaddress . Inputs: account_index - unsigned int; Return subaddresses for this account. address_index - array of unsigned int; (Optional) List of subaddresses to return from an account. Outputs: address - string; The 95-character hex address string of the loki-wallet-rpc in session. addresses array of addresses informations address string; The 95-character hex (sub)address string. label string; Label of the (sub)address address_index unsigned int; index of the subaddress used boolean; states if the (sub)address has already received funds Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_address\",\"params\":{\"account_index\":0,\"address_index\":[0,1,4]}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"address\": \"55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt\", \"addresses\": [{ \"address\": \"55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt\", \"address_index\": 0, \"label\": \"Primary account\", \"used\": true },{ \"address\": \"7BnERTpvL5MbCLtj5n9No7J5oE5hHiB3tVCK5cjSvCsYWD2WRJLFuWeKTLiXo5QJqt2ZwUaLy2Vh1Ad51K7FNgqcHgjW85o\", \"address_index\": 1, \"label\": \"\", \"used\": true },{ \"address\": \"77xa6Dha7kzCQuvmd8iB5VYoMkdenwCNRU9khGhExXQ8KLL3z1N1ZATBD1sFPenyHWT9cm4fVFnCAUApY53peuoZFtwZiw5\", \"address_index\": 4, \"label\": \"test2\", \"used\": true }] } }","title":"get_address"},{"location":"Developer/WalletRPCGuide/#get_address_index","text":"Get account and address indexes from a specific (sub)address Alias: None . Inputs: address - String; (sub)address to look for. Outputs: index - subaddress informations major unsigned int; Account index. minor unsigned int; Address index. Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_address_index\",\"params\":{\"address\":\"7BnERTpvL5MbCLtj5n9No7J5oE5hHiB3tVCK5cjSvCsYWD2WRJLFuWeKTLiXo5QJqt2ZwUaLy2Vh1Ad51K7FNgqcHgjW85o\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"index\": { \"major\": 0, \"minor\": 1 } } }","title":"get_address_index"},{"location":"Developer/WalletRPCGuide/#create_address","text":"Create a new address for an account. Optionally, label the new address. Alias: None . Inputs: account_index - unsigned int; Create a new address for this account. label - string; (Optional) Label for the new address. Outputs: address - string; Newly created address. Base58 representation of the public keys. address_index - unsigned int; Index of the new address under the input account. Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"create_address\",\"params\":{\"account_index\":0,\"label\":\"new-sub\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"address\": \"7BG5jr9QS5sGMdpbBrZEwVLZjSKJGJBsXdZLt8wiXyhhLjy7x2LZxsrAnHTgD8oG46ZtLjUGic2pWc96GFkGNPQQDA3Dt7Q\", \"address_index\": 5 } }","title":"create_address"},{"location":"Developer/WalletRPCGuide/#label_address","text":"Label an address. Alias: None . Inputs: index - subaddress index; JSON Object containing the major & minor address index: major - unsigned int; Account index for the subaddress. minor - unsigned int; Index of the subaddress in the account. label - string; Label for the address. Outputs: None . Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"label_address\",\"params\":{\"index\":{\"major\":0,\"minor\":5},\"label\":\"myLabel\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { } }","title":"label_address"},{"location":"Developer/WalletRPCGuide/#get_accounts","text":"Get all accounts for a wallet. Optionally filter accounts by tag. Alias: None . Inputs: tag - string; (Optional) Tag for filtering accounts. Outputs: subaddress_accounts - array of subaddress account information: account_index - unsigned int; Index of the account. balance - unsigned int; Balance of the account (locked or unlocked). base_address - string; Base64 representation of the first subaddress in the account. label - string; (Optional) Label of the account. tag - string; (Optional) Tag for filtering accounts. unlocked_balance - unsigned int; Unlocked balance for the account. total_balance - unsigned int; Total balance of the selected accounts (locked or unlocked). total_unlocked_balance - unsigned int; Total unlocked balance of the selected accounts. Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_accounts\",\"params\":{\"tag\":\"myTag\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"subaddress_accounts\": [{ \"account_index\": 0, \"balance\": 157663195572433688, \"base_address\": \"55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt\", \"label\": \"Primary account\", \"tag\": \"myTag\", \"unlocked_balance\": 157443303037455077 },{ \"account_index\": 1, \"balance\": 0, \"base_address\": \"77Vx9cs1VPicFndSVgYUvTdLCJEZw9h81hXLMYsjBCXSJfUehLa9TDW3Ffh45SQa7xb6dUs18mpNxfUhQGqfwXPSMrvKhVp\", \"label\": \"Secondary account\", \"tag\": \"myTag\", \"unlocked_balance\": 0 }], \"total_balance\": 157663195572433688, \"total_unlocked_balance\": 157443303037455077 } }","title":"get_accounts"},{"location":"Developer/WalletRPCGuide/#create_account","text":"Create a new account with an optional label. Alias: None . Inputs: label - string; (Optional) Label for the account. Outputs: account_index - unsigned int; Index of the new account. address - string; Address for this account. Base58 representation of the public keys. Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"create_account\",\"params\":{\"label\":\"Secondary account\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"account_index\": 1, \"address\": \"77Vx9cs1VPicFndSVgYUvTdLCJEZw9h81hXLMYsjBCXSJfUehLa9TDW3Ffh45SQa7xb6dUs18mpNxfUhQGqfwXPSMrvKhVp\" } }","title":"create_account"},{"location":"Developer/WalletRPCGuide/#label_account","text":"Label an account. Alias: None . Inputs: account_index - unsigned int; Apply label to account at this index. label - string; Label for the account. Outputs: None . Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"label_account\",\"params\":{\"account_index\":0,\"label\":\"Primary account\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"account_tags\": [{ \"accounts\": [0,1], \"label\": \"\", \"tag\": \"myTag\" }] } }","title":"label_account"},{"location":"Developer/WalletRPCGuide/#get_account_tags","text":"Get a list of user-defined account tags. Alias: None . Inputs: None . Outputs: account_tags - array of account tag information: tag - string; Filter tag. label - string; Label for the tag. accounts - array of int; List of tagged account indices. Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_account_tags\",\"params\":\"\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"account_tags\": [{ \"accounts\": [0], \"label\": \"Test tag\", \"tag\": \"myTag\" }] } }","title":"get_account_tags"},{"location":"Developer/WalletRPCGuide/#tag_accounts","text":"Apply a filtering tag to a list of accounts. Alias: None . Inputs: tag - string; Tag for the accounts. accounts - array of unsigned int; Tag this list of accounts. Outputs: None . Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"tag_accounts\",\"params\":{\"tag\":\"myTag\",\"accounts\":[0,1]}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { } }","title":"tag_accounts"},{"location":"Developer/WalletRPCGuide/#untag_accounts","text":"Remove filtering tag from a list of accounts. Alias: None . Inputs: accounts - array of unsigned int; Remove tag from this list of accounts. Outputs: None . Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"untag_accounts\",\"params\":{\"accounts\":[1]}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { } }","title":"untag_accounts"},{"location":"Developer/WalletRPCGuide/#set_account_tag_description","text":"Set description for an account tag. Alias: None . Inputs: tag - string; Set a description for this tag. description - string; Description for the tag. Outputs: None . Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"set_account_tag_description\",\"params\":{\"tag\":\"myTag\",\"description\":\"Test tag\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { } }","title":"set_account_tag_description"},{"location":"Developer/WalletRPCGuide/#get_height","text":"Returns the wallet's current block height. Alias: getheight . Inputs: None . Outputs: height - unsigned int; The current loki-wallet-rpc's blockchain height. If the wallet has been offline for a long time, it may need to catch up with the daemon. Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_height\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"height\": 145545 } }","title":"get_height"},{"location":"Developer/WalletRPCGuide/#transfer","text":"Send loki to a number of recipients. Alias: None . Inputs: destinations - array of destinations to receive LOKI: amount - unsigned int; Amount to send to each destination, in atomic units. address - string; Destination public address. account_index - unsigned int; (Optional) Transfer from this account index. (Defaults to 0) subaddr_indices - array of unsigned int; (Optional) Transfer from this set of subaddresses. (Defaults to 0) priority - unsigned int; Set a priority for the transaction. Accepted Values are: 0-3 for: default, unimportant, normal, elevated, priority. mixin - unsigned int; Number of outputs from the blockchain to mix with (0 means no mixing). ring_size - unsigned int; Number of outputs to mix in the transaction (this output + N decoys from the blockchain). unlock_time - unsigned int; Number of blocks before the loki can be spent (0 to not add a lock). payment_id - string; (Optional) Random 32-byte/64-character hex string to identify a transaction. get_tx_key - boolean; (Optional) Return the transaction key after sending. do_not_relay - boolean; (Optional) If true, the newly created transaction will not be relayed to the loki network. (Defaults to false) get_tx_hex - boolean; Return the transaction as hex string after sending (Defaults to false) get_tx_metadata - boolean; Return the metadata needed to relay the transaction. (Defaults to false) Outputs: amount - Amount transferred for the transaction. fee - Integer value of the fee charged for the txn. multisig_txset - Set of multisig transactions in the process of being signed (empty for non-multisig). tx_blob - Raw transaction represented as hex string, if get_tx_hex is true. tx_hash - String for the publically searchable transaction hash. tx_key - String for the transaction key if get_tx_key is true, otherwise, blank string. tx_metadata - Set of transaction metadata needed to relay this transfer later, if get_tx_metadata is true. unsigned_txset - String. Set of unsigned tx for cold-signing purposes. Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"transfer\",\"params\":{\"destinations\":[{\"amount\":100000000000,\"address\":\"7BnERTpvL5MbCLtj5n9No7J5oE5hHiB3tVCK5cjSvCsYWD2WRJLFuWeKTLiXo5QJqt2ZwUaLy2Vh1Ad51K7FNgqcHgjW85o\"},{\"amount\":200000000000,\"address\":\"75sNpRwUtekcJGejMuLSGA71QFuK1qcCVLZnYRTfQLgFU5nJ7xiAHtR5ihioS53KMe8pBhH61moraZHyLoG4G7fMER8xkNv\"}],\"account_index\":0,\"subaddr_indices\":[0],\"priority\":0,\"ring_size\":7,\"get_tx_key\": true}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"amount\": 300000000000, \"fee\": 86897600000, \"multisig_txset\": \"\", \"tx_blob\": \"\", \"tx_hash\": \"7663438de4f72b25a0e395b770ea9ecf7108cd2f0c4b75be0b14a103d3362be9\", \"tx_key\": \"25c9d8ec20045c80c93d665c9d3684aab7335f8b2cd02e1ba2638485afd1c70e236c4bdd7a2f1cb511dbf466f13421bdf8df988b7b969c448ca6239d7251490e4bf1bbf9f6ffacffdcdc93b9d1648ec499eada4d6b4e02ce92d4a1c0452e5d009fbbbf15b549df8856205a4c7bda6338d82c823f911acd00cb75850b198c5803\", \"tx_metadata\": \"\", \"unsigned_txset\": \"\" } }","title":"transfer"},{"location":"Developer/WalletRPCGuide/#transfer_split","text":"Same as transfer, but can split into more than one tx if necessary. Alias: None . Inputs: destinations - array of destinations to receive LOKI: amount - unsigned int; Amount to send to each destination, in atomic units. address - string; Destination public address. account_index - unsigned int; (Optional) Transfer from this account index. (Defaults to 0) subaddr_indices - array of unsigned int; (Optional) Transfer from this set of subaddresses. (Defaults to 0) mixin - unsigned int; Number of outputs from the blockchain to mix with (0 means no mixing). ring_size - unsigned int; Sets ringsize to n (mixin + 1). unlock_time - unsigned int; Number of blocks before the loki can be spent (0 to not add a lock). payment_id - string; (Optional) Random 32-byte/64-character hex string to identify a transaction. get_tx_keys - boolean; (Optional) Return the transaction keys after sending. priority - unsigned int; Set a priority for the transactions. Accepted Values are: 0-3 for: default, unimportant, normal, elevated, priority. do_not_relay - boolean; (Optional) If true, the newly created transaction will not be relayed to the loki network. (Defaults to false) get_tx_hex - boolean; Return the transactions as hex string after sending new_algorithm - boolean; True to use the new transaction construction algorithm, defaults to false. get_tx_metadata - boolean; Return list of transaction metadata needed to relay the transfer later. Outputs: tx_hash_list - array of: string. The tx hashes of every transaction. tx_key_list - array of: string. The transaction keys for every transaction. amount_list - array of: integer. The amount transferred for every transaction. fee_list - array of: integer. The amount of fees paid for every transaction. tx_blob_list - array of: string. The tx as hex string for every transaction. tx_metadata_list - array of: string. List of transaction metadata needed to relay the transactions later. multisig_txset - string. The set of signing keys used in a multisig transaction (empty for non-multisig). unsigned_txset - string. Set of unsigned tx for cold-signing purposes. Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"transfer_split\",\"params\":{\"destinations\":[{\"amount\":1000000000000,\"address\":\"7BnERTpvL5MbCLtj5n9No7J5oE5hHiB3tVCK5cjSvCsYWD2WRJLFuWeKTLiXo5QJqt2ZwUaLy2Vh1Ad51K7FNgqcHgjW85o\"},{\"amount\":2000000000000,\"address\":\"75sNpRwUtekcJGejMuLSGA71QFuK1qcCVLZnYRTfQLgFU5nJ7xiAHtR5ihioS53KMe8pBhH61moraZHyLoG4G7fMER8xkNv\"}],\"account_index\":0,\"subaddr_indices\":[0],\"priority\":0,\"ring_size\":7,\"get_tx_key\": true}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"amount_list\": [3000000000000], \"fee_list\": [85106400000], \"multisig_txset\": \"\", \"tx_hash_list\": [\"c8d815f48f27d53fdaf198a74b292a91bfaf87529a9a9a9ee66079a890b3b58b\"], \"unsigned_txset\": \"\" } }","title":"transfer_split"},{"location":"Developer/WalletRPCGuide/#sign_transfer","text":"Sign a transaction created on a read-only wallet (in cold-signing process) Alias: None . Inputs: unsigned_txset - string. Set of unsigned tx returned by \"transfer\" or \"transfer_split\" methods. export_raw - boolean; (Optional) If true, return the raw transaction data. (Defaults to false) Outputs: signed_txset - string. Set of signed tx to be used for submitting transfer. tx_hash_list - array of: string. The tx hashes of every transaction. tx_raw_list - array of: string. The tx raw data of every transaction. In the example below, we first generate an unsigned_txset on a read only wallet before signing it: Generate unsigned_txset using the above \"transfer\" method on read-only wallet: curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"transfer\",\"params\":{\"destinations\":[{\"amount\":1000000000000,\"address\":\"7BnERTpvL5MbCLtj5n9No7J5oE5hHiB3tVCK5cjSvCsYWD2WRJLFuWeKTLiXo5QJqt2ZwUaLy2Vh1Ad51K7FNgqcHgjW85o\"}],\"account_index\":0,\"subaddr_indices\":[0],\"priority\":0,\"ring_size\":7,\"do_not_relay\":true,\"get_tx_hex\":true}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"amount\": 1000000000000, \"fee\": 15202740000, \"multisig_txset\": \"\", \"tx_blob\": \"...long_hex...\", \"tx_hash\": \"c648ba0a049e5ce4ec21361dbf6e4b21eac0f828eea9090215de86c76b31d0a4\", \"tx_key\": \"\", \"tx_metadata\": \"\", \"unsigned_txset\": \"...long_hex...\" } } Sign tx using the previously generated unsigned_txset $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"sign_transfer\",\"params\":{\"unsigned_txset\":...long_hex...\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"signed_txset\": \"...long_hex...\", \"tx_hash_list\": [\"ff2e2d49fbfb1c9a55754f786576e171c8bf21b463a74438df604b7fa6cebc6d\"] } }","title":"sign_transfer"},{"location":"Developer/WalletRPCGuide/#submit_transfer","text":"Submit a previously signed transaction on a read-only wallet (in cold-signing process). Alias: None . Inputs: tx_data_hex - string; Set of signed tx returned by \"sign_transfer\" Outputs: tx_hash_list - array of: string. The tx hashes of every transaction. In the example below, we submit the transfer using the signed_txset generated above: curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"submit_transfer\",\"params\":{\"tx_data_hex\":...long_hex...\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"tx_hash_list\": [\"40fad7c828bb383ac02648732f7afce9adc520ba5629e1f5d9c03f584ac53d74\"] } }","title":"submit_transfer"},{"location":"Developer/WalletRPCGuide/#sweep_dust","text":"Send all dust outputs back to the wallet's, to make them easier to spend (and mix). Alias: sweep_unmixable . Inputs: get_tx_keys - boolean; (Optional) Return the transaction keys after sending. do_not_relay - boolean; (Optional) If true, the newly created transaction will not be relayed to the loki network. (Defaults to false) get_tx_hex - boolean; (Optional) Return the transactions as hex string after sending. (Defaults to false) get_tx_metadata - boolean; (Optional) Return list of transaction metadata needed to relay the transfer later. (Defaults to false) Outputs: tx_hash_list - array of: string. The tx hashes of every transaction. tx_key_list - array of: string. The transaction keys for every transaction. amount_list - array of: integer. The amount transferred for every transaction. fee_list - array of: integer. The amount of fees paid for every transaction. tx_blob_list - array of: string. The tx as hex string for every transaction. tx_metadata_list - array of: string. List of transaction metadata needed to relay the transactions later. multisig_txset - string. The set of signing keys used in a multisig transaction (empty for non-multisig). unsigned_txset - string. Set of unsigned tx for cold-signing purposes. Example (In this example, sweep_dust returns nothing because there are no funds to sweep): $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"sweep_dust\",\"params\":{\"get_tx_keys\":true}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"multisig_txset\": \"\", \"unsigned_txset\": \"\" } }","title":"sweep_dust"},{"location":"Developer/WalletRPCGuide/#sweep_all","text":"Send all unlocked balance to an address. Alias: None . Inputs: address - string; Destination public address. account_index - unsigned int; Sweep transactions from this account. subaddr_indices - array of unsigned int; (Optional) Sweep from this set of subaddresses in the account. priority - unsigned int; (Optional) Priority for sending the sweep transfer, partially determines fee. mixin - unsigned int; Number of outputs from the blockchain to mix with (0 means no mixing). ring_size - unsigned int; Sets ringsize to n (mixin + 1). unlock_time - unsigned int; Number of blocks before the loki can be spent (0 to not add a lock). payment_id - string; (Optional) Random 32-byte/64-character hex string to identify a transaction. get_tx_keys - boolean; (Optional) Return the transaction keys after sending. below_amount - unsigned int; (Optional) Include outputs below this amount. do_not_relay - boolean; (Optional) If true, do not relay this sweep transfer. (Defaults to false) get_tx_hex - boolean; (Optional) return the transactions as hex encoded string. (Defaults to false) get_tx_metadata - boolean; (Optional) return the transaction metadata as a string. (Defaults to false) Outputs: tx_hash_list - array of: string. The tx hashes of every transaction. tx_key_list - array of: string. The transaction keys for every transaction. amount_list - array of: integer. The amount transferred for every transaction. fee_list - array of: integer. The amount of fees paid for every transaction. tx_blob_list - array of: string. The tx as hex string for every transaction. tx_metadata_list - array of: string. List of transaction metadata needed to relay the transactions later. multisig_txset - string. The set of signing keys used in a multisig transaction (empty for non-multisig). unsigned_txset - string. Set of unsigned tx for cold-signing purposes. Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"sweep_all\",\"params\":{\"address\":\"55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt\",\"subaddr_indices\":[4],\"ring_size\":7,\"unlock_time\":0,\"get_tx_keys\":true}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"amount_list\": [9985885770000], \"fee_list\": [14114230000], \"multisig_txset\": \"\", \"tx_hash_list\": [\"ab4b6b65cc8cd8c9dd317d0b90d97582d68d0aa1637b0065b05b61f9a66ea5c5\"], \"tx_key_list\": [\"b9b4b39d3bb3062ddb85ec0266d4df39058f4c86077d99309f218ce4d76af607\"], \"unsigned_txset\": \"\" } }","title":"sweep_all"},{"location":"Developer/WalletRPCGuide/#sweep_single","text":"Send all of a specific unlocked output to an address. Alias: None . Inputs: address - string; Destination public address. account_index - unsigned int; Sweep transactions from this account. subaddr_indices - array of unsigned int; (Optional) Sweep from this set of subaddresses in the account. priority - unsigned int; (Optional) Priority for sending the sweep transfer, partially determines fee. mixin - unsigned int; Number of outputs from the blockchain to mix with (0 means no mixing). ring_size - unsigned int; Sets ringsize to n (mixin + 1). unlock_time - unsigned int; Number of blocks before the loki can be spent (0 to not add a lock). payment_id - string; (Optional) Random 32-byte/64-character hex string to identify a transaction. get_tx_keys - boolean; (Optional) Return the transaction keys after sending. key_image - string; Key image of specific output to sweep. below_amount - unsigned int; (Optional) Include outputs below this amount. do_not_relay - boolean; (Optional) If true, do not relay this sweep transfer. (Defaults to false) get_tx_hex - boolean; (Optional) return the transactions as hex encoded string. (Defaults to false) get_tx_metadata - boolean; (Optional) return the transaction metadata as a string. (Defaults to false) Outputs: tx_hash_list - array of: string. The tx hashes of every transaction. tx_key_list - array of: string. The transaction keys for every transaction. amount_list - array of: integer. The amount transferred for every transaction. fee_list - array of: integer. The amount of fees paid for every transaction. tx_blob_list - array of: string. The tx as hex string for every transaction. tx_metadata_list - array of: string. List of transaction metadata needed to relay the transactions later. multisig_txset - string. The set of signing keys used in a multisig transaction (empty for non-multisig). unsigned_txset - string. Set of unsigned tx for cold-signing purposes. Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"sweep_single\",\"params\":{\"address\":\"74Jsocx8xbpTBEjm3ncKE5LBQbiJouyCDaGhgSiebpvNDXZnTAbW2CmUR5SsBeae2pNk9WMVuz6jegkC4krUyqRjA6VjoLD\",\"ring_size\":7,\"unlock_time\":0,\"key_image\":\"a7834459ef795d2efb6f665d2fd758c8d9288989d8d4c712a68f8023f7804a5e\",\"get_tx_keys\":true}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"amount\": 27126892247503, \"fee\": 14111630000, \"multisig_txset\": \"\", \"tx_blob\": \"\", \"tx_hash\": \"106d4391a031e5b735ded555862fec63233e34e5fa4fc7edcfdbe461c275ae5b\", \"tx_key\": \"\", \"tx_metadata\": \"\", \"unsigned_txset\": \"\" } }","title":"sweep_single"},{"location":"Developer/WalletRPCGuide/#relay_tx","text":"Relay a transaction previously created with \"do_not_relay\":true . Alias: None . Inputs: hex - string; transaction metadata returned from a transfer method with get_tx_metadata set to true . Outputs: tx_hash - String for the publically searchable transaction hash. Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"relay_tx\",\"params\":{\"hex\":\"...tx_metadata...\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"tx_hash\": \"1c42dcc5672bb09bccf33fb1e9ab4a498af59a6dbd33b3d0cfb289b9e0e25fa5\" } }","title":"relay_tx"},{"location":"Developer/WalletRPCGuide/#store","text":"Save the wallet file. Alias: None . Inputs: None . Outputs: None . Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"store\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { } }","title":"store"},{"location":"Developer/WalletRPCGuide/#get_payments","text":"Get a list of incoming payments using a given payment id. Alias: None . Inputs: payment_id - string; Payment ID used to find the payments (16 characters hex). Outputs: payments - list of: payment_id - string; Payment ID matching the input parameter. tx_hash - string; Transaction hash used as the transaction ID. amount - unsigned int; Amount for this payment. block_height - unsigned int; Height of the block that first confirmed this payment. unlock_time - unsigned int; Time (in block height) until this payment is safe to spend. subaddr_index - subaddress index: major - unsigned int; Account index for the subaddress. minor - unsigned int; Index of the subaddress in the account. address - string; Address receiving the payment; Base58 representation of the public keys. Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_payments\",\"params\":{\"payment_id\":\"60900e5603bf96e3\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"payments\": [{ \"address\": \"55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt\", \"amount\": 1000000000000, \"block_height\": 127606, \"payment_id\": \"60900e5603bf96e3\", \"subaddr_index\": { \"major\": 0, \"minor\": 0 }, \"tx_hash\": \"3292e83ad28fc1cc7bc26dbd38862308f4588680fbf93eae3e803cddd1bd614f\", \"unlock_time\": 0 }] } }","title":"get_payments"},{"location":"Developer/WalletRPCGuide/#get_bulk_payments","text":"Get a list of incoming payments using a given payment id, or a list of payments ids, from a given height. This method is the preferred method over get_payments because it has the same functionality but is more extendable. Either is fine for looking up transactions by a single payment ID. Alias: None . Inputs: payment_ids - array of: string; Payment IDs used to find the payments (16 characters hex). min_block_height - unsigned int; The block height at which to start looking for payments. Outputs: payments - list of: payment_id - string; Payment ID matching one of the input IDs. tx_hash - string; Transaction hash used as the transaction ID. amount - unsigned int; Amount for this payment. block_height - unsigned int; Height of the block that first confirmed this payment. unlock_time - unsigned int; Time (in block height) until this payment is safe to spend. subaddr_index - subaddress index: major - unsigned int; Account index for the subaddress. minor - unsigned int; Index of the subaddress in the account. address - string; Address receiving the payment; Base58 representation of the public keys. Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_bulk_payments\",\"params\":{\"payment_ids\":[\"60900e5603bf96e3\"],\"min_block_height\":\"120000\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"payments\": [{ \"address\": \"55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt\", \"amount\": 1000000000000, \"block_height\": 127606, \"payment_id\": \"60900e5603bf96e3\", \"subaddr_index\": { \"major\": 0, \"minor\": 0 }, \"tx_hash\": \"3292e83ad28fc1cc7bc26dbd38862308f4588680fbf93eae3e803cddd1bd614f\", \"unlock_time\": 0 }] } }","title":"get_bulk_payments"},{"location":"Developer/WalletRPCGuide/#incoming_transfers","text":"Return a list of incoming transfers to the wallet. Inputs: transfer_type - string; \"all\": all the transfers, \"available\": only transfers which are not yet spent, OR \"unavailable\": only transfers which are already spent. account_index - unsigned int; (Optional) Return transfers for this account. (defaults to 0) subaddr_indices - array of unsigned int; (Optional) Return transfers sent to these subaddresses. verbose - boolean; (Optional) Enable verbose output, return key image if true. Outputs: transfers - list of: amount - unsigned int; Amount of this transfer. global_index - unsigned int; Mostly internal use, can be ignored by most users. key_image - string; Key image for the incoming transfer's unspent output (empty unless verbose is true). spent - boolean; Indicates if this transfer has been spent. subaddr_index - unsigned int; Subaddress index for incoming transfer. tx_hash - string; Several incoming transfers may share the same hash if they were in the same transaction. tx_size - unsigned int; Size of transaction in bytes. Example, get all transfers: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"incoming_transfers\",\"params\":{\"transfer_type\":\"all\",\"account_index\":0,\"subaddr_indices\":[3],\"verbose\":true}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"transfers\": [{ \"amount\": 60000000000000, \"global_index\": 122405, \"key_image\": \"768f5144777eb23477ab7acf83562581d690abaf98ca897c03a9d2b900eb479b\", \"spent\": true, \"subaddr_index\": 3, \"tx_hash\": \"f53401f21c6a43e44d5dd7a90eba5cf580012ad0e15d050059136f8a0da34f6b\", \"tx_size\": 159 },{ \"amount\": 27126892247503, \"global_index\": 594994, \"key_image\": \"7e561394806afd1be61980cc3431f6ef3569fa9151cd8d234f8ec13aa145695e\", \"spent\": false, \"subaddr_index\": 3, \"tx_hash\": \"106d4391a031e5b735ded555862fec63233e34e5fa4fc7edcfdbe461c275ae5b\", \"tx_size\": 157 },{ \"amount\": 27169374733655, \"global_index\": 594997, \"key_image\": \"e76c0a3bfeaae35e4173712f782eb34011198e26b990225b71aa787c8ba8a157\", \"spent\": false, \"subaddr_index\": 3, \"tx_hash\": \"0bd959b59117ee1254bd8e5aa8e77ec04ef744144a1ffb2d5c1eb9380a719621\", \"tx_size\": 158 }] } } Example, get available transfers: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"incoming_transfers\",\"params\":{\"transfer_type\":\"available\",\"account_index\":0,\"subaddr_indices\":[3],\"verbose\":true}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"transfers\": [{ \"amount\": 27126892247503, \"global_index\": 594994, \"key_image\": \"7e561394806afd1be61980cc3431f6ef3569fa9151cd8d234f8ec13aa145695e\", \"spent\": false, \"subaddr_index\": 3, \"tx_hash\": \"106d4391a031e5b735ded555862fec63233e34e5fa4fc7edcfdbe461c275ae5b\", \"tx_size\": 157 },{ \"amount\": 27169374733655, \"global_index\": 594997, \"key_image\": \"e76c0a3bfeaae35e4173712f782eb34011198e26b990225b71aa787c8ba8a157\", \"spent\": false, \"subaddr_index\": 3, \"tx_hash\": \"0bd959b59117ee1254bd8e5aa8e77ec04ef744144a1ffb2d5c1eb9380a719621\", \"tx_size\": 158 }] } } Example, get unavailable transfers: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"incoming_transfers\",\"params\":{\"transfer_type\":\"unavailable\",\"account_index\":0,\"subaddr_indices\":[3],\"verbose\":true}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"transfers\": [{ \"amount\": 60000000000000, \"global_index\": 122405, \"key_image\": \"768f5144777eb23477ab7acf83562581d690abaf98ca897c03a9d2b900eb479b\", \"spent\": true, \"subaddr_index\": 3, \"tx_hash\": \"f53401f21c6a43e44d5dd7a90eba5cf580012ad0e15d050059136f8a0da34f6b\", \"tx_size\": 159 }] } }","title":"incoming_transfers"},{"location":"Developer/WalletRPCGuide/#query_key","text":"Return the spend or view private key. Alias: None . Inputs: key_type - string; Which key to retrieve: \"mnemonic\" - the mnemonic seed (older wallets do not have one) OR \"view_key\" - the view key Outputs: key - string; The view key will be hex encoded, while the mnemonic will be a string of words. Example (Query view key): $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"query_key\",\"params\":{\"key_type\":\"view_key\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"key\": \"0a1a38f6d246e894600a3e27238a064bf5e8d91801df47a17107596b1378e501\" } } Example (Query mnemonic key): $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"query_key\",\"params\":{\"key_type\":\"mnemonic\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"key\": \"vocal either anvil films dolphin zeal bacon cuisine quote syndrome rejoices envy okay pancakes tulips lair greater petals organs enmity dedicated oust thwart tomorrow tomorrow\" } }","title":"query_key"},{"location":"Developer/WalletRPCGuide/#make_integrated_address","text":"Make an integrated address from the wallet address and a payment id. Alias: None . Inputs: standard_address - string; (Optional, defaults to primary address) Destination public address. payment_id - string; (Optional, defaults to a random ID) 16 characters hex encoded. Outputs: integrated_address - string payment_id - string; hex encoded; Example (Payment ID is empty, use a random ID): $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"make_integrated_address\",\"params\":{\"standard_address\":\"55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"integrated_address\": \"5F38Rw9HKeaLQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZXCkbHUXdPHyiUeRyokn\", \"payment_id\": \"420fa29b2d9a49f5\" } }","title":"make_integrated_address"},{"location":"Developer/WalletRPCGuide/#split_integrated_address","text":"Retrieve the standard address and payment id corresponding to an integrated address. Alias: None . Inputs: integrated_address - string Outputs: is_subaddress - boolean; States if the address is a subaddress payment - string; hex encoded standard_address - string Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"split_integrated_address\",\"params\":{\"integrated_address\": \"5F38Rw9HKeaLQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZXCkbHUXdPHyiUeRyokn\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"is_subaddress\": false, \"payment_id\": \"420fa29b2d9a49f5\", \"standard_address\": \"55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt\" } }","title":"split_integrated_address"},{"location":"Developer/WalletRPCGuide/#stop_wallet","text":"Stops the wallet, storing the current state. Alias: None . Inputs: None . Outputs: None . Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"stop_wallet\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { } }","title":"stop_wallet"},{"location":"Developer/WalletRPCGuide/#rescan_blockchain","text":"Rescan the blockchain from scratch, losing any information which can not be recovered from the blockchain itself. This includes destination addresses, tx secret keys, tx notes, etc. Alias: None . Inputs: None . Outputs: None . Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"rescan_blockchain\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { } }","title":"rescan_blockchain"},{"location":"Developer/WalletRPCGuide/#set_tx_notes","text":"Set arbitrary string notes for transactions. Alias: None . Inputs: txids - array of string; transaction ids notes - array of string; notes for the transactions Outputs: None . Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"set_tx_notes\",\"params\":{\"txids\":[\"3292e83ad28fc1cc7bc26dbd38862308f4588680fbf93eae3e803cddd1bd614f\"],\"notes\":[\"This is an example\"]}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { } }","title":"set_tx_notes"},{"location":"Developer/WalletRPCGuide/#get_tx_notes","text":"Get string notes for transactions. Alias: None . Inputs: txids - array of string; transaction ids Outputs: notes - array of string; notes for the transactions Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_tx_notes\",\"params\":{\"txids\":[\"3292e83ad28fc1cc7bc26dbd38862308f4588680fbf93eae3e803cddd1bd614f\"]}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"notes\": [\"This is an example\"] } }","title":"get_tx_notes"},{"location":"Developer/WalletRPCGuide/#set_attribute","text":"Set arbitrary attribute. Alias: None . Inputs: key - string; attribute name value - string; attribute value Outputs: None . Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"set_attribute\",\"params\":{\"key\":\"my_attribute\",\"value\":\"my_value\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { } }","title":"set_attribute"},{"location":"Developer/WalletRPCGuide/#get_attribute","text":"Get attribute value by name. Alias: None . Inputs: key - string; attribute name Outputs: value - string; attribute value Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_attribute\",\"params\":{\"key\":\"my_attribute\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"value\": \"my_value\" } }","title":"get_attribute"},{"location":"Developer/WalletRPCGuide/#get_tx_key","text":"Get transaction secret key from transaction id. Alias: None . Inputs: txid - string; transaction id. Outputs: tx_key - string; transaction secret key. Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_tx_key\",\"params\":{\"txid\":\"19d5089f9469db3d90aca9024dfcb17ce94b948300101c8345a5e9f7257353be\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"tx_key\": \"feba662cf8fb6d0d0da18fc9b70ab28e01cc76311278fdd7fe7ab16360762b06\" } }","title":"get_tx_key"},{"location":"Developer/WalletRPCGuide/#check_tx_key","text":"Check a transaction in the blockchain with its secret key. Alias: None . Inputs: txid - string; transaction id. tx_key - string; transaction secret key. address - string; destination public address of the transaction. Outputs: confirmations - unsigned int; Number of block mined after the one with the transaction. in_pool - boolean; States if the transaction is still in pool or has been added to a block. received - unsigned int; Amount of the transaction. Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"check_tx_key\",\"params\":{\"txid\":\"19d5089f9469db3d90aca9024dfcb17ce94b948300101c8345a5e9f7257353be\",\"tx_key\":\"feba662cf8fb6d0d0da18fc9b70ab28e01cc76311278fdd7fe7ab16360762b06\",\"address\":\"7BnERTpvL5MbCLtj5n9No7J5oE5hHiB3tVCK5cjSvCsYWD2WRJLFuWeKTLiXo5QJqt2ZwUaLy2Vh1Ad51K7FNgqcHgjW85o\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"confirmations\": 0, \"in_pool\": false, \"received\": 1000000000000 } }","title":"check_tx_key"},{"location":"Developer/WalletRPCGuide/#get_tx_proof","text":"Get transaction signature to prove it. Alias: None . Inputs: txid - string; transaction id. address - string; destination public address of the transaction. message - string; (Optional) add a message to the signature to further authenticate the prooving process. Outputs: signature - string; transaction signature. Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_tx_proof\",\"params\":{\"txid\":\"19d5089f9469db3d90aca9024dfcb17ce94b948300101c8345a5e9f7257353be\",\"address\":\"7BnERTpvL5MbCLtj5n9No7J5oE5hHiB3tVCK5cjSvCsYWD2WRJLFuWeKTLiXo5QJqt2ZwUaLy2Vh1Ad51K7FNgqcHgjW85o\",\"message\":\"this is my transaction\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"signature\": \"InProofV13vqBCT6dpSAXkypZmSEMPGVnNRFDX2vscUYeVS4WnSVnV5BwLs31T9q6Etfj9Wts6tAxSAS4gkMeSYzzLS7Gt4vvCSQRh9niGJMUDJsB5hTzb2XJiCkUzWkkcjLFBBRVD5QZ\" } }","title":"get_tx_proof"},{"location":"Developer/WalletRPCGuide/#check_tx_proof","text":"Prove a transaction by checking its signature. Alias: None . Inputs: txid - string; transaction id. address - string; destination public address of the transaction. message - string; (Optional) Should be the same message used in get_tx_proof . signature - string; transaction signature to confirm. Outputs: confirmations - unsigned int; Number of block mined after the one with the transaction. good - boolean; States if the inputs proves the transaction. in_pool - boolean; States if the transaction is still in pool or has been added to a block. received - unsigned int; Amount of the transaction. In the example below, the transaction has been proven: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"check_tx_proof\",\"params\":{\"txid\":\"19d5089f9469db3d90aca9024dfcb17ce94b948300101c8345a5e9f7257353be\",\"address\":\"7BnERTpvL5MbCLtj5n9No7J5oE5hHiB3tVCK5cjSvCsYWD2WRJLFuWeKTLiXo5QJqt2ZwUaLy2Vh1Ad51K7FNgqcHgjW85o\",\"message\":\"this is my transaction\",\"signature\":\"InProofV13vqBCT6dpSAXkypZmSEMPGVnNRFDX2vscUYeVS4WnSVnV5BwLs31T9q6Etfj9Wts6tAxSAS4gkMeSYzzLS7Gt4vvCSQRh9niGJMUDJsB5hTzb2XJiCkUzWkkcjLFBBRVD5QZ\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"confirmations\": 482, \"good\": true, \"in_pool\": false, \"received\": 1000000000000 } } In the example below, the wrong message is used, avoiding the transaction to be proved: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"check_tx_proof\",\"params\":{\"txid\":\"19d5089f9469db3d90aca9024dfcb17ce94b948300101c8345a5e9f7257353be\",\"address\":\"7BnERTpvL5MbCLtj5n9No7J5oE5hHiB3tVCK5cjSvCsYWD2WRJLFuWeKTLiXo5QJqt2ZwUaLy2Vh1Ad51K7FNgqcHgjW85o\",\"message\":\"wrong message\",\"signature\":\"InProofV13vqBCT6dpSAXkypZmSEMPGVnNRFDX2vscUYeVS4WnSVnV5BwLs31T9q6Etfj9Wts6tAxSAS4gkMeSYzzLS7Gt4vvCSQRh9niGJMUDJsB5hTzb2XJiCkUzWkkcjLFBBRVD5QZ\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"confirmations\": 0, \"good\": false, \"in_pool\": false, \"received\": 0 } }","title":"check_tx_proof"},{"location":"Developer/WalletRPCGuide/#get_spend_proof","text":"Generate a signature to prove a spend. Unlike proving a transaction, it does not requires the destination public address. Alias: None . Inputs: txid - string; transaction id. message - string; (Optional) add a message to the signature to further authenticate the prooving process. Outputs: signature - string; spend signature. Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_spend_proof\",\"params\":{\"txid\":\"19d5089f9469db3d90aca9024dfcb17ce94b948300101c8345a5e9f7257353be\",\"message\":\"this is my transaction\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"signature\": \"SpendProofV1aSh8Todhk54736iXgV6vJAFP7egxByuMWZeyNDaN2JY737S95X5zz5mNMQSuCNSLjjhi5HJCsndpNWSNVsuThxwv285qy1KkUrLFRkxMSCjfL6bbycYN33ScZ5UB4Fzseceo1ndpL393T1q638VmcU3a56dhNHF1RPZFiGPS61FA78nXFSqE9uoKCCoHkEz83M1dQVhxZV5CEPF2P6VioGTKgprLCH9vvj9k1ivd4SX19L2VSMc3zD1u3mkR24ioETvxBoLeBSpxMoikyZ6inhuPm8yYo9YWyFtQK4XYfAV9mJ9knz5fUPXR8vvh7KJCAg4dqeJXTVb4mbMzYtsSZXHd6ouWoyCd6qMALdW8pKhgMCHcVYMWp9X9WHZuCo9rsRjRpg15sJUw7oJg1JoGiVgj8P4JeGDjnZHnmLVa5bpJhVCbMhyM7JLXNQJzFWTGC27TQBbthxCfQaKdusYnvZnKPDJWSeceYEFzepUnsWhQtyhbb73FzqgWC4eKEFKAZJqT2LuuSoxmihJ9acnFK7Ze23KTVYgDyMKY61VXADxmSrBvwUtxCaW4nQtnbMxiPMNnDMzeixqsFMBtN72j5UqhiLRY99k6SE7Qf5f29haNSBNSXCFFHChPKNTwJrehkofBdKUhh2VGPqZDNoefWUwfudeu83t85bmjv8Q3LrQSkFgFjRT5tLo8TMawNXoZCrQpyZrEvnodMDDUUNf3NL7rxyv3gM1KrTWjYaWXFU2RAsFee2Q2MTwUW7hR25cJvSFuB1BX2bfkoCbiMk923tHZGU2g7rSKF1GDDkXAc1EvFFD4iGbh1Q5t6hPRhBV8PEncdcCWGq5uAL5D4Bjr6VXG8uNeCy5oYWNgbZ5JRSfm7QEhPv8Fy9AKMgmCxDGMF9dVEaU6tw2BAnJavQdfrxChbDBeQXzCbCfep6oei6n2LZdE5Q84wp7eoQFE5Cwuo23tHkbJCaw2njFi3WGBbA7uGZaGHJPyB2rofTWBiSUXZnP2hiE9bjJghAcDm1M4LVLfWvhZmFEnyeru3VWMETnetz1BYLUC5MJGFXuhnHwWh7F6r74FDyhdswYop4eWPbyrXMXmUQEccTGd2NaT8g2VHADZ76gMC6BjWESvcnz2D4n8XwdmM7ZQ1jFwhuXrBfrb1dwRasyXxxHMGAC2onatNiExyeQ9G1W5LwqNLAh9hvcaNTGaYKYXoceVzLkgm6e5WMkLsCwuZXvB\" } }","title":"get_spend_proof"},{"location":"Developer/WalletRPCGuide/#check_spend_proof","text":"Prove a spend using a signature. Unlike proving a transaction, it does not requires the destination public address. Alias: None . Inputs: txid - string; transaction id. message - string; (Optional) Should be the same message used in get_spend_proof . signature - string; spend signature to confirm. Outputs: good - boolean; States if the inputs proves the spend. In the example below, the spend has been proven: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"check_spend_proof\",\"params\":{\"txid\":\"19d5089f9469db3d90aca9024dfcb17ce94b948300101c8345a5e9f7257353be\",\"message\":\"this is my transaction\",\"signature\":\"SpendProofV1aSh8Todhk54736iXgV6vJAFP7egxByuMWZeyNDaN2JY737S95X5zz5mNMQSuCNSLjjhi5HJCsndpNWSNVsuThxwv285qy1KkUrLFRkxMSCjfL6bbycYN33ScZ5UB4Fzseceo1ndpL393T1q638VmcU3a56dhNHF1RPZFiGPS61FA78nXFSqE9uoKCCoHkEz83M1dQVhxZV5CEPF2P6VioGTKgprLCH9vvj9k1ivd4SX19L2VSMc3zD1u3mkR24ioETvxBoLeBSpxMoikyZ6inhuPm8yYo9YWyFtQK4XYfAV9mJ9knz5fUPXR8vvh7KJCAg4dqeJXTVb4mbMzYtsSZXHd6ouWoyCd6qMALdW8pKhgMCHcVYMWp9X9WHZuCo9rsRjRpg15sJUw7oJg1JoGiVgj8P4JeGDjnZHnmLVa5bpJhVCbMhyM7JLXNQJzFWTGC27TQBbthxCfQaKdusYnvZnKPDJWSeceYEFzepUnsWhQtyhbb73FzqgWC4eKEFKAZJqT2LuuSoxmihJ9acnFK7Ze23KTVYgDyMKY61VXADxmSrBvwUtxCaW4nQtnbMxiPMNnDMzeixqsFMBtN72j5UqhiLRY99k6SE7Qf5f29haNSBNSXCFFHChPKNTwJrehkofBdKUhh2VGPqZDNoefWUwfudeu83t85bmjv8Q3LrQSkFgFjRT5tLo8TMawNXoZCrQpyZrEvnodMDDUUNf3NL7rxyv3gM1KrTWjYaWXFU2RAsFee2Q2MTwUW7hR25cJvSFuB1BX2bfkoCbiMk923tHZGU2g7rSKF1GDDkXAc1EvFFD4iGbh1Q5t6hPRhBV8PEncdcCWGq5uAL5D4Bjr6VXG8uNeCy5oYWNgbZ5JRSfm7QEhPv8Fy9AKMgmCxDGMF9dVEaU6tw2BAnJavQdfrxChbDBeQXzCbCfep6oei6n2LZdE5Q84wp7eoQFE5Cwuo23tHkbJCaw2njFi3WGBbA7uGZaGHJPyB2rofTWBiSUXZnP2hiE9bjJghAcDm1M4LVLfWvhZmFEnyeru3VWMETnetz1BYLUC5MJGFXuhnHwWh7F6r74FDyhdswYop4eWPbyrXMXmUQEccTGd2NaT8g2VHADZ76gMC6BjWESvcnz2D4n8XwdmM7ZQ1jFwhuXrBfrb1dwRasyXxxHMGAC2onatNiExyeQ9G1W5LwqNLAh9hvcaNTGaYKYXoceVzLkgm6e5WMkLsCwuZXvB\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"good\": true } } In the example below, the wrong message is used, avoiding the spend to be proved: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"check_spend_proof\",\"params\":{\"txid\":\"19d5089f9469db3d90aca9024dfcb17ce94b948300101c8345a5e9f7257353be\",\"message\":\"wrong message\",\"signature\":\"SpendProofV1aSh8Todhk54736iXgV6vJAFP7egxByuMWZeyNDaN2JY737S95X5zz5mNMQSuCNSLjjhi5HJCsndpNWSNVsuThxwv285qy1KkUrLFRkxMSCjfL6bbycYN33ScZ5UB4Fzseceo1ndpL393T1q638VmcU3a56dhNHF1RPZFiGPS61FA78nXFSqE9uoKCCoHkEz83M1dQVhxZV5CEPF2P6VioGTKgprLCH9vvj9k1ivd4SX19L2VSMc3zD1u3mkR24ioETvxBoLeBSpxMoikyZ6inhuPm8yYo9YWyFtQK4XYfAV9mJ9knz5fUPXR8vvh7KJCAg4dqeJXTVb4mbMzYtsSZXHd6ouWoyCd6qMALdW8pKhgMCHcVYMWp9X9WHZuCo9rsRjRpg15sJUw7oJg1JoGiVgj8P4JeGDjnZHnmLVa5bpJhVCbMhyM7JLXNQJzFWTGC27TQBbthxCfQaKdusYnvZnKPDJWSeceYEFzepUnsWhQtyhbb73FzqgWC4eKEFKAZJqT2LuuSoxmihJ9acnFK7Ze23KTVYgDyMKY61VXADxmSrBvwUtxCaW4nQtnbMxiPMNnDMzeixqsFMBtN72j5UqhiLRY99k6SE7Qf5f29haNSBNSXCFFHChPKNTwJrehkofBdKUhh2VGPqZDNoefWUwfudeu83t85bmjv8Q3LrQSkFgFjRT5tLo8TMawNXoZCrQpyZrEvnodMDDUUNf3NL7rxyv3gM1KrTWjYaWXFU2RAsFee2Q2MTwUW7hR25cJvSFuB1BX2bfkoCbiMk923tHZGU2g7rSKF1GDDkXAc1EvFFD4iGbh1Q5t6hPRhBV8PEncdcCWGq5uAL5D4Bjr6VXG8uNeCy5oYWNgbZ5JRSfm7QEhPv8Fy9AKMgmCxDGMF9dVEaU6tw2BAnJavQdfrxChbDBeQXzCbCfep6oei6n2LZdE5Q84wp7eoQFE5Cwuo23tHkbJCaw2njFi3WGBbA7uGZaGHJPyB2rofTWBiSUXZnP2hiE9bjJghAcDm1M4LVLfWvhZmFEnyeru3VWMETnetz1BYLUC5MJGFXuhnHwWh7F6r74FDyhdswYop4eWPbyrXMXmUQEccTGd2NaT8g2VHADZ76gMC6BjWESvcnz2D4n8XwdmM7ZQ1jFwhuXrBfrb1dwRasyXxxHMGAC2onatNiExyeQ9G1W5LwqNLAh9hvcaNTGaYKYXoceVzLkgm6e5WMkLsCwuZXvB\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"good\": false } }","title":"check_spend_proof"},{"location":"Developer/WalletRPCGuide/#get_reserve_proof","text":"Generate a signature to prove of an available amount in a wallet. Alias: None . Inputs: all - boolean; Proves all wallet balance to be disposable. account_index - unsigned int; Specify the account from witch to prove reserve. (ignored if all is set to true) amount - unsigned int; Amount (in atomic units) to prove the account has for reserve. (ignored if all is set to true) message - string; (Optional) add a message to the signature to further authenticate the prooving process. Outputs: signature - string; reserve signature. Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_reserve_proof\",\"params\":{\"all\":false,\"account_index\":0,\"amount\":100000000000}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"signature\": \"ReserveProofV11BZ23sBt9sZJeGccf84mzyAmNCP3KzYbE1111112VKmH111118NfCYJQjZ6c46gT2kXgcHCaSSZeL8sRdzqjqx7i1e7FQfQGu2o113UYFVdwzHQi3iENDPa76Kn1BvywbKz3bMkXdZkBEEhBSF4kjjGaiMJ1ucKb6wvMVC4A8sA4nZEdL2Mk3wBucJCYTZwKqA8i1M113kqakDkG25FrjiDqdQTCYz2wDBmfKxF3eQiV5FWzZ6HmAyxnqTWUiMWukP9A3Edy3ZXqjP1b23dhz7Mbj39bBxe3ZeDNu9HnTSqYvHNRyqCkeUMJpHyQweqjGUJ1DSfFYr33J1E7MkhMnEi1o7trqWjVix32XLetYfePG73yvHbS24837L7Q64i5n1LSpd9yMiQZ3Dyaysi5y6jPx7TpAvnSqBFtuCciKoNzaXoA3dqt9cuVFZTXzdXKqdt3cXcVJMNxY8RvKPVQHhUur94Lpo1nSpxf7BN5a5rHrbZFqoZszsZmiWikYPkLX72XUdw6NWjLrTBxSy7KuPYH86c6udPEXLo2xgN6XHMBMBJzt8FqqK7EcpNUBkuHm2AtpGkf9CABY3oSjDQoRF5n4vNLd3qUaxNsG4XJ12L9gJ7GrK273BxkfEA8fDdxPrb1gpespbgEnCTuZHqj1A\" } }","title":"get_reserve_proof"},{"location":"Developer/WalletRPCGuide/#check_reserve_proof","text":"Proves a wallet has a disposable reserve using a signature. Alias: None . Inputs: address - string; Public address of the wallet. message - string; (Optional) Should be the same message used in get_reserve_proof . signature - string; reserve signature to confirm. Outputs: good - boolean; States if the inputs proves the reserve. In the example below, the reserve has been proven: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"check_reserve_proof\",\"params\":{\"address\":\"55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt\",\"signature\":\"ReserveProofV11BZ23sBt9sZJeGccf84mzyAmNCP3KzYbE1111112VKmH111118NfCYJQjZ6c46gT2kXgcHCaSSZeL8sRdzqjqx7i1e7FQfQGu2o113UYFVdwzHQi3iENDPa76Kn1BvywbKz3bMkXdZkBEEhBSF4kjjGaiMJ1ucKb6wvMVC4A8sA4nZEdL2Mk3wBucJCYTZwKqA8i1M113kqakDkG25FrjiDqdQTCYz2wDBmfKxF3eQiV5FWzZ6HmAyxnqTWUiMWukP9A3Edy3ZXqjP1b23dhz7Mbj39bBxe3ZeDNu9HnTSqYvHNRyqCkeUMJpHyQweqjGUJ1DSfFYr33J1E7MkhMnEi1o7trqWjVix32XLetYfePG73yvHbS24837L7Q64i5n1LSpd9yMiQZ3Dyaysi5y6jPx7TpAvnSqBFtuCciKoNzaXoA3dqt9cuVFZTXzdXKqdt3cXcVJMNxY8RvKPVQHhUur94Lpo1nSpxf7BN5a5rHrbZFqoZszsZmiWikYPkLX72XUdw6NWjLrTBxSy7KuPYH86c6udPEXLo2xgN6XHMBMBJzt8FqqK7EcpNUBkuHm2AtpGkf9CABY3oSjDQoRF5n4vNLd3qUaxNsG4XJ12L9gJ7GrK273BxkfEA8fDdxPrb1gpespbgEnCTuZHqj1A\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"good\": true, \"spent\": 0, \"total\": 100000000000 } } In the example below, all wallet reserve has been proven: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"check_reserve_proof\",\"params\":{\"address\":\"55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt\",\"message\":\"I have 10 at least\",\"signature\":\"...signature...\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"good\": true, \"spent\": 0, \"total\": 164113855714662789 } } In the example below, the wrong message is used, avoiding the reserve to be proved: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"check_spend_proof\",\"params\":{\"txid\":\"19d5089f9469db3d90aca9024dfcb17ce94b948300101c8345a5e9f7257353be\",\"message\":\"wrong message\",\"signature\":\"SpendProofV1aSh8Todhk54736iXgV6vJAFP7egxByuMWZeyNDaN2JY737S95X5zz5mNMQSuCNSLjjhi5HJCsndpNWSNVsuThxwv285qy1KkUrLFRkxMSCjfL6bbycYN33ScZ5UB4Fzseceo1ndpL393T1q638VmcU3a56dhNHF1RPZFiGPS61FA78nXFSqE9uoKCCoHkEz83M1dQVhxZV5CEPF2P6VioGTKgprLCH9vvj9k1ivd4SX19L2VSMc3zD1u3mkR24ioETvxBoLeBSpxMoikyZ6inhuPm8yYo9YWyFtQK4XYfAV9mJ9knz5fUPXR8vvh7KJCAg4dqeJXTVb4mbMzYtsSZXHd6ouWoyCd6qMALdW8pKhgMCHcVYMWp9X9WHZuCo9rsRjRpg15sJUw7oJg1JoGiVgj8P4JeGDjnZHnmLVa5bpJhVCbMhyM7JLXNQJzFWTGC27TQBbthxCfQaKdusYnvZnKPDJWSeceYEFzepUnsWhQtyhbb73FzqgWC4eKEFKAZJqT2LuuSoxmihJ9acnFK7Ze23KTVYgDyMKY61VXADxmSrBvwUtxCaW4nQtnbMxiPMNnDMzeixqsFMBtN72j5UqhiLRY99k6SE7Qf5f29haNSBNSXCFFHChPKNTwJrehkofBdKUhh2VGPqZDNoefWUwfudeu83t85bmjv8Q3LrQSkFgFjRT5tLo8TMawNXoZCrQpyZrEvnodMDDUUNf3NL7rxyv3gM1KrTWjYaWXFU2RAsFee2Q2MTwUW7hR25cJvSFuB1BX2bfkoCbiMk923tHZGU2g7rSKF1GDDkXAc1EvFFD4iGbh1Q5t6hPRhBV8PEncdcCWGq5uAL5D4Bjr6VXG8uNeCy5oYWNgbZ5JRSfm7QEhPv8Fy9AKMgmCxDGMF9dVEaU6tw2BAnJavQdfrxChbDBeQXzCbCfep6oei6n2LZdE5Q84wp7eoQFE5Cwuo23tHkbJCaw2njFi3WGBbA7uGZaGHJPyB2rofTWBiSUXZnP2hiE9bjJghAcDm1M4LVLfWvhZmFEnyeru3VWMETnetz1BYLUC5MJGFXuhnHwWh7F6r74FDyhdswYop4eWPbyrXMXmUQEccTGd2NaT8g2VHADZ76gMC6BjWESvcnz2D4n8XwdmM7ZQ1jFwhuXrBfrb1dwRasyXxxHMGAC2onatNiExyeQ9G1W5LwqNLAh9hvcaNTGaYKYXoceVzLkgm6e5WMkLsCwuZXvB\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"good\": false } }","title":"check_reserve_proof"},{"location":"Developer/WalletRPCGuide/#get_transfers","text":"Returns a list of transfers. Alias: None . Inputs: in - boolean; (Optional) Include incoming transfers. out - boolean; (Optional) Include outgoing transfers. pending - boolean; (Optional) Include pending transfers. failed - boolean; (Optional) Include failed transfers. pool - boolean; (Optional) Include transfers from the daemon's transaction pool. filter_by_height - boolean; (Optional) Filter transfers by block height. min_height - unsigned int; (Optional) Minimum block height to scan for transfers, if filtering by height is enabled. max_height - unsigned int; (Opional) Maximum block height to scan for transfers, if filtering by height is enabled (defaults to max block height). account_index - unsigned int; (Optional) Index of the account to query for transfers. (defaults to 0) subaddr_indices - array of unsigned int; (Optional) List of subaddress indices to query for transfers. (defaults to 0) Outputs: in array of transfers: address - string; Public address of the transfer. amount - unsigned int; Amount transferred. confirmations - unsigned int; Number of block mined since the block containing this transaction (or block height at which the transaction should be added to a block if not yet confirmed). double_spend_seen - boolean; True if the key image(s) for the transfer have been seen before. fee - unsigned int; Transaction fee for this transfer. height - unsigned int; Height of the first block that confirmed this transfer (0 if not mined yet). note - string; Note about this transfer. payment_id - string; Payment ID for this transfer. subaddr_index - JSON object containing the major & minor subaddress index: major - unsigned int; Account index for the subaddress. minor - unsigned int; Index of the subaddress under the account. suggested_confirmations_threshold - unsigned int; Estimation of the confirmations needed for the transaction to be included in a block. timestamp - unsigned int; POSIX timestamp for when this transfer was first confirmed in a block (or timestamp submission if not mined yet). txid - string; Transaction ID for this transfer. type - string; Transfer type: \"in\" unlock_time - unsigned int; Number of blocks until transfer is safely spendable. out array of transfers (see above). pending array of transfers (see above). failed array of transfers (see above). pool array of transfers (see above). Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_transfers\",\"params\":{\"in\":true,\"account_index\":1}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"in\": [{ \"address\": \"77Vx9cs1VPicFndSVgYUvTdLCJEZw9h81hXLMYsjBCXSJfUehLa9TDW3Ffh45SQa7xb6dUs18mpNxfUhQGqfwXPSMrvKhVp\", \"amount\": 200000000000, \"confirmations\": 1, \"double_spend_seen\": false, \"fee\": 21650200000, \"height\": 153624, \"note\": \"\", \"payment_id\": \"0000000000000000\", \"subaddr_index\": { \"major\": 1, \"minor\": 0 }, \"suggested_confirmations_threshold\": 1, \"timestamp\": 1535918400, \"txid\": \"c36258a276018c3a4bc1f195a7fb530f50cd63a4fa765fb7c6f7f49fc051762a\", \"type\": \"in\", \"unlock_time\": 0 }] } }","title":"get_transfers"},{"location":"Developer/WalletRPCGuide/#get_transfer_by_txid","text":"Show information about a transfer to/from this address. Alias: None . Inputs: txid - string; Transaction ID used to find the transfer. account_index - unsigned int; (Optional) Index of the account to query for the transfer. Outputs: transfer - JSON object containing payment information: address - string; Address that transferred the funds. Base58 representation of the public keys. amount - unsigned int; Amount of this transfer. confirmations - unsigned int; Number of block mined since the block containing this transaction (or block height at which the transaction should be added to a block if not yet confirmed). destinations - array of JSON objects containing transfer destinations: amount - unsigned int; Amount transferred to this destination. address - string; Address for this destination. Base58 representation of the public keys. double_spend_seen - boolean; True if the key image(s) for the transfer have been seen before. fee - unsigned int; Transaction fee for this transfer. height - unsigned int; Height of the first block that confirmed this transfer. note - string; Note about this transfer. payment_id - string; Payment ID for this transfer. subaddr_index - JSON object containing the major & minor subaddress index: major - unsigned int; Account index for the subaddress. minor - unsigned int; Index of the subaddress under the account. suggested_confirmations_threshold - unsigned int; Estimation of the confirmations needed for the transaction to be included in a block. timestamp - unsigned int; POSIX timestamp for the block that confirmed this transfer (or timestamp submission if not mined yet). txid - string; Transaction ID of this transfer (same as input TXID). type - string; Type of transfer, one of the following: \"in\", \"out\", \"pending\", \"failed\", \"pool\" unlock_time - unsigned int; Number of blocks until transfer is safely spendable. Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_transfer_by_txid\",\"params\":{\"txid\":\"c36258a276018c3a4bc1f195a7fb530f50cd63a4fa765fb7c6f7f49fc051762a\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"transfer\": { \"address\": \"55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt\", \"amount\": 300000000000, \"confirmations\": 1, \"destinations\": [{ \"address\": \"7BnERTpvL5MbCLtj5n9No7J5oE5hHiB3tVCK5cjSvCsYWD2WRJLFuWeKTLiXo5QJqt2ZwUaLy2Vh1Ad51K7FNgqcHgjW85o\", \"amount\": 100000000000 },{ \"address\": \"77Vx9cs1VPicFndSVgYUvTdLCJEZw9h81hXLMYsjBCXSJfUehLa9TDW3Ffh45SQa7xb6dUs18mpNxfUhQGqfwXPSMrvKhVp\", \"amount\": 200000000000 }], \"double_spend_seen\": false, \"fee\": 21650200000, \"height\": 153624, \"note\": \"\", \"payment_id\": \"0000000000000000\", \"subaddr_index\": { \"major\": 0, \"minor\": 0 }, \"suggested_confirmations_threshold\": 1, \"timestamp\": 1535918400, \"txid\": \"c36258a276018c3a4bc1f195a7fb530f50cd63a4fa765fb7c6f7f49fc051762a\", \"type\": \"out\", \"unlock_time\": 0 } } }","title":"get_transfer_by_txid"},{"location":"Developer/WalletRPCGuide/#sign","text":"Sign a string. Alias: None . Inputs: data - string; Anything you need to sign. Outputs: signature - string; Signature generated against the \"data\" and the account public address. Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"sign\",\"params\":{\"data\":\"This is sample data to be signed\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"signature\": \"SigV14K6G151gycjiGxjQ74tKX6A2LwwghvuHjcDeuRFQio5LS6Gb27BNxjYQY1dPuUvXkEbGQUkiHSVLPj4nJAHRrrw3\" } }","title":"sign"},{"location":"Developer/WalletRPCGuide/#verify","text":"Verify a signature on a string. Alias: None . Inputs: data - string; What should have been signed. address - string; Public address of the wallet used to sign the data. signature - string; signature generated by sign method. Outputs: good - boolean; Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"verify\",\"params\":{\"data\":\"This is sample data to be signed\",\"address\":\"55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt\",\"signature\":\"SigV14K6G151gycjiGxjQ74tKX6A2LwwghvuHjcDeuRFQio5LS6Gb27BNxjYQY1dPuUvXkEbGQUkiHSVLPj4nJAHRrrw3\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"good\": true } }","title":"verify"},{"location":"Developer/WalletRPCGuide/#export_outputs","text":"Export all outputs in hex format. Alias: None . Inputs: None . Outputs: outputs_data_hex - string; wallet outputs in hex format. Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"export_outputs\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"outputs_data_hex\": \"...outputs...\" } }","title":"export_outputs"},{"location":"Developer/WalletRPCGuide/#import_outputs","text":"Import outputs in hex format. Alias: None . Inputs: outputs_data_hex - string; wallet outputs in hex format. Outputs: num_imported - unsigned int; number of outputs imported. Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"import_outputs\",\"params\":{\"outputs_data_hex\":\"...outputs...\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"num_imported\": 6400 } }","title":"import_outputs"},{"location":"Developer/WalletRPCGuide/#export_key_images","text":"Export a signed set of key images. Alias: None . Inputs: None . Outputs: signed_key_images - array of signed key images: key_image - string; signature - string; Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"export_key_images\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"signed_key_images\": [{ \"key_image\": \"cd35239b72a35e26a57ed17400c0b66944a55de9d5bda0f21190fed17f8ea876\", \"signature\": \"c9d736869355da2538ab4af188279f84138c958edbae3c5caf388a63cd8e780b8c5a1aed850bd79657df659422c463608ea4e0c730ba9b662c906ae933816d00\" },{ \"key_image\": \"65158a8ee5a3b32009b85a307d85b375175870e560e08de313531c7dbbe6fc19\", \"signature\": \"c96e40d09dfc45cfc5ed0b76bfd7ca793469588bb0cf2b4d7b45ef23d40fd4036057b397828062e31700dc0c2da364f50cd142295a8405b9fe97418b4b745d0c\" },...] } }","title":"export_key_images"},{"location":"Developer/WalletRPCGuide/#import_key_images","text":"Import signed key images list and verify their spent status. Alias: None . Inputs: signed_key_images - array of signed key images: key_image - string; signature - string; Outputs: height - unsigned int; spent - unsigned int; Amount (in atomic units) spent from those key images. unspent - unsigned int; Amount (in atomic units) still available from those key images. Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"import_key_images\", \"params\":{\"signed_key_images\":[{\"key_image\":\"cd35239b72a35e26a57ed17400c0b66944a55de9d5bda0f21190fed17f8ea876\",\"signature\":\"c9d736869355da2538ab4af188279f84138c958edbae3c5caf388a63cd8e780b8c5a1aed850bd79657df659422c463608ea4e0c730ba9b662c906ae933816d00\"},{\"key_image\":\"65158a8ee5a3b32009b85a307d85b375175870e560e08de313531c7dbbe6fc19\",\"signature\":\"c96e40d09dfc45cfc5ed0b76bfd7ca793469588bb0cf2b4d7b45ef23d40fd4036057b397828062e31700dc0c2da364f50cd142295a8405b9fe97418b4b745d0c\"}]}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"height\": 76428, \"spent\": 62708953408711, \"unspent\": 0 } }","title":"import_key_images"},{"location":"Developer/WalletRPCGuide/#make_uri","text":"Create a payment URI using the official URI spec. Alias: None . Inputs: address - string; Wallet address amount - unsigned int; (optional) the integer amount to receive, in atomic units payment_id - string; (optional) 16 or 64 character hexadecimal payment id recipient_name - string; (optional) name of the payment recipient tx_description - string; (optional) Description of the reason for the tx Outputs: uri - string; This contains all the payment input information as a properly formatted payment URI Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"make_uri\",\"params\":{\"address\":\"55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt\",\"amount\":10,\"payment_id\":\"420fa29b2d9a49f5\",\"tx_description\":\"Testing out the make_uri function.\",\"recipient_name\":\"el00ruobuob Stagenet wallet\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"uri\": \"loki:55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt?tx_payment_id=420fa29b2d9a49f5&tx_amount=0.000000000010&recipient_name=el00ruobuob%20Stagenet%20wallet&tx_description=Testing%20out%20the%20make_uri%20function.\" } }","title":"make_uri"},{"location":"Developer/WalletRPCGuide/#parse_uri","text":"Parse a payment URI to get payment information. Alias: None . Inputs: uri - string; This contains all the payment input information as a properly formatted payment URI Outputs: uri - JSON object containing payment information: address - string; Wallet address amount - unsigned int; Decimal amount to receive, in coin units (0 if not provided) payment_id - string; 16 or 64 character hexadecimal payment id (empty if not provided) recipient_name - string; Name of the payment recipient (empty if not provided) tx_description - string; Description of the reason for the tx (empty if not provided) Example: $ curl -X POST http://127.0.0.1:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"parse_uri\",\"params\":{\"uri\":\"loki:55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt?tx_payment_id=420fa29b2d9a49f5&tx_amount=0.000000000010&recipient_name=el00ruobuob%20Stagenet%20wallet&tx_description=Testing%20out%20the%20make_uri%20function.\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"uri\": { \"address\": \"55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt\", \"amount\": 10, \"payment_id\": \"420fa29b2d9a49f5\", \"recipient_name\": \"el00ruobuob Stagenet wallet\", \"tx_description\": \"Testing out the make_uri function.\" } } }","title":"parse_uri"},{"location":"Developer/WalletRPCGuide/#get_address_book","text":"Retrieves entries from the address book. Alias: None . Inputs: entries - array of unsigned int; indices of the requested address book entries Outputs: entries - array of entries: address - string; Public address of the entry description - string; Description of this address entry index - unsigned int; payment_id - string; Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_address_book\",\"params\":{\"entries\":[0,1]}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"entries\": [{ \"address\": \"77Vx9cs1VPicFndSVgYUvTdLCJEZw9h81hXLMYsjBCXSJfUehLa9TDW3Ffh45SQa7xb6dUs18mpNxfUhQGqfwXPSMrvKhVp\", \"description\": \"Second account\", \"index\": 0, \"payment_id\": \"0000000000000000000000000000000000000000000000000000000000000000\" },{ \"address\": \"78P16M3XmFRGcWFCcsgt1WcTntA1jzcq31seQX1Eg92j8VQ99NPivmdKam4J5CKNAD7KuNWcq5xUPgoWczChzdba5WLwQ4j\", \"description\": \"Third account\", \"index\": 1, \"payment_id\": \"0000000000000000000000000000000000000000000000000000000000000000\" }] } }","title":"get_address_book"},{"location":"Developer/WalletRPCGuide/#add_address_book","text":"Add an entry to the address book. Alias: None . Inputs: address - string; payment_id - (optional) string, defaults to \"0000000000000000000000000000000000000000000000000000000000000000\"; description - (optional) string, defaults to \"\"; Outputs: index - unsigned int; The index of the address book entry. Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"add_address_book\",\"params\":{\"address\":\"78P16M3XmFRGcWFCcsgt1WcTntA1jzcq31seQX1Eg92j8VQ99NPivmdKam4J5CKNAD7KuNWcq5xUPgoWczChzdba5WLwQ4j\",\"description\":\"Third account\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"index\": 1 } }","title":"add_address_book"},{"location":"Developer/WalletRPCGuide/#delete_address_book","text":"Delete an entry from the address book. Alias: None . Inputs: index - unsigned int; The index of the address book entry. Outputs: None . Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"delete_address_book\",\"params\":{\"index\":1}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { } }","title":"delete_address_book"},{"location":"Developer/WalletRPCGuide/#refresh","text":"Refresh a wallet after openning. Alias: None . Inputs: start_height - unsigned int; (Optional) The block height from which to start refreshing. Outputs: blocks_fetched - unsigned int; Number of new blocks scanned. received_money - boolean; States if transactions to the wallet have been found in the blocks. Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"refresh\",\"params\":{\"start_height\":100000}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"blocks_fetched\": 24, \"received_money\": true } }","title":"refresh"},{"location":"Developer/WalletRPCGuide/#rescan_spent","text":"Rescan the blockchain for spent outputs. Alias: None . Inputs: None . Outputs: None . Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"rescan_spent\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { } }","title":"rescan_spent"},{"location":"Developer/WalletRPCGuide/#start_mining","text":"Start mining in the loki daemon. Alias: None . Inputs: threads_count - unsigned int; Number of threads created for mining. do_background_mining - boolean; Allow to start the miner in smart mining mode. ignore_battery - boolean; Ignore battery status (for smart mining only) Outputs: None . Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"start_mining\",\"params\":{\"threads_count\":1,\"do_background_mining\":true,\"ignore_battery\":false}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { } }","title":"start_mining"},{"location":"Developer/WalletRPCGuide/#stop_mining","text":"Stop mining in the loki daemon. Alias: None . Inputs: None . Outputs: None . Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"stop_mining\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { } }","title":"stop_mining"},{"location":"Developer/WalletRPCGuide/#get_languages","text":"Get a list of available languages for your wallet's seed. Alias: None . Inputs: None . Outputs: languages - array of string; List of available languages Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_languages\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"languages\": [\"Deutsch\",\"English\",\"Espa\u00f1ol\",\"Fran\u00e7ais\",\"Italiano\",\"Nederlands\",\"Portugu\u00eas\",\"\u0440\u0443\u0441\u0441\u043a\u0438\u0439 \u044f\u0437\u044b\u043a\",\"\u65e5\u672c\u8a9e\",\"\u7b80\u4f53\u4e2d\u6587 (\u4e2d\u56fd)\",\"Esperanto\",\"Lojban\"] } }","title":"get_languages"},{"location":"Developer/WalletRPCGuide/#create_wallet","text":"Create a new wallet. You need to have set the argument \"\u2013wallet-dir\" when launching loki-wallet-rpc to make this work. Alias: None . Inputs: filename - string; Wallet file name. password - string; (Optional) password to protect the wallet. language - string; Language for your wallets' seed. Outputs: None . Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"create_wallet\",\"params\":{\"filename\":\"mytestwallet\",\"password\":\"mytestpassword\",\"language\":\"English\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { } }","title":"create_wallet"},{"location":"Developer/WalletRPCGuide/#open_wallet","text":"Open a wallet. You need to have set the argument \"\u2013wallet-dir\" when launching loki-wallet-rpc to make this work. Alias: None . Inputs: filename - string; wallet name stored in \u2013wallet-dir. password - string; (Optional) only needed if the wallet has a password defined. Outputs: None . Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"open_wallet\",\"params\":{\"filename\":\"mytestwallet\",\"password\":\"mytestpassword\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { } }","title":"open_wallet"},{"location":"Developer/WalletRPCGuide/#close_wallet","text":"Close the currently opened wallet, after trying to save it. Alias: None . Inputs: None . Outputs: None . Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"close_wallet\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { } }","title":"close_wallet"},{"location":"Developer/WalletRPCGuide/#change_wallet_password","text":"Change a wallet password. Alias: None . Inputs: old_password - string; (Optional) Current wallet password, if defined. new_password - string; (Optional) New wallet password, if not blank. Outputs: None . Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"change_wallet_password\",\"params\":{\"old_password\":\"theCurrentSecretPassPhrase\",\"new_password\":\"theNewSecretPassPhrase\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { } }","title":"change_wallet_password"},{"location":"Developer/WalletRPCGuide/#is_multisig","text":"Check if a wallet is a multisig one. Alias: None . Inputs: None . Outputs: multisig - boolean; States if the wallet is multisig ready - boolean; threshold - unsigned int; Amount of signature needed to sign a transfer. total - unsigned int; Total amount of signature in the multisig wallet. Example for a non-multisig wallet: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"is_multisig\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"multisig\": false, \"ready\": false, \"threshold\": 0, \"total\": 0 } } Example for a multisig wallet: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"is_multisig\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"multisig\": true, \"ready\": true, \"threshold\": 2, \"total\": 2 } }","title":"is_multisig"},{"location":"Developer/WalletRPCGuide/#prepare_multisig","text":"Prepare a wallet for multisig by generating a multisig string to share with peers. Alias: None . Inputs: None . Outputs: multisig_info - string; Multisig string to share with peers to create the multisig wallet. Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"prepare_multisig\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"multisig_info\": \"MultisigV1BFdxQ653cQHB8wsj9WJQd2VdnjxK89g5M94dKPBNw22reJnyJYKrz6rJeXdjFwJ3Mz6n4qNQLd6eqUZKLiNzJFi3UPNVcTjtkG2aeSys9sYkvYYKMZ7chCxvoEXVgm74KKUcUu4V8xveCBFadFuZs8shnxBWHbcwFr5AziLr2mE7KHJT\" } }","title":"prepare_multisig"},{"location":"Developer/WalletRPCGuide/#make_multisig","text":"Make a wallet multisig by importing peers multisig string. Alias: None . Inputs: multisig_info - array of string; List of multisig string from peers. threshold - unsigned int; Amount of signatures needed to sign a transfer. Must be less or equal than the amount of signature in multisig_info . password - string; Wallet password Outputs: address - string; multisig wallet address. multisig_info - string; Multisig string to share with peers to create the multisig wallet (extra step for N-1/N wallets). Example for 2/2 Multisig Wallet: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"make_multisig\",\"params\":{\"multisig_info\":[\"MultisigV1K4tGGe8QirZdHgTYoBZMumSug97fdDyM3Z63M3ZY5VXvAdoZvx16HJzPCP4Rp2ABMKUqLD2a74ugMdBfrVpKt4BwD8qCL5aZLrsYWoHiA7JJwDESuhsC3eF8QC9UMvxLXEMsMVh16o98GnKRYz1HCKXrAEWfcrCHyz3bLW1Pdggyowop\"],\"threshold\":2}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"address\": \"55SoZTKH7D39drxfgT62k8T4adVFjmDLUXnbzEKYf1MoYwnmTNKKaqGfxm4sqeKCHXQ5up7PVxrkoeRzXu83d8xYURouMod\", \"multisig_info\": \"\" } } Example for 2/3 Multisig Wallet: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"make_multisig\",\"params\":{\"multisig_info\":[\"MultisigV1MTVm4DZAdJw1PyVutpSy8Q4WisZBCFRAaZY7hhQnMwr5AZ4swzThyaSiVVQM5FHj1JQi3zPKhQ4k81BZkPSEaFjwRJtbfqfJcVvCqRnmBVcWVxhnihX5s8fZWBCjKrzT3CS95spG4dzNzJSUcjheAkLzCpVmSzGtgwMhAS3Vuz9Pas24\",\"MultisigV1TEx58ycKCd6ADCfxF8hALpcdSRAkhZTi1bu4Rs6FdRC98EdB1LY7TAkMxasM55khFgcxrSXivaSr5FCMyJGHmojm1eE4HpGWPeZKv6cgCTThRzC4u6bkkSoFQdbzWN92yn1XEjuP2XQrGHk81mG2LMeyB51MWKJAVF99Pg9mX2BpmYFj\"],\"threshold\":2}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"address\": \"51sLpF8fWaK1111111111111111111111111111111111ABVbHNf1JFWJyFp5YZgZRQ44RiviJi1sPHgLVMbckRsDkTRgKS\", \"multisig_info\": \"MultisigxV18jCaYAQQvzCMUJaAWMCaAbAoHpAD6WPmYDmLtBtazD654E8RWkLaGRf29fJ3stU471MELKxwufNYeigP7LoE4tn2Sscwn5g7PyCfcBc1V4ffRHY3Kxqq6VocSCUTncpVeUskaDKuTAWtdB9VTBGW7iG1cd7Zm1dYgur3CiemkGjRUAj9bL3xTEuyaKGYSDhtpFZFp99HQX57EawhiRHk3qq4hjWX\" } }","title":"make_multisig"},{"location":"Developer/WalletRPCGuide/#export_multisig_info","text":"Export multisig info for other participants. Alias: None . Inputs: None . Outputs: info - string; Multisig info in hex format for other participants. Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"export_multisig_info\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"info\": \"4d6f6e65726f206d756c7469736967206578706f72740105cf6442b09b75f5eca9d846771fe1a879c9a97ab0553ffbcec64b1148eb7832b51e7898d7944c41cee000415c5a98f4f80dc0efdae379a98805bb6eacae743446f6f421cd03e129eb5b27d6e3b73eb6929201507c1ae706c1a9ecd26ac8601932415b0b6f49cbbfd712e47d01262c59980a8f9a8be776f2bf585f1477a6df63d6364614d941ecfdcb6e958a390eb9aa7c87f056673d73bc7c5f0ab1f74a682e902e48a3322c0413bb7f6fd67404f13fb8e313f70a0ce568c853206751a334ef490068d3c8ca0e\" } }","title":"export_multisig_info"},{"location":"Developer/WalletRPCGuide/#import_multisig_info","text":"Import multisig info from other participants. Alias: None . Inputs: info - array of string; List of multisig info in hex format from other participants. Outputs: n_outputs - unsigned int; Number of outputs signed with those multisig info. Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"import_multisig_info\",\"params\":{\"info\":[\"...multisig_info...\"]}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"n_outputs\": 35 } }","title":"import_multisig_info"},{"location":"Developer/WalletRPCGuide/#finalize_multisig","text":"Turn this wallet into a multisig wallet, extra step for N-1/N wallets. Alias: None . Inputs: multisig_info - array of string; List of multisig string from peers. password - string; Wallet password Outputs: address - string; multisig wallet address. Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"finalize_multisig\",\"params\":{\"multisig_info\":[\"MultisigxV1JNC6Ja2oBt5Sqea9LN2YEF7WYZCpHqr2EKvPG89Trf3X4E8RWkLaGRf29fJ3stU471MELKxwufNYeigP7LoE4tn2McPr4SbL9q15xNvZT5uwC9YRr7UwjXqSZHmTWN9PBuZEKVAQ4HPPyQciSCdNjgwsuFRBzrskMdMUwNMgKst1debYfm37i6PSzDoS2tk4kYTYj83kkAdR7kdshet1axQPd6HQ\",\"MultisigxV1Unma7Ko4zdd8Ps3Af4oZwtj2JdWKzwNfP6s2G9ZvXhMoSscwn5g7PyCfcBc1V4ffRHY3Kxqq6VocSCUTncpVeUskMcPr4SbL9q15xNvZT5uwC9YRr7UwjXqSZHmTWN9PBuZE1LTpWxLoC3vPMSrqVVcjnmL9LYfdCZz3fECjNZbCEDq3PHDiUuY5jurQTcNoGhDTio5WM9xaAdim9YByiS5KyqF4\"]}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"address\": \"5B9gZUTDuHTcGGuY3nL3t8K2tDnEHeRVHSBQgLZUTQxtFYVLnho5JJjWJyFp5YZgZRQ44RiviJi1sPHgLVMbckRsDqDx1gV\" } }","title":"finalize_multisig"},{"location":"Developer/WalletRPCGuide/#sign_multisig","text":"Sign a transaction in multisig. Alias: None . Inputs: tx_data_hex - string; Multisig transaction in hex format, as returned by transfer under multisig_txset . Outputs: tx_data_hex - string; Multisig transaction in hex format. tx_hash_list - array of string; List of transaction Hash. Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"sign_multisig\",\"params\":{\"tx_data_hex\":\"...multisig_txset...\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"tx_data_hex\": \"...multisig_txset...\", \"tx_hash_list\": [\"4996091b61c1be112c1097fd5e97d8ff8b28f0e5e62e1137a8c831bacf034f2d\"] } }","title":"sign_multisig"},{"location":"Developer/WalletRPCGuide/#submit_multisig","text":"Submit a signed multisig transaction. Alias: None . Inputs: tx_data_hex - string; Multisig transaction in hex format, as returned by sign_multisig under tx_data_hex . Outputs: tx_hash_list - array of string; List of transaction Hash. Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"submit_multisig\",\"params\":{\"tx_data_hex\":\"...tx_data_hex...\"}}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"tx_hash_list\": [\"4996091b61c1be112c1097fd5e97d8ff8b28f0e5e62e1137a8c831bacf034f2d\"] } }","title":"submit_multisig"},{"location":"Developer/WalletRPCGuide/#get_version","text":"Get RPC version Major & Minor integer-format, where Major is the first 16 bits and Minor the last 16 bits. Alias: None . Inputs: None . Outputs: version - unsigned int; RPC version, formatted with Major * 2^16 + Minor (Major encoded over the first 16 bits, and Minor over the last 16 bits). Example: $ curl -X POST http://localhost:18082/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_version\"}' -H 'Content-Type: application/json' { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"version\": 65539 } }","title":"get_version"},{"location":"Developer/WalletRPCGuide/#sources","text":"Reworked GetMonero.org RPC calls for Loki under their copyright license .","title":"Sources:"},{"location":"Governance/Governance/","text":"Loki Governance \u00b6 Governance is an essential part of cryptocurrency design and should be supported at the protocol level. The risk of weak, informally defined governance has been studied extensively throughout the history of blockchain technology. Bitcoin and Ethereum experienced contentious hard forks that split the focus and efforts of their respective communities. Although hard forks can be used as a governance strategy, they should always be considered as a last resort rather than the solution to every contentious issue. The Loki governance system is designed to resolve potential issues by providing a structured environment for discourse and representation, and also to source funding for the development of Loki without reliance on external influence or altruism. Beyond the prevention of hard forks, governance structures should create the means to internally fund new projects which improve upon the Loki ecosystem. Funding projects internally can prevent the formation of special interest groups that do not necessarily have motives that are in line with the users, miners, or Service Nodes. We have seen this in Bitcoin and various Bitcoin forks with the formation of for-profit companies, such as Blockstream, Bitcoin ABC, and Bitcoin Unlimited, that have been frequently accused of hiring developers to make protocol-specific changes to Bitcoin and Bitcoin Cash aimed to further their own business objectives or follow their specific ideology. It is for this reason that in every Loki block, 5% of the reward is allocated for the purpose of network governance. This provides a steady flow of Loki that will be distributed amongst community projects, software developers, and integration teams. In a future update, of this 5% block reward, 3.75% will be controlled by the Loki Foundation and 1.25% will be controlled by the Service Nodes through the Loki Funding System . This will encourage fair representation of the Service Nodes and will allow for community funding proposals that can occur outside of the direct control of the Loki Foundation.","title":"Overview"},{"location":"Governance/Governance/#loki-governance","text":"Governance is an essential part of cryptocurrency design and should be supported at the protocol level. The risk of weak, informally defined governance has been studied extensively throughout the history of blockchain technology. Bitcoin and Ethereum experienced contentious hard forks that split the focus and efforts of their respective communities. Although hard forks can be used as a governance strategy, they should always be considered as a last resort rather than the solution to every contentious issue. The Loki governance system is designed to resolve potential issues by providing a structured environment for discourse and representation, and also to source funding for the development of Loki without reliance on external influence or altruism. Beyond the prevention of hard forks, governance structures should create the means to internally fund new projects which improve upon the Loki ecosystem. Funding projects internally can prevent the formation of special interest groups that do not necessarily have motives that are in line with the users, miners, or Service Nodes. We have seen this in Bitcoin and various Bitcoin forks with the formation of for-profit companies, such as Blockstream, Bitcoin ABC, and Bitcoin Unlimited, that have been frequently accused of hiring developers to make protocol-specific changes to Bitcoin and Bitcoin Cash aimed to further their own business objectives or follow their specific ideology. It is for this reason that in every Loki block, 5% of the reward is allocated for the purpose of network governance. This provides a steady flow of Loki that will be distributed amongst community projects, software developers, and integration teams. In a future update, of this 5% block reward, 3.75% will be controlled by the Loki Foundation and 1.25% will be controlled by the Service Nodes through the Loki Funding System . This will encourage fair representation of the Service Nodes and will allow for community funding proposals that can occur outside of the direct control of the Loki Foundation.","title":"Loki Governance"},{"location":"Governance/LokiFundingSystem/","text":"Loki Funding System \u00b6 Note: The loki Funding System has not been implemented at this current time. When implemented the Loki Funding System may be different to the below information. Although the Loki Foundation is made from a diverse group of individuals who represent the Loki Project, the Foundation is subject to both its own governing constitution and the laws of Australia. This could prove to be a limiting factor in the range of decisions the Foundation can make. The Loki Funding System will allow for a portion of the block reward to be acted on purely by a vote from the Service Nodes . Service Nodes represent entities from all over the world and are not beholden to input from the Loki Project Team or Foundation, this allows them to reach a new level of autonomy in the decisions they can make. Service Nodes are the most staked participants in the network and they are financially incentivised to make decisions that grow the value of Loki. Proposals \u00b6 Every proposal that will be put before the Service Nodes will be published on the Loki blockchain. If a given party wants to present a proposal to the Service Nodes, the party must construct a proposal transaction. Because the proposal transactions content must be readable and outputs must be burned, they forgo the privacy features of typical Loki transactions. Funding blocks will be created every 43,000 blocks (approximately 60 Days). Proposal leaders can submit their proposals at any time during this period. However, it should be considered that the closer they submit to the beginning of each proposal phase, the more time they have to gain votes from each Service Node. Attached to each transaction is an extra field which contains the information that each Service Node needs to understand to vote on the proposal.This information includes; a 20 character proposal title, a URL linking to a detailed explanation of the proposal, the amount of Loki the proposal is seeking, a payment address, and an escrow agent if chosen. Pending agreement from the Loki Foundation , users who make proposals can also elect for the Loki Foundation or any other third-party to act as an escrow agent, releasing funds as milestones are reached. Additionally, to encourage a high-standard of proposals and prevent spamming of these transactions, each proposal transaction must burn a non-trivial amount of Loki. Voting \u00b6 Each Service Nodes will carry a specific key for voting. This key can be exported and utilized to vote on behalf of a Service Node without having to login to the server where it is hosted. Voting will not occur on chain, rather, each Service Node signals their support, dissent, or abstinence for each active proposal on the blockchain. Service Nodes can vote on proposals as soon as they are committed to the blockchain until the next bimonthly funding block. Shortly before the creation of the next funding block, a swarm is chosen to collect a tally of all of the votes that have been cast. This tally is then submitted into the nodes mempool and lives there until a miner reaches the funding block. This information is then used to construct the block which allocates a reward to the winning proposals. Proposals are only passed when the result of the yes votes minus the no votes is equal to 15% of the node count on the Service Node network. Funds Distribution \u00b6 All proceeds from the Loki Funding System will be paid through funding blocks. Funding block rewards operate similarly to traditional block rewards, as an entirely non-custodial way to distribute Loki. Every 43,000 blocks (approximately 60 Days) a funding block is constructed by miners. This block contains 1.25% of the overall block reward for the entire funding block period. To construct a valid funding block, miners must be able to assess proposals that have reached the required percentage of votes. This is done by using the information that the Service Nodes commit to the blockchain, which contains both the addresses to be paid and the state of all votes. All Service Nodes will validate the miners funding block and discard any funding blocks which pay invalid addresses. Often the sum of Loki required by approved proposals will either exceed or fall below the total amount built up in that 60 day period. Should the total sum of approved proposals exceed that which is available in the funding block, the miner will construct the funding block prioritising proposals that were committed to the blockchain earlier. Remaining approved proposals will remain committed to the blockchain until the next Funding block.","title":"Loki Funding System"},{"location":"Governance/LokiFundingSystem/#loki-funding-system","text":"Note: The loki Funding System has not been implemented at this current time. When implemented the Loki Funding System may be different to the below information. Although the Loki Foundation is made from a diverse group of individuals who represent the Loki Project, the Foundation is subject to both its own governing constitution and the laws of Australia. This could prove to be a limiting factor in the range of decisions the Foundation can make. The Loki Funding System will allow for a portion of the block reward to be acted on purely by a vote from the Service Nodes . Service Nodes represent entities from all over the world and are not beholden to input from the Loki Project Team or Foundation, this allows them to reach a new level of autonomy in the decisions they can make. Service Nodes are the most staked participants in the network and they are financially incentivised to make decisions that grow the value of Loki.","title":"Loki Funding System"},{"location":"Governance/LokiFundingSystem/#proposals","text":"Every proposal that will be put before the Service Nodes will be published on the Loki blockchain. If a given party wants to present a proposal to the Service Nodes, the party must construct a proposal transaction. Because the proposal transactions content must be readable and outputs must be burned, they forgo the privacy features of typical Loki transactions. Funding blocks will be created every 43,000 blocks (approximately 60 Days). Proposal leaders can submit their proposals at any time during this period. However, it should be considered that the closer they submit to the beginning of each proposal phase, the more time they have to gain votes from each Service Node. Attached to each transaction is an extra field which contains the information that each Service Node needs to understand to vote on the proposal.This information includes; a 20 character proposal title, a URL linking to a detailed explanation of the proposal, the amount of Loki the proposal is seeking, a payment address, and an escrow agent if chosen. Pending agreement from the Loki Foundation , users who make proposals can also elect for the Loki Foundation or any other third-party to act as an escrow agent, releasing funds as milestones are reached. Additionally, to encourage a high-standard of proposals and prevent spamming of these transactions, each proposal transaction must burn a non-trivial amount of Loki.","title":"Proposals"},{"location":"Governance/LokiFundingSystem/#voting","text":"Each Service Nodes will carry a specific key for voting. This key can be exported and utilized to vote on behalf of a Service Node without having to login to the server where it is hosted. Voting will not occur on chain, rather, each Service Node signals their support, dissent, or abstinence for each active proposal on the blockchain. Service Nodes can vote on proposals as soon as they are committed to the blockchain until the next bimonthly funding block. Shortly before the creation of the next funding block, a swarm is chosen to collect a tally of all of the votes that have been cast. This tally is then submitted into the nodes mempool and lives there until a miner reaches the funding block. This information is then used to construct the block which allocates a reward to the winning proposals. Proposals are only passed when the result of the yes votes minus the no votes is equal to 15% of the node count on the Service Node network.","title":"Voting"},{"location":"Governance/LokiFundingSystem/#funds-distribution","text":"All proceeds from the Loki Funding System will be paid through funding blocks. Funding block rewards operate similarly to traditional block rewards, as an entirely non-custodial way to distribute Loki. Every 43,000 blocks (approximately 60 Days) a funding block is constructed by miners. This block contains 1.25% of the overall block reward for the entire funding block period. To construct a valid funding block, miners must be able to assess proposals that have reached the required percentage of votes. This is done by using the information that the Service Nodes commit to the blockchain, which contains both the addresses to be paid and the state of all votes. All Service Nodes will validate the miners funding block and discard any funding blocks which pay invalid addresses. Often the sum of Loki required by approved proposals will either exceed or fall below the total amount built up in that 60 day period. Should the total sum of approved proposals exceed that which is available in the funding block, the miner will construct the funding block prioritising proposals that were committed to the blockchain earlier. Remaining approved proposals will remain committed to the blockchain until the next Funding block.","title":"Funds Distribution"},{"location":"Governance/TheLokiFoundation/","text":"The Loki Foundation \u00b6 The Loki Foundation is a registered non-profit organisation based in Australia. This central legal entity exists to allow the Loki Project to operate within a well defined legal framework and to give those working on the project legal protections and obligations. The Loki Foundation was incorporated in Australia, in 2018, and uses the same constitution as the example provided by the Australian Charities and Not-for-profits Commission (ACNC) . This constitution gives the Foundation the same corporate governance structure as many other non-profit organisations, where the company has no shareholders or beneficiaries, the governing board members each have seats with term limits, and conduct actions by voting on resolutions put forward by their fellow members. The Loki Foundation is structured to achieve registered charity status in Australia. This organisation is constitutionally bound to spend any income (including the governance block reward) on the furthering of the project and aligned initiatives. As an externally audited organisation, transparency is critical to maintaining any registered charity status the Loki Foundation receives, and to assure the general public that the Loki Foundation remains honest and keeps spending within reasonable bounds. The Loki Foundation is accountable both to the community and its auditors. Should this system ultimately fail to serve Loki and its surrounding projects, hard protections exist. Should a hard for with enough network consensus arise, there exists an opportunity to remove or replace the Loki Foundation as the recipient of this block reward .","title":"The Loki Foundation"},{"location":"Governance/TheLokiFoundation/#the-loki-foundation","text":"The Loki Foundation is a registered non-profit organisation based in Australia. This central legal entity exists to allow the Loki Project to operate within a well defined legal framework and to give those working on the project legal protections and obligations. The Loki Foundation was incorporated in Australia, in 2018, and uses the same constitution as the example provided by the Australian Charities and Not-for-profits Commission (ACNC) . This constitution gives the Foundation the same corporate governance structure as many other non-profit organisations, where the company has no shareholders or beneficiaries, the governing board members each have seats with term limits, and conduct actions by voting on resolutions put forward by their fellow members. The Loki Foundation is structured to achieve registered charity status in Australia. This organisation is constitutionally bound to spend any income (including the governance block reward) on the furthering of the project and aligned initiatives. As an externally audited organisation, transparency is critical to maintaining any registered charity status the Loki Foundation receives, and to assure the general public that the Loki Foundation remains honest and keeps spending within reasonable bounds. The Loki Foundation is accountable both to the community and its auditors. Should this system ultimately fail to serve Loki and its surrounding projects, hard protections exist. Should a hard for with enough network consensus arise, there exists an opportunity to remove or replace the Loki Foundation as the recipient of this block reward .","title":"The Loki Foundation"},{"location":"Introduction/GettingStarted/","text":"Getting Started \u00b6 1. Educate Yourself \u00b6 Privacy is having the agency to decide when you reveal personal information. It is a particularly valuable quality today, when the collection and storage of personal data is taking place at unprecedented levels. We are in an age where data is of high value, and Loki aims to equip individuals with tools to obfuscate their information and interactions with the internet. Protecting your data keeps power on your side. Loki's privacy tools offer free communication by incentivising individuals through its cryptocurrency block reward to keep the network private, secure and untraceable. Before you start using Loki, you should educate yourself about how Loki will help you obfuscate your data. 2. Download a Privacy Tool. \u00b6 Loki network enables privacy tools, and you should use them if you want to protect your privacy. Privacy Tool Description Download Session Session is an end-to-end encrypted messenger that removes sensitive metadata collection, and is designed for people who want privacy and freedom from any forms of surveillance. Download Lokinet Privately Access Censorship Resistant Websites. Routing in Lokinet doesn\u2019t rely on any single server making it resilient to attack. Internet service providers can\u2019t block access to your websites on Lokinet. Download Loki Wallets Wallets offer a gateway to private decentralised transactions and communications. They allow you to hold, secure and trade Loki with peers. Download 3. Choose Your Wallet \u00b6 Loki wallets are a gateway into private decentralised transactions and communications. They allow you to hold private keys, secure Loki, stake Loki and trade peer-to-peer. If you are unsure about which wallet to choose, check out Which Wallet To Use . 4. Acquire Loki \u00b6 Loki can be purchased on exchanges with Bitcoin and other cryptocurrencies. You can also aquire Loki by mining . Mining is the process of extracting Loki for securing and verifying transactions made on the blockchain. 5. Stake and Earn Loki \u00b6 Once you own Loki, you can stake it to the network to run a Loki Service Node, with peers or by yourself, and be rewarded with additional Loki for your contribution to expanding the Loki network. To operate a Service Node , an operator time-locks a significant amount of Loki and provides a minimum level of bandwidth and storage to the network. In return for their services, Loki Service Node operators receive a portion of the block reward from each block.","title":"Getting Started"},{"location":"Introduction/GettingStarted/#getting-started","text":"","title":"Getting Started"},{"location":"Introduction/GettingStarted/#1-educate-yourself","text":"Privacy is having the agency to decide when you reveal personal information. It is a particularly valuable quality today, when the collection and storage of personal data is taking place at unprecedented levels. We are in an age where data is of high value, and Loki aims to equip individuals with tools to obfuscate their information and interactions with the internet. Protecting your data keeps power on your side. Loki's privacy tools offer free communication by incentivising individuals through its cryptocurrency block reward to keep the network private, secure and untraceable. Before you start using Loki, you should educate yourself about how Loki will help you obfuscate your data.","title":"1. Educate Yourself"},{"location":"Introduction/GettingStarted/#2-download-a-privacy-tool","text":"Loki network enables privacy tools, and you should use them if you want to protect your privacy. Privacy Tool Description Download Session Session is an end-to-end encrypted messenger that removes sensitive metadata collection, and is designed for people who want privacy and freedom from any forms of surveillance. Download Lokinet Privately Access Censorship Resistant Websites. Routing in Lokinet doesn\u2019t rely on any single server making it resilient to attack. Internet service providers can\u2019t block access to your websites on Lokinet. Download Loki Wallets Wallets offer a gateway to private decentralised transactions and communications. They allow you to hold, secure and trade Loki with peers. Download","title":"2. Download a Privacy Tool."},{"location":"Introduction/GettingStarted/#3-choose-your-wallet","text":"Loki wallets are a gateway into private decentralised transactions and communications. They allow you to hold private keys, secure Loki, stake Loki and trade peer-to-peer. If you are unsure about which wallet to choose, check out Which Wallet To Use .","title":"3. Choose Your Wallet"},{"location":"Introduction/GettingStarted/#4-acquire-loki","text":"Loki can be purchased on exchanges with Bitcoin and other cryptocurrencies. You can also aquire Loki by mining . Mining is the process of extracting Loki for securing and verifying transactions made on the blockchain.","title":"4. Acquire Loki"},{"location":"Introduction/GettingStarted/#5-stake-and-earn-loki","text":"Once you own Loki, you can stake it to the network to run a Loki Service Node, with peers or by yourself, and be rewarded with additional Loki for your contribution to expanding the Loki network. To operate a Service Node , an operator time-locks a significant amount of Loki and provides a minimum level of bandwidth and storage to the network. In return for their services, Loki Service Node operators receive a portion of the block reward from each block.","title":"5. Stake and Earn Loki"},{"location":"Introduction/LokiNetwork/","text":"Loki Network \u00b6 Wallets \u00b6 Wallets offer a gateway to private decentralised transactions and communications. They allow you to hold, secure and trade Loki with peers. Download an official Loki wallet today and start taking back control of your online privacy. To learn more about wallets, click here . Confused about which wallet to use? Check out the \" Which wallet to use? \" guide. Mining \u00b6 Mining on the Loki Network is the process of solving a difficult computational puzzle through a Proof-of-Work (PoW) protocol and compiling newly created transactions into a block. Miners do this in order to earn money from the Block Reward and the fees associated from the transactions they include in each block. The Loki cryptocurrency can be mined using the RandomXL algorithm. To learn more about mining, click here . Service Nodes \u00b6 Loki utilises a network of Service Nodes which are paid to propagate the blockchain and process transactions. Service Nodes require a collateral of Loki to be active, and this gives the Loki network built-in market-based Sybil resistance by forcing actors to incur a large cost in order to attempt any form of temporal analysis on the network. In addition, because Service Nodes are rewarded for staying active on the network, they can be leveraged to maintain the Lokinet by routing traffic . Service Nodes are also leveraged to maintain the Loki Services by handling special off-chain activities, as seen in the case of Session . To learn more about Service Nodes, click here . Lokinet \u00b6 Lokinet is a network that uses market-based Sybil attack resistance and onion routing to create a new way to privately access the internet . Users of Lokinet will be able to access normal websites and SNApps without revealing their IP address. SNApps are traditional web applications that sit inside Lokinet and are hidden from the rest of the internet. The host\u2019s IP is never revealed, so SNApps provide excellent protection for the development of censorship resistant social media, marketplaces, information sharing sites, and other apps that depend on user and server anonymity. To learn more about Lokinet, click here . Loki Services \u00b6 Loki Services are back-end user-facing applications, such as Session and Blink . Off-chain networking and/or storage activities for these services are handled by swarms , groups of Service Nodes who query each other to enforce each other's honesty. This creates a trustless environment where no centralised leader can enforce censorship on any of the off-chain activities being conducted on the Loki Network. To learn more about Loki Services, click here . Session \u00b6 Session is an end-to-end encrypted messenger that removes sensitive metadata collection, and is designed for people who want privacy and freedom from any forms of surveillance. Session is one of the best private messengers to use as it does not require phone numbers or a central server. All the messages are routed through the service nodes which in turn offers a sybil resistant and censor resistant messaging platform. To learn more about Session, click here . Advanced \u00b6 Learn more about Loki by browsing through the Advanced section. Topics that are covered include: Technical Specs Loki's Cryptoeconomics Sybil Resistance Dynamic Block Size CryptoNote Elements used by Loki. Additionally, you can find information on how Loki is going to mitigate Denial of Service Attacks , circumvent IP and Packet Blocking , and deal with underperforming nodes through Swarm Flagging . FAQ \u00b6 If you have a question, chances are other developers or community members have asked it. Check out our \" Frequently Asked Questions \" page. If the information you are looking for is not there, please join one of our community chat groups, such as our Telegram group or Discord channel, and ask one of our community managers. Contributing \u00b6 Want to contribute to the Loki-Docs page? Check out \" How to Contribute to Loki-Docs \". Have you found a security vulnerability in Loki's code? Have a look at Loki's Vulnerabiity Response Disclosure and get in contact with us.","title":"Introduction"},{"location":"Introduction/LokiNetwork/#loki-network","text":"","title":"Loki Network"},{"location":"Introduction/LokiNetwork/#wallets","text":"Wallets offer a gateway to private decentralised transactions and communications. They allow you to hold, secure and trade Loki with peers. Download an official Loki wallet today and start taking back control of your online privacy. To learn more about wallets, click here . Confused about which wallet to use? Check out the \" Which wallet to use? \" guide.","title":"Wallets"},{"location":"Introduction/LokiNetwork/#mining","text":"Mining on the Loki Network is the process of solving a difficult computational puzzle through a Proof-of-Work (PoW) protocol and compiling newly created transactions into a block. Miners do this in order to earn money from the Block Reward and the fees associated from the transactions they include in each block. The Loki cryptocurrency can be mined using the RandomXL algorithm. To learn more about mining, click here .","title":"Mining"},{"location":"Introduction/LokiNetwork/#service-nodes","text":"Loki utilises a network of Service Nodes which are paid to propagate the blockchain and process transactions. Service Nodes require a collateral of Loki to be active, and this gives the Loki network built-in market-based Sybil resistance by forcing actors to incur a large cost in order to attempt any form of temporal analysis on the network. In addition, because Service Nodes are rewarded for staying active on the network, they can be leveraged to maintain the Lokinet by routing traffic . Service Nodes are also leveraged to maintain the Loki Services by handling special off-chain activities, as seen in the case of Session . To learn more about Service Nodes, click here .","title":"Service Nodes"},{"location":"Introduction/LokiNetwork/#lokinet","text":"Lokinet is a network that uses market-based Sybil attack resistance and onion routing to create a new way to privately access the internet . Users of Lokinet will be able to access normal websites and SNApps without revealing their IP address. SNApps are traditional web applications that sit inside Lokinet and are hidden from the rest of the internet. The host\u2019s IP is never revealed, so SNApps provide excellent protection for the development of censorship resistant social media, marketplaces, information sharing sites, and other apps that depend on user and server anonymity. To learn more about Lokinet, click here .","title":"Lokinet"},{"location":"Introduction/LokiNetwork/#loki-services","text":"Loki Services are back-end user-facing applications, such as Session and Blink . Off-chain networking and/or storage activities for these services are handled by swarms , groups of Service Nodes who query each other to enforce each other's honesty. This creates a trustless environment where no centralised leader can enforce censorship on any of the off-chain activities being conducted on the Loki Network. To learn more about Loki Services, click here .","title":"Loki Services"},{"location":"Introduction/LokiNetwork/#session","text":"Session is an end-to-end encrypted messenger that removes sensitive metadata collection, and is designed for people who want privacy and freedom from any forms of surveillance. Session is one of the best private messengers to use as it does not require phone numbers or a central server. All the messages are routed through the service nodes which in turn offers a sybil resistant and censor resistant messaging platform. To learn more about Session, click here .","title":"Session"},{"location":"Introduction/LokiNetwork/#advanced","text":"Learn more about Loki by browsing through the Advanced section. Topics that are covered include: Technical Specs Loki's Cryptoeconomics Sybil Resistance Dynamic Block Size CryptoNote Elements used by Loki. Additionally, you can find information on how Loki is going to mitigate Denial of Service Attacks , circumvent IP and Packet Blocking , and deal with underperforming nodes through Swarm Flagging .","title":"Advanced"},{"location":"Introduction/LokiNetwork/#faq","text":"If you have a question, chances are other developers or community members have asked it. Check out our \" Frequently Asked Questions \" page. If the information you are looking for is not there, please join one of our community chat groups, such as our Telegram group or Discord channel, and ask one of our community managers.","title":"FAQ"},{"location":"Introduction/LokiNetwork/#contributing","text":"Want to contribute to the Loki-Docs page? Check out \" How to Contribute to Loki-Docs \". Have you found a security vulnerability in Loki's code? Have a look at Loki's Vulnerabiity Response Disclosure and get in contact with us.","title":"Contributing"},{"location":"LokiServices/Blink/","text":"Loki Blink Design \u00b6 Metadata \u00b6 LIP Number : LIP-4 Title : Loki Blink [No Vote] Author : Jason Rhinelander (@jagerman) jason@loki.network Status : Draft Type : Core Created : 2019-06-06 Requires : LIP-3 (checkpointing) Source : LIP 4 Version history \u00b6 v0.9 Initial public draft. 1. Summary \u00b6 Blink is Loki\u2019s instant payment mechanism proposed in the original Loki whitepaper. Once completed, Blink will allow users to send payments instantly to each other and allow instantly resend of received Blink transactions without requiring blockchain confirmations. This document is intended to serve as a whitepaper underlying the concrete design for the implementation of Loki Blink with an expectation of inclusion in the 5.0.0 release. 2. Abstract \u00b6 Blink takes advantage of Loki\u2019s service node layer and checkpointing mechanism to provide a strong assurance that a transaction will eventually reach the blockchain without risk of various adversarial attacks cancelling the transaction. It does this by using multiple quorums to validate a transfer and block conflicting transfers. This validation in combination with checkpointing and updated blockchain consensus rules help ensure that such validated transfers have a strong assurance of reaching the transaction memory pool and thus can be relied upon without requiring mining confirmations. 3. Blink from the user perspective \u00b6 3.1. Wallet side \u00b6 From the user (wallet) side, initiating a Blink transfer is nearly identical to initiating a normal transfer, but with an extra flag (e.g. GUI checkbox, RPC parameter, CLI option) to say \u201cBlink this transaction!\u201d. The fees of the blink transaction are higher as it involves considerably more work for the network: service nodes must validate the transaction, and all nodes must perform extra validation steps and require some temporary extra storage to store recent Blink transaction details. For the user receiving a blink transaction, the wallet will see the received amount virtually instantly (that is, as soon as it is received by the lokid and the wallet refreshes with the daemon). Moreover these funds will be instantly spendable: unlike a regular transaction there will be no lock on the received funds before they can be spent again. The wallet user can immediately re-Blink the funds to someone else, or can send off a regular (non-Blink) transaction that spends the received Blink outputs instantly without needing to wait for the Blink transaction to be mined into a block. 3.2. Re-blinking \u00b6 One of the goals of Blink is the ability to \u201cre-Blink\u201d: That is, we want a Blink transaction to be instantly available to the recipient indistinguishable from a (confirmed) non-Blink transaction from a usability perspective. For example, when Ava blinks 10 LOKI to Betty then that transaction is initially still in the mempool, but we don\u2019t want Betty to have to worry about this technical detail: instead Betty can instantly Blink it to someone else, send a regular transaction, or use it to stake a new service node without waiting for even a single confirmation. 3.3. Fees \u00b6 The precise fee schedule is yet to be determined, but will be an additional amount on top of the current transaction fee, most likely calculated as a multiple of the transaction fee. Additionally, Blink transactions will not have a choice in transaction priority: since they are instantly spendable and guaranteed by the network, there would be little point in a user ever choosing anything higher than the minimum. Thus, for now, we mandate that Blink fees must always be submitted with a \u201cnormal\u201d priority transaction fee (but this is tentative and may be adjust this before final Blink release). The extra Blink fee doesn\u2019t go to anyone: rather it gets permanently destroyed as part of the transaction. We considered two alternatives here: Collecting fees and redistributing to SN over time. This would involve temporarily burning Blink fees, but keeping track of how much had been burned and continually reemitting them over a period of time as an extra rewards to Service Nodes. (For example: in every block, reduce the current pool of burned fees by 0.1% and reemit it to the service nodes that earn a reward in that block). Just burning fees. Ultimately we decided on the second approach because: It is much simpler. It is more predictable: SN rewards (for a stable number of service nodes) are known precisely. In the end, the two approaches are effectively equivalent in terms of total emission. By equivalent I am assuming that we have a specific net emission target. For simplicity, I\u2019ll just talk about the long-term 28 LOKI/block emissions, and, for the sake of example, assume that it is divided up so that service nodes get 20 LOKI/block of that; [1] the remaining 8 is foundation and miner coinbase rewards. What I mean by net emission is that if we have an average burning of 5 LOKI/block in Blink fees, then the net emission would 23 LOKI/block. But let\u2019s suppose that 25 LOKI/block is our actual desired long-run emission target. With method 1, we\u2019re emitting 28 LOKI/block: burned Blink fees are reemitted over time and so, much like regular tx fees, there is no net gain or loss. To hit the 25 LOKI/block target we\u2019d have to adjust the formula to reduce emissions to 25 LOKI/block. With method 2, where we are burning 5 LOKI/block in fees, we are generate net emissions of 23 LOKI/block; to hit the same 25 LOKI/block target, then, we would need to increase coinbase emissions by 2 LOKI/block to hit our target. Either way we arrive at the same place: net emissions of 25 LOKI/block through adjustment of the emission schedule. This was just an example, of course; our actual target could be 20 or 28 or 12 or whatever else. But with method 2, service nodes always know exactly what they will earn, while with method 1 there is more variability: large, sustained differences in the volume of Blink transactions will affect SN profitability, while in method 2 such differences will affect the overall coin emission but not the amount earned by a service node. Thus, given the simpler approach and essential equivalence between the two approaches, we decided to pursue method 2. (Of course, like anything in Loki, we can always change the design later given compelling reasons to do so!) 4. Technical design \u00b6 4.1. Transaction overview \u00b6 In a nutshell (with most of the details covered later in this document): The wallet builds a transaction and sends it to the lokid to be blinked. The lokid then looks up the Blink quorum, connects to a few nodes in this quorum, sending the transaction to them to be signed. The quorum distributes the transaction within itself, and once enough approval signatures are collected, broadcasts the transaction and signature data to the service node\u2019s p2p peers to disseminate it across the network. The lokid talking to the quorum then receives a confirmation message (with signatures) to relay to the wallet. These steps are depicted in Figure 1. Note that the diagram has been significantly simplified for illustration to show only three service nodes per quorum rather than the actual ten. In more detail: The wallet constructs a transaction. This transaction is almost like a regular transaction except that it leaves enough inputs unspent to cover both the required mining transaction fee and the Blink fee. This transaction gets send to the wallet\u2019s lokid for handling. lokid looks at the transaction, does some preliminary checks (as it would with any transaction) and additional checks related to the Blink transaction (such as having the correct transaction priority and blink fee). These checks are not strictly required for network security\u2014they will also be done by the service nodes \u2014 but can give an immediate failure response to the wallet if the node reasonably believes the transaction will fail. Assuming the preliminary checks pass, the node then uses the current blockchain height to determine the transaction\u2019s signing height, h . This h value then determines two current Blink quorums, Q and Q\u2019 (more details on quorum construction are in the Quorum selection section below). The lokid handling the transaction connects directly to 2 nodes selected randomly from each quorum and sends the transaction (plus other required details such as h ) to be signed. The receiving quorum nodes directly contacted by the initiating lokid forward the transaction details to the other quorum nodes for verification. Each service node in the two quorums performs checks on the validity of the transaction, such as ensuring that it isn\u2019t already spent, that it isn\u2019t already in the mempool, that miner and Blink fees are correctly specified, and that the requested signature height, h , h is approximately current (within 2 blocks of what the service node believes is the current height), and that the key images have not been already locked out by a previous, different Blink transaction signing. Assuming everything checks out, the service node records the transaction\u2019s key images locally (to lock them out from being signed again by this service node), signs the transaction hash with the service node private key, and sends the signature to the other quorum members. As each of the quorum members receives a supermajority of valid signatures (i.e. 7 in total) from both quorums it immediately sends out the transaction and signature details to its blockchain peers via its p2p network. If the quorum node in question is one of the nodes that was directly contacted by lokid, it additionally communicates the success back to the caller. These signed mempool transactions, however, are much stronger than a regular mempool transaction in that they can trigger a reorg or lead to rejected blocks: more details on this are covered below. In the case of detectable failure (for example, from a detected double-spend confirmed by a sufficient number of service nodes), a failure message is returned to the caller. If a failure is caused by too many quorum nodes timing out the caller is expected to itself timeout after an appropriate amount of time waiting for a response. The initiating lokid waits for success, failure, or timeout from the quorum nodes it contacted, and once received (or timed out), sends this information back to the wallet. 4.2. Quorum selection \u00b6 Quorum selection works by using the requested signing height h to deterministically select the two relevant quorums, Q and Q\u2019 . A quorum Q is determined by the 5-block range within which h falls, and Q\u2019 is the quorum for the immediately subsequent 5-block range. For example, any h value in 1000\u20131004 will yield the same Q and Q\u2019 quorums, and this Q\u2019 will be exactly the same quorum as the Q quorum for an h value in the 1005\u20131009 signing height range. In other words, Q\u2019(h=1003) and Q(h=1006) are the same quorum . All service nodes in Q and Q\u2019 refuse to sign a transaction with a requested signing height h that is more than 2 blocks behind or ahead of the service node\u2019s current blockchain height: this is to allow some tolerance for Blink transactions to succeed even if new blocks are propagating through the network during the Blink transaction signing process. This \u00b12 tolerance is designed to make the user experience better: using a node that is slightly out of sync [2] will still work fine rather than returning a Blink failure. It also avoids potential Blink failures on the part of quorum nodes: if a block happens to arrive during the actual signing process such that half of the quorum see the new block and half see the old block the quorum will still sign without issue. On the other hand the \u00b12 limit on the signing height also prevents abuse: the larger the allowed range, the more choices a malicious actor would have to pick and choose a \u201cfriendly\u201d quorum. The quorum sample itself needs to be effectively immutable, and so we propose a deterministic random sampling using a MT19937-64 random number generator seeded with the block hash 35 blocks before the first valid quorum height, h\u2080 . Thus quorum Q for height 1002 is determined by block 965 (35 blocks before the first signing height of the quorum, h\u2080 =1000), and quorum Q\u2019 is determined by block 970 (35 blocks before the first height of the second quorum, h\u2019\u2080 =1005). Moreover the sampling algorithm excludes any service nodes that are scheduled to expire before block h\u2080 +10. For validation of a Blink transaction we require a supermajority of signatures from both quorums. The point here of using the two quorums is to prevent a timing conflict where, if we had just one quorum per block (or range of blocks), then one Blink transaction could be signed by quorum Q\u2081 and another transaction spending the same keys could be signed by quorum Q\u2082 before the first transaction is broadcast to the network. By using two overlapping quorums we end up with the key images in question being locked both in the current quorum but also in the following quorum (which could come as early as the next block). Even if the next Blink transaction switches to a new quorum, the overlap ensures that it simply switching to a quorum that has already locked any key images of Blink transactions submitted in the last few blocks. 4.2.1. Overlapping quorums rationale \u00b6 There are three reasons for using these two overlapping quorums. First, we want the quorum signature process to \u201creach\u201d a few blocks into the future (5\u20139 blocks ahead with 5-block quorums) to give enough time for the quorum signatures to disseminate across the network. While 5 blocks is more than would be typically required, there are some edge cases discussed in detail below that can lower this future block interval to just 2 blocks. Second, Blink processing is expected to require a substantial number of connections between service nodes; with 5-block quorums we can at least reduce the frequency with which connections need to be established as service nodes will keep their connections open for the duration of the quorum. Third, using two quorums offers considerable higher security than one quorum of twice the size for two reasons. First, each quorum is essentially a new random draw of service nodes; that means the more quorums you have over a given period of time the more random draws you do, and with more draws you get more \u201cchances\u201d to pick a compromised sample. Second, two consecutive supermajorities of quorums of half the size is considerably more secure than one supermajority of a quorum twice the size. Some numbers can help demonstrate this: suppose the network has 1000 service nodes, and a single malicious actor is in control of 25% of those service nodes. Under alternative A, we require the majority of a single quorum of 20 service nodes, and require a 70% of the service nodes\u2019 signatures. Under alternative B, we require two quorums of 10 service nodes each, again requiring 70% signatures from each quorum. Under scenario A in any given quorum the actor has a probability of 0.00000381 of having the required 70% majority. Under scenario B, the actor has a probability of 0.000000173: that is, under scenario A, the actor is about 22 times more likely to obtain control of any random quorum than any random quorum pair. Or to put it into context: in a one year span, there\u2019s about an 18% chance that this bad actor would gain quorum control for at least a single quorum under scenario A, and about a 0.9% chance that he would under scenario B. As for quorum length, if quorums lasted for one block instead of five there would be a 4.4% chance of this 25% operator having a quorum supermajority at least once under the overlapping quorum design, and a 63% chance under the single quorum design. If this adversary actually controlled an incredible 50% of the service node network it would be quite difficult to avoid a compromise: he would have quorum supermajority votes about 2% of the time under the single quorum approach, and 0.3% of the time under the overlapping quorum approach. Such an adversary would have a 95% chance of quorum ownership at least once per day with a quorum of 20, and a 35% chance per day with overlapping quorums. It is worth pointing out, in passing, that these probabilities are countered by the economic design of Loki: even if such adversaries existed, they would have a strong financial incentive to ensure that the network is not compromised as such a compromise would likely have a significant negative impact on their own holdings, which are heavily invested and locked into service node stakes. There is, of course, some desirable statistical properties of making a quorum longer : if quorums changed on a 10 block cycle you\u2019d cut the probability of compromise by nearly half (to 0.45% in the overlapping case). This gain isn\u2019t huge, though; moreover the longer the quorum becomes the more complications can arise from service node deregistrations, and the more time you allow for coordination between service node operators looking to cheat the system. Instead, if we wanted to further increase the security of Blink transactions, a preferable approach would be to use a triple quorum. It could also be possible to enable an opt-in triple quorum, at a higher fee, to allow users to send with a paranoid level of assurance. (This is now, however, part of the current Blink plan.) 4.2.2. Quorum selection block and checkpointing rationale \u00b6 Using a lag of 30 blocks for quorum determination was chosen to interact with Loki checkpointing. Unlike checkpointing and deregistration quorums, a change in Blink quorums would be highly undesirable as the validity of the Blink signature would no longer hold. Thus we want to use a height from the blockchain that is sufficiently far back as to be highly likely to be made immutable via checkpointing. By basing the quorum on h\u2080 -30 we give ample time for checkpointing even if 2-3 checkpoints have been missed. For example, if blinking at height 1000 then Q\u2019 begins at 1005, which means the relevant block for determination of Q\u2019 is 975. Checkpointing normally occurs every 4 blocks with immutability occurring after 3 checkpoints. Thus in typical times it can be up to 4 blocks since the last checkpoint quorum, which itself establishes a checkpoint on a block 4 blocks earlier. Allowing up to 2 blocks for the quorum to vote and disseminate the checkpoint to the network this means the first checkpoint is usually between 4 and 10 blocks ago, the second is 8-14 blocks ago, and the third, immutable checkpoint is 12-18 blocks ago. If one of these checkpoints were missed (for example because of a quorum failure) then the immutable checkpoint could be 16-22 blocks ago; and if three were missed, up to 30 blocks ago. Thus the h\u2080 -35 rule establishes that both quorum selections are established by a block at least 30 blocks in the past, which allows Blink to tolerate up to 3 missing checkpoints. To further secure Blink transactions we further require that the quorum seed heights are checkpoint-immutable: both the initiating lokid and the quorum service nodes will verify that the quorum seed height is in fact checkpointed, refusing to sign (and thus failing the Blink if enough fail to see the required checkpoints) if it is not. This ensures that Blink transactions are secure by preferring to fail a Blink signature rather than include one that has any chance of being invalidated by a block reorganization. 4.3. Quorum validation \u00b6 Some potential cases are depicted below: 4.3.1. TX example one \u00b6 TX\u2081 is depicting a transaction submitted to a daemon which sees the current height of the network at 1002. We can think about a few different cases: Submitting the blink transaction normally at the known height (1002). Thus we get Q = Q\u2081 and Q\u2019 = Q\u2082 for the two quorums. The initiating lokid contacts a random service node q from Q\u2081 , passes along the transaction, and waits for a reply from q . q in turn communicates with its quorum peers and the subsequent quorum ( Q\u2082 ) to build the required set of signatures. Once the required signatures are accumulated the transaction is released by the quorum service nodes to their peers. The Blink TX is broadcast to the network. Because a majority of Q\u2082 service nodes signed it and will not resign the same key images, the earliest possible Blink height to spend the same key images is 1010, which can be used by a cheating lokid at network block 1008 at the earliest. Submitting slightly behind the network (1000 or 1001). This could happen, for instance, because there have been two recent blocks that the local lokid has not synchronized yet. Generally everything here works as above: the service nodes at height 1002 will still sign the block (assuming the transaction itself is valid) because the requested signature height is within 2 of their current height. Submitting slightly ahead of the network (1003 or 1004). This could happen, for instance, if the local node is close to a very lucky pool that has just discovered a couple blocks that haven\u2019t disseminated across the network yet. Again, this is handled just like the above: even though the service nodes haven\u2019t yet seen a block newer than 1002 it still satisfies the within-2 rule and so they will still sign (assuming the transaction is valid). Submitting well behind or well ahead of the network (999 or lower, or 1005 or higher). In this case the quorum will not accumulate enough signatures because the within-2 requirement is violated. In this case a failure gets returned to the initiating lokid. [3] The first three (accepted) cases above all result in the earliest block a cheater could submit to being 1008 (i.e. abusing the within-2 rule to submit a h=1010 block), giving a worst case of at least 4 blocks needing to be transmitted to the network before a duplicate Blink could be submitted; since Blink dissemination is high-priority this should result in a high level of assuredness that a Blink double-spend cannot be performed in this scenario. 4.3.2. TX example two \u00b6 TX\u2082 in Figure 2 shows a transaction that is sent via a lokid that sees the current h=1006 , i.e. in the second block of quorum Q\u2082 . I\u2019ll just ignore the h>1008 and h\\<1004 cases (see above for why they are dead ends). Case 1: Submitting h =1005, 1006, 1007, 1008. This case is largely the same as TX\u2081 , but now the two quorums are Q\u2082 and Q\u2083 . The earlier a theoretical double-spending Blink could be submitted is with h =1015 at actual height 1013: that is, a minimum of 5 network blocks away. Case 2: Submitting h =1004 (either due to a lagging node, or a malicious actor). This ends up using the same quorums as TX\u2081 (that is, Q\u2081 and Q\u2082 ). As in TX\u2081 , the earliest possible double spend could be submitted at 1008. Case 2 here represents the worst possible scenario: there are just two network blocks between the current height (1006) and the height at which a blink transaction could be submitted to a completely independent quorum pair. There is a potential issue here from an attacker, discussed in further detail below. 4.3.3. TX example three \u00b6 TX\u2083 is included for completeness to show that cheating ahead by a quorum has no advantage for a potential attacker. This depicts the sending transaction at h =1009. The attack essentially has two relevant choices: h =1007\u20131009, or h =1010,1011. In the first case, he gets quorums Q\u2082 and Q\u2083 , making his earlier possible Blink double-spend at h =1015 (submitted at h =1013), which is Stats geek note: the probability of being 3+ blocks behind the network with lag L seconds is the CDF value of a Poisson distribution with \u03bb= L /120 at k =3. 4.4. Repeated signing of the same transaction \u00b6 One possible Blink failure mode is that the requested signature height, h , is seen as too old (or even too new) by some or all members of the service node quorum if it does not fit within their \u00b12 tolerance. This could be caused, for example, by the lokid the wallet is talking to being out of sync. In the case of such a failure, the calling lokid could check for new blocks and, if changed, resubmit the transaction for signing at an updated signing height h . We want this resubmission to succeed even if it goes to the same quorum, as it makes the Blink process more robust to network synchronization issues. This means, in particular, that service nodes will need to add an exception to the normal key image blacklisting if asked to re-sign the exact same transaction for which the key images were blacklisted. 4.5. Signature failure: key images may stay unblinkable (for up to 10 blocks). \u00b6 When a service node signs a transaction as part of a given quorum it will never sign a different transaction containing any of the same key images again as part of that quorum. Since failures are possible for multiple reasons, however, it does not block the key images of a transaction that it refused to sign. It is possible, however, for a transaction to fail to be signed by a supermajority while still being signed by a superminority (that is, by enough other nodes to prevent a supermajority). This case is expected to be rare: the criteria for service node disagreement is small: effectively you would need (roughly) half of the service nodes to see something wrong with the transaction. It is not impossible, however: if a regular transaction spending the same key images is mined and the block transmitted in the middle of signing the blink could fail. The user-facing problem that could arise here is that the transaction that gets signed includes multiple key images, only some of which are ineligible. The service nodes that signed the transaction, however, end up locking all of the key images for the duration of the quorum ( i.e. the next 4\u20139 blocks), so even once the user wallet sees the updated chain a new transaction might end up trying to blink using an input that is temporarily non-blinkable (note that it will still be regularly minable since the Blink was not transmitted due to the quorum failure). This case seems rare: it would require a legitimate user spending regular transactions and blinking at the same time from different wallets. It\u2019s possible, of course, but given the rarity and the relatively minor consequence (not being able to Blink those outputs for 10\u201320 minutes) for now we will simple leave this as a known limitation. 4.6. Blink transactions entering the mempool \u00b6 Blink transactions themselves are perfectly ordinary transactions on the blockchain: the signatures applied by service nodes do not end up as part of the transaction that gets mined into the chain. Instead this metadata is shared and synchronized between nodes from the time when a Blink transaction enters the mempool until the transaction is mined and secured behind an immutable Loki checkpoint boundary. An incoming Blink transaction in the mempool will also be transmitted with the Blink height and the verifiable Blink signatures at which the transaction was signed. Based on this, a loki node receiving a blink transaction will perform multiple actions: Verify that the Blink signatures are the correct signers for the given height, and that the signatures are valid (and if not reject the Blink transaction). Check to see if any of the key images were spent in or before the last irreversible checkpoint block: if so, reject the Blink transaction. Check to see if the mempool already contains any Blink transactions that have a higher priority (i.e. lower height) than the incoming transactions, and if so, refuse the incoming transactions. (This shouldn\u2019t be possible, but is included as a safeguard to maintain consensus). Check the current chain back to the last irreversible checkpoint: if any blocks contain any transactions that spend any of the key images in the new Blink transaction then roll back the chain as much as needed to remove those transactions from the blockchain, re-adding any rolled back transactions into the mempool (as occurs already with any reorg). Reject any non-Blink transaction from the mempool that spend the same key images as the new Blink transaction (if we just rolled back then this means immediately rejecting the conflicting transactions). Reject any Blink transactions from the mempool that spend the same key images but have a lower priority (i.e. higher height) than the new Blink transaction. This should not be possible in general, but needs to be specified anyway to avoid a consensus failure (as with the mirrored check above). Note that this actual removal could cascade if there are other transactions referencing the removed Blink transaction. Another difference with Blink transactions is that they should not be subject to the existing 2-week mempool transaction timeout. We don\u2019t want someone to be able to submit a low-priority Blink transaction while the network is flooded with higher priority transactions and be able to wait out the transaction until timeout. As long as Blink transactions stay in the mempool until mined all an attacker can do is delay the transaction from being mined, but cannot cause it to be dropped no matter how long he prevents mining. In the unlikely event of a bug that makes a Blink transaction inadmissible to the blockchain for some unforeseen reason, this approach will keep the transaction alive indefinitely until the bug can be addressed. [4] Second, Blink transactions need to be more actively propagated across the network than current transactions. Currently the mempool is not actively synchronized across nodes; instead new transactions are simply broadcast to all connected peers when received. A new node, a node that was temporarily down when the transaction propagated across the network, or a node that has had its mempool manually flushed does not receive existing mempool transactions from peers if it misses it the first time. This needs to change for Blink transactions: when a p2p connection is established we need each peer to send the other a list of any pending Blink transaction details it doesn\u2019t already have. Effectively we need Blink transactions in the mempool to become first-class synchronization objects, just like blocks. Finally, synchronized Blink transactions may not be (and do not need to be) identical across the network in terms of attached quorum signatures: it is entirely possible for two nodes to receive a different set of 14 signatures: so long as all are valid for the quorum 4.7. Blink transactions entering the blockchain \u00b6 A transaction entering the blockchain from the mempool requires two changes: first, the Blink transaction\u2019s unspent amount now includes both the tx fee, as before, but now also the Blink fee. Second, because transactions can reference other Blink transactions currently in the mempool this puts an ordering on transactions: if A includes B in its ring signatures (whether as the actual key image or a decoy) then there is an implied ordering for mined block selection: A cannot be included in a block before the block in which B is included. This requires, of course, changes to the transaction selection algorithm used to construct block templates for miners. 4.8. Re-Blinking implementation \u00b6 As discussed in Re-blinking we need received Blink funds to be instantly spendable. That means that the recipient\u2019s wallet needs to recognize that those received funds are immediately spendable, whether in a new non-Blink transaction or in a new Blink transaction. In either case this means the new transaction will spend outputs that aren\u2019t yet on the chain, but are still in pending Blink transactions in the mempool. We need to update lokid and the wallet allow this. This does, however, raise another important issue, addressed in the next section. 4.9. Ring signature implications \u00b6 The anonymity in Loki depends on the actual and decoy outputs being included in the transaction ring signature being indistinguishable. Quick turn-around re-blinking breaks that with the current ring signature selection in two ways: First, a Blink transaction that enters the mempool that includes a mempool Blink transaction in its ring signature provides a perfect link between the transactions because currently only blockchain transactions but not mempool transactions are ever included in a ring signature. Even if you don\u2019t have the mempool history you can still infer likely links between Blink transactions that are very close together (i.e. within a small number of blocks). As outputs in the same block (or within a couple blocks) are highly unlikely to occur naturally, seeing such transactions in the mempool give a high probability that the transactions are linked. [5] To get around this problem, we will need to update the ring signature construction to be able to select from both existing blockchain transactions and Blink transactions in the mempool for both Blink transactions and regular transactions . (This of course imposes additional mempool ordering constraints to those discussed in the blockchain section as ordering also applies to non-Blink transactions using mempool decoys.) Further investigation will be needed to determine a good selection probability (and will likely need tweaking in future releases), but we will aim to be on the side of having too high a probability: using too low a probability is much worse as it would make Blink transactions still stand out (albeit imperfectly). Potentially including mempool Blink transactions in normal transaction ring signatures is important as well: because a Blink transaction is instantly spendable, a non-Blink transaction including a recent Blink transaction would similarly link the outputs together. Thus we potentially include Blink dummy transactions in all transactions (which has the separate advantage of simplifying the code: building a Blink transaction and building a regular transaction will be identical). 4.10. Blink and checkpoints \u00b6 Blink transaction metadata (i.e. quorum signatures, signing height) is meant to be temporary data that only needs to be kept until the transaction is unequivocally committed to the blockchain. Thus Blink is designed to work with Loki\u2019s checkpointing feature: once the transaction has passed the point where it is not reversible\u2014that is, once it has been signed by three checkpoint quorums\u2014service nodes can discard the metadata. 4.11. Quorum communication \u00b6 Current quorum communication (e.g. for deregistration voting or for the upcoming checkpointing support) relies on a gossip protocol to carry messages over the loki p2p layer. While this is manageable for those applications it is not going to be sufficiently scalable for Blink quorum voting. Instead part of the Blink development will be to build a direct communication layer where service nodes connect directly to one another for quorum purposes. The initial plan is for quorum SNs to communicate directly with each (using the SN public IP being added in #622 ). This communication layer will also be designed to handle quorum traffic for service node deregistration and allow faster and more efficient communication in those scenarios as well. The specific implementation details will be developed further during the Blink implementation; the current plan is to create a relatively simple SN-to-SN protocol using ZMQ (which is already a loki core dependency) over which quorum members communicate, and over which the initiating lokid contacts quorum service nodes to begin the Blink signing process. The initial approach here is to use a fully-connected quorum: 9 open connections, roughly half inbound and half outbound, for each SN, held open (and reestablished upon disconnection) for the duration of the Blink quorum validity. As a simple fully connected approach, the following table shows node-to-node connections within a quorum: where \u201co\u201d indicates that the row node establishes an outgoing connection to the column node and \u201ci\u201d indicates that the row node receives an incoming connection from the column node. Additionally once the depicted quorum Q becomes the first quorum, nodes 6\u201310 establish outgoing connections to nodes 1\u20135 of following quorum, Q\u2019. (Similarly, but not depicted, when Q is the second quorum there will be inbound connections to SN\u2081 through SN\u2085 from the previous quorum\u2019s last 5 nodes): first node in the quorum will open connections to nodes 2\u20136, the second node will open to nodes 3\u20137, and so on. The sixth node will open connections to nodes 7\u201310, the seventh node to 8\u201310 and 1, and so on. Additionally, once a quorum becomes the first quorum, nodes 6\u201310 each establish a connection to nodes 1\u20135 in the second quorum. This is designed to be balanced: each service node establishes outgoing connections to exactly 5 other service nodes, and is connected to by a (different) 5 service nodes. Each of these Additionally, each quorum would have some nodes that establish a connection to some of the nodes in the following quorum over which messages will be passed when a quorum has acquired the required supermajority of signatures. 4.12. Service node deregistrations \u00b6 As discussed in the Quorum Selection section, the service nodes that make up a quorum are chosen by excluding service nodes that have (or will) expire before the quorum completes its tasks. A related problem, however, is that there are unforseeable deregistrations that may occur (or may have already occurred) since the seed height. This is partially addressed by the quorum tolerance: since a quorum required only 7 of 10 votes, it can continue to function even if 3 nodes deregister. It is, however, possible (albeit extremely unlikely) that 4 or more nodes have been deregistered from the network in either quorum, either before the quorum begins or during the quorum validity period. If this occurs, a quorum member must simply refuse to sign. This can also be checked by the initiating lokid: if it fails to build a quorum of at least 7 active nodes in each quorum it can immediately return an error to the initiating wallet that the Blink service is temporarily down. The reason that we cannot add \u201csubstitute\u201d nodes in the event of deregistrations is that it would affect the validity of quorum signatures if a blockchain reorganization should happen: such a reorganization could delay the deregistration to the point that the substitute isn\u2019t actually valid anymore, thereby invalidating the Blink signature. It is tempting to at least consider substitutions for deregistrations that are past an immutable checkpoint boundary, but again this would not work: though checkpoints are distributed across the network, they are a moving target that is external to the blockchain itself. Thus determining the correct set of quorum signatures would change as checkpoints propagate the network and so verification of having the correct set of signatures would be impossible. We believe that the 7 of 10 threshold, allowing for up to three failures (including deregistrations) should be sufficient to keep Blink operational in all but extreme circumstances (such as mass Service Node deregistrations). Should this prove problematic, the recommended approach is to increase the quorum size, slightly reduce the supermajority requirement, or both. 5. Potential attacks \u00b6 While the basics of the above in normal operation are fine, there are several edge cases that need to be addressed specifically to prevent accidental conflict or deliberate attacks. 5.1. Double-spending Blink tx + non-Blink tx \u00b6 This attack would work by privately mining a block where the inputs used in a Blink transaction are spent, conducting a Blink transaction, then releasing the private block to the network after the Blink transaction has been approved. This would be a classic double spend, but because Blink transactions are 0-confirmation transactions, you don\u2019t need a 51% attack; you would just need a single block and a bit of luck. The solution to this is that Blink transactions in the mempool are stronger for consensus purposes than non-Blink transactions on the chain . That is, if a Blink-signed transaction arrives in the mempool that conflicts with (i.e. spends the same inputs as) a transaction already mined on the chain then the block containing the conflicting non-Blink transaction is no longer a valid blockchain block and must be rolled back. There is a limitation to this, however: if the conflicting block has passed an irreversible checkpoint boundary then it is instead the Blink transaction that is invalid. [6] 5.2. Double-spending Blink + Blink \u00b6 Sending two parallel Blink transactions that spend some of the same inputs at the same signing height h isn\u2019t possible: the approving service nodes by design will not sign twice for the same outputs, and to actually be accepted a Blink transaction must be signed by a supermajority of the service nodes in the (unique) signing quorum. Sending two Blink transactions at different heights, however, can be a potential issue if exploited by something I will call \u201cquorum hopping\u201d and address in the next section. 5.3. Quorum hopping \u00b6 In order to double-spend Blink transactions it is necessary to \u201cquorum hop\u201d \u2013 that is, to have your transaction signed by two independent sets of quorums. Practically speaking, that means that that you need one Blink transaction signed by Q\u2081 and Q\u2082 , and another spending the same outputs signed by Q\u2083 and Q\u2084 . [7] For the purposes of illustration, I\u2019ll continue with TX example two from Figure 2, and I\u2019ll assume the attacker has an arbitrary amount of hash power available. In order to quorum hop, the attacker needs to get signatures from Q\u2081 and Q\u2082 and signatures for another transaction spending the same outputs from Q\u2083 and Q\u2084 . The basic assurance is that while the current network is at height 1006, Q\u2084 won\u2019t sign a transaction. However, 1006 is close enough to the quorum endpoint that the attacker does get a choice between the Q\u2081/Q\u2082 pair and the Q\u2082/Q\u2083 pair: though Q\u2082/Q\u2083 is the proper quorum pair for a truthful h =1006 request, we allow him to claim h =1004 (to allow for network latency). To get a successful signing from the Q\u2083/Q\u2084 quorum pair, however, the second Blink transaction must request a signing height of at least h =1010, and the quorum won\u2019t accept such a height unless it locally sees at least h =1008. This means the attacker needs to get two new blocks on the network quickly but not too quickly: if too fast, the transaction may reach too many of the Q\u2081/Q\u2082 quorum members that the first tx signature fails. If too slow, the signed transaction broadcast from Q\u2081/Q\u2082 service nodes may reach enough Q\u2083/Q\u2084 service nodes that signing of the second transaction fails. Thus we\u2019ll assume that there is some small window for \u201cgoldilocks\u201d timing: timing that is not too fast to reach Q\u2081/Q\u2082 and not too slow to reach Q\u2083/Q\u2084 after the first transaction. The timing of the attack would go like this: Privately mine and withhold 2 blocks (heights 1007 and 1008). Initiate a Blink signing at h =1004 (thus using the Q\u2081/Q\u2082 quorum pair). Release the withheld blocks; ideally send them directly to Q\u2083/Q\u2084 quorum members. Initiate the conflicting transaction Blink signing at h =1008 (thus using Q\u2083/Q\u2084 ). If successful, nodes on the network will end up receiving two conflict Blink transactions with valid signatures. First, for a unique consensus rule, we need to pick a consensus winner, which is easy enough: we simple prefer the Blink transaction with an earlier signing height and reject the later one. [8] Second, and more important, we want to make the attack to be \u201cimpossible\u201d [9] . This is done by effectively adding a delay to Blink signing in potentially problematic case, effectively shortening the \u201cgoldilocks\u201d window to nothing. Specifically the proposed delay is as follows: when a quorum service node is asked to sign a transaction at height h , it checks the time when it received the critical block that allowed the given quorum pair associated with height h . If this critical block was received less than 5 seconds ago, it delays the Blink checks and signing until at least 5 seconds have elapsed since that critical block was was received by the given service node. For example, the critical block for a signing height of 1007 would be 1003; for 1010 it would be 1008: The whole idea here is to add enough of a delay that the Blink transaction being signed by Q\u2081/Q\u2082 has time to propagate to enough Q\u2083/Q\u2084 service nodes that they will see the double-spending attempt and thus fail to build enough signatures to Blink the transaction. 5 seconds should generally be much more than enough for reach all the quorum members, but we don\u2019t actually need it to reach all: rather it is enough to reach just a supermajority-busting minority or either Q\u2083 or Q\u2084 service nodes. A delay of up to 5-seconds is highly undesirable for a Blink transaction, of course, so it is worth considering how unlikely this delay would be under typical blockchain activity when an honest user is sending a Blink transaction. Let\u2019s suppose the user submits a transaction to sign at height h=1010 , and so quorum service nodes check when they received block h=1008 to figure out whether they need to delay. In order to trigger a delay, we need h=1008 to have been received by the service node less than 5 seconds before the signing request is received. Adding an extra couple of seconds for blocks to reach service nodes, this means we need to have found 3 (or more) blocks on the network in approximately 7 seconds. Given LOKI\u2019s 120-second block target, the probability of seeing this naturally is approximately 0.000031[^prob_7s]; even if we allowed for increased network latency to delay block transmission by 5 seconds the probability of triggering the delay is still only 0.000091. These probabilities are also worst cases conditional on using the first block in a new quorum (which itself only occurs 1/5 of the time). If we consider the probabilities for a transaction signed at h=1011 , we would need 4 network blocks received in the same timeframe: that is, 0.00000046 for a 7-second window and 0.00000188 for a 10-second window. Thus suffice it to say that the probability of an honest user accidentally hitting the delay is small. Even if they do hit it because of extremely bad luck, the only consequence is a delay of at most 5 seconds for their Blink confirmation. 5.4. Signature withholding \u00b6 The design requires the Blink quorum itself to disseminate the Blink transaction to the network. This has one potential advantage of having the transaction go out faster (service nodes are often better connected), but the more important reason is to prevent the caller from withholding the Blink transaction to cancel out a later Blink transaction. Such an attack would work as follows: Attacker constructs a Blink transaction sending funds to himself; he submits at the current height using quorums Q\u2081 and Q\u2082 . Instead of immediately transmitting the signed transaction to the network, however, he stores it. He then waits a few blocks for a height that will let him use a different quorum pair, Q\u2083 and Q\u2084 . The attacker constructs another Blink transaction sending the same outputs to an exotic car dealer who, seeing the Blink transaction on the network, hands over the keys to a brand new Italian sports car. While driving off, the attacker releases the initial Blink signatures which replaces the car payment transaction with his earlier transaction to himself, making the car payment permanently unspendable. To avoid the problem, we need to force the transaction dissemination as quickly as possible: thus mandating that the service node quorums should themselves broadcast it; this effectively means the Blink transaction will be broadcast to the network from 14\u201320 well-connected nodes. As a side effect, this broad dissemination method also ensures that Blink transactions reach all nodes very quickly. 5.5. 51% attack to reorganize the Blink quorum \u00b6 The idea behind this attack is that an attacker would submit a blink transaction then attempt to invalidate it by using a 51% attack to reorganize the blockchain far enough back as to disrupt the quorum seed, thus making the blink signatures on the transaction no longer valid. This attack is prevented by requiring a long (35-block) lag for quorum determination and not having service nodes sign a transaction if they do not see their quorum seed height as checkpoint-immutable. See Quorum selection block and checkpointingrationale for more details. 6. Future ideas \u00b6 There are myriad ways the Blink implementation could be extended and advanced; this section is laying out some of them. Note that there is no guarantee that all of these will be implemented. 6.1. Dynamic fees \u00b6 In the Fees section we currently mandate that the miner transaction fee for a Blink transaction must always be set to the \u201cnormal\u201d priority fee. This is sub-optimal: a dynamic system that sets a fee based on the blockchain activity. For example, the transaction priority (and thus the fee) could be calculated by considering the average fee and fill percentage of the 60 blocks ending 30 blocks before the Blink height to calculate a fee. The Blink portion of the fee could similarly be dynamic based on the number of recent Blink transactions on the blockchain. 6.2. Merging transactions \u00b6 Given a pair of Blink transactions on the mempool, it ought to be possible to merge them into a single transaction. For example, if Kee blinks funds to Jason and Jason reblinks those funds to Simon, it ought to be possible (at least in some situations) to merge the transactions in such a way that both can be replaced with a single merged transaction that spends all the same outputs and pays the right recipients, but is combined into a single, smaller transaction on the blockchain. The privacy components of Loki\u2019s underlying design certainly complicates the idea, but it is worth pursuing at least some research into whether and how this could be accomplished. In theory this combining could also be done for regular transactions, but starting this with Blink with its much stronger guarantees of blockchain acceptance seems safer. 6.3. Allowing different Blink supermajority levels \u00b6 In this plan we simply specify a quorum of 10 and supermajority of 7. It seems plausible, however, to let advanced users require an extra paranoid level of security by including a flag requesting a higher level of signing: for example, requiring 8 or 9 signatures per quorum. This would increase the likelihood of failures due to quorum communication issues, and would likely slightly increase the typical Blink time, but would be entirely feasible to support. One question mark around this is whether it would be a particularly valuable addition for LOKI users. On the one hand it would allow extra choice, but there is uncertainty as to whether this extra choice would actually be used. A larger concern is that the option of a \u201cmore secure\u201d mode would imply that the default 7/10 supermajority requirement is somehow less secure, despite the design (as laid out in this document) explicitly targetting building a secure system. Indeed the only security gained from a higher quorum level is higher protection again quorum ownership by an adversary. As the statistics in the Overlapping quorums rationale point out, however, this is already an extremely low risk even for someone in control of a huge portion of the network\u2019s service nodes. Thus it might be preferable to not offer such a feature explicitly to undermine that the current Blink system is already designed to be highly secure. Users who need an extra paranoid level of security will always be better off using a regular transaction and waiting for many confirmations plus service node checkpoints. 6.4. Quorum communication via mesh network \u00b6 The idea proposed above for intra-quorum communication is simple, but probably does not scale well to larger quorum (such as the 20-node quorum used for checkpoints). An alternative approach is to use a partially connected mesh network over which some SNs route messages for other SNs. This complicated the mechanism (because more node-to-node routing is required) and slightly reduces the speed, but network latency is less of a concern for checkpointing than it is for Blink transactions. 6.5. Carrying traffic over lokinet \u00b6 One aspect to consider in the future is the possibility of carrying all blink coordination traffic over lokinet rather than establishing direct public IP SN-to-SN connections. Such transmission can still be fast by using 0-hop paths within lokinet (which are effectively just encrypted direction connections). There is no particular reason that this data needs to be encrypted or hidden, but this would have some advantage for lokinet by providing cover traffic, and would let lokinet deal with any connection nuances. One technical caveat raised by lokinet devs when discussing this idea is that we would have to take steps to ensure that lokinet\u2019s connectivity parameters remain sufficiently high to not partition the network: So the idea is that snodes within a quorum are going to talk to each other. If this goes over 0-hop lokinet then their lokinet routers will have connections to one-another. This is fine. The possible issue arises because lokinet routers have a preset minimum number of connections to other routers that they want to maintain. If this minimum is low enough that it is satisfied by the quorum size then the routers may not seek out connections to other routers and, in theory, that quorum could become partitioned from the network by way of all the routers only connecting to one-another and not other routers outside their quorum. It doesn\u2019t seem super likely to happen, and is easily prevented anyway by setting min_conn_count > quorum_size , but it is technically possible without that mitigation so I figure we may as well set our desired minimum connection count for the routers higher just in case. Another possibility is to include some sort of flag to tell lokinet to not consider this a connection for the purposes of maintaining the minimum connection count. Footnotes \u00b6 This split is purely for the sake of example and not meant to be taken as a concrete plan to change the coinbase reward to these particular values. Any such change in reward structure is obviously entirely outside the purview of this document. A node that is one minute behind the network will fall to more than 2 blocks away from the proper height 0.18% of the time; with two minute lag the node will exceed 2 blocks 1.89% of the time; a thirty-second-slow node will be a problem 0.013% of the time. Since a node lagging by any of these values occurs only rarely (not consistently), the actual probability of users encountering such failures on a decently connected node should be much lower. It is possible for the quorum to return an error status indicating that the lokid should retry at a new height; it is up to the lokid whether it wants to do this or return an error to the client. This is actually a bit more complicated because new transactions can be submitted that spend the Blink transaction outputs or that include the Blink transaction outputs as a decoy. That means those transactions themselves will depend on the Blink transaction, adding further chaining. Effectively the only way to get a tx in block *h* that refers to a tx in block *h* or *h-1* is if a blockchain reorganization that dumps transactions back into the mempool happens; this typically only occurs in a 51% attack so can be considered rare enough to provide a high assurance of the link between transactions. This case is virtually impossible in normal operations, but it must still be specified and handled for completeness of consensus rules. You could hop further, of course, to *Q\u2084* and *Q\u2085*, but the attack is the same: it is just more costly to pull off. In theory there could be transactions that reference the second transaction\u2019s outputs that would also need to be ejected from the mempool. Given that the window of opportunity here is extremely small, this seems a negligible concern. In a practical sense, of course. More technically, we want the attack to be extremely difficult to carry out.","title":"Blink"},{"location":"LokiServices/Blink/#loki-blink-design","text":"","title":"Loki Blink Design"},{"location":"LokiServices/Blink/#metadata","text":"LIP Number : LIP-4 Title : Loki Blink [No Vote] Author : Jason Rhinelander (@jagerman) jason@loki.network Status : Draft Type : Core Created : 2019-06-06 Requires : LIP-3 (checkpointing) Source : LIP 4","title":"Metadata"},{"location":"LokiServices/Blink/#version-history","text":"v0.9 Initial public draft.","title":"Version history"},{"location":"LokiServices/Blink/#1-summary","text":"Blink is Loki\u2019s instant payment mechanism proposed in the original Loki whitepaper. Once completed, Blink will allow users to send payments instantly to each other and allow instantly resend of received Blink transactions without requiring blockchain confirmations. This document is intended to serve as a whitepaper underlying the concrete design for the implementation of Loki Blink with an expectation of inclusion in the 5.0.0 release.","title":"1. Summary"},{"location":"LokiServices/Blink/#2-abstract","text":"Blink takes advantage of Loki\u2019s service node layer and checkpointing mechanism to provide a strong assurance that a transaction will eventually reach the blockchain without risk of various adversarial attacks cancelling the transaction. It does this by using multiple quorums to validate a transfer and block conflicting transfers. This validation in combination with checkpointing and updated blockchain consensus rules help ensure that such validated transfers have a strong assurance of reaching the transaction memory pool and thus can be relied upon without requiring mining confirmations.","title":"2. Abstract"},{"location":"LokiServices/Blink/#3-blink-from-the-user-perspective","text":"","title":"3. Blink from the user perspective"},{"location":"LokiServices/Blink/#31-wallet-side","text":"From the user (wallet) side, initiating a Blink transfer is nearly identical to initiating a normal transfer, but with an extra flag (e.g. GUI checkbox, RPC parameter, CLI option) to say \u201cBlink this transaction!\u201d. The fees of the blink transaction are higher as it involves considerably more work for the network: service nodes must validate the transaction, and all nodes must perform extra validation steps and require some temporary extra storage to store recent Blink transaction details. For the user receiving a blink transaction, the wallet will see the received amount virtually instantly (that is, as soon as it is received by the lokid and the wallet refreshes with the daemon). Moreover these funds will be instantly spendable: unlike a regular transaction there will be no lock on the received funds before they can be spent again. The wallet user can immediately re-Blink the funds to someone else, or can send off a regular (non-Blink) transaction that spends the received Blink outputs instantly without needing to wait for the Blink transaction to be mined into a block.","title":"3.1. Wallet side"},{"location":"LokiServices/Blink/#32-re-blinking","text":"One of the goals of Blink is the ability to \u201cre-Blink\u201d: That is, we want a Blink transaction to be instantly available to the recipient indistinguishable from a (confirmed) non-Blink transaction from a usability perspective. For example, when Ava blinks 10 LOKI to Betty then that transaction is initially still in the mempool, but we don\u2019t want Betty to have to worry about this technical detail: instead Betty can instantly Blink it to someone else, send a regular transaction, or use it to stake a new service node without waiting for even a single confirmation.","title":"3.2. Re-blinking"},{"location":"LokiServices/Blink/#33-fees","text":"The precise fee schedule is yet to be determined, but will be an additional amount on top of the current transaction fee, most likely calculated as a multiple of the transaction fee. Additionally, Blink transactions will not have a choice in transaction priority: since they are instantly spendable and guaranteed by the network, there would be little point in a user ever choosing anything higher than the minimum. Thus, for now, we mandate that Blink fees must always be submitted with a \u201cnormal\u201d priority transaction fee (but this is tentative and may be adjust this before final Blink release). The extra Blink fee doesn\u2019t go to anyone: rather it gets permanently destroyed as part of the transaction. We considered two alternatives here: Collecting fees and redistributing to SN over time. This would involve temporarily burning Blink fees, but keeping track of how much had been burned and continually reemitting them over a period of time as an extra rewards to Service Nodes. (For example: in every block, reduce the current pool of burned fees by 0.1% and reemit it to the service nodes that earn a reward in that block). Just burning fees. Ultimately we decided on the second approach because: It is much simpler. It is more predictable: SN rewards (for a stable number of service nodes) are known precisely. In the end, the two approaches are effectively equivalent in terms of total emission. By equivalent I am assuming that we have a specific net emission target. For simplicity, I\u2019ll just talk about the long-term 28 LOKI/block emissions, and, for the sake of example, assume that it is divided up so that service nodes get 20 LOKI/block of that; [1] the remaining 8 is foundation and miner coinbase rewards. What I mean by net emission is that if we have an average burning of 5 LOKI/block in Blink fees, then the net emission would 23 LOKI/block. But let\u2019s suppose that 25 LOKI/block is our actual desired long-run emission target. With method 1, we\u2019re emitting 28 LOKI/block: burned Blink fees are reemitted over time and so, much like regular tx fees, there is no net gain or loss. To hit the 25 LOKI/block target we\u2019d have to adjust the formula to reduce emissions to 25 LOKI/block. With method 2, where we are burning 5 LOKI/block in fees, we are generate net emissions of 23 LOKI/block; to hit the same 25 LOKI/block target, then, we would need to increase coinbase emissions by 2 LOKI/block to hit our target. Either way we arrive at the same place: net emissions of 25 LOKI/block through adjustment of the emission schedule. This was just an example, of course; our actual target could be 20 or 28 or 12 or whatever else. But with method 2, service nodes always know exactly what they will earn, while with method 1 there is more variability: large, sustained differences in the volume of Blink transactions will affect SN profitability, while in method 2 such differences will affect the overall coin emission but not the amount earned by a service node. Thus, given the simpler approach and essential equivalence between the two approaches, we decided to pursue method 2. (Of course, like anything in Loki, we can always change the design later given compelling reasons to do so!)","title":"3.3. Fees"},{"location":"LokiServices/Blink/#4-technical-design","text":"","title":"4. Technical design"},{"location":"LokiServices/Blink/#41-transaction-overview","text":"In a nutshell (with most of the details covered later in this document): The wallet builds a transaction and sends it to the lokid to be blinked. The lokid then looks up the Blink quorum, connects to a few nodes in this quorum, sending the transaction to them to be signed. The quorum distributes the transaction within itself, and once enough approval signatures are collected, broadcasts the transaction and signature data to the service node\u2019s p2p peers to disseminate it across the network. The lokid talking to the quorum then receives a confirmation message (with signatures) to relay to the wallet. These steps are depicted in Figure 1. Note that the diagram has been significantly simplified for illustration to show only three service nodes per quorum rather than the actual ten. In more detail: The wallet constructs a transaction. This transaction is almost like a regular transaction except that it leaves enough inputs unspent to cover both the required mining transaction fee and the Blink fee. This transaction gets send to the wallet\u2019s lokid for handling. lokid looks at the transaction, does some preliminary checks (as it would with any transaction) and additional checks related to the Blink transaction (such as having the correct transaction priority and blink fee). These checks are not strictly required for network security\u2014they will also be done by the service nodes \u2014 but can give an immediate failure response to the wallet if the node reasonably believes the transaction will fail. Assuming the preliminary checks pass, the node then uses the current blockchain height to determine the transaction\u2019s signing height, h . This h value then determines two current Blink quorums, Q and Q\u2019 (more details on quorum construction are in the Quorum selection section below). The lokid handling the transaction connects directly to 2 nodes selected randomly from each quorum and sends the transaction (plus other required details such as h ) to be signed. The receiving quorum nodes directly contacted by the initiating lokid forward the transaction details to the other quorum nodes for verification. Each service node in the two quorums performs checks on the validity of the transaction, such as ensuring that it isn\u2019t already spent, that it isn\u2019t already in the mempool, that miner and Blink fees are correctly specified, and that the requested signature height, h , h is approximately current (within 2 blocks of what the service node believes is the current height), and that the key images have not been already locked out by a previous, different Blink transaction signing. Assuming everything checks out, the service node records the transaction\u2019s key images locally (to lock them out from being signed again by this service node), signs the transaction hash with the service node private key, and sends the signature to the other quorum members. As each of the quorum members receives a supermajority of valid signatures (i.e. 7 in total) from both quorums it immediately sends out the transaction and signature details to its blockchain peers via its p2p network. If the quorum node in question is one of the nodes that was directly contacted by lokid, it additionally communicates the success back to the caller. These signed mempool transactions, however, are much stronger than a regular mempool transaction in that they can trigger a reorg or lead to rejected blocks: more details on this are covered below. In the case of detectable failure (for example, from a detected double-spend confirmed by a sufficient number of service nodes), a failure message is returned to the caller. If a failure is caused by too many quorum nodes timing out the caller is expected to itself timeout after an appropriate amount of time waiting for a response. The initiating lokid waits for success, failure, or timeout from the quorum nodes it contacted, and once received (or timed out), sends this information back to the wallet.","title":"4.1. Transaction overview"},{"location":"LokiServices/Blink/#42-quorum-selection","text":"Quorum selection works by using the requested signing height h to deterministically select the two relevant quorums, Q and Q\u2019 . A quorum Q is determined by the 5-block range within which h falls, and Q\u2019 is the quorum for the immediately subsequent 5-block range. For example, any h value in 1000\u20131004 will yield the same Q and Q\u2019 quorums, and this Q\u2019 will be exactly the same quorum as the Q quorum for an h value in the 1005\u20131009 signing height range. In other words, Q\u2019(h=1003) and Q(h=1006) are the same quorum . All service nodes in Q and Q\u2019 refuse to sign a transaction with a requested signing height h that is more than 2 blocks behind or ahead of the service node\u2019s current blockchain height: this is to allow some tolerance for Blink transactions to succeed even if new blocks are propagating through the network during the Blink transaction signing process. This \u00b12 tolerance is designed to make the user experience better: using a node that is slightly out of sync [2] will still work fine rather than returning a Blink failure. It also avoids potential Blink failures on the part of quorum nodes: if a block happens to arrive during the actual signing process such that half of the quorum see the new block and half see the old block the quorum will still sign without issue. On the other hand the \u00b12 limit on the signing height also prevents abuse: the larger the allowed range, the more choices a malicious actor would have to pick and choose a \u201cfriendly\u201d quorum. The quorum sample itself needs to be effectively immutable, and so we propose a deterministic random sampling using a MT19937-64 random number generator seeded with the block hash 35 blocks before the first valid quorum height, h\u2080 . Thus quorum Q for height 1002 is determined by block 965 (35 blocks before the first signing height of the quorum, h\u2080 =1000), and quorum Q\u2019 is determined by block 970 (35 blocks before the first height of the second quorum, h\u2019\u2080 =1005). Moreover the sampling algorithm excludes any service nodes that are scheduled to expire before block h\u2080 +10. For validation of a Blink transaction we require a supermajority of signatures from both quorums. The point here of using the two quorums is to prevent a timing conflict where, if we had just one quorum per block (or range of blocks), then one Blink transaction could be signed by quorum Q\u2081 and another transaction spending the same keys could be signed by quorum Q\u2082 before the first transaction is broadcast to the network. By using two overlapping quorums we end up with the key images in question being locked both in the current quorum but also in the following quorum (which could come as early as the next block). Even if the next Blink transaction switches to a new quorum, the overlap ensures that it simply switching to a quorum that has already locked any key images of Blink transactions submitted in the last few blocks.","title":"4.2. Quorum selection"},{"location":"LokiServices/Blink/#421-overlapping-quorums-rationale","text":"There are three reasons for using these two overlapping quorums. First, we want the quorum signature process to \u201creach\u201d a few blocks into the future (5\u20139 blocks ahead with 5-block quorums) to give enough time for the quorum signatures to disseminate across the network. While 5 blocks is more than would be typically required, there are some edge cases discussed in detail below that can lower this future block interval to just 2 blocks. Second, Blink processing is expected to require a substantial number of connections between service nodes; with 5-block quorums we can at least reduce the frequency with which connections need to be established as service nodes will keep their connections open for the duration of the quorum. Third, using two quorums offers considerable higher security than one quorum of twice the size for two reasons. First, each quorum is essentially a new random draw of service nodes; that means the more quorums you have over a given period of time the more random draws you do, and with more draws you get more \u201cchances\u201d to pick a compromised sample. Second, two consecutive supermajorities of quorums of half the size is considerably more secure than one supermajority of a quorum twice the size. Some numbers can help demonstrate this: suppose the network has 1000 service nodes, and a single malicious actor is in control of 25% of those service nodes. Under alternative A, we require the majority of a single quorum of 20 service nodes, and require a 70% of the service nodes\u2019 signatures. Under alternative B, we require two quorums of 10 service nodes each, again requiring 70% signatures from each quorum. Under scenario A in any given quorum the actor has a probability of 0.00000381 of having the required 70% majority. Under scenario B, the actor has a probability of 0.000000173: that is, under scenario A, the actor is about 22 times more likely to obtain control of any random quorum than any random quorum pair. Or to put it into context: in a one year span, there\u2019s about an 18% chance that this bad actor would gain quorum control for at least a single quorum under scenario A, and about a 0.9% chance that he would under scenario B. As for quorum length, if quorums lasted for one block instead of five there would be a 4.4% chance of this 25% operator having a quorum supermajority at least once under the overlapping quorum design, and a 63% chance under the single quorum design. If this adversary actually controlled an incredible 50% of the service node network it would be quite difficult to avoid a compromise: he would have quorum supermajority votes about 2% of the time under the single quorum approach, and 0.3% of the time under the overlapping quorum approach. Such an adversary would have a 95% chance of quorum ownership at least once per day with a quorum of 20, and a 35% chance per day with overlapping quorums. It is worth pointing out, in passing, that these probabilities are countered by the economic design of Loki: even if such adversaries existed, they would have a strong financial incentive to ensure that the network is not compromised as such a compromise would likely have a significant negative impact on their own holdings, which are heavily invested and locked into service node stakes. There is, of course, some desirable statistical properties of making a quorum longer : if quorums changed on a 10 block cycle you\u2019d cut the probability of compromise by nearly half (to 0.45% in the overlapping case). This gain isn\u2019t huge, though; moreover the longer the quorum becomes the more complications can arise from service node deregistrations, and the more time you allow for coordination between service node operators looking to cheat the system. Instead, if we wanted to further increase the security of Blink transactions, a preferable approach would be to use a triple quorum. It could also be possible to enable an opt-in triple quorum, at a higher fee, to allow users to send with a paranoid level of assurance. (This is now, however, part of the current Blink plan.)","title":"4.2.1. Overlapping quorums rationale"},{"location":"LokiServices/Blink/#422-quorum-selection-block-and-checkpointing-rationale","text":"Using a lag of 30 blocks for quorum determination was chosen to interact with Loki checkpointing. Unlike checkpointing and deregistration quorums, a change in Blink quorums would be highly undesirable as the validity of the Blink signature would no longer hold. Thus we want to use a height from the blockchain that is sufficiently far back as to be highly likely to be made immutable via checkpointing. By basing the quorum on h\u2080 -30 we give ample time for checkpointing even if 2-3 checkpoints have been missed. For example, if blinking at height 1000 then Q\u2019 begins at 1005, which means the relevant block for determination of Q\u2019 is 975. Checkpointing normally occurs every 4 blocks with immutability occurring after 3 checkpoints. Thus in typical times it can be up to 4 blocks since the last checkpoint quorum, which itself establishes a checkpoint on a block 4 blocks earlier. Allowing up to 2 blocks for the quorum to vote and disseminate the checkpoint to the network this means the first checkpoint is usually between 4 and 10 blocks ago, the second is 8-14 blocks ago, and the third, immutable checkpoint is 12-18 blocks ago. If one of these checkpoints were missed (for example because of a quorum failure) then the immutable checkpoint could be 16-22 blocks ago; and if three were missed, up to 30 blocks ago. Thus the h\u2080 -35 rule establishes that both quorum selections are established by a block at least 30 blocks in the past, which allows Blink to tolerate up to 3 missing checkpoints. To further secure Blink transactions we further require that the quorum seed heights are checkpoint-immutable: both the initiating lokid and the quorum service nodes will verify that the quorum seed height is in fact checkpointed, refusing to sign (and thus failing the Blink if enough fail to see the required checkpoints) if it is not. This ensures that Blink transactions are secure by preferring to fail a Blink signature rather than include one that has any chance of being invalidated by a block reorganization.","title":"4.2.2. Quorum selection block and checkpointing rationale"},{"location":"LokiServices/Blink/#43-quorum-validation","text":"Some potential cases are depicted below:","title":"4.3. Quorum validation"},{"location":"LokiServices/Blink/#431-tx-example-one","text":"TX\u2081 is depicting a transaction submitted to a daemon which sees the current height of the network at 1002. We can think about a few different cases: Submitting the blink transaction normally at the known height (1002). Thus we get Q = Q\u2081 and Q\u2019 = Q\u2082 for the two quorums. The initiating lokid contacts a random service node q from Q\u2081 , passes along the transaction, and waits for a reply from q . q in turn communicates with its quorum peers and the subsequent quorum ( Q\u2082 ) to build the required set of signatures. Once the required signatures are accumulated the transaction is released by the quorum service nodes to their peers. The Blink TX is broadcast to the network. Because a majority of Q\u2082 service nodes signed it and will not resign the same key images, the earliest possible Blink height to spend the same key images is 1010, which can be used by a cheating lokid at network block 1008 at the earliest. Submitting slightly behind the network (1000 or 1001). This could happen, for instance, because there have been two recent blocks that the local lokid has not synchronized yet. Generally everything here works as above: the service nodes at height 1002 will still sign the block (assuming the transaction itself is valid) because the requested signature height is within 2 of their current height. Submitting slightly ahead of the network (1003 or 1004). This could happen, for instance, if the local node is close to a very lucky pool that has just discovered a couple blocks that haven\u2019t disseminated across the network yet. Again, this is handled just like the above: even though the service nodes haven\u2019t yet seen a block newer than 1002 it still satisfies the within-2 rule and so they will still sign (assuming the transaction is valid). Submitting well behind or well ahead of the network (999 or lower, or 1005 or higher). In this case the quorum will not accumulate enough signatures because the within-2 requirement is violated. In this case a failure gets returned to the initiating lokid. [3] The first three (accepted) cases above all result in the earliest block a cheater could submit to being 1008 (i.e. abusing the within-2 rule to submit a h=1010 block), giving a worst case of at least 4 blocks needing to be transmitted to the network before a duplicate Blink could be submitted; since Blink dissemination is high-priority this should result in a high level of assuredness that a Blink double-spend cannot be performed in this scenario.","title":"4.3.1. TX example one"},{"location":"LokiServices/Blink/#432-tx-example-two","text":"TX\u2082 in Figure 2 shows a transaction that is sent via a lokid that sees the current h=1006 , i.e. in the second block of quorum Q\u2082 . I\u2019ll just ignore the h>1008 and h\\<1004 cases (see above for why they are dead ends). Case 1: Submitting h =1005, 1006, 1007, 1008. This case is largely the same as TX\u2081 , but now the two quorums are Q\u2082 and Q\u2083 . The earlier a theoretical double-spending Blink could be submitted is with h =1015 at actual height 1013: that is, a minimum of 5 network blocks away. Case 2: Submitting h =1004 (either due to a lagging node, or a malicious actor). This ends up using the same quorums as TX\u2081 (that is, Q\u2081 and Q\u2082 ). As in TX\u2081 , the earliest possible double spend could be submitted at 1008. Case 2 here represents the worst possible scenario: there are just two network blocks between the current height (1006) and the height at which a blink transaction could be submitted to a completely independent quorum pair. There is a potential issue here from an attacker, discussed in further detail below.","title":"4.3.2. TX example two"},{"location":"LokiServices/Blink/#433-tx-example-three","text":"TX\u2083 is included for completeness to show that cheating ahead by a quorum has no advantage for a potential attacker. This depicts the sending transaction at h =1009. The attack essentially has two relevant choices: h =1007\u20131009, or h =1010,1011. In the first case, he gets quorums Q\u2082 and Q\u2083 , making his earlier possible Blink double-spend at h =1015 (submitted at h =1013), which is Stats geek note: the probability of being 3+ blocks behind the network with lag L seconds is the CDF value of a Poisson distribution with \u03bb= L /120 at k =3.","title":"4.3.3. TX example three"},{"location":"LokiServices/Blink/#44-repeated-signing-of-the-same-transaction","text":"One possible Blink failure mode is that the requested signature height, h , is seen as too old (or even too new) by some or all members of the service node quorum if it does not fit within their \u00b12 tolerance. This could be caused, for example, by the lokid the wallet is talking to being out of sync. In the case of such a failure, the calling lokid could check for new blocks and, if changed, resubmit the transaction for signing at an updated signing height h . We want this resubmission to succeed even if it goes to the same quorum, as it makes the Blink process more robust to network synchronization issues. This means, in particular, that service nodes will need to add an exception to the normal key image blacklisting if asked to re-sign the exact same transaction for which the key images were blacklisted.","title":"4.4. Repeated signing of the same transaction"},{"location":"LokiServices/Blink/#45-signature-failure-key-images-may-stay-unblinkable-for-up-to-10-blocks","text":"When a service node signs a transaction as part of a given quorum it will never sign a different transaction containing any of the same key images again as part of that quorum. Since failures are possible for multiple reasons, however, it does not block the key images of a transaction that it refused to sign. It is possible, however, for a transaction to fail to be signed by a supermajority while still being signed by a superminority (that is, by enough other nodes to prevent a supermajority). This case is expected to be rare: the criteria for service node disagreement is small: effectively you would need (roughly) half of the service nodes to see something wrong with the transaction. It is not impossible, however: if a regular transaction spending the same key images is mined and the block transmitted in the middle of signing the blink could fail. The user-facing problem that could arise here is that the transaction that gets signed includes multiple key images, only some of which are ineligible. The service nodes that signed the transaction, however, end up locking all of the key images for the duration of the quorum ( i.e. the next 4\u20139 blocks), so even once the user wallet sees the updated chain a new transaction might end up trying to blink using an input that is temporarily non-blinkable (note that it will still be regularly minable since the Blink was not transmitted due to the quorum failure). This case seems rare: it would require a legitimate user spending regular transactions and blinking at the same time from different wallets. It\u2019s possible, of course, but given the rarity and the relatively minor consequence (not being able to Blink those outputs for 10\u201320 minutes) for now we will simple leave this as a known limitation.","title":"4.5. Signature failure: key images may stay unblinkable (for up to 10 blocks)."},{"location":"LokiServices/Blink/#46-blink-transactions-entering-the-mempool","text":"Blink transactions themselves are perfectly ordinary transactions on the blockchain: the signatures applied by service nodes do not end up as part of the transaction that gets mined into the chain. Instead this metadata is shared and synchronized between nodes from the time when a Blink transaction enters the mempool until the transaction is mined and secured behind an immutable Loki checkpoint boundary. An incoming Blink transaction in the mempool will also be transmitted with the Blink height and the verifiable Blink signatures at which the transaction was signed. Based on this, a loki node receiving a blink transaction will perform multiple actions: Verify that the Blink signatures are the correct signers for the given height, and that the signatures are valid (and if not reject the Blink transaction). Check to see if any of the key images were spent in or before the last irreversible checkpoint block: if so, reject the Blink transaction. Check to see if the mempool already contains any Blink transactions that have a higher priority (i.e. lower height) than the incoming transactions, and if so, refuse the incoming transactions. (This shouldn\u2019t be possible, but is included as a safeguard to maintain consensus). Check the current chain back to the last irreversible checkpoint: if any blocks contain any transactions that spend any of the key images in the new Blink transaction then roll back the chain as much as needed to remove those transactions from the blockchain, re-adding any rolled back transactions into the mempool (as occurs already with any reorg). Reject any non-Blink transaction from the mempool that spend the same key images as the new Blink transaction (if we just rolled back then this means immediately rejecting the conflicting transactions). Reject any Blink transactions from the mempool that spend the same key images but have a lower priority (i.e. higher height) than the new Blink transaction. This should not be possible in general, but needs to be specified anyway to avoid a consensus failure (as with the mirrored check above). Note that this actual removal could cascade if there are other transactions referencing the removed Blink transaction. Another difference with Blink transactions is that they should not be subject to the existing 2-week mempool transaction timeout. We don\u2019t want someone to be able to submit a low-priority Blink transaction while the network is flooded with higher priority transactions and be able to wait out the transaction until timeout. As long as Blink transactions stay in the mempool until mined all an attacker can do is delay the transaction from being mined, but cannot cause it to be dropped no matter how long he prevents mining. In the unlikely event of a bug that makes a Blink transaction inadmissible to the blockchain for some unforeseen reason, this approach will keep the transaction alive indefinitely until the bug can be addressed. [4] Second, Blink transactions need to be more actively propagated across the network than current transactions. Currently the mempool is not actively synchronized across nodes; instead new transactions are simply broadcast to all connected peers when received. A new node, a node that was temporarily down when the transaction propagated across the network, or a node that has had its mempool manually flushed does not receive existing mempool transactions from peers if it misses it the first time. This needs to change for Blink transactions: when a p2p connection is established we need each peer to send the other a list of any pending Blink transaction details it doesn\u2019t already have. Effectively we need Blink transactions in the mempool to become first-class synchronization objects, just like blocks. Finally, synchronized Blink transactions may not be (and do not need to be) identical across the network in terms of attached quorum signatures: it is entirely possible for two nodes to receive a different set of 14 signatures: so long as all are valid for the quorum","title":"4.6. Blink transactions entering the mempool"},{"location":"LokiServices/Blink/#47-blink-transactions-entering-the-blockchain","text":"A transaction entering the blockchain from the mempool requires two changes: first, the Blink transaction\u2019s unspent amount now includes both the tx fee, as before, but now also the Blink fee. Second, because transactions can reference other Blink transactions currently in the mempool this puts an ordering on transactions: if A includes B in its ring signatures (whether as the actual key image or a decoy) then there is an implied ordering for mined block selection: A cannot be included in a block before the block in which B is included. This requires, of course, changes to the transaction selection algorithm used to construct block templates for miners.","title":"4.7. Blink transactions entering the blockchain"},{"location":"LokiServices/Blink/#48-re-blinking-implementation","text":"As discussed in Re-blinking we need received Blink funds to be instantly spendable. That means that the recipient\u2019s wallet needs to recognize that those received funds are immediately spendable, whether in a new non-Blink transaction or in a new Blink transaction. In either case this means the new transaction will spend outputs that aren\u2019t yet on the chain, but are still in pending Blink transactions in the mempool. We need to update lokid and the wallet allow this. This does, however, raise another important issue, addressed in the next section.","title":"4.8. Re-Blinking implementation"},{"location":"LokiServices/Blink/#49-ring-signature-implications","text":"The anonymity in Loki depends on the actual and decoy outputs being included in the transaction ring signature being indistinguishable. Quick turn-around re-blinking breaks that with the current ring signature selection in two ways: First, a Blink transaction that enters the mempool that includes a mempool Blink transaction in its ring signature provides a perfect link between the transactions because currently only blockchain transactions but not mempool transactions are ever included in a ring signature. Even if you don\u2019t have the mempool history you can still infer likely links between Blink transactions that are very close together (i.e. within a small number of blocks). As outputs in the same block (or within a couple blocks) are highly unlikely to occur naturally, seeing such transactions in the mempool give a high probability that the transactions are linked. [5] To get around this problem, we will need to update the ring signature construction to be able to select from both existing blockchain transactions and Blink transactions in the mempool for both Blink transactions and regular transactions . (This of course imposes additional mempool ordering constraints to those discussed in the blockchain section as ordering also applies to non-Blink transactions using mempool decoys.) Further investigation will be needed to determine a good selection probability (and will likely need tweaking in future releases), but we will aim to be on the side of having too high a probability: using too low a probability is much worse as it would make Blink transactions still stand out (albeit imperfectly). Potentially including mempool Blink transactions in normal transaction ring signatures is important as well: because a Blink transaction is instantly spendable, a non-Blink transaction including a recent Blink transaction would similarly link the outputs together. Thus we potentially include Blink dummy transactions in all transactions (which has the separate advantage of simplifying the code: building a Blink transaction and building a regular transaction will be identical).","title":"4.9. Ring signature implications"},{"location":"LokiServices/Blink/#410-blink-and-checkpoints","text":"Blink transaction metadata (i.e. quorum signatures, signing height) is meant to be temporary data that only needs to be kept until the transaction is unequivocally committed to the blockchain. Thus Blink is designed to work with Loki\u2019s checkpointing feature: once the transaction has passed the point where it is not reversible\u2014that is, once it has been signed by three checkpoint quorums\u2014service nodes can discard the metadata.","title":"4.10. Blink and checkpoints"},{"location":"LokiServices/Blink/#411-quorum-communication","text":"Current quorum communication (e.g. for deregistration voting or for the upcoming checkpointing support) relies on a gossip protocol to carry messages over the loki p2p layer. While this is manageable for those applications it is not going to be sufficiently scalable for Blink quorum voting. Instead part of the Blink development will be to build a direct communication layer where service nodes connect directly to one another for quorum purposes. The initial plan is for quorum SNs to communicate directly with each (using the SN public IP being added in #622 ). This communication layer will also be designed to handle quorum traffic for service node deregistration and allow faster and more efficient communication in those scenarios as well. The specific implementation details will be developed further during the Blink implementation; the current plan is to create a relatively simple SN-to-SN protocol using ZMQ (which is already a loki core dependency) over which quorum members communicate, and over which the initiating lokid contacts quorum service nodes to begin the Blink signing process. The initial approach here is to use a fully-connected quorum: 9 open connections, roughly half inbound and half outbound, for each SN, held open (and reestablished upon disconnection) for the duration of the Blink quorum validity. As a simple fully connected approach, the following table shows node-to-node connections within a quorum: where \u201co\u201d indicates that the row node establishes an outgoing connection to the column node and \u201ci\u201d indicates that the row node receives an incoming connection from the column node. Additionally once the depicted quorum Q becomes the first quorum, nodes 6\u201310 establish outgoing connections to nodes 1\u20135 of following quorum, Q\u2019. (Similarly, but not depicted, when Q is the second quorum there will be inbound connections to SN\u2081 through SN\u2085 from the previous quorum\u2019s last 5 nodes): first node in the quorum will open connections to nodes 2\u20136, the second node will open to nodes 3\u20137, and so on. The sixth node will open connections to nodes 7\u201310, the seventh node to 8\u201310 and 1, and so on. Additionally, once a quorum becomes the first quorum, nodes 6\u201310 each establish a connection to nodes 1\u20135 in the second quorum. This is designed to be balanced: each service node establishes outgoing connections to exactly 5 other service nodes, and is connected to by a (different) 5 service nodes. Each of these Additionally, each quorum would have some nodes that establish a connection to some of the nodes in the following quorum over which messages will be passed when a quorum has acquired the required supermajority of signatures.","title":"4.11. Quorum communication"},{"location":"LokiServices/Blink/#412-service-node-deregistrations","text":"As discussed in the Quorum Selection section, the service nodes that make up a quorum are chosen by excluding service nodes that have (or will) expire before the quorum completes its tasks. A related problem, however, is that there are unforseeable deregistrations that may occur (or may have already occurred) since the seed height. This is partially addressed by the quorum tolerance: since a quorum required only 7 of 10 votes, it can continue to function even if 3 nodes deregister. It is, however, possible (albeit extremely unlikely) that 4 or more nodes have been deregistered from the network in either quorum, either before the quorum begins or during the quorum validity period. If this occurs, a quorum member must simply refuse to sign. This can also be checked by the initiating lokid: if it fails to build a quorum of at least 7 active nodes in each quorum it can immediately return an error to the initiating wallet that the Blink service is temporarily down. The reason that we cannot add \u201csubstitute\u201d nodes in the event of deregistrations is that it would affect the validity of quorum signatures if a blockchain reorganization should happen: such a reorganization could delay the deregistration to the point that the substitute isn\u2019t actually valid anymore, thereby invalidating the Blink signature. It is tempting to at least consider substitutions for deregistrations that are past an immutable checkpoint boundary, but again this would not work: though checkpoints are distributed across the network, they are a moving target that is external to the blockchain itself. Thus determining the correct set of quorum signatures would change as checkpoints propagate the network and so verification of having the correct set of signatures would be impossible. We believe that the 7 of 10 threshold, allowing for up to three failures (including deregistrations) should be sufficient to keep Blink operational in all but extreme circumstances (such as mass Service Node deregistrations). Should this prove problematic, the recommended approach is to increase the quorum size, slightly reduce the supermajority requirement, or both.","title":"4.12. Service node deregistrations"},{"location":"LokiServices/Blink/#5-potential-attacks","text":"While the basics of the above in normal operation are fine, there are several edge cases that need to be addressed specifically to prevent accidental conflict or deliberate attacks.","title":"5. Potential attacks"},{"location":"LokiServices/Blink/#51-double-spending-blink-tx-non-blink-tx","text":"This attack would work by privately mining a block where the inputs used in a Blink transaction are spent, conducting a Blink transaction, then releasing the private block to the network after the Blink transaction has been approved. This would be a classic double spend, but because Blink transactions are 0-confirmation transactions, you don\u2019t need a 51% attack; you would just need a single block and a bit of luck. The solution to this is that Blink transactions in the mempool are stronger for consensus purposes than non-Blink transactions on the chain . That is, if a Blink-signed transaction arrives in the mempool that conflicts with (i.e. spends the same inputs as) a transaction already mined on the chain then the block containing the conflicting non-Blink transaction is no longer a valid blockchain block and must be rolled back. There is a limitation to this, however: if the conflicting block has passed an irreversible checkpoint boundary then it is instead the Blink transaction that is invalid. [6]","title":"5.1. Double-spending Blink tx + non-Blink tx"},{"location":"LokiServices/Blink/#52-double-spending-blink-blink","text":"Sending two parallel Blink transactions that spend some of the same inputs at the same signing height h isn\u2019t possible: the approving service nodes by design will not sign twice for the same outputs, and to actually be accepted a Blink transaction must be signed by a supermajority of the service nodes in the (unique) signing quorum. Sending two Blink transactions at different heights, however, can be a potential issue if exploited by something I will call \u201cquorum hopping\u201d and address in the next section.","title":"5.2. Double-spending Blink + Blink"},{"location":"LokiServices/Blink/#53-quorum-hopping","text":"In order to double-spend Blink transactions it is necessary to \u201cquorum hop\u201d \u2013 that is, to have your transaction signed by two independent sets of quorums. Practically speaking, that means that that you need one Blink transaction signed by Q\u2081 and Q\u2082 , and another spending the same outputs signed by Q\u2083 and Q\u2084 . [7] For the purposes of illustration, I\u2019ll continue with TX example two from Figure 2, and I\u2019ll assume the attacker has an arbitrary amount of hash power available. In order to quorum hop, the attacker needs to get signatures from Q\u2081 and Q\u2082 and signatures for another transaction spending the same outputs from Q\u2083 and Q\u2084 . The basic assurance is that while the current network is at height 1006, Q\u2084 won\u2019t sign a transaction. However, 1006 is close enough to the quorum endpoint that the attacker does get a choice between the Q\u2081/Q\u2082 pair and the Q\u2082/Q\u2083 pair: though Q\u2082/Q\u2083 is the proper quorum pair for a truthful h =1006 request, we allow him to claim h =1004 (to allow for network latency). To get a successful signing from the Q\u2083/Q\u2084 quorum pair, however, the second Blink transaction must request a signing height of at least h =1010, and the quorum won\u2019t accept such a height unless it locally sees at least h =1008. This means the attacker needs to get two new blocks on the network quickly but not too quickly: if too fast, the transaction may reach too many of the Q\u2081/Q\u2082 quorum members that the first tx signature fails. If too slow, the signed transaction broadcast from Q\u2081/Q\u2082 service nodes may reach enough Q\u2083/Q\u2084 service nodes that signing of the second transaction fails. Thus we\u2019ll assume that there is some small window for \u201cgoldilocks\u201d timing: timing that is not too fast to reach Q\u2081/Q\u2082 and not too slow to reach Q\u2083/Q\u2084 after the first transaction. The timing of the attack would go like this: Privately mine and withhold 2 blocks (heights 1007 and 1008). Initiate a Blink signing at h =1004 (thus using the Q\u2081/Q\u2082 quorum pair). Release the withheld blocks; ideally send them directly to Q\u2083/Q\u2084 quorum members. Initiate the conflicting transaction Blink signing at h =1008 (thus using Q\u2083/Q\u2084 ). If successful, nodes on the network will end up receiving two conflict Blink transactions with valid signatures. First, for a unique consensus rule, we need to pick a consensus winner, which is easy enough: we simple prefer the Blink transaction with an earlier signing height and reject the later one. [8] Second, and more important, we want to make the attack to be \u201cimpossible\u201d [9] . This is done by effectively adding a delay to Blink signing in potentially problematic case, effectively shortening the \u201cgoldilocks\u201d window to nothing. Specifically the proposed delay is as follows: when a quorum service node is asked to sign a transaction at height h , it checks the time when it received the critical block that allowed the given quorum pair associated with height h . If this critical block was received less than 5 seconds ago, it delays the Blink checks and signing until at least 5 seconds have elapsed since that critical block was was received by the given service node. For example, the critical block for a signing height of 1007 would be 1003; for 1010 it would be 1008: The whole idea here is to add enough of a delay that the Blink transaction being signed by Q\u2081/Q\u2082 has time to propagate to enough Q\u2083/Q\u2084 service nodes that they will see the double-spending attempt and thus fail to build enough signatures to Blink the transaction. 5 seconds should generally be much more than enough for reach all the quorum members, but we don\u2019t actually need it to reach all: rather it is enough to reach just a supermajority-busting minority or either Q\u2083 or Q\u2084 service nodes. A delay of up to 5-seconds is highly undesirable for a Blink transaction, of course, so it is worth considering how unlikely this delay would be under typical blockchain activity when an honest user is sending a Blink transaction. Let\u2019s suppose the user submits a transaction to sign at height h=1010 , and so quorum service nodes check when they received block h=1008 to figure out whether they need to delay. In order to trigger a delay, we need h=1008 to have been received by the service node less than 5 seconds before the signing request is received. Adding an extra couple of seconds for blocks to reach service nodes, this means we need to have found 3 (or more) blocks on the network in approximately 7 seconds. Given LOKI\u2019s 120-second block target, the probability of seeing this naturally is approximately 0.000031[^prob_7s]; even if we allowed for increased network latency to delay block transmission by 5 seconds the probability of triggering the delay is still only 0.000091. These probabilities are also worst cases conditional on using the first block in a new quorum (which itself only occurs 1/5 of the time). If we consider the probabilities for a transaction signed at h=1011 , we would need 4 network blocks received in the same timeframe: that is, 0.00000046 for a 7-second window and 0.00000188 for a 10-second window. Thus suffice it to say that the probability of an honest user accidentally hitting the delay is small. Even if they do hit it because of extremely bad luck, the only consequence is a delay of at most 5 seconds for their Blink confirmation.","title":"5.3. Quorum hopping"},{"location":"LokiServices/Blink/#54-signature-withholding","text":"The design requires the Blink quorum itself to disseminate the Blink transaction to the network. This has one potential advantage of having the transaction go out faster (service nodes are often better connected), but the more important reason is to prevent the caller from withholding the Blink transaction to cancel out a later Blink transaction. Such an attack would work as follows: Attacker constructs a Blink transaction sending funds to himself; he submits at the current height using quorums Q\u2081 and Q\u2082 . Instead of immediately transmitting the signed transaction to the network, however, he stores it. He then waits a few blocks for a height that will let him use a different quorum pair, Q\u2083 and Q\u2084 . The attacker constructs another Blink transaction sending the same outputs to an exotic car dealer who, seeing the Blink transaction on the network, hands over the keys to a brand new Italian sports car. While driving off, the attacker releases the initial Blink signatures which replaces the car payment transaction with his earlier transaction to himself, making the car payment permanently unspendable. To avoid the problem, we need to force the transaction dissemination as quickly as possible: thus mandating that the service node quorums should themselves broadcast it; this effectively means the Blink transaction will be broadcast to the network from 14\u201320 well-connected nodes. As a side effect, this broad dissemination method also ensures that Blink transactions reach all nodes very quickly.","title":"5.4. Signature withholding"},{"location":"LokiServices/Blink/#55-51-attack-to-reorganize-the-blink-quorum","text":"The idea behind this attack is that an attacker would submit a blink transaction then attempt to invalidate it by using a 51% attack to reorganize the blockchain far enough back as to disrupt the quorum seed, thus making the blink signatures on the transaction no longer valid. This attack is prevented by requiring a long (35-block) lag for quorum determination and not having service nodes sign a transaction if they do not see their quorum seed height as checkpoint-immutable. See Quorum selection block and checkpointingrationale for more details.","title":"5.5. 51% attack to reorganize the Blink quorum"},{"location":"LokiServices/Blink/#6-future-ideas","text":"There are myriad ways the Blink implementation could be extended and advanced; this section is laying out some of them. Note that there is no guarantee that all of these will be implemented.","title":"6. Future ideas"},{"location":"LokiServices/Blink/#61-dynamic-fees","text":"In the Fees section we currently mandate that the miner transaction fee for a Blink transaction must always be set to the \u201cnormal\u201d priority fee. This is sub-optimal: a dynamic system that sets a fee based on the blockchain activity. For example, the transaction priority (and thus the fee) could be calculated by considering the average fee and fill percentage of the 60 blocks ending 30 blocks before the Blink height to calculate a fee. The Blink portion of the fee could similarly be dynamic based on the number of recent Blink transactions on the blockchain.","title":"6.1. Dynamic fees"},{"location":"LokiServices/Blink/#62-merging-transactions","text":"Given a pair of Blink transactions on the mempool, it ought to be possible to merge them into a single transaction. For example, if Kee blinks funds to Jason and Jason reblinks those funds to Simon, it ought to be possible (at least in some situations) to merge the transactions in such a way that both can be replaced with a single merged transaction that spends all the same outputs and pays the right recipients, but is combined into a single, smaller transaction on the blockchain. The privacy components of Loki\u2019s underlying design certainly complicates the idea, but it is worth pursuing at least some research into whether and how this could be accomplished. In theory this combining could also be done for regular transactions, but starting this with Blink with its much stronger guarantees of blockchain acceptance seems safer.","title":"6.2. Merging transactions"},{"location":"LokiServices/Blink/#63-allowing-different-blink-supermajority-levels","text":"In this plan we simply specify a quorum of 10 and supermajority of 7. It seems plausible, however, to let advanced users require an extra paranoid level of security by including a flag requesting a higher level of signing: for example, requiring 8 or 9 signatures per quorum. This would increase the likelihood of failures due to quorum communication issues, and would likely slightly increase the typical Blink time, but would be entirely feasible to support. One question mark around this is whether it would be a particularly valuable addition for LOKI users. On the one hand it would allow extra choice, but there is uncertainty as to whether this extra choice would actually be used. A larger concern is that the option of a \u201cmore secure\u201d mode would imply that the default 7/10 supermajority requirement is somehow less secure, despite the design (as laid out in this document) explicitly targetting building a secure system. Indeed the only security gained from a higher quorum level is higher protection again quorum ownership by an adversary. As the statistics in the Overlapping quorums rationale point out, however, this is already an extremely low risk even for someone in control of a huge portion of the network\u2019s service nodes. Thus it might be preferable to not offer such a feature explicitly to undermine that the current Blink system is already designed to be highly secure. Users who need an extra paranoid level of security will always be better off using a regular transaction and waiting for many confirmations plus service node checkpoints.","title":"6.3. Allowing different Blink supermajority levels"},{"location":"LokiServices/Blink/#64-quorum-communication-via-mesh-network","text":"The idea proposed above for intra-quorum communication is simple, but probably does not scale well to larger quorum (such as the 20-node quorum used for checkpoints). An alternative approach is to use a partially connected mesh network over which some SNs route messages for other SNs. This complicated the mechanism (because more node-to-node routing is required) and slightly reduces the speed, but network latency is less of a concern for checkpointing than it is for Blink transactions.","title":"6.4. Quorum communication via mesh network"},{"location":"LokiServices/Blink/#65-carrying-traffic-over-lokinet","text":"One aspect to consider in the future is the possibility of carrying all blink coordination traffic over lokinet rather than establishing direct public IP SN-to-SN connections. Such transmission can still be fast by using 0-hop paths within lokinet (which are effectively just encrypted direction connections). There is no particular reason that this data needs to be encrypted or hidden, but this would have some advantage for lokinet by providing cover traffic, and would let lokinet deal with any connection nuances. One technical caveat raised by lokinet devs when discussing this idea is that we would have to take steps to ensure that lokinet\u2019s connectivity parameters remain sufficiently high to not partition the network: So the idea is that snodes within a quorum are going to talk to each other. If this goes over 0-hop lokinet then their lokinet routers will have connections to one-another. This is fine. The possible issue arises because lokinet routers have a preset minimum number of connections to other routers that they want to maintain. If this minimum is low enough that it is satisfied by the quorum size then the routers may not seek out connections to other routers and, in theory, that quorum could become partitioned from the network by way of all the routers only connecting to one-another and not other routers outside their quorum. It doesn\u2019t seem super likely to happen, and is easily prevented anyway by setting min_conn_count > quorum_size , but it is technically possible without that mitigation so I figure we may as well set our desired minimum connection count for the routers higher just in case. Another possibility is to include some sort of flag to tell lokinet to not consider this a connection for the purposes of maintaining the minimum connection count.","title":"6.5. Carrying traffic over lokinet"},{"location":"LokiServices/Blink/#footnotes","text":"This split is purely for the sake of example and not meant to be taken as a concrete plan to change the coinbase reward to these particular values. Any such change in reward structure is obviously entirely outside the purview of this document. A node that is one minute behind the network will fall to more than 2 blocks away from the proper height 0.18% of the time; with two minute lag the node will exceed 2 blocks 1.89% of the time; a thirty-second-slow node will be a problem 0.013% of the time. Since a node lagging by any of these values occurs only rarely (not consistently), the actual probability of users encountering such failures on a decently connected node should be much lower. It is possible for the quorum to return an error status indicating that the lokid should retry at a new height; it is up to the lokid whether it wants to do this or return an error to the client. This is actually a bit more complicated because new transactions can be submitted that spend the Blink transaction outputs or that include the Blink transaction outputs as a decoy. That means those transactions themselves will depend on the Blink transaction, adding further chaining. Effectively the only way to get a tx in block *h* that refers to a tx in block *h* or *h-1* is if a blockchain reorganization that dumps transactions back into the mempool happens; this typically only occurs in a 51% attack so can be considered rare enough to provide a high assurance of the link between transactions. This case is virtually impossible in normal operations, but it must still be specified and handled for completeness of consensus rules. You could hop further, of course, to *Q\u2084* and *Q\u2085*, but the attack is the same: it is just more costly to pull off. In theory there could be transactions that reference the second transaction\u2019s outputs that would also need to be ejected from the mempool. Given that the window of opportunity here is extremely small, this seems a negligible concern. In a practical sense, of course. More technically, we want the attack to be extremely difficult to carry out.","title":"Footnotes"},{"location":"LokiServices/LokiServicesOverview/","text":"Loki Services Overview \u00b6 Loki Services are built upon the protocol level of the Loki network. Loki Services leverage the Service Node layer to allow for decentralised services. Similar to the investment that miners make into hardware, each Service Node operator freezes Loki coins when they begin to operate a Service Node. This frozen capital is called the staking requirement and helps serve the two purposes for Loki Services: Every Service Node operator has a sufficiently large stake in the success of the network. Should any Service Node operator provide poor performance to the network, or act dishonestly, they undermine and risk devaluing their own stake within the network. It provides an opportunity for more aggressive enforcement; if the network is able to effectively limit dishonest nodes from receiving a reward, then dishonest nodes must bear the opportunity cost of both the reward loss and the remaining lockup time on their collateral. If we take the above points to be true, and we can enforce aggressive punishments for poorly behaving nodes, then we can create groups of Service Nodes which can be queried to come to consensus on the state of the blockchain or to enforce special off-chain node behaviour. In Loki, this behaviour pertains to both networking and storage activities. These off-chain activities are combined to be the back-end of user-facing applications that leverage these desirable properties, which are called Loki services. Example Loki Services: Session Blink Transactions","title":"Overview"},{"location":"LokiServices/LokiServicesOverview/#loki-services-overview","text":"Loki Services are built upon the protocol level of the Loki network. Loki Services leverage the Service Node layer to allow for decentralised services. Similar to the investment that miners make into hardware, each Service Node operator freezes Loki coins when they begin to operate a Service Node. This frozen capital is called the staking requirement and helps serve the two purposes for Loki Services: Every Service Node operator has a sufficiently large stake in the success of the network. Should any Service Node operator provide poor performance to the network, or act dishonestly, they undermine and risk devaluing their own stake within the network. It provides an opportunity for more aggressive enforcement; if the network is able to effectively limit dishonest nodes from receiving a reward, then dishonest nodes must bear the opportunity cost of both the reward loss and the remaining lockup time on their collateral. If we take the above points to be true, and we can enforce aggressive punishments for poorly behaving nodes, then we can create groups of Service Nodes which can be queried to come to consensus on the state of the blockchain or to enforce special off-chain node behaviour. In Loki, this behaviour pertains to both networking and storage activities. These off-chain activities are combined to be the back-end of user-facing applications that leverage these desirable properties, which are called Loki services. Example Loki Services: Session Blink Transactions","title":"Loki Services Overview"},{"location":"LokiServices/Messenger/HowToRegisterSessionNames/","text":"How to register an LNS mapping \u00b6 LNS mapping registration will be supported in the CLI wallet at launch. The following steps can be used to register and update LNS mappings in the CLI wallet. Note that you can access a detailed description of each command within the app by using help <command_name> . Purchasing a Loki Name Service record \u00b6 Purchasing an LNS record in the CLI wallet uses the lns_buy_mapping command. All arguments for the lns_buy_mapping command are optional except for the <name> and <value> that the name maps to. lns_buy_mapping [index=<N1>[,<N2>,...]] [<priority>] [owner=<value>] [backup_owner=<value>] <name> <value> Example: Buy a LNS record that maps \u2018KeeJef\u2019 to a Session Public Key, 053 \u2026 254. The wallet buying is the owner of the record. lns_buy_mapping KeeJef 053b6b764388cd6c4d38ae0b3e7492a8ecf0076e270c013bb5693d973045f45254 Example: Buy a LNS record that maps \u2018KeeJef\u2019 to a Session Public Key, 053 \u2026 254. The wallet buying the mapping is the owner of the record, but specifies a backup owner who will also be authorised to update the record. lns_buy_mapping backup_owner=T6U7AaNgN2cARpR7CNHGChGMjsmjq5ffh4hLa4DjUUXtKS3bPy2rKTX614RxmpPPX6KjZzqUSSpAEcoghASTXqvP1qMsJzWch KeeJef 053b6b764388cd6c4d38ae0b3e7492a8ecf0076e270c013bb5693d973045f45254 Example: Buy a LNS record that maps \u2018KeeJef\u2019 to a Session Public Key, 053 \u2026 254. You buy on behalf of another wallet T6UD8..ppir and specify another backup wallet. lns_buy_mapping owner=T6UD8TM1t7mUYmMCHXQ67Kg5jXBwoVxNqGpXctnsLXtGBEFnhq37RQAA8jgqgD9U6QbeNGqAkkVXucXQ5txE6Mrk2aRwpppir backup_owner=T6U7AaNgN2cARpR7CNHGChGMjsmjq5ffh4hLa4DjUUXtKS3bPy2rKTX614RxmpPPX6KjZzqUSSpAEcoghASTXqvP1qMsJzWch KeeJef 053b6b764388cd6c4d38ae0b3e7492a8ecf0076e270c013bb5693d973045f45254 Updating a Loki Name Service record: Wallet executing update is owner of record \u00b6 Updating an LNS record in the CLI wallet uses the lns_update_mapping command. All arguments for the lns_update_mapping command are optional except the name of the record to update, and at least one field of the record to update ( owner , backup_owner , or value ). The [signature] argument is for deferring updates to the record, and is explained in detail in the next section. lns_update_mapping [owner=<value>] [backup_owner=<value>] [value=<lns_value>] [signature=<hex_signature>] <name> Example: Updating the owner of the record (essentially transferring ownership \u2014 after changing ownership, you will no longer be authorised to update the record). lns_update_mapping owner=T6UC1nSy2289uX8R2jS3ci7y6eNnVdvhSQRoZtckPzmrQgJ3CyUhUtxgxuedusx9TCKVhZZBCuwFkKoJ3joXStWh1QozRsXXo KeeJef Note: At this time you can only update Session ID mappings, you cannot yet add a wallet address mapping to your name \u2014 this will require additional changes which will be implemented at a later date. Example: Update all fields of the mapping. lns_update_mapping owner=T6UD8TM1t7mUYmMCHXQ67Kg5jXBwoVxNqGpXctnsLXtGBEFnhq37RQAA8jgqgD9U6QbeNGqAkkVXucXQ5txE6Mrk2aRwpppir backup_owner=T6TEJJRfvhMZbJpRuchJtmQAjuyCUAyYy2yVcc9ySxTHXWgwQkupjUJUQsyCoyYfRGReAY3pgaYxUHwoKEkWNh5o2qe5Btt3x value=0596d2fdc1407490e1bb7cbca3f3674606d3ef9b1d01cf46199ee5c8932d83f40a KeeJef Updating a Loki Name Service Record: Wallet executing is not owner of record) \u00b6 In this scenario, you have a LNS record that you wish to update, and you\u2019re able to coordinate with the wallet owning the record. The wallet that owns the record can execute this command to generate a signature. lns_make_update_mapping_signature [owner=<value>] [backup_owner=<value>] [value=<lns_value>] <name> Example: User transfers ownership of a record to another person T6TEJ...t3x with the value 058c...c08. The original owner generates a signature. lns_make_update_mapping_signature owner=T6TEJJRfvhMZbJpRuchJtmQAjuyCUAyYy2yVcc9ySxTHXWgwQkupjUJUQsyCoyYfRGReAY3pgaYxUHwoKEkWNh5o2qe5Btt3x value=058c72182ecf25172999414f098f91c07bcf12eae7e0c810659f533e81dc865c08 KeeJef The generated signature: 3ede65e0a78eca500549dde612d02d8aeb3f3dd0f3accd767a2f013cab6e3d486582506fbeb7edb1bda209b333fe7f125fd29f6add6c72b20af320de3537788885fee8b6d76f14b4ad253db2f70a518054bb6f512465e1b6cc154c551d3d59b5bf528eef5a678dbee48e2da74a2803c47295acd6967ea5545f6213456a0f5ead On the wallet to execute, the arguments must match the arguments specified in the lns_make_update_mapping_signature with the added signature argument. lns_update_mapping owner=T6TEJJRfvhMZbJpRuchJtmQAjuyCUAyYy2yVcc9ySxTHXWgwQkupjUJUQsyCoyYfRGReAY3pgaYxUHwoKEkWNh5o2qe5Btt3x value=058c72182ecf25172999414f098f91c07bcf12eae7e0c810659f533e81dc865c08 signature=3ede65e0a78eca500549dde612d02d8aeb3f3dd0f3accd767a2f013cab6e3d486582506fbeb7edb1bda209b333fe7f125fd29f6add6c72b20af320de3537788885fee8b6d76f14b4ad253db2f70a518054bb6f512465e1b6cc154c551d3d59b5bf528eef5a678dbee48e2da74a2803c47295acd6967ea5545f6213456a0f5ead KeeJef","title":"Register Session/Wallet names"},{"location":"LokiServices/Messenger/HowToRegisterSessionNames/#how-to-register-an-lns-mapping","text":"LNS mapping registration will be supported in the CLI wallet at launch. The following steps can be used to register and update LNS mappings in the CLI wallet. Note that you can access a detailed description of each command within the app by using help <command_name> .","title":"How to register an LNS mapping"},{"location":"LokiServices/Messenger/HowToRegisterSessionNames/#purchasing-a-loki-name-service-record","text":"Purchasing an LNS record in the CLI wallet uses the lns_buy_mapping command. All arguments for the lns_buy_mapping command are optional except for the <name> and <value> that the name maps to. lns_buy_mapping [index=<N1>[,<N2>,...]] [<priority>] [owner=<value>] [backup_owner=<value>] <name> <value> Example: Buy a LNS record that maps \u2018KeeJef\u2019 to a Session Public Key, 053 \u2026 254. The wallet buying is the owner of the record. lns_buy_mapping KeeJef 053b6b764388cd6c4d38ae0b3e7492a8ecf0076e270c013bb5693d973045f45254 Example: Buy a LNS record that maps \u2018KeeJef\u2019 to a Session Public Key, 053 \u2026 254. The wallet buying the mapping is the owner of the record, but specifies a backup owner who will also be authorised to update the record. lns_buy_mapping backup_owner=T6U7AaNgN2cARpR7CNHGChGMjsmjq5ffh4hLa4DjUUXtKS3bPy2rKTX614RxmpPPX6KjZzqUSSpAEcoghASTXqvP1qMsJzWch KeeJef 053b6b764388cd6c4d38ae0b3e7492a8ecf0076e270c013bb5693d973045f45254 Example: Buy a LNS record that maps \u2018KeeJef\u2019 to a Session Public Key, 053 \u2026 254. You buy on behalf of another wallet T6UD8..ppir and specify another backup wallet. lns_buy_mapping owner=T6UD8TM1t7mUYmMCHXQ67Kg5jXBwoVxNqGpXctnsLXtGBEFnhq37RQAA8jgqgD9U6QbeNGqAkkVXucXQ5txE6Mrk2aRwpppir backup_owner=T6U7AaNgN2cARpR7CNHGChGMjsmjq5ffh4hLa4DjUUXtKS3bPy2rKTX614RxmpPPX6KjZzqUSSpAEcoghASTXqvP1qMsJzWch KeeJef 053b6b764388cd6c4d38ae0b3e7492a8ecf0076e270c013bb5693d973045f45254","title":"Purchasing a Loki Name Service record"},{"location":"LokiServices/Messenger/HowToRegisterSessionNames/#updating-a-loki-name-service-record-wallet-executing-update-is-owner-of-record","text":"Updating an LNS record in the CLI wallet uses the lns_update_mapping command. All arguments for the lns_update_mapping command are optional except the name of the record to update, and at least one field of the record to update ( owner , backup_owner , or value ). The [signature] argument is for deferring updates to the record, and is explained in detail in the next section. lns_update_mapping [owner=<value>] [backup_owner=<value>] [value=<lns_value>] [signature=<hex_signature>] <name> Example: Updating the owner of the record (essentially transferring ownership \u2014 after changing ownership, you will no longer be authorised to update the record). lns_update_mapping owner=T6UC1nSy2289uX8R2jS3ci7y6eNnVdvhSQRoZtckPzmrQgJ3CyUhUtxgxuedusx9TCKVhZZBCuwFkKoJ3joXStWh1QozRsXXo KeeJef Note: At this time you can only update Session ID mappings, you cannot yet add a wallet address mapping to your name \u2014 this will require additional changes which will be implemented at a later date. Example: Update all fields of the mapping. lns_update_mapping owner=T6UD8TM1t7mUYmMCHXQ67Kg5jXBwoVxNqGpXctnsLXtGBEFnhq37RQAA8jgqgD9U6QbeNGqAkkVXucXQ5txE6Mrk2aRwpppir backup_owner=T6TEJJRfvhMZbJpRuchJtmQAjuyCUAyYy2yVcc9ySxTHXWgwQkupjUJUQsyCoyYfRGReAY3pgaYxUHwoKEkWNh5o2qe5Btt3x value=0596d2fdc1407490e1bb7cbca3f3674606d3ef9b1d01cf46199ee5c8932d83f40a KeeJef","title":"Updating a Loki Name Service record: Wallet executing update is owner of record"},{"location":"LokiServices/Messenger/HowToRegisterSessionNames/#updating-a-loki-name-service-record-wallet-executing-is-not-owner-of-record","text":"In this scenario, you have a LNS record that you wish to update, and you\u2019re able to coordinate with the wallet owning the record. The wallet that owns the record can execute this command to generate a signature. lns_make_update_mapping_signature [owner=<value>] [backup_owner=<value>] [value=<lns_value>] <name> Example: User transfers ownership of a record to another person T6TEJ...t3x with the value 058c...c08. The original owner generates a signature. lns_make_update_mapping_signature owner=T6TEJJRfvhMZbJpRuchJtmQAjuyCUAyYy2yVcc9ySxTHXWgwQkupjUJUQsyCoyYfRGReAY3pgaYxUHwoKEkWNh5o2qe5Btt3x value=058c72182ecf25172999414f098f91c07bcf12eae7e0c810659f533e81dc865c08 KeeJef The generated signature: 3ede65e0a78eca500549dde612d02d8aeb3f3dd0f3accd767a2f013cab6e3d486582506fbeb7edb1bda209b333fe7f125fd29f6add6c72b20af320de3537788885fee8b6d76f14b4ad253db2f70a518054bb6f512465e1b6cc154c551d3d59b5bf528eef5a678dbee48e2da74a2803c47295acd6967ea5545f6213456a0f5ead On the wallet to execute, the arguments must match the arguments specified in the lns_make_update_mapping_signature with the added signature argument. lns_update_mapping owner=T6TEJJRfvhMZbJpRuchJtmQAjuyCUAyYy2yVcc9ySxTHXWgwQkupjUJUQsyCoyYfRGReAY3pgaYxUHwoKEkWNh5o2qe5Btt3x value=058c72182ecf25172999414f098f91c07bcf12eae7e0c810659f533e81dc865c08 signature=3ede65e0a78eca500549dde612d02d8aeb3f3dd0f3accd767a2f013cab6e3d486582506fbeb7edb1bda209b333fe7f125fd29f6add6c72b20af320de3537788885fee8b6d76f14b4ad253db2f70a518054bb6f512465e1b6cc154c551d3d59b5bf528eef5a678dbee48e2da74a2803c47295acd6967ea5545f6213456a0f5ead KeeJef","title":"Updating a Loki Name Service Record: Wallet executing is not owner of record)"},{"location":"LokiServices/Messenger/JoinOpenGroupDesktop/","text":"How to join a Session open group (on desktop) \u00b6 Click the \u2018globe\u2019 icon in the sidebar: Click \u2018Join Open Group\u2019: Enter the URL of the open group you\u2019d like to join: Click \u2018Join Open Group\u2019: Enjoy being part of a new community on Session!","title":"Join Open Group on Desktop"},{"location":"LokiServices/Messenger/JoinOpenGroupDesktop/#how-to-join-a-session-open-group-on-desktop","text":"Click the \u2018globe\u2019 icon in the sidebar: Click \u2018Join Open Group\u2019: Enter the URL of the open group you\u2019d like to join: Click \u2018Join Open Group\u2019: Enjoy being part of a new community on Session!","title":"How to join a Session open group (on desktop)"},{"location":"LokiServices/Messenger/JoinOpenGroupMobile/","text":"How to join a Session open group (on mobile) \u00b6 Tap the \u2018globe\u2019 icon. Enter the URL of the open group you\u2019d like to join (be sure to include https:// at the start of the URL!) Tap \u2018next\u2019. Enjoy being part of a new community on Session!","title":"Join Open Group on Mobile"},{"location":"LokiServices/Messenger/JoinOpenGroupMobile/#how-to-join-a-session-open-group-on-mobile","text":"Tap the \u2018globe\u2019 icon. Enter the URL of the open group you\u2019d like to join (be sure to include https:// at the start of the URL!) Tap \u2018next\u2019. Enjoy being part of a new community on Session!","title":"How to join a Session open group (on mobile)"},{"location":"LokiServices/Messenger/LokiNameSystem/","text":"Loki Name System \u00b6 LNS will be released in a limited capacity on the 25th of March alongside the Valiant Vidar hard fork, so it\u2019s important to communicate what you will be able to do with LNS when it launches. How to register a Session/Wallet name. \u00b6 Go to the How to register Session/Wallet name guide . Namespaces \u00b6 The LNS namespace is broken up into two distinct sections, one section is responsible for all lokinet names, referred to as .loki names and the other section is responsible for Wallet and Session usernames. On the initial release we will only be allowing the registration of Wallet and Session usernames. Names \u00b6 Each LNS name can resolve to a Session public key, Wallet address or .loki address. Session and Wallet names are within the same namespace. When purchasing a Session record, the Wallet record is automatically added to your possession. Lokinet names are in their own namespaces. For example, when purchasing \u2018KeeJef\u2019 in the Session namespace, you can assign a Session public key. Additionally you can update the wallet record under a 2nd transaction. So when a user looks up \u2018KeeJef\u2019 they are returned both a Session ID and Wallet address, SessionID: 053b6b764388cd6c4d38ae0b3e7492a8ecf0076e270c013bb5693d973045f45254 Wallet Address: LBMTVEK8WRiC9rmfoKEjyrZSRje6PdiTU6926LjMkGMUdzyApMvXUbH4LswHnLjMjMPLUbDKiL3RCRQe5XFiobWb8jQrApR It is also possible to purchase \u2018KeeJef.loki\u2019 in the Lokinet namespace that is unique from the Session and Wallet namespace. However this will not be available immediately. Depending on which context the name is being used, the application will automatically use the relevant mapping. Rules \u00b6 Each namespace, (Session and Wallet) (Lokinet) have restrictions on the characters allowed in the name. All names are case-insensitive. For Session, the name has to start with a (alphanumeric or underscore), and can have (alphanumeric, hyphens or underscores) in between and must end with a (alphanumeric or underscore). Users may register names with special characters or emojis by using the equivalent Punycode representation. The name must be at least 1 character, and at most- 64 characters long. For Lokinet, the domain has to start with an alphanumeric, and can have (alphanumeric or hyphens) in between. The character before the domain suffix .loki must be alphanumeric followed by the suffix .loki . Users may register names with special characters or emojis by using the equivalent Punycode representation. The domain name must be at most 253 characters long, including the .loki suffix. Time \u00b6 By default all mappings in the Session/Wallet namespace will be preserved forever, this is important to ensure that wallet mappings don't change when a user wants to send money to a name. The .loki namespace will have reregistration periods to deter domain squatting and release names if the keys that registered them are lost. Ownership, Transfer, Updates and management \u00b6 By default names are owned by the wallet address that purchased the name. However names can also be purchased on behalf of another user. Up to 2 wallet addresses may be specified as the owners of a name. This means up to 2 wallets to update and or transfer ownership of the record. Once a domain is owned it can be transferred to another user's Loki wallet by specifying the address of that wallet and paying the standard transaction fee to transfer the ownership. Updates to mappings can be made at any time by the owner, at the cost of the standard transaction fee to include the new mapping in the blockchain. Management of all owned names will be possible through the Loki Desktop Wallet initially however we aim to add functionality to register and manage names to the Session software in the future. Cost \u00b6 Names in the Session/Wallet namespace cost 20 Loki to register, We will try to update this cost per hardfork to target the $5-10 USD range. Privacy \u00b6 It is up to each user to choose what information they map publicly, if you don\u2019t want to map your Session ID or Wallet address to your real world identity you might want to choose a different alias instead of something related to your name. Basic encryption is employed to mask publicity of data on the surface level, however please do not rely on this for critical privacy requirements. See the Loki Name Service technical document for more information. All wallet sub-addresses generated via account new are supported as owners. Technical Documentation \u00b6 Record Encryption/Decryption \u00b6 LNS records stored in the blockchain undergo basic encryption and decryption to deter monitoring of the chain. It does not provide strong guarantees for privacy and should not be relied on for critical privacy usage. At its core, a typical LNS record from the database looks like name_hashed encrypted_value register_height owner backup_owner txid prev_txid register_height more fields (implementation details, see loki_name_system.h) Of which, name_hashed and encrypted_value use some form of encryption or decryption. name_hashed \u00b6 Human readable name is hashed with blake2b with the following parameters Key Length: 0 bytes Hash Length: 32 bytes Name hash converted to base64 for storage into the sqlite3 database (this provides optimal lexicographic lookup as a key). hash32 = Blake2B(name, key=0) name_hash = Base64Encode(hash32) encrypted_value \u00b6 Generate the secret key for decryption/encryption using the unhashed name with Argon2ID v1.3 and the following parameters as of Valiant Vidar v7.1.X Iterations: 3 Memory: 268_435_456 bytes Salt Length: 0 bytes Key Length: 32 bytes Decrypt/encrypt the value represented in binary with XSalsa20Poly1305 and the following parameters as of Valiant Vidar v7.1.X Nonce: 0 bytes key32 = Argon2ID(iterations=3, memory=268435436, salt=0) encrypted_value = XSalsa20Poly1305Encrypt(value, key32, nonce=0) decrypted_value = XSalsa20Poly1305Decrypt(encrypted_value, key32, nonce=0) Owners \u00b6 In the Loki Name System (LNS), an owner of a record has the ability to update information about the record by making a transaction on the Loki blockchain. Owners are specified when buying a record and in LNS we support 2 types. A standard Ed25519 keypair and a Loki Wallet address. By default, the wallet is configured to assign itself as the owner of the mapping when purchased. Record Updating \u00b6 LNS records can be updated by getting the owner of the record to generate a signature that authorises the protocol to update fields in the record. The following fields can be updated in the record Value Owner Backup Owner Copy the fields to update into a buffer Copy the TXID into the buffer that last updated the record (which can be retrieved by querying the mapping). Hash the buffer with blake2b with the following parameters Key Length: 0 bytes Hash Length: 32 bytes Sign the hashed buffer If the current owner (or backup owner) is a wallet address, it must be signed with the current owner's (or backup owner's) wallet secret spend key. If the current owner (or backup owner) is a ed25519 key, it must be signed with the current owner's (or backup owner's) ed25519 secret key. // *If value is specified, copy the value to the buffer, otherwise skip. buffer[] = {*binary_value, *owner, *backup_owner, prev_txid} hash32 = Blake2B(buffer, key=0) if (monero) signature = generate_signature(hash32, spend_pkey, spend_skey) else signature = ed25519_signature(hash32, ed25519_skey)","title":"Loki Name System"},{"location":"LokiServices/Messenger/LokiNameSystem/#loki-name-system","text":"LNS will be released in a limited capacity on the 25th of March alongside the Valiant Vidar hard fork, so it\u2019s important to communicate what you will be able to do with LNS when it launches.","title":"Loki Name System"},{"location":"LokiServices/Messenger/LokiNameSystem/#how-to-register-a-sessionwallet-name","text":"Go to the How to register Session/Wallet name guide .","title":"How to register a Session/Wallet name."},{"location":"LokiServices/Messenger/LokiNameSystem/#namespaces","text":"The LNS namespace is broken up into two distinct sections, one section is responsible for all lokinet names, referred to as .loki names and the other section is responsible for Wallet and Session usernames. On the initial release we will only be allowing the registration of Wallet and Session usernames.","title":"Namespaces"},{"location":"LokiServices/Messenger/LokiNameSystem/#names","text":"Each LNS name can resolve to a Session public key, Wallet address or .loki address. Session and Wallet names are within the same namespace. When purchasing a Session record, the Wallet record is automatically added to your possession. Lokinet names are in their own namespaces. For example, when purchasing \u2018KeeJef\u2019 in the Session namespace, you can assign a Session public key. Additionally you can update the wallet record under a 2nd transaction. So when a user looks up \u2018KeeJef\u2019 they are returned both a Session ID and Wallet address, SessionID: 053b6b764388cd6c4d38ae0b3e7492a8ecf0076e270c013bb5693d973045f45254 Wallet Address: LBMTVEK8WRiC9rmfoKEjyrZSRje6PdiTU6926LjMkGMUdzyApMvXUbH4LswHnLjMjMPLUbDKiL3RCRQe5XFiobWb8jQrApR It is also possible to purchase \u2018KeeJef.loki\u2019 in the Lokinet namespace that is unique from the Session and Wallet namespace. However this will not be available immediately. Depending on which context the name is being used, the application will automatically use the relevant mapping.","title":"Names"},{"location":"LokiServices/Messenger/LokiNameSystem/#rules","text":"Each namespace, (Session and Wallet) (Lokinet) have restrictions on the characters allowed in the name. All names are case-insensitive. For Session, the name has to start with a (alphanumeric or underscore), and can have (alphanumeric, hyphens or underscores) in between and must end with a (alphanumeric or underscore). Users may register names with special characters or emojis by using the equivalent Punycode representation. The name must be at least 1 character, and at most- 64 characters long. For Lokinet, the domain has to start with an alphanumeric, and can have (alphanumeric or hyphens) in between. The character before the domain suffix .loki must be alphanumeric followed by the suffix .loki . Users may register names with special characters or emojis by using the equivalent Punycode representation. The domain name must be at most 253 characters long, including the .loki suffix.","title":"Rules"},{"location":"LokiServices/Messenger/LokiNameSystem/#time","text":"By default all mappings in the Session/Wallet namespace will be preserved forever, this is important to ensure that wallet mappings don't change when a user wants to send money to a name. The .loki namespace will have reregistration periods to deter domain squatting and release names if the keys that registered them are lost.","title":"Time"},{"location":"LokiServices/Messenger/LokiNameSystem/#ownership-transfer-updates-and-management","text":"By default names are owned by the wallet address that purchased the name. However names can also be purchased on behalf of another user. Up to 2 wallet addresses may be specified as the owners of a name. This means up to 2 wallets to update and or transfer ownership of the record. Once a domain is owned it can be transferred to another user's Loki wallet by specifying the address of that wallet and paying the standard transaction fee to transfer the ownership. Updates to mappings can be made at any time by the owner, at the cost of the standard transaction fee to include the new mapping in the blockchain. Management of all owned names will be possible through the Loki Desktop Wallet initially however we aim to add functionality to register and manage names to the Session software in the future.","title":"Ownership, Transfer, Updates and management"},{"location":"LokiServices/Messenger/LokiNameSystem/#cost","text":"Names in the Session/Wallet namespace cost 20 Loki to register, We will try to update this cost per hardfork to target the $5-10 USD range.","title":"Cost"},{"location":"LokiServices/Messenger/LokiNameSystem/#privacy","text":"It is up to each user to choose what information they map publicly, if you don\u2019t want to map your Session ID or Wallet address to your real world identity you might want to choose a different alias instead of something related to your name. Basic encryption is employed to mask publicity of data on the surface level, however please do not rely on this for critical privacy requirements. See the Loki Name Service technical document for more information. All wallet sub-addresses generated via account new are supported as owners.","title":"Privacy"},{"location":"LokiServices/Messenger/LokiNameSystem/#technical-documentation","text":"","title":"Technical Documentation"},{"location":"LokiServices/Messenger/LokiNameSystem/#record-encryptiondecryption","text":"LNS records stored in the blockchain undergo basic encryption and decryption to deter monitoring of the chain. It does not provide strong guarantees for privacy and should not be relied on for critical privacy usage. At its core, a typical LNS record from the database looks like name_hashed encrypted_value register_height owner backup_owner txid prev_txid register_height more fields (implementation details, see loki_name_system.h) Of which, name_hashed and encrypted_value use some form of encryption or decryption.","title":"Record Encryption/Decryption"},{"location":"LokiServices/Messenger/LokiNameSystem/#name_hashed","text":"Human readable name is hashed with blake2b with the following parameters Key Length: 0 bytes Hash Length: 32 bytes Name hash converted to base64 for storage into the sqlite3 database (this provides optimal lexicographic lookup as a key). hash32 = Blake2B(name, key=0) name_hash = Base64Encode(hash32)","title":"name_hashed"},{"location":"LokiServices/Messenger/LokiNameSystem/#encrypted_value","text":"Generate the secret key for decryption/encryption using the unhashed name with Argon2ID v1.3 and the following parameters as of Valiant Vidar v7.1.X Iterations: 3 Memory: 268_435_456 bytes Salt Length: 0 bytes Key Length: 32 bytes Decrypt/encrypt the value represented in binary with XSalsa20Poly1305 and the following parameters as of Valiant Vidar v7.1.X Nonce: 0 bytes key32 = Argon2ID(iterations=3, memory=268435436, salt=0) encrypted_value = XSalsa20Poly1305Encrypt(value, key32, nonce=0) decrypted_value = XSalsa20Poly1305Decrypt(encrypted_value, key32, nonce=0)","title":"encrypted_value"},{"location":"LokiServices/Messenger/LokiNameSystem/#owners","text":"In the Loki Name System (LNS), an owner of a record has the ability to update information about the record by making a transaction on the Loki blockchain. Owners are specified when buying a record and in LNS we support 2 types. A standard Ed25519 keypair and a Loki Wallet address. By default, the wallet is configured to assign itself as the owner of the mapping when purchased.","title":"Owners"},{"location":"LokiServices/Messenger/LokiNameSystem/#record-updating","text":"LNS records can be updated by getting the owner of the record to generate a signature that authorises the protocol to update fields in the record. The following fields can be updated in the record Value Owner Backup Owner Copy the fields to update into a buffer Copy the TXID into the buffer that last updated the record (which can be retrieved by querying the mapping). Hash the buffer with blake2b with the following parameters Key Length: 0 bytes Hash Length: 32 bytes Sign the hashed buffer If the current owner (or backup owner) is a wallet address, it must be signed with the current owner's (or backup owner's) wallet secret spend key. If the current owner (or backup owner) is a ed25519 key, it must be signed with the current owner's (or backup owner's) ed25519 secret key. // *If value is specified, copy the value to the buffer, otherwise skip. buffer[] = {*binary_value, *owner, *backup_owner, prev_txid} hash32 = Blake2B(buffer, key=0) if (monero) signature = generate_signature(hash32, spend_pkey, spend_skey) else signature = ed25519_signature(hash32, ed25519_skey)","title":"Record Updating"},{"location":"LokiServices/Messenger/Session/","text":"Session \u00b6 Session is an open-source, public-key-based secure messaging application which uses a set of decentralised storage servers and an onion routing protocol to send end-to-end encrypted messages with minimal exposure of user metadata. It does this while also providing common features of mainstream messaging applications. Download Links \u00b6 Head over to the Session website to get your Session download Links: Download Register Session Name \u00b6 Head over to the How to register Session/Wallet name guide . Introduction \u00b6 Over the past 10 years, there has been a significant increase in the usage of instant messengers, with the most widely-used messengers each having amassed over 1 billion users. The potential privacy and security shortfalls of many popular messaging applications have been widely discussed. Most current methods of protecting user data privacy are focused on encrypting the contents of messages, an approach which has been relatively successful. This wide deployment of end-to-end encryption (E2EE) does increase user privacy; however, it largely fails to address the growing use of metadata by corporate and state-level actors as a method of tracking user activity. In the context of private messaging, metadata includes the IP addresses and phone numbers of the participants, the time and quantity of sent messages, and the relationship each account has with other accounts. Increasingly, it is the existence and analysis of this metadata that poses a significant privacy risk to journalists, demonstrators and human rights activists. Session is, in large part, a response to this growing risk; it attempts to build robust metadata protection on top of existing protocols, including the Signal protocol, which have already been proven to be effective in providing secure communication channels. Session works to reduce metadata collection in several ways: Firstly, Session does not rely on central servers, instead using a decentralised network of thousands of economically incentivised nodes to perform all core messaging functionality . For those services where decentralisation is impractical, like storage of attachments and hosting of large group chat channels , Session allows users to self-host infrastructure, or rely on built-in encryption and metadata protection to mitigate trust concerns. Secondly, Session ensures that IP addresses cannot be linked to messages sent or received by users. This is accomplished by using an onion routing protocol called onion requests . Thirdly, Session does not ask or require users to provide a phone number or email address when registering a new account. Instead, it uses pseudonymous public-private key pairs as the basis of an account\u2019s identity.","title":"Overview"},{"location":"LokiServices/Messenger/Session/#session","text":"Session is an open-source, public-key-based secure messaging application which uses a set of decentralised storage servers and an onion routing protocol to send end-to-end encrypted messages with minimal exposure of user metadata. It does this while also providing common features of mainstream messaging applications.","title":"Session"},{"location":"LokiServices/Messenger/Session/#download-links","text":"Head over to the Session website to get your Session download Links: Download","title":"Download Links"},{"location":"LokiServices/Messenger/Session/#register-session-name","text":"Head over to the How to register Session/Wallet name guide .","title":"Register Session Name"},{"location":"LokiServices/Messenger/Session/#introduction","text":"Over the past 10 years, there has been a significant increase in the usage of instant messengers, with the most widely-used messengers each having amassed over 1 billion users. The potential privacy and security shortfalls of many popular messaging applications have been widely discussed. Most current methods of protecting user data privacy are focused on encrypting the contents of messages, an approach which has been relatively successful. This wide deployment of end-to-end encryption (E2EE) does increase user privacy; however, it largely fails to address the growing use of metadata by corporate and state-level actors as a method of tracking user activity. In the context of private messaging, metadata includes the IP addresses and phone numbers of the participants, the time and quantity of sent messages, and the relationship each account has with other accounts. Increasingly, it is the existence and analysis of this metadata that poses a significant privacy risk to journalists, demonstrators and human rights activists. Session is, in large part, a response to this growing risk; it attempts to build robust metadata protection on top of existing protocols, including the Signal protocol, which have already been proven to be effective in providing secure communication channels. Session works to reduce metadata collection in several ways: Firstly, Session does not rely on central servers, instead using a decentralised network of thousands of economically incentivised nodes to perform all core messaging functionality . For those services where decentralisation is impractical, like storage of attachments and hosting of large group chat channels , Session allows users to self-host infrastructure, or rely on built-in encryption and metadata protection to mitigate trust concerns. Secondly, Session ensures that IP addresses cannot be linked to messages sent or received by users. This is accomplished by using an onion routing protocol called onion requests . Thirdly, Session does not ask or require users to provide a phone number or email address when registering a new account. Instead, it uses pseudonymous public-private key pairs as the basis of an account\u2019s identity.","title":"Introduction"},{"location":"LokiServices/Messenger/attachments/","text":"Attachments \u00b6 Although Service Nodes have the ability to store data on behalf of clients, this responsibility only extends so far. Requiring Service nodes to store attachments, which can easily be orders of magnitude larger than messages (and might need to be stored for longer periods of time) would place an undue burden on the Service Node network. With this in mind, a logical solution is for Session to interface with an untrusted centralised server that stores data obliviously. As long as the central server cannot know the contents of files, or who is storing and requesting the files, this system does not cause any metadata leakage. This is achieved by first padding each attachment to fit within a fixed number of constant sizes between 0 and 10 megabytes, then encrypting the attachment with a random symmetric AES key. The sender then uploads the encrypted file using an onion request. In response, the file server provides a link to the piece of content, returned via the onion request path. Once the sender obtains this link, they then send a message to the recipient via an existing pairwise session. This message contains a link to the content, a hash of the content, and the decryption key. The recipient then uses an onion request to pull the encrypted attachment from the centralised file server and decrypt it locally using the decryption key provided by the sender. The recipient also checks the hash against the attachment, ensuring the file has not been modified in transit. By default, all Session clients use a Session file server run by the Loki Foundation for attachment sending and storage. Since attachments are not considered a core feature of Session, this design is in keeping with Session's design principles. The file server is fully open-source, with setup instructions provided so that users are able to set up their own file server. Users are able to specify in the Session client which file server they want to use for attachment sending functionality. This is important both for providing users with choice and control, and ensuring the continued usefulness and functionality of Session if the Loki Foundation were no longer able to maintain the default Session file server.","title":"Attachments"},{"location":"LokiServices/Messenger/attachments/#attachments","text":"Although Service Nodes have the ability to store data on behalf of clients, this responsibility only extends so far. Requiring Service nodes to store attachments, which can easily be orders of magnitude larger than messages (and might need to be stored for longer periods of time) would place an undue burden on the Service Node network. With this in mind, a logical solution is for Session to interface with an untrusted centralised server that stores data obliviously. As long as the central server cannot know the contents of files, or who is storing and requesting the files, this system does not cause any metadata leakage. This is achieved by first padding each attachment to fit within a fixed number of constant sizes between 0 and 10 megabytes, then encrypting the attachment with a random symmetric AES key. The sender then uploads the encrypted file using an onion request. In response, the file server provides a link to the piece of content, returned via the onion request path. Once the sender obtains this link, they then send a message to the recipient via an existing pairwise session. This message contains a link to the content, a hash of the content, and the decryption key. The recipient then uses an onion request to pull the encrypted attachment from the centralised file server and decrypt it locally using the decryption key provided by the sender. The recipient also checks the hash against the attachment, ensuring the file has not been modified in transit. By default, all Session clients use a Session file server run by the Loki Foundation for attachment sending and storage. Since attachments are not considered a core feature of Session, this design is in keeping with Session's design principles. The file server is fully open-source, with setup instructions provided so that users are able to set up their own file server. Users are able to specify in the Session client which file server they want to use for attachment sending functionality. This is important both for providing users with choice and control, and ensuring the continued usefulness and functionality of Session if the Loki Foundation were no longer able to maintain the default Session file server.","title":"Attachments"},{"location":"LokiServices/Messenger/client_side_protection/","text":"Client-Side Protections \u00b6 Secure messaging applications have typically focused their development efforts towards providing protections against network and server level adversaries, which has led to new advances in encryption and metadata protections. However, when interviewing high risk individuals researchers, it has been found that client-side privacy and security protections are some of the most-requested features. High-risk individuals may not be focused on protecting themselves against global adversaries, but instead against a small nation state, or corporate entity. For these individuals, endpoint compromise, device seizure, and forced disclosures are described as the biggest risks. To better mitigate these risks, Session implements a number of client-side protections which allow users to better manage the security of the Session app on their device. Deletion \u00b6 Granular message and data deletion controls are important for users who are likely to have their devices physically sized. Session implements standard features like disappearing messages, which are deleted from sending and receiving clients after being viewed, and the ability to fully wipe all client side stored data. However, Session also features additional ways to manage client side security. Duress Codes \u00b6 Users may set a PIN or pattern lock to access the Session app, which adds additional security on top of any device-level passcodes. As an additional layer of security, users may also specify a duress code, which if entered in lieu of the standard Session app PIN, will wipe Session app data on the device. This is useful in cases where users are forced to unlock their devices and wish for it to appear as if there was never data to begin with. Remote Deletion \u00b6 Remote deletion allows a user to specify a trusted friend and negotiate a shared secret with that friend. Once this secret is generated and stored on the device, the trusted friend can generate a remote deletion message which reveals this prearranged secret. When this message is received by the user\u2019s device, it initiates the immediate destruction of their local database. Pseudonyms High-risk users such as whistleblowers often need to create accounts which are not linked to any real-world physical identifiers (e.g. phone numbers and email addresses). Session account creation only requires generation of a public-private key pair, making it trivial for users to establish multiple pseudonyms without needing to link their account to pieces of information which could be used to identify them. Backup and Restore Account States \u00b6 Border crossings or checkpoints can be an area of significantly increased risk for high-risk users. In these zones, high-risk users may be forced to disclose passwords and surrender devices so device images can be taken. To protect their data, some high-risk individuals have begun implementing a strategy of backing up device and application data, wiping their device to cross a border or pass through a checkpoint, and then restoring that data once it is safe to do so. To ease this process, Session supports encrypted backups to a number of popular cloud services. Backups are encrypted with a symmetric key derived from the user\u2019s Session long-term private key, meaning the user only needs knowledge of their 12 word mnemonic seed (recovery phrase) to recover their account after completing the border or checkpoint crossing.","title":"Client Side Protection"},{"location":"LokiServices/Messenger/client_side_protection/#client-side-protections","text":"Secure messaging applications have typically focused their development efforts towards providing protections against network and server level adversaries, which has led to new advances in encryption and metadata protections. However, when interviewing high risk individuals researchers, it has been found that client-side privacy and security protections are some of the most-requested features. High-risk individuals may not be focused on protecting themselves against global adversaries, but instead against a small nation state, or corporate entity. For these individuals, endpoint compromise, device seizure, and forced disclosures are described as the biggest risks. To better mitigate these risks, Session implements a number of client-side protections which allow users to better manage the security of the Session app on their device.","title":"Client-Side Protections"},{"location":"LokiServices/Messenger/client_side_protection/#deletion","text":"Granular message and data deletion controls are important for users who are likely to have their devices physically sized. Session implements standard features like disappearing messages, which are deleted from sending and receiving clients after being viewed, and the ability to fully wipe all client side stored data. However, Session also features additional ways to manage client side security.","title":"Deletion"},{"location":"LokiServices/Messenger/client_side_protection/#duress-codes","text":"Users may set a PIN or pattern lock to access the Session app, which adds additional security on top of any device-level passcodes. As an additional layer of security, users may also specify a duress code, which if entered in lieu of the standard Session app PIN, will wipe Session app data on the device. This is useful in cases where users are forced to unlock their devices and wish for it to appear as if there was never data to begin with.","title":"Duress Codes"},{"location":"LokiServices/Messenger/client_side_protection/#remote-deletion","text":"Remote deletion allows a user to specify a trusted friend and negotiate a shared secret with that friend. Once this secret is generated and stored on the device, the trusted friend can generate a remote deletion message which reveals this prearranged secret. When this message is received by the user\u2019s device, it initiates the immediate destruction of their local database. Pseudonyms High-risk users such as whistleblowers often need to create accounts which are not linked to any real-world physical identifiers (e.g. phone numbers and email addresses). Session account creation only requires generation of a public-private key pair, making it trivial for users to establish multiple pseudonyms without needing to link their account to pieces of information which could be used to identify them.","title":"Remote Deletion"},{"location":"LokiServices/Messenger/client_side_protection/#backup-and-restore-account-states","text":"Border crossings or checkpoints can be an area of significantly increased risk for high-risk users. In these zones, high-risk users may be forced to disclose passwords and surrender devices so device images can be taken. To protect their data, some high-risk individuals have begun implementing a strategy of backing up device and application data, wiping their device to cross a border or pass through a checkpoint, and then restoring that data once it is safe to do so. To ease this process, Session supports encrypted backups to a number of popular cloud services. Backups are encrypted with a symmetric key derived from the user\u2019s Session long-term private key, meaning the user only needs knowledge of their 12 word mnemonic seed (recovery phrase) to recover their account after completing the border or checkpoint crossing.","title":"Backup and Restore Account States"},{"location":"LokiServices/Messenger/group_chats/","text":"Group Chats \u00b6 Instant messaging applications are increasingly becoming places for communities to gather, rather than simply being used for one-on-one conversations. This has led to widespread use of group chats, channels, and similar functionality in messaging applications. Many of the most popular messaging applications support group chats, but the levels of encryption and privacy provided to users in these group chats is often unclear. Group chats in applications such as Telegram and Facebook Messenger only support transport encryption, rather than end-to-end encryption. Even those applications which do support end-to-end encryption in group chats (e.g. Signal and WhatsApp) still use central servers to store and disseminate messages. There are two key areas to focus on when considering the deployment of encrypted group chats in Session. Scaling \u00b6 There are two main approaches to sending messages in a group chat: server-side fanout and client-side fanout. The choice of method can have a significant impact on the scalability of the group chat. In client-side fanout, the client individually pushes their message to each recipient device or swarm. Client-side fanout is preferable in some cases since it can be done in peer-to-peer networks and does not require the establishment of a central server. However, client-side fanout can prove burdensome on client bandwidth and CPU usage as the number of group members increase \u2014 a factor which proves particularly problematic for mobile devices. Figure 1: Client sends message using client-side fanout. In server-side fanout, the client typically sends their message to a server, from which the message is pushed out to each of the other clients (the other clients may also fetch the message from the server at a later point in time), which is more efficient for larger groups. Figure 2: Client sends message using server-side fanout: Here, the client sends the message to the server (solid red line) and the server then distributes the messages to clients (dotted red lines) End-to-end Encryption \u00b6 Another factor which impacts group chat scalability is the choice of how to implement end-to-end encryption. The most naive solution to building group chats in Session would be to simply leverage the existing pairwise sessions we can create for one-on-one conversations. To send a message to a group chat, a pairwise session would be started with every member of the group, and each message would be individually encrypted for each participant. This provides the group chat with the same guarantees possessed by standard pairwise communications using the Signal protocol: perfect forward secrecy and deniable authentication. However, this would come at the cost of requiring the payload to be encrypted and stored N times, where N is the number of members in the group. This process could become burdensome for low-powered clients participating in large group chats. One way to improve group chats is to adopt the \"Sender Keys\" system used by WhatsApp. This system involves a set of keys (a Chain Key and a Signature Key) that each client generates for each of its groups. These Sender Keys are shared between all group members in a traditional pairwise manner using the Signal protocol. When a client needs to send a message to the group, it derives a message encryption key using its Chain Key and encrypts the message only once. In Session, this would allow only having to generate proof of work exactly once per message, irrespective of the number of members in a group. The same ciphertext can then be decrypted by all other group members, as they can generate the same message key from the senders' chain key. Note that all future keys can be generated this way by all group members, so no further sharing of keys is necessary. However, all Sender Keys in the group will need to be updated whenever a group member leaves or is kicked from the group to ensure that they won't be able to read future messages. Additionally, this approach has the downside of losing the \u201cself healing\u201d property of the traditional Signal protocol provided in pairwise sessions. The Sender Keys scheme is effective in small- to medium-sized group chats where the membership set changes infrequently. However, it can be impractical in larger groups, where users frequently leave (or are kicked from) the chat as all Sender Keys must be updated and redistributed in each such event. Further improvements to the Sender Keys scheme have been proposed in the draft MLS specification (discussed in Future Work below). Other Considerations \u00b6 Group Size \u00b6 It may be possible to create large encrypted groups that scale well even when members are added and removed frequently. However, the reality of large groups is that as more members are added to the group, it becomes increasingly likely that members will leak or otherwise share the contents of the conversation. Identifying and removing a malicious or compromised group member in a very large group is difficult, and thus, perfect forward secrecy and deniability would be violated in such cases, unless malicious users could be identified and removed. Proof of Work \u00b6 A small proof of work must be produced for each new message which is sent offline and stored in a swarm (see Spam below). In a case where many group members are offline at the same time, the sender must calculate many such proofs of work before their message can be delivered to all members of the chat, this quickly becomes taxing on mobile devices. Metadata Protection \u00b6 Information about a group chat, including the public keys of members, administrators, and the IP addresses of users, should be kept private by participants, as public availability of information about the relationships between public keys significantly reduces privacy Group Type Comparisons \u00b6 With the above considerations in mind, Session deploys two different schemes for the encryption and scaling of group chats, with scheme selection based on group size. Closed Groups 3 - 500 Members \u00b6 To initialise a closed group chat, a user selects a number of users from their contacts list. The user's client sends a control message through a pairwise channel to the selected users. This control message communicates the group name, group members, group avatar, and other relevant data about the group. If the group chat includes users who have not previously communicated with each other, sessions are established between these users in the background. Using these pairwise channels, the group derives shared ephemeral encryption and signing keys. This ensures messages only need to be encrypted once for the entire group, as per the Sender Keys scheme detailed above. Instead of communicating these encrypted messages to each user in the group individually, the group chooses a random swarm to store non-pairwise messages. This ensures messages are only stored on a single swarm, regardless of group size. Onion requests are used for transmitting messages to and from the shared swarm, and also used any time pairwise communication is required. Closed Group Administration \u00b6 The creator of a closed group becomes the administrator of that group. All users added to the group have rights to add new members, but users can only be kicked from the group by the administrator. This information is shared through pairwise channels when the group is created, and sent via a pairwise channel to new members when they join the group. Open Groups \u00b6 Large closed groups run into significant scaling issues when members leave the group, as keys must be re-derived and redistributed to the entire group \u2014 an inefficient process when there may be hundreds or thousands of members. Additionally, as previously addressed, the usefulness of end-to-end encryption in very large groups is unclear, since a single malicious group member or compromised device is catastrophic to group privacy, and in large groups this is extremely difficult to protect against, regardless of the degree of encryption deployed. In Session, once group membership reaches the upper bound for closed groups, the administrator is encouraged to convert the group into an open group. open groups revert to transport-only encryption, which protects users against network adversaries but provides comparably weak protection against server-side attacks. To balance the risk of such attacks, Session's open groups do not use the Service Node architecture. Open groups instead require group administrators to operate their own server, or arrange for a channel to be created on an existing open group server host. The software required to do this is open-source, and a reference implementation is provided. All messages and attachments stored on open group servers are fetched and posted through onion requests using the IP address or domain name of the open group host server, preserving network-layer anonymity for participants. Open Group Administration \u00b6 Administration of open groups is comparably more complex than that of closed groups. The open group server operator is the original administrator, and they are able to add new administrators. All administrators have the right to delete messages from the server. Joining rights to open groups falls into one of two categories: whitelist-based groups and blacklist-based groups. Whitelist-based groups require each user's public key to be preapproved (added to the whitelist) by an administrator, and users must be invited before being able to join the open group. Blacklist-based groups can be joined by any user who knows the domain/IP address of the group, but users can be banned if an administrator adds their public key to a list of banned public keys (the blacklist).","title":"Group Chats"},{"location":"LokiServices/Messenger/group_chats/#group-chats","text":"Instant messaging applications are increasingly becoming places for communities to gather, rather than simply being used for one-on-one conversations. This has led to widespread use of group chats, channels, and similar functionality in messaging applications. Many of the most popular messaging applications support group chats, but the levels of encryption and privacy provided to users in these group chats is often unclear. Group chats in applications such as Telegram and Facebook Messenger only support transport encryption, rather than end-to-end encryption. Even those applications which do support end-to-end encryption in group chats (e.g. Signal and WhatsApp) still use central servers to store and disseminate messages. There are two key areas to focus on when considering the deployment of encrypted group chats in Session.","title":"Group Chats"},{"location":"LokiServices/Messenger/group_chats/#scaling","text":"There are two main approaches to sending messages in a group chat: server-side fanout and client-side fanout. The choice of method can have a significant impact on the scalability of the group chat. In client-side fanout, the client individually pushes their message to each recipient device or swarm. Client-side fanout is preferable in some cases since it can be done in peer-to-peer networks and does not require the establishment of a central server. However, client-side fanout can prove burdensome on client bandwidth and CPU usage as the number of group members increase \u2014 a factor which proves particularly problematic for mobile devices. Figure 1: Client sends message using client-side fanout. In server-side fanout, the client typically sends their message to a server, from which the message is pushed out to each of the other clients (the other clients may also fetch the message from the server at a later point in time), which is more efficient for larger groups. Figure 2: Client sends message using server-side fanout: Here, the client sends the message to the server (solid red line) and the server then distributes the messages to clients (dotted red lines)","title":"Scaling"},{"location":"LokiServices/Messenger/group_chats/#end-to-end-encryption","text":"Another factor which impacts group chat scalability is the choice of how to implement end-to-end encryption. The most naive solution to building group chats in Session would be to simply leverage the existing pairwise sessions we can create for one-on-one conversations. To send a message to a group chat, a pairwise session would be started with every member of the group, and each message would be individually encrypted for each participant. This provides the group chat with the same guarantees possessed by standard pairwise communications using the Signal protocol: perfect forward secrecy and deniable authentication. However, this would come at the cost of requiring the payload to be encrypted and stored N times, where N is the number of members in the group. This process could become burdensome for low-powered clients participating in large group chats. One way to improve group chats is to adopt the \"Sender Keys\" system used by WhatsApp. This system involves a set of keys (a Chain Key and a Signature Key) that each client generates for each of its groups. These Sender Keys are shared between all group members in a traditional pairwise manner using the Signal protocol. When a client needs to send a message to the group, it derives a message encryption key using its Chain Key and encrypts the message only once. In Session, this would allow only having to generate proof of work exactly once per message, irrespective of the number of members in a group. The same ciphertext can then be decrypted by all other group members, as they can generate the same message key from the senders' chain key. Note that all future keys can be generated this way by all group members, so no further sharing of keys is necessary. However, all Sender Keys in the group will need to be updated whenever a group member leaves or is kicked from the group to ensure that they won't be able to read future messages. Additionally, this approach has the downside of losing the \u201cself healing\u201d property of the traditional Signal protocol provided in pairwise sessions. The Sender Keys scheme is effective in small- to medium-sized group chats where the membership set changes infrequently. However, it can be impractical in larger groups, where users frequently leave (or are kicked from) the chat as all Sender Keys must be updated and redistributed in each such event. Further improvements to the Sender Keys scheme have been proposed in the draft MLS specification (discussed in Future Work below).","title":"End-to-end Encryption"},{"location":"LokiServices/Messenger/group_chats/#other-considerations","text":"","title":"Other Considerations"},{"location":"LokiServices/Messenger/group_chats/#group-size","text":"It may be possible to create large encrypted groups that scale well even when members are added and removed frequently. However, the reality of large groups is that as more members are added to the group, it becomes increasingly likely that members will leak or otherwise share the contents of the conversation. Identifying and removing a malicious or compromised group member in a very large group is difficult, and thus, perfect forward secrecy and deniability would be violated in such cases, unless malicious users could be identified and removed.","title":"Group Size"},{"location":"LokiServices/Messenger/group_chats/#proof-of-work","text":"A small proof of work must be produced for each new message which is sent offline and stored in a swarm (see Spam below). In a case where many group members are offline at the same time, the sender must calculate many such proofs of work before their message can be delivered to all members of the chat, this quickly becomes taxing on mobile devices.","title":"Proof of Work"},{"location":"LokiServices/Messenger/group_chats/#metadata-protection","text":"Information about a group chat, including the public keys of members, administrators, and the IP addresses of users, should be kept private by participants, as public availability of information about the relationships between public keys significantly reduces privacy","title":"Metadata Protection"},{"location":"LokiServices/Messenger/group_chats/#group-type-comparisons","text":"With the above considerations in mind, Session deploys two different schemes for the encryption and scaling of group chats, with scheme selection based on group size.","title":"Group Type Comparisons"},{"location":"LokiServices/Messenger/group_chats/#closed-groups-3-500-members","text":"To initialise a closed group chat, a user selects a number of users from their contacts list. The user's client sends a control message through a pairwise channel to the selected users. This control message communicates the group name, group members, group avatar, and other relevant data about the group. If the group chat includes users who have not previously communicated with each other, sessions are established between these users in the background. Using these pairwise channels, the group derives shared ephemeral encryption and signing keys. This ensures messages only need to be encrypted once for the entire group, as per the Sender Keys scheme detailed above. Instead of communicating these encrypted messages to each user in the group individually, the group chooses a random swarm to store non-pairwise messages. This ensures messages are only stored on a single swarm, regardless of group size. Onion requests are used for transmitting messages to and from the shared swarm, and also used any time pairwise communication is required.","title":"Closed Groups 3 - 500 Members"},{"location":"LokiServices/Messenger/group_chats/#closed-group-administration","text":"The creator of a closed group becomes the administrator of that group. All users added to the group have rights to add new members, but users can only be kicked from the group by the administrator. This information is shared through pairwise channels when the group is created, and sent via a pairwise channel to new members when they join the group.","title":"Closed Group Administration"},{"location":"LokiServices/Messenger/group_chats/#open-groups","text":"Large closed groups run into significant scaling issues when members leave the group, as keys must be re-derived and redistributed to the entire group \u2014 an inefficient process when there may be hundreds or thousands of members. Additionally, as previously addressed, the usefulness of end-to-end encryption in very large groups is unclear, since a single malicious group member or compromised device is catastrophic to group privacy, and in large groups this is extremely difficult to protect against, regardless of the degree of encryption deployed. In Session, once group membership reaches the upper bound for closed groups, the administrator is encouraged to convert the group into an open group. open groups revert to transport-only encryption, which protects users against network adversaries but provides comparably weak protection against server-side attacks. To balance the risk of such attacks, Session's open groups do not use the Service Node architecture. Open groups instead require group administrators to operate their own server, or arrange for a channel to be created on an existing open group server host. The software required to do this is open-source, and a reference implementation is provided. All messages and attachments stored on open group servers are fetched and posted through onion requests using the IP address or domain name of the open group host server, preserving network-layer anonymity for participants.","title":"Open Groups"},{"location":"LokiServices/Messenger/group_chats/#open-group-administration","text":"Administration of open groups is comparably more complex than that of closed groups. The open group server operator is the original administrator, and they are able to add new administrators. All administrators have the right to delete messages from the server. Joining rights to open groups falls into one of two categories: whitelist-based groups and blacklist-based groups. Whitelist-based groups require each user's public key to be preapproved (added to the whitelist) by an administrator, and users must be invited before being able to join the open group. Blacklist-based groups can be joined by any user who knows the domain/IP address of the group, but users can be banned if an administrator adds their public key to a list of banned public keys (the blacklist).","title":"Open Group Administration"},{"location":"LokiServices/Messenger/infrastructure/","text":"Infrastructure \u00b6 Foundations \u00b6 At its core, Session is built on the Loki Service Node network, so it is important to understand what this network is, how it functions, and what properties Session derives from it. Service Nodes \u00b6 Many projects have attempted to establish decentralised permissionless networks. These projects have often found themselves struggling with a \u2018tragedy of the commons\u2019 of sorts, wherein public servers, required for the operation of the network, are under-resourced and overused. This inadvertently causes the network to provide poor service to users, which discourages further use or expansion of the network. Conversely, those projects which are able to create large, public permissionless networks find themselves constantly facing questions about the parties that contribute to running that infrastructure. This can be especially damaging when the operation of that infrastructure can adversely affect the privacy, security, or user experience of an application. For example, the Tor network faces constant questions about evidence of Sybil attacks from unknown parties attempting to run large sections of of the public routing network, which could be used to deanonymise users . Session seeks to sidestep these questions by using a different type of public access network: a staked routing and storage network called the Loki Service Node network. This network is based on the Loki blockchain, which itself is based on the Cryptonote protocol. Through the integration of a blockchain network, Session creates a financial precondition for anyone wishing to host a server on the network, and thus participate in Session\u2019s message storage and routing architecture. Authorisation for a server to operate on the network is attained through the server operator conducting a special staking transaction, which requires that an operator provably lock an amount of Loki cryptocurrency assigned to their node (approximately 18,550 Loki coins; equivalent USD 7,420 dollars as of 10/02/2020). This staking system provides a defense against Sybil attacks by limiting attackers based on the amount of financial resources they have available. The staking system also achieves two other goals which further reduce the likelihood of a Sybil attack. Firstly, the need for attackers to buy or control Loki to run Service Nodes creates a feedback loop of increasing prices to run large portions of the network. That is, as the attacker buys or acquires more Loki and locks it, removing it from the circulating supply, the supply of Loki is decreased and the demand from the attacker must be sustained. This causes the price of any remaining Loki to increase, furthering the feedback loop of increasing prices. Secondly, the staking system binds an attacker to their stake, meaning if they are found to be performing active attacks, the underlying value of their stake can sharply decline as users lose trust in the network, or could be destroyed or locked by the network, in any case increasing the attackers sunken costs. The other main advantage of a staked blockchain network is that Service Nodes earn rewards for the work they do. Service Nodes are paid a portion of the block reward minted upon the creation of each new block. This system makes Session distinct from altruistic networks like Tor and I2P and instead provides an incentive linked directly with the performance of a Service Node. Honest node behaviour and the provision of a minimum standard of operation is ensured through a consensus-based testing suite. Misbehaving nodes face the threat of having their staked capital locked, while the previously-mentioned cryptocurrency rewards function as the positive incentive for nodes to behave honestly and provide at least the minimum standard of service to the network. Onion Requests \u00b6 The other foundational component of Session is an onion routing protocol, referred to as onion requests, which enables Session clients to obfuscate their IP addresses by creating a 3-hop randomised path through the Service Node network. Onion requests use a simple onion routing protocol which successively encrypts each request for each of the three hops, ensuring: the first Service Node only knows the IP address of the client and the IP address of the middle Service Node, the middle Service Node only knows the IP address of the first and last Service Nodes, and the last Service Node only knows the IP address of the middle Service Node and the final destination IP address for the request. Each Session client establishes a path on startup, and once established, all requests for messages, attachments and meta information are sent through this path. Session clients establish a path by selecting three random nodes from their Service Node list (see bootstrapping), which contains each Service Node\u2019s IP address, storage server port and X25519 key. Clients use this information to create an onion, with each layer being encrypted with the X25519 key of its respective service node. This onion is sent to the first Service Node\u2019s storage server; this Service Node then decrypts its layer of the onion. When a Service Node unwraps a layer, the destination key for the next node is revealed. The first Service Node decrypts its layer and initialises a ZMQ connection with the specified downstream node. When the onion reaches the final node in the path, that node sends a path build success message backwards through the path, which indicates a successful path built upon its receipt by the client. Upon receiving the path build success message, the client will encrypt their messages with the X25519 keys of the final destination, be that a Service Node, file server, open group server, or client. The client also includes an ephemeral X25519 key in their request. When the destination server or client receives the request, they decrypt it and generate a response. This response is then sent back down the previously-established path, encrypted for the initial sender\u2019s (the client\u2019s) ephemeral key, so that the client can decrypt this response upon receiving it. Building on Foundations \u00b6 Onion requests provide a straightforward anonymous networking layer, and the Service Node network provides an incentivised, self-regulating network of remote servers which provide bandwidth and storage space. A number of services are built on top of this foundation in order to give Session features commonly expected of modern messaging applications. Storage Message storage is an essential feature for any chat application aiming to provide a good user experience. When a user sends a message, they expect the recipient to receive that message even if they turn off their device after the message has been sent. Users also expect the user on the other end to receive the message when their device wakes up from an offline state. Apps that run on decentralised networks typically cannot provide this experience, because of the lack of incentive structures and, consequently, the ephemeral nature of clients and servers on such a network. Session is able to provide message storage through the incentivised Service Node network and its usage of swarms. Swarms \u00b6 Although the Loki blockchain incentivises correct Service Node behaviour through rewards and punishments, these incentive models cannot prevent nodes going offline unexpectedly due to operator choice, software bugs, or data center outages. Therefore, for redundancy, a secondary logical data storage layer must be built on top of the Service Node network to ensure reliable message storage and retrieval. This secondary logical layer is provided by replicating messages across small groupings of Service Nodes called swarms. The swarm a Service Node initially joins is determined at the time of that Service Node\u2019s registration, with the Service Node having minimal influence over which swarm it joins. This protects against swarms being entirely made up of malicious or non-performant nodes, which is important to maintain the network\u2019s self-regulating properties. Composition of each swarm inevitably changes as the networks evolves: some nodes leave the network and the newly registered nodes take their place. If a swarm loses a large number of nodes it may additionally \"steal\" a node from some other, larger swarm. In the unlikely event that the network has no swarms to steal from (i.e., every swarm is at Nmin=5 nodes), the \u2018starving\u2019 swarm (a swarm with fewer than Nmin nodes) will be dissolved and its nodes will be redistributed among the remaining swarms. Conversely, when a large number of nodes enter the network that would oversaturate existing swarms (i.e., every swarm is already at max capacity Nmax=10), a new swarm is created from a random selection of Ntarget=7 excess nodes. Note that Nmin < Ntarget < Nmax to ensure that a newly generated swarm doesn\u2019t get dissolved shortly after and that there is still room for growth. The outcome of this algorithm is the creation and, when necessary, rebalancing of swarms of around Nmin\u2060\u2013Nmax Service Nodes which store and serve Session clients\u2019 messages. The goal of the swarm algorithm is to ensure that no swarm is controlled by a single entity and that the network is resilient enough to handle both small and large scale events where Service Nodes are no longer contactable, ensuring data integrity and privacy in both cases. The following set of simple rules ensure that Service Nodes within swarms remain synchronised as the composition of swarms changes: When a node joins a new swarm, existing swarm members recognise this and push the swarm\u2019s data records to the new member. When a node leaves a swarm, its existing records can be safely erased, with the exception of when the node is migrating from a dissolving swarm. In this case, the migrating node determines the swarms responsible for its records and distributes them accordingly. Identity and Long-Term Keys \u00b6 The majority of popular messaging applications require the user to register with an email or phone number in order to use the service. This provides some advantages, including account verification, for purposes of spam protection, and social network discoverability. However, such requirements also create some major privacy and security issues for users. The use of a phone number as the basis for ownership of an identity key/long-term key pair weakens security against user accounts being compromised, such as in the cases of popular applications like Signal and WhatsApp. This weakness primarily stems from the fact that phone numbers are managed by centralised service providers (i.e. telecommunications service providers) who can circumvent user control, allowing these providers to assume direct control of specific users\u2019 numbers. Widespread legislation already exists to compel service providers to take this kind of action. Additionally, methods such as SIM swapping attacks, service provider hacking, and phone number recycling can all be exploited by lower-level actors . Signal and Whatsapp put forward varying degrees of protection against these types of attacks. Signal and WhatsApp both send a 'Safety numbers have changed' warning to a user's contacts if identity keys are changed. In practice, however, users rarely verify these details out-of-band . Both Signal and WhatsApp also allow users to set a \"registration PIN lock\" . This protection means that an attacker (including a service provider or state-level actor) needs access to both the phone number and the registration PIN code to modify identity keys. However, this feature is off by default, difficult to find in the settings menu, and automatically disabled after periods of user inactivity. These factors all significantly reduce the efficacy of registration PIN locks as a protective measure against the security risks of phone number-linked accounts. Using phone numbers as the basis for account registration also greatly weakens the privacy achievable by an average user. In most countries, users must provide personally identifiable information such as a passport, drivers' license or identity card to obtain a phone number \u2014 permanently mapping users\u2019 identities to their phone numbers.These identity mappings are kept in private databases that can be queried by governments or the service providers that own them. There are also a number of web scrapers and indexers that automatically scrape phone numbers associated with individuals. These scrapers may target sources such as leaked databases, public social media profiles, and business phone numbers to link people to their phone numbers. Since the only method of initiating contact with a user in Signal, WhatsApp, or similar application is to know the user\u2019s phone number, this immediately strips away user anonymity \u2014 a significant concern for whistleblowers, activists, protestors and other such users. Account systems based on phone numbers also limit the potential for the establishment of multiple identities by a single user. These systems also prevent high-risk users without access to a phone number from accessing these services. Session does not use email addresses or phone numbers as the basis of its account system. Instead, user identity is established through the generation of X25519 public-private key pairs. These key pairs are not required to be linked with any other identifier, and new key pairs can be generated on-device in seconds. This means that each key pair (and thus, each account) is pseudonymous, unless intentionally linked with an individual identity by the user through out-of-band activity. Restoration \u00b6 Because Session does not have a central server to keep records of user identities, the commonly expected user experience of being able to recover an account using a username and password is not possible. Instead, users are prompted to write down their long-term private key (represented as a mnemonic seed, referred to within Session as a recovery phrase) upon account generation. A user can use this backup key to recover their account if their device is lost or destroyed, and the user's contacts will be able to continue contacting that same user account, rather than having to re-initiate contact with a new key.","title":"Infrastructure"},{"location":"LokiServices/Messenger/infrastructure/#infrastructure","text":"","title":"Infrastructure"},{"location":"LokiServices/Messenger/infrastructure/#foundations","text":"At its core, Session is built on the Loki Service Node network, so it is important to understand what this network is, how it functions, and what properties Session derives from it.","title":"Foundations"},{"location":"LokiServices/Messenger/infrastructure/#service-nodes","text":"Many projects have attempted to establish decentralised permissionless networks. These projects have often found themselves struggling with a \u2018tragedy of the commons\u2019 of sorts, wherein public servers, required for the operation of the network, are under-resourced and overused. This inadvertently causes the network to provide poor service to users, which discourages further use or expansion of the network. Conversely, those projects which are able to create large, public permissionless networks find themselves constantly facing questions about the parties that contribute to running that infrastructure. This can be especially damaging when the operation of that infrastructure can adversely affect the privacy, security, or user experience of an application. For example, the Tor network faces constant questions about evidence of Sybil attacks from unknown parties attempting to run large sections of of the public routing network, which could be used to deanonymise users . Session seeks to sidestep these questions by using a different type of public access network: a staked routing and storage network called the Loki Service Node network. This network is based on the Loki blockchain, which itself is based on the Cryptonote protocol. Through the integration of a blockchain network, Session creates a financial precondition for anyone wishing to host a server on the network, and thus participate in Session\u2019s message storage and routing architecture. Authorisation for a server to operate on the network is attained through the server operator conducting a special staking transaction, which requires that an operator provably lock an amount of Loki cryptocurrency assigned to their node (approximately 18,550 Loki coins; equivalent USD 7,420 dollars as of 10/02/2020). This staking system provides a defense against Sybil attacks by limiting attackers based on the amount of financial resources they have available. The staking system also achieves two other goals which further reduce the likelihood of a Sybil attack. Firstly, the need for attackers to buy or control Loki to run Service Nodes creates a feedback loop of increasing prices to run large portions of the network. That is, as the attacker buys or acquires more Loki and locks it, removing it from the circulating supply, the supply of Loki is decreased and the demand from the attacker must be sustained. This causes the price of any remaining Loki to increase, furthering the feedback loop of increasing prices. Secondly, the staking system binds an attacker to their stake, meaning if they are found to be performing active attacks, the underlying value of their stake can sharply decline as users lose trust in the network, or could be destroyed or locked by the network, in any case increasing the attackers sunken costs. The other main advantage of a staked blockchain network is that Service Nodes earn rewards for the work they do. Service Nodes are paid a portion of the block reward minted upon the creation of each new block. This system makes Session distinct from altruistic networks like Tor and I2P and instead provides an incentive linked directly with the performance of a Service Node. Honest node behaviour and the provision of a minimum standard of operation is ensured through a consensus-based testing suite. Misbehaving nodes face the threat of having their staked capital locked, while the previously-mentioned cryptocurrency rewards function as the positive incentive for nodes to behave honestly and provide at least the minimum standard of service to the network.","title":"Service Nodes"},{"location":"LokiServices/Messenger/infrastructure/#onion-requests","text":"The other foundational component of Session is an onion routing protocol, referred to as onion requests, which enables Session clients to obfuscate their IP addresses by creating a 3-hop randomised path through the Service Node network. Onion requests use a simple onion routing protocol which successively encrypts each request for each of the three hops, ensuring: the first Service Node only knows the IP address of the client and the IP address of the middle Service Node, the middle Service Node only knows the IP address of the first and last Service Nodes, and the last Service Node only knows the IP address of the middle Service Node and the final destination IP address for the request. Each Session client establishes a path on startup, and once established, all requests for messages, attachments and meta information are sent through this path. Session clients establish a path by selecting three random nodes from their Service Node list (see bootstrapping), which contains each Service Node\u2019s IP address, storage server port and X25519 key. Clients use this information to create an onion, with each layer being encrypted with the X25519 key of its respective service node. This onion is sent to the first Service Node\u2019s storage server; this Service Node then decrypts its layer of the onion. When a Service Node unwraps a layer, the destination key for the next node is revealed. The first Service Node decrypts its layer and initialises a ZMQ connection with the specified downstream node. When the onion reaches the final node in the path, that node sends a path build success message backwards through the path, which indicates a successful path built upon its receipt by the client. Upon receiving the path build success message, the client will encrypt their messages with the X25519 keys of the final destination, be that a Service Node, file server, open group server, or client. The client also includes an ephemeral X25519 key in their request. When the destination server or client receives the request, they decrypt it and generate a response. This response is then sent back down the previously-established path, encrypted for the initial sender\u2019s (the client\u2019s) ephemeral key, so that the client can decrypt this response upon receiving it.","title":"Onion Requests"},{"location":"LokiServices/Messenger/infrastructure/#building-on-foundations","text":"Onion requests provide a straightforward anonymous networking layer, and the Service Node network provides an incentivised, self-regulating network of remote servers which provide bandwidth and storage space. A number of services are built on top of this foundation in order to give Session features commonly expected of modern messaging applications. Storage Message storage is an essential feature for any chat application aiming to provide a good user experience. When a user sends a message, they expect the recipient to receive that message even if they turn off their device after the message has been sent. Users also expect the user on the other end to receive the message when their device wakes up from an offline state. Apps that run on decentralised networks typically cannot provide this experience, because of the lack of incentive structures and, consequently, the ephemeral nature of clients and servers on such a network. Session is able to provide message storage through the incentivised Service Node network and its usage of swarms.","title":"Building on Foundations"},{"location":"LokiServices/Messenger/infrastructure/#swarms","text":"Although the Loki blockchain incentivises correct Service Node behaviour through rewards and punishments, these incentive models cannot prevent nodes going offline unexpectedly due to operator choice, software bugs, or data center outages. Therefore, for redundancy, a secondary logical data storage layer must be built on top of the Service Node network to ensure reliable message storage and retrieval. This secondary logical layer is provided by replicating messages across small groupings of Service Nodes called swarms. The swarm a Service Node initially joins is determined at the time of that Service Node\u2019s registration, with the Service Node having minimal influence over which swarm it joins. This protects against swarms being entirely made up of malicious or non-performant nodes, which is important to maintain the network\u2019s self-regulating properties. Composition of each swarm inevitably changes as the networks evolves: some nodes leave the network and the newly registered nodes take their place. If a swarm loses a large number of nodes it may additionally \"steal\" a node from some other, larger swarm. In the unlikely event that the network has no swarms to steal from (i.e., every swarm is at Nmin=5 nodes), the \u2018starving\u2019 swarm (a swarm with fewer than Nmin nodes) will be dissolved and its nodes will be redistributed among the remaining swarms. Conversely, when a large number of nodes enter the network that would oversaturate existing swarms (i.e., every swarm is already at max capacity Nmax=10), a new swarm is created from a random selection of Ntarget=7 excess nodes. Note that Nmin < Ntarget < Nmax to ensure that a newly generated swarm doesn\u2019t get dissolved shortly after and that there is still room for growth. The outcome of this algorithm is the creation and, when necessary, rebalancing of swarms of around Nmin\u2060\u2013Nmax Service Nodes which store and serve Session clients\u2019 messages. The goal of the swarm algorithm is to ensure that no swarm is controlled by a single entity and that the network is resilient enough to handle both small and large scale events where Service Nodes are no longer contactable, ensuring data integrity and privacy in both cases. The following set of simple rules ensure that Service Nodes within swarms remain synchronised as the composition of swarms changes: When a node joins a new swarm, existing swarm members recognise this and push the swarm\u2019s data records to the new member. When a node leaves a swarm, its existing records can be safely erased, with the exception of when the node is migrating from a dissolving swarm. In this case, the migrating node determines the swarms responsible for its records and distributes them accordingly.","title":"Swarms"},{"location":"LokiServices/Messenger/infrastructure/#identity-and-long-term-keys","text":"The majority of popular messaging applications require the user to register with an email or phone number in order to use the service. This provides some advantages, including account verification, for purposes of spam protection, and social network discoverability. However, such requirements also create some major privacy and security issues for users. The use of a phone number as the basis for ownership of an identity key/long-term key pair weakens security against user accounts being compromised, such as in the cases of popular applications like Signal and WhatsApp. This weakness primarily stems from the fact that phone numbers are managed by centralised service providers (i.e. telecommunications service providers) who can circumvent user control, allowing these providers to assume direct control of specific users\u2019 numbers. Widespread legislation already exists to compel service providers to take this kind of action. Additionally, methods such as SIM swapping attacks, service provider hacking, and phone number recycling can all be exploited by lower-level actors . Signal and Whatsapp put forward varying degrees of protection against these types of attacks. Signal and WhatsApp both send a 'Safety numbers have changed' warning to a user's contacts if identity keys are changed. In practice, however, users rarely verify these details out-of-band . Both Signal and WhatsApp also allow users to set a \"registration PIN lock\" . This protection means that an attacker (including a service provider or state-level actor) needs access to both the phone number and the registration PIN code to modify identity keys. However, this feature is off by default, difficult to find in the settings menu, and automatically disabled after periods of user inactivity. These factors all significantly reduce the efficacy of registration PIN locks as a protective measure against the security risks of phone number-linked accounts. Using phone numbers as the basis for account registration also greatly weakens the privacy achievable by an average user. In most countries, users must provide personally identifiable information such as a passport, drivers' license or identity card to obtain a phone number \u2014 permanently mapping users\u2019 identities to their phone numbers.These identity mappings are kept in private databases that can be queried by governments or the service providers that own them. There are also a number of web scrapers and indexers that automatically scrape phone numbers associated with individuals. These scrapers may target sources such as leaked databases, public social media profiles, and business phone numbers to link people to their phone numbers. Since the only method of initiating contact with a user in Signal, WhatsApp, or similar application is to know the user\u2019s phone number, this immediately strips away user anonymity \u2014 a significant concern for whistleblowers, activists, protestors and other such users. Account systems based on phone numbers also limit the potential for the establishment of multiple identities by a single user. These systems also prevent high-risk users without access to a phone number from accessing these services. Session does not use email addresses or phone numbers as the basis of its account system. Instead, user identity is established through the generation of X25519 public-private key pairs. These key pairs are not required to be linked with any other identifier, and new key pairs can be generated on-device in seconds. This means that each key pair (and thus, each account) is pseudonymous, unless intentionally linked with an individual identity by the user through out-of-band activity.","title":"Identity and Long-Term Keys"},{"location":"LokiServices/Messenger/infrastructure/#restoration","text":"Because Session does not have a central server to keep records of user identities, the commonly expected user experience of being able to recover an account using a username and password is not possible. Instead, users are prompted to write down their long-term private key (represented as a mnemonic seed, referred to within Session as a recovery phrase) upon account generation. A user can use this backup key to recover their account if their device is lost or destroyed, and the user's contacts will be able to continue contacting that same user account, rather than having to re-initiate contact with a new key.","title":"Restoration"},{"location":"LokiServices/Messenger/message_routing/","text":"Message Routing \u00b6 Session follows one of two distinct cases for message routing, depending on the availability of participating clients: Asynchronous (Offline) Routing \u00b6 By default, or when either of the participating clients' statuses is determined as offline (see Synchronous Routing for how client status is determined), Session will use asynchronous routing. In asynchronous routing, the sender determines the recipient's swarm by obtaining the deterministic mapping between the recipient's long-term public key and the currently registered Service Nodes. This information is initially requested from a random Service Node by the sender and updated whenever the client gets an error message in the response that indicates a missing swarm. Once this mapping is determined, the sender creates the message protobuf and packs the protobuf in an envelope with the information to be processed by Service Nodes: the long-term public key of the recipient, a timestamp, TTL (\"time to live\") and a nonce which proves the completion of the required proof of work (see Attacks \u2014 Spam). The sender then sends the envelope using an onion request to one or more random Service Nodes within the target swarm (in practice, each request is always sent to 3 service nodes to achieve a high degree of redundancy). These Service Nodes then propagate the message to the remaining nodes in the swarm, and each Service Node stores the message for the duration of its specified TTL. Alice uses an onion request to communicate with three random Service Nodes in Bob\u2019s swarm. Bob then uses an onion request to retrieve said message, by talking to three random Service Nodes in his swarm. Not shown here is the process of Alice\u2019s message being replicated across Bob\u2019s swarm. Synchronous (Online) Routing \u00b6 Session clients expose their online status in the encrypted protobuf of any asynchronous message they send. Along with their online status, a sending client also lists a Service Node in their swarm which they are listening to via onion request. When a Session client receives a message which signals the online status of another client, the receiver sends an onion request to the sender's specified listening node. The recipient also exposes their own listening node to the sender. If this process is successful, both sender and receiver will have knowledge of each others' online status and corresponding listening nodes. Messages may now be sent synchronously through onion requests to the conversing clients' respective listening nodes. Alice uses an onion request to send a message to Bob\u2019s listening node. Bob receives this message using an onion request, then sends a message to Alice\u2019s listening node. Messages sent using this synchronous method do not contain proof of work, and listening nodes do not replicate or store messages. To ensure messages are not lost, receiving clients send acknowledgements after receipt of each message. If either device goes offline, this acknowledgement will not be received, and the client which is still online will fall back to using the above asynchronous method of message transmission. Encryption and the Signal Protocol \u00b6 So far, we have discussed both the transport and storage of messages. However, any secure messaging application also requires message encryption in order to preserve user privacy. In order for messages to maintain perfect forward secrecy (PFS) and deniable authentication, we cannot only encrypt messages using the long-term public keys of each Session client. Instead, Session uses the Signal protocol. The Signal protocol allows clients to maintain PFS and Deniable Authentication in an asynchronous messaging context after initially establishing a session using long-term keys. The Signal protocol achieves perfect forward secrecy through an Extended Triple Diffie-Hellman (X3DH) key agreement protocol and the Double Ratchet protocol for deriving message keys. X3DH works in the following way. Consider clients A and B that want to establish a session. A and B each have a long-term identity key: IK_a, IK_b, respectively. Additionally, each client holds a key signed with their identity key (SK_a, SK_b), that they update on a regular basis. Finally, each client generates a one-time key (OTK) for every session they want to establish. Client A can start a session with client B if it obtains a set of B's \"prekeys\", consisting of IK_b(pub), SK_b(pub), OK_b(pub). A then validates the signature on SK_b, generates an ephemeral key EK_a, and performs a series of Diffie-Hellman derivations: DH1 = DH(IK_a(sec), SK_b(pub)) DH2 = DH(EK_a(sec), IK_b(pub)) DH3 = DH(EK_a(sec), SK_b(pub)) DH4 = DH(EK_a(sec), OK_b(pub)) The DH components are then concatenated and passed through a key derivation function (KDF) to derive a shared secret key K, which is used to initialise the Double Ratchet: K = KDF(DH1 || DH2 || DH3 || DH4) Client A is now ready to start deriving message keys using the Double Ratchet, and thus start communicating with B. In the first message that it sends, A includes IK_a(pub), EK_a(pub) necessary for B to derive K. The Double Ratchet uses a chain of Key derivation functions (KDF), each taking the previous chain key and DH parameters communicated by both clients in each of their messages, and producing the next chain key and the actual message key used for encrypting the next message. Even if some message keys get exposed, only the messages related to those keys would be compromised, and the remaining message history would continue to be hidden (the PFS property) as KDF is a one-way function. Additionally, no future messages would be exposed (the \u201cself healing\u201d property) as the potential attacker would be missing the necessary DH parameters to maintain the ratchet. The Signal protocol obtains deniability through the same scheme by allowing for all ephemeral keys used in the scheme to be left unsigned by both parties. This allows any user to create ephemeral keys for any other user, combine those ephemeral keys with their own long term and ephemeral keys to produce plausible yet forged transcripts. The Signal protocol achieves X3DH in an asynchronous environment through the use of prekeys, which contain the required information to asynchronously calculate the ephemeral keys used in the X3DH protocol. In the case of the Signal application, prekeys are stored on a central server, ensuring that these prekeys are available even when a user's device is offline. Modifications to the Signal Protocol \u00b6 Session does not modify the fundamentals of the Signal protocol. However, in order to avoid using centralised servers, we have made some changes to the sharing of prekey bundles. In Session, the sharing of prekey bundles is conducted through the 'friend request' system (see below). We also add additional information to each message, for the purpose of routing the message to its desired recipient and verifying that it was created correctly. Friend Requests \u00b6 Friend requests are sent the first time a client initiates communication with a new contact. Friend requests contain a short message with a written introduction, the sender's prekey bundle, and meta-information like the sender's display name and public key, which the recipient can use to respond. Friend requests are encrypted for the public key of the recipient using ECDH. When a friend request is received, the client can choose whether to accept it. Upon acceptance, the client can use the prekey bundle to begin a session as per the original Signal protocol, and start sending messages asynchronously.","title":"Message Routing"},{"location":"LokiServices/Messenger/message_routing/#message-routing","text":"Session follows one of two distinct cases for message routing, depending on the availability of participating clients:","title":"Message Routing"},{"location":"LokiServices/Messenger/message_routing/#asynchronous-offline-routing","text":"By default, or when either of the participating clients' statuses is determined as offline (see Synchronous Routing for how client status is determined), Session will use asynchronous routing. In asynchronous routing, the sender determines the recipient's swarm by obtaining the deterministic mapping between the recipient's long-term public key and the currently registered Service Nodes. This information is initially requested from a random Service Node by the sender and updated whenever the client gets an error message in the response that indicates a missing swarm. Once this mapping is determined, the sender creates the message protobuf and packs the protobuf in an envelope with the information to be processed by Service Nodes: the long-term public key of the recipient, a timestamp, TTL (\"time to live\") and a nonce which proves the completion of the required proof of work (see Attacks \u2014 Spam). The sender then sends the envelope using an onion request to one or more random Service Nodes within the target swarm (in practice, each request is always sent to 3 service nodes to achieve a high degree of redundancy). These Service Nodes then propagate the message to the remaining nodes in the swarm, and each Service Node stores the message for the duration of its specified TTL. Alice uses an onion request to communicate with three random Service Nodes in Bob\u2019s swarm. Bob then uses an onion request to retrieve said message, by talking to three random Service Nodes in his swarm. Not shown here is the process of Alice\u2019s message being replicated across Bob\u2019s swarm.","title":"Asynchronous (Offline) Routing"},{"location":"LokiServices/Messenger/message_routing/#synchronous-online-routing","text":"Session clients expose their online status in the encrypted protobuf of any asynchronous message they send. Along with their online status, a sending client also lists a Service Node in their swarm which they are listening to via onion request. When a Session client receives a message which signals the online status of another client, the receiver sends an onion request to the sender's specified listening node. The recipient also exposes their own listening node to the sender. If this process is successful, both sender and receiver will have knowledge of each others' online status and corresponding listening nodes. Messages may now be sent synchronously through onion requests to the conversing clients' respective listening nodes. Alice uses an onion request to send a message to Bob\u2019s listening node. Bob receives this message using an onion request, then sends a message to Alice\u2019s listening node. Messages sent using this synchronous method do not contain proof of work, and listening nodes do not replicate or store messages. To ensure messages are not lost, receiving clients send acknowledgements after receipt of each message. If either device goes offline, this acknowledgement will not be received, and the client which is still online will fall back to using the above asynchronous method of message transmission.","title":"Synchronous (Online) Routing"},{"location":"LokiServices/Messenger/message_routing/#encryption-and-the-signal-protocol","text":"So far, we have discussed both the transport and storage of messages. However, any secure messaging application also requires message encryption in order to preserve user privacy. In order for messages to maintain perfect forward secrecy (PFS) and deniable authentication, we cannot only encrypt messages using the long-term public keys of each Session client. Instead, Session uses the Signal protocol. The Signal protocol allows clients to maintain PFS and Deniable Authentication in an asynchronous messaging context after initially establishing a session using long-term keys. The Signal protocol achieves perfect forward secrecy through an Extended Triple Diffie-Hellman (X3DH) key agreement protocol and the Double Ratchet protocol for deriving message keys. X3DH works in the following way. Consider clients A and B that want to establish a session. A and B each have a long-term identity key: IK_a, IK_b, respectively. Additionally, each client holds a key signed with their identity key (SK_a, SK_b), that they update on a regular basis. Finally, each client generates a one-time key (OTK) for every session they want to establish. Client A can start a session with client B if it obtains a set of B's \"prekeys\", consisting of IK_b(pub), SK_b(pub), OK_b(pub). A then validates the signature on SK_b, generates an ephemeral key EK_a, and performs a series of Diffie-Hellman derivations: DH1 = DH(IK_a(sec), SK_b(pub)) DH2 = DH(EK_a(sec), IK_b(pub)) DH3 = DH(EK_a(sec), SK_b(pub)) DH4 = DH(EK_a(sec), OK_b(pub)) The DH components are then concatenated and passed through a key derivation function (KDF) to derive a shared secret key K, which is used to initialise the Double Ratchet: K = KDF(DH1 || DH2 || DH3 || DH4) Client A is now ready to start deriving message keys using the Double Ratchet, and thus start communicating with B. In the first message that it sends, A includes IK_a(pub), EK_a(pub) necessary for B to derive K. The Double Ratchet uses a chain of Key derivation functions (KDF), each taking the previous chain key and DH parameters communicated by both clients in each of their messages, and producing the next chain key and the actual message key used for encrypting the next message. Even if some message keys get exposed, only the messages related to those keys would be compromised, and the remaining message history would continue to be hidden (the PFS property) as KDF is a one-way function. Additionally, no future messages would be exposed (the \u201cself healing\u201d property) as the potential attacker would be missing the necessary DH parameters to maintain the ratchet. The Signal protocol obtains deniability through the same scheme by allowing for all ephemeral keys used in the scheme to be left unsigned by both parties. This allows any user to create ephemeral keys for any other user, combine those ephemeral keys with their own long term and ephemeral keys to produce plausible yet forged transcripts. The Signal protocol achieves X3DH in an asynchronous environment through the use of prekeys, which contain the required information to asynchronously calculate the ephemeral keys used in the X3DH protocol. In the case of the Signal application, prekeys are stored on a central server, ensuring that these prekeys are available even when a user's device is offline.","title":"Encryption and the Signal Protocol"},{"location":"LokiServices/Messenger/message_routing/#modifications-to-the-signal-protocol","text":"Session does not modify the fundamentals of the Signal protocol. However, in order to avoid using centralised servers, we have made some changes to the sharing of prekey bundles. In Session, the sharing of prekey bundles is conducted through the 'friend request' system (see below). We also add additional information to each message, for the purpose of routing the message to its desired recipient and verifying that it was created correctly.","title":"Modifications to the Signal Protocol"},{"location":"LokiServices/Messenger/message_routing/#friend-requests","text":"Friend requests are sent the first time a client initiates communication with a new contact. Friend requests contain a short message with a written introduction, the sender's prekey bundle, and meta-information like the sender's display name and public key, which the recipient can use to respond. Friend requests are encrypted for the public key of the recipient using ECDH. When a friend request is received, the client can choose whether to accept it. Upon acceptance, the client can use the prekey bundle to begin a session as per the original Signal protocol, and start sending messages asynchronously.","title":"Friend Requests"},{"location":"LokiServices/Messenger/multi_device_setup/","text":"Session multi-device setup \u00b6 Session now features cross-platform multidevice support, allowing you to use the same private key across your devices while maintaining security and privacy. Multidevice support is currently in early alpha, and the setup process is less streamlined than it will be when the feature moves out of alpha. The steps outlined in this guide will help you avoid data loss or other adverse effects when setting up multidevice for your Session. Primary and secondary device \u00b6 Currently Session only supports two devices per account: a primary and secondary device. This is only a temporary limitation; in future more than two devices will be able to be connected to the same account. To get started with multi-device, you'll need to start by deciding which device you want to be your primary device, and which will be your secondary. Requirements: \u00b6 Primary Device: A device with Session downloaded, installed and set up. Primary Public Key: The public key from your primary device generated by the Session. Secondary Device: A device with the Session installed but not initialised to a key. Preparation \u00b6 If you have Session installed on both devices and they both have their own public keys already, you'll need to delete one public key (effectively deleting one of your Session accounts). This device will become your secondary device. Mobile as secondary device \u00b6 If you want your mobile (i.e. smartphone or tablet) to be your secondary device and your mobile copy of Session already has its own public key, delete the Session application and redownload it from the Apple App Store or Google Play Store. Desktop as secondary device \u00b6 If you want your desktop (or laptop) messenger as your secondary device and it already has its own public key, open Session on your desktop or laptop and go to File > Preferences > Clear Data . Setup \u00b6 For this demonstration we are going to have our mobile device as our primary device and a desktop as our secondary. Step 1: Get public address from primary device \u00b6 On your mobile messenger, go into settings by tapping on your profile icon and copy your public key. You will need to send this public key to the device that will be your secondary device. Step 2: Paste public key into secondary device \u00b6 WARNING: Do NOT skip past this step. If you click the Link button on your secondary device before the primary device is ready and waiting you may lose the chance to sync the devices. Your desktop copy of Session should not yet have a public key attached to it. If you already have an account set up on your desktop messenger, jump back to Desktop as a secondary device and clear your data. Upon opening the Session desktop client, you will be prompted with 3 options: Register a new account Restore using seed Link device to an existing account Click Link device to an existing account and paste your public key copied in step 1 . Do not click the LINK button yet. We need to prepare our primary device first. Step 3: Prepare primary device \u00b6 To prepare the primary device, we need to go back into the Settings menu and click the Link Device button. Once the button has been clicked, Session on your primary device will show a new popup saying \"Waiting for Device\". Step 4: Click Link button on secondary device \u00b6 Now you can click the Link button on your desktop copy of Session. Step 5: Authorise connection on your primary device \u00b6 Once you've clicked Link on your secondary device, you will be prompted to authorise the link request on your primary device. Check that the 3 words match between devices, and authorise the request. Congratulations! \u00b6 You've successfully set up a multi-device account on Session. \u00b6","title":"Multi-Device Setup"},{"location":"LokiServices/Messenger/multi_device_setup/#session-multi-device-setup","text":"Session now features cross-platform multidevice support, allowing you to use the same private key across your devices while maintaining security and privacy. Multidevice support is currently in early alpha, and the setup process is less streamlined than it will be when the feature moves out of alpha. The steps outlined in this guide will help you avoid data loss or other adverse effects when setting up multidevice for your Session.","title":"Session multi-device setup"},{"location":"LokiServices/Messenger/multi_device_setup/#primary-and-secondary-device","text":"Currently Session only supports two devices per account: a primary and secondary device. This is only a temporary limitation; in future more than two devices will be able to be connected to the same account. To get started with multi-device, you'll need to start by deciding which device you want to be your primary device, and which will be your secondary.","title":"Primary and secondary device"},{"location":"LokiServices/Messenger/multi_device_setup/#requirements","text":"Primary Device: A device with Session downloaded, installed and set up. Primary Public Key: The public key from your primary device generated by the Session. Secondary Device: A device with the Session installed but not initialised to a key.","title":"Requirements:"},{"location":"LokiServices/Messenger/multi_device_setup/#preparation","text":"If you have Session installed on both devices and they both have their own public keys already, you'll need to delete one public key (effectively deleting one of your Session accounts). This device will become your secondary device.","title":"Preparation"},{"location":"LokiServices/Messenger/multi_device_setup/#mobile-as-secondary-device","text":"If you want your mobile (i.e. smartphone or tablet) to be your secondary device and your mobile copy of Session already has its own public key, delete the Session application and redownload it from the Apple App Store or Google Play Store.","title":"Mobile as secondary device"},{"location":"LokiServices/Messenger/multi_device_setup/#desktop-as-secondary-device","text":"If you want your desktop (or laptop) messenger as your secondary device and it already has its own public key, open Session on your desktop or laptop and go to File > Preferences > Clear Data .","title":"Desktop as secondary device"},{"location":"LokiServices/Messenger/multi_device_setup/#setup","text":"For this demonstration we are going to have our mobile device as our primary device and a desktop as our secondary.","title":"Setup"},{"location":"LokiServices/Messenger/multi_device_setup/#step-1-get-public-address-from-primary-device","text":"On your mobile messenger, go into settings by tapping on your profile icon and copy your public key. You will need to send this public key to the device that will be your secondary device.","title":"Step 1: Get public address from primary device"},{"location":"LokiServices/Messenger/multi_device_setup/#step-2-paste-public-key-into-secondary-device","text":"WARNING: Do NOT skip past this step. If you click the Link button on your secondary device before the primary device is ready and waiting you may lose the chance to sync the devices. Your desktop copy of Session should not yet have a public key attached to it. If you already have an account set up on your desktop messenger, jump back to Desktop as a secondary device and clear your data. Upon opening the Session desktop client, you will be prompted with 3 options: Register a new account Restore using seed Link device to an existing account Click Link device to an existing account and paste your public key copied in step 1 . Do not click the LINK button yet. We need to prepare our primary device first.","title":"Step 2: Paste public key into secondary device"},{"location":"LokiServices/Messenger/multi_device_setup/#step-3-prepare-primary-device","text":"To prepare the primary device, we need to go back into the Settings menu and click the Link Device button. Once the button has been clicked, Session on your primary device will show a new popup saying \"Waiting for Device\".","title":"Step 3: Prepare primary device"},{"location":"LokiServices/Messenger/multi_device_setup/#step-4-click-link-button-on-secondary-device","text":"Now you can click the Link button on your desktop copy of Session.","title":"Step 4: Click Link button on secondary device"},{"location":"LokiServices/Messenger/multi_device_setup/#step-5-authorise-connection-on-your-primary-device","text":"Once you've clicked Link on your secondary device, you will be prompted to authorise the link request on your primary device. Check that the 3 words match between devices, and authorise the request.","title":"Step 5: Authorise connection on your primary device"},{"location":"LokiServices/Messenger/multi_device_setup/#congratulations","text":"","title":"Congratulations!"},{"location":"LokiServices/Messenger/multi_device_setup/#youve-successfully-set-up-a-multi-device-account-on-session","text":"","title":"You've successfully set up a multi-device account on Session."},{"location":"LokiServices/Messenger/multidevice/","text":"Multi-Device \u00b6 Modern messaging applications are expected to sync data (message histories, contact lists, etc.) across multiple devices, ensuring that users are able to move between a laptop and a phone (for example) and continue their conversations where they left off. Such multi-device syncing of messages is more difficult in the context of the Signal protocol since key materials are constantly rotated and deleted after a period of time. This means when messaging other users, an out-of-sync device in a multi-device configuration will encrypt using the wrong keypairs. Sesame, Signal\u2019s session management algorithm, attempts to resolve this, but must rely on a central server to provide a consistent transcript of messages to multiple user devices. Since Session does not rely upon central servers, Session requires a different solution, which we broadly refer to as \u2018Multi-Device.\u2019 Device Linking \u00b6 Once an account has been created on one device (referred to as the primary device), the other device (the secondary device) initiates the linking process, which creates a new public/private key pair. A pairwise channel is established between primary and secondary devices, and the primary device's private keys are shared from the primary device to the secondary device. To the user, it now appears that both primary and secondary devices are using the same public/private key pair. Friend Requests \u00b6 Consider user A with two devices (A1, A2) who wants to start communicating with user B, who also has two devices (B1,B2). User A obtains B\u2019s primary public key, i.e., the pubkey of its primary device (B1), out of band. Using this public key, one of A\u2019s devices (A1) sends a friend request to B\u2019s primary device's swarm containing its prekey bundle and the list of its linked devices (A2). Both primary and secondary devices (B1,B2) scan the primary device's swarm periodically, looking for new friend requests. When A\u2019s friend request is found, either one of the devices is able to accept the friend request and initiate a session with A1. The device that accepts the friend request, say B2, then uses the pre-established pairwise channel to notify the other device (B1) of actions it has taken, and instructs B1 to request a session with all of A\u2019s devices. B2 also establishes any outstanding sessions with A\u2019s devices. Finally, B2 provides A with the public key of all of its own linked devices (B1), so A knows to link them. A and B can now begin communicating in a multi-device setting. Alice sends Bob a friend request with multi-device enabled Sending and Receiving Messages \u00b6 After the initial friend request process, the clients can start communicating. When client A needs to send a message to a multi-device-enabled user B, they deliver the message to all of B's linked devices using the established pairwise sessions. Note that secondary devices only poll the primary\u2019s device swarm for establishing new sessions; regular data messages are associated with the device\u2019s own keys, and thus arrive at the device\u2019s own swarm. If user A also has multiple devices, they additionally send a copy of the message to all of their other devices, which appear in those device's message history as having been sent by them, ensuring that their message history is synced across devices. Multi-device sending: Here, Alice sends a message from her primary device to Bob, who has multi-device enabled. Alice sends a message to Bob\u2019s primary and secondary device swarms. She also sends a message to her own secondary device\u2019s swarm, for later retrieval. Not shown here: Onion requests, swarm message replication Open Groups \u00b6 All open group messages are signed by a user's long-term identity key. Recall that secondary devices have access to the primary device\u2019s long-term identity private key as a result of the linking procedure. The secondary devices thus can sign all open group messages using that key. This ensures that other users in the open group see messages from both the primary and secondary device as coming from the same user (having been signed by the same key).","title":"Multi-Device"},{"location":"LokiServices/Messenger/multidevice/#multi-device","text":"Modern messaging applications are expected to sync data (message histories, contact lists, etc.) across multiple devices, ensuring that users are able to move between a laptop and a phone (for example) and continue their conversations where they left off. Such multi-device syncing of messages is more difficult in the context of the Signal protocol since key materials are constantly rotated and deleted after a period of time. This means when messaging other users, an out-of-sync device in a multi-device configuration will encrypt using the wrong keypairs. Sesame, Signal\u2019s session management algorithm, attempts to resolve this, but must rely on a central server to provide a consistent transcript of messages to multiple user devices. Since Session does not rely upon central servers, Session requires a different solution, which we broadly refer to as \u2018Multi-Device.\u2019","title":"Multi-Device"},{"location":"LokiServices/Messenger/multidevice/#device-linking","text":"Once an account has been created on one device (referred to as the primary device), the other device (the secondary device) initiates the linking process, which creates a new public/private key pair. A pairwise channel is established between primary and secondary devices, and the primary device's private keys are shared from the primary device to the secondary device. To the user, it now appears that both primary and secondary devices are using the same public/private key pair.","title":"Device Linking"},{"location":"LokiServices/Messenger/multidevice/#friend-requests","text":"Consider user A with two devices (A1, A2) who wants to start communicating with user B, who also has two devices (B1,B2). User A obtains B\u2019s primary public key, i.e., the pubkey of its primary device (B1), out of band. Using this public key, one of A\u2019s devices (A1) sends a friend request to B\u2019s primary device's swarm containing its prekey bundle and the list of its linked devices (A2). Both primary and secondary devices (B1,B2) scan the primary device's swarm periodically, looking for new friend requests. When A\u2019s friend request is found, either one of the devices is able to accept the friend request and initiate a session with A1. The device that accepts the friend request, say B2, then uses the pre-established pairwise channel to notify the other device (B1) of actions it has taken, and instructs B1 to request a session with all of A\u2019s devices. B2 also establishes any outstanding sessions with A\u2019s devices. Finally, B2 provides A with the public key of all of its own linked devices (B1), so A knows to link them. A and B can now begin communicating in a multi-device setting. Alice sends Bob a friend request with multi-device enabled","title":"Friend Requests"},{"location":"LokiServices/Messenger/multidevice/#sending-and-receiving-messages","text":"After the initial friend request process, the clients can start communicating. When client A needs to send a message to a multi-device-enabled user B, they deliver the message to all of B's linked devices using the established pairwise sessions. Note that secondary devices only poll the primary\u2019s device swarm for establishing new sessions; regular data messages are associated with the device\u2019s own keys, and thus arrive at the device\u2019s own swarm. If user A also has multiple devices, they additionally send a copy of the message to all of their other devices, which appear in those device's message history as having been sent by them, ensuring that their message history is synced across devices. Multi-device sending: Here, Alice sends a message from her primary device to Bob, who has multi-device enabled. Alice sends a message to Bob\u2019s primary and secondary device swarms. She also sends a message to her own secondary device\u2019s swarm, for later retrieval. Not shown here: Onion requests, swarm message replication","title":"Sending and Receiving Messages"},{"location":"LokiServices/Messenger/multidevice/#open-groups","text":"All open group messages are signed by a user's long-term identity key. Recall that secondary devices have access to the primary device\u2019s long-term identity private key as a result of the linking procedure. The secondary devices thus can sign all open group messages using that key. This ensures that other users in the open group see messages from both the primary and secondary device as coming from the same user (having been signed by the same key).","title":"Open Groups"},{"location":"LokiServices/Messenger/opengroup_setup/","text":"Session Open Group Setup \u00b6 An express REST API for serving persistence history public chat rooms for Session. Open groups are not limited in size as they are hosted by your own server. Please be aware these are PUBLIC groups and sensitive private information should not be shared in this group format. It's run by 2 daemons, the platform servers providing an ADN standard REST API and another with Session specific behaviors (crypto-key registration and enhanced moderation functions). Requirements \u00b6 Hosting with a public IP address make sure you have a working DNS hostname that points to your public IP address. an email address (LetsEncrypt requires this) We recommend you have at least 4GB of free disk space and 512mb of ram (it may runs with less but use at your own risk) Installation \u00b6 1. Install docker (debian) \u00b6 for non-debian-based installation instructions of Docker: https://docs.docker.com/v17.12/install/#server Use this guide for additional troubleshooting help: https://docs.docker.com/v17.12/install/linux/docker-ce/debian/#set-up-the-repository or https://docs.docker.com/v17.12/install/linux/docker-ce/ubuntu/ Remove any possibly previously installed docker installations \u00b6 sudo apt-get remove docker docker-engine docker.io Install official docker repo \u00b6 sudo apt-get update sudo apt-get install apt-transport-https ca-certificates curl gnupg2 software-properties-common For Debian \u00b6 curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add - sudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/debian $(lsb_release -cs) stable\" For Ubuntu \u00b6 curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - sudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\" Install and test docker \u00b6 apt-get update sudo apt-get install docker-ce To check to make sure it's all working: docker run hello-world 2. Install docker-compose \u00b6 Create docker-compose script \u00b6 curl -L \"https://github.com/docker/compose/releases/download/1.25.0/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose make sure it's executable \u00b6 chmod u+x /usr/local/bin/docker-compose 3. Install SOGS \u00b6 git clone https://github.com/loki-project/session-open-group-server.git Install SOGS git submodules \u00b6 cd session-open-group-server git submodule init git submodule update Make sure permissions on acme.json is correct \u00b6 chmod 600 docker/acme.json Set up config \u00b6 cp loki_template.ini loki.ini Get your PUBKEY \u00b6 replace PUBKEY with your key and run echo \"PUBKEY=true\" >> loki.ini Start it \u00b6 Replace your@email.tld with your email address and yourssl.domain.tld with your public facing hostname. These are required for getting an SSL certification from LetsEncrypt which we will attempt to automatically do for you. EMAIL=your@email.tld DOMAIN=yourssl.domain.tld docker-compose up -d Upgrade instruction \u00b6 make sure you're in the loki-messenger-public-server directory EMAIL=your@email.tld DOMAIN=yourssl.domain.tld docker-compose down to stop it from running git pull to grab the latest source and configs git submodule init to grab any submodule changes git submodule update to grab any platform/nodepomf changes EMAIL=your@email.tld DOMAIN=yourssl.domain.tld docker-compose build to update the local docker images EMAIL=your@email.tld DOMAIN=yourssl.domain.tld docker-compose up -d to restart the server Getting Help \u00b6 If something in this guide isn\u2019t making sense, or if you\u2019re running into issues that you can\u2019t identify on your own, the first place to go would be the #lokinet-help channel on discord . Alternatively, you can find help on our other communication channels such as telegram , twitter , or reddit . Reporting Bugs \u00b6 After you have sought out for help through our communication channels and have not come to any solutions we recommend opening up a issue ticket on the Session public server repository. Please use the following Github Issue Template for any github issues created: Github Issue Template Example .","title":"OpenGroup Setup"},{"location":"LokiServices/Messenger/opengroup_setup/#session-open-group-setup","text":"An express REST API for serving persistence history public chat rooms for Session. Open groups are not limited in size as they are hosted by your own server. Please be aware these are PUBLIC groups and sensitive private information should not be shared in this group format. It's run by 2 daemons, the platform servers providing an ADN standard REST API and another with Session specific behaviors (crypto-key registration and enhanced moderation functions).","title":"Session Open Group Setup"},{"location":"LokiServices/Messenger/opengroup_setup/#requirements","text":"Hosting with a public IP address make sure you have a working DNS hostname that points to your public IP address. an email address (LetsEncrypt requires this) We recommend you have at least 4GB of free disk space and 512mb of ram (it may runs with less but use at your own risk)","title":"Requirements"},{"location":"LokiServices/Messenger/opengroup_setup/#installation","text":"","title":"Installation"},{"location":"LokiServices/Messenger/opengroup_setup/#1-install-docker-debian","text":"for non-debian-based installation instructions of Docker: https://docs.docker.com/v17.12/install/#server Use this guide for additional troubleshooting help: https://docs.docker.com/v17.12/install/linux/docker-ce/debian/#set-up-the-repository or https://docs.docker.com/v17.12/install/linux/docker-ce/ubuntu/","title":"1. Install docker (debian)"},{"location":"LokiServices/Messenger/opengroup_setup/#remove-any-possibly-previously-installed-docker-installations","text":"sudo apt-get remove docker docker-engine docker.io","title":"Remove any possibly previously installed docker installations"},{"location":"LokiServices/Messenger/opengroup_setup/#install-official-docker-repo","text":"sudo apt-get update sudo apt-get install apt-transport-https ca-certificates curl gnupg2 software-properties-common","title":"Install official docker repo"},{"location":"LokiServices/Messenger/opengroup_setup/#for-debian","text":"curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add - sudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/debian $(lsb_release -cs) stable\"","title":"For Debian"},{"location":"LokiServices/Messenger/opengroup_setup/#for-ubuntu","text":"curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - sudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\"","title":"For Ubuntu"},{"location":"LokiServices/Messenger/opengroup_setup/#install-and-test-docker","text":"apt-get update sudo apt-get install docker-ce To check to make sure it's all working: docker run hello-world","title":"Install and test docker"},{"location":"LokiServices/Messenger/opengroup_setup/#2-install-docker-compose","text":"","title":"2. Install docker-compose"},{"location":"LokiServices/Messenger/opengroup_setup/#create-docker-compose-script","text":"curl -L \"https://github.com/docker/compose/releases/download/1.25.0/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose","title":"Create docker-compose script"},{"location":"LokiServices/Messenger/opengroup_setup/#make-sure-its-executable","text":"chmod u+x /usr/local/bin/docker-compose","title":"make sure it's executable"},{"location":"LokiServices/Messenger/opengroup_setup/#3-install-sogs","text":"git clone https://github.com/loki-project/session-open-group-server.git","title":"3. Install SOGS"},{"location":"LokiServices/Messenger/opengroup_setup/#install-sogs-git-submodules","text":"cd session-open-group-server git submodule init git submodule update","title":"Install SOGS git submodules"},{"location":"LokiServices/Messenger/opengroup_setup/#make-sure-permissions-on-acmejson-is-correct","text":"chmod 600 docker/acme.json","title":"Make sure permissions on acme.json is correct"},{"location":"LokiServices/Messenger/opengroup_setup/#set-up-config","text":"cp loki_template.ini loki.ini","title":"Set up config"},{"location":"LokiServices/Messenger/opengroup_setup/#get-your-pubkey","text":"replace PUBKEY with your key and run echo \"PUBKEY=true\" >> loki.ini","title":"Get your PUBKEY"},{"location":"LokiServices/Messenger/opengroup_setup/#start-it","text":"Replace your@email.tld with your email address and yourssl.domain.tld with your public facing hostname. These are required for getting an SSL certification from LetsEncrypt which we will attempt to automatically do for you. EMAIL=your@email.tld DOMAIN=yourssl.domain.tld docker-compose up -d","title":"Start it"},{"location":"LokiServices/Messenger/opengroup_setup/#upgrade-instruction","text":"make sure you're in the loki-messenger-public-server directory EMAIL=your@email.tld DOMAIN=yourssl.domain.tld docker-compose down to stop it from running git pull to grab the latest source and configs git submodule init to grab any submodule changes git submodule update to grab any platform/nodepomf changes EMAIL=your@email.tld DOMAIN=yourssl.domain.tld docker-compose build to update the local docker images EMAIL=your@email.tld DOMAIN=yourssl.domain.tld docker-compose up -d to restart the server","title":"Upgrade instruction"},{"location":"LokiServices/Messenger/opengroup_setup/#getting-help","text":"If something in this guide isn\u2019t making sense, or if you\u2019re running into issues that you can\u2019t identify on your own, the first place to go would be the #lokinet-help channel on discord . Alternatively, you can find help on our other communication channels such as telegram , twitter , or reddit .","title":"Getting Help"},{"location":"LokiServices/Messenger/opengroup_setup/#reporting-bugs","text":"After you have sought out for help through our communication channels and have not come to any solutions we recommend opening up a issue ticket on the Session public server repository. Please use the following Github Issue Template for any github issues created: Github Issue Template Example .","title":"Reporting Bugs"},{"location":"LokiServices/Messenger/testing/","text":"Testing \u00b6 Service Nodes are rewarded for providing services to the network in an honest and consistent manner. Consequently, dishonest Service Nodes must be prevented from refusing to store messages for the network while continuing to collect rewards . This is accomplished through Service Node testing, a network-level system of peer policing. Service Node Testing \u00b6 Every Service Node monitors the state of the Loki blockchain, which periodically generates blocks whose hashes are relatively unpredictable. On every block, Service Nodes use this blockhash to deterministically derive a pair of nodes within each swarm : one to be tested (T) and one to perform verification (V). Since T and V both belong to the same swarm, they are expected to store the same database records. As a way of testing this, Node V selects a random record from its database (verifying that the message indeed belongs to the current swarm) and sends a test request to node T, containing only the record's hash and the current block height h. T is expected to respond with the record's actual data. Note that the official binaries used by honest Service Nodes do not expose an endpoint for retrieving a record by its hash, so a cheating node would generally have to download the entire database from one of its honest peers to search for the requested record, making cheating impractical. When T receives a test request, it first confirms that (T, V) is correct for the specified height h and that h is within some reasonable boundary. It then tries to retrieve the requested record from its own database. Note that due to the nature of message propagation, it is possible for V to hold a record for a message before T first receives it, so T will wait for a short time for the message to arrive, and only then respond to the test. When the requested record is obtained, T can respond to the test with the requested record's data. If V does not receive the response within some acceptable time window or it is incorrect, V reports T to the blockchain as having failed the test. In cases of repeated failures, the Service Nodes as a collective might then decide to decommission or deregister T if it consistently fails storage tests as reported by multiple other Service Nodes.","title":"Testing"},{"location":"LokiServices/Messenger/testing/#testing","text":"Service Nodes are rewarded for providing services to the network in an honest and consistent manner. Consequently, dishonest Service Nodes must be prevented from refusing to store messages for the network while continuing to collect rewards . This is accomplished through Service Node testing, a network-level system of peer policing.","title":"Testing"},{"location":"LokiServices/Messenger/testing/#service-node-testing","text":"Every Service Node monitors the state of the Loki blockchain, which periodically generates blocks whose hashes are relatively unpredictable. On every block, Service Nodes use this blockhash to deterministically derive a pair of nodes within each swarm : one to be tested (T) and one to perform verification (V). Since T and V both belong to the same swarm, they are expected to store the same database records. As a way of testing this, Node V selects a random record from its database (verifying that the message indeed belongs to the current swarm) and sends a test request to node T, containing only the record's hash and the current block height h. T is expected to respond with the record's actual data. Note that the official binaries used by honest Service Nodes do not expose an endpoint for retrieving a record by its hash, so a cheating node would generally have to download the entire database from one of its honest peers to search for the requested record, making cheating impractical. When T receives a test request, it first confirms that (T, V) is correct for the specified height h and that h is within some reasonable boundary. It then tries to retrieve the requested record from its own database. Note that due to the nature of message propagation, it is possible for V to hold a record for a message before T first receives it, so T will wait for a short time for the message to arrive, and only then respond to the test. When the requested record is obtained, T can respond to the test with the requested record's data. If V does not receive the response within some acceptable time window or it is incorrect, V reports T to the blockchain as having failed the test. In cases of repeated failures, the Service Nodes as a collective might then decide to decommission or deregister T if it consistently fails storage tests as reported by multiple other Service Nodes.","title":"Service Node Testing"},{"location":"LokiServices/Messenger/threat_model/","text":"Threat Model \u00b6 It is useful to understand the protections Session provides to users, and the threat model which it is effective in defending against. Protections \u00b6 Session aims to provide the following protections against attackers within the scope of the threat model: Sender Anonymity : The long-term identity key of the sender is only knowable to the member(s) of the conversation, and the IP address of the sender is unknown to all parties except the first hop in the onion routing path. Recipient Anonymity : The IP address of the recipient is unknown to all parties except the first hop in the onion routing path. Data Integrity : Messages are received intact and unmodified, and if messages are modified they appear as corrupted and are discarded. Storage : Messages are stored and available for the duration of their specified time to live. End-to-end encryption : Messages (with the exception of friend requests) maintain the properties of the Off the Record (OTR) messaging protocol, namely Perfect Forward Secrecy and Deniable Authentication. In Scope \u00b6 Service Node Operators - Passive/Action attacks \u00b6 Storage of messages in Session is handled by Service Node operators. Since the Service Node network is permissionless (only sufficient stake is required to join), our threat model considers a highly resourced attacker that has limited financial resources and can only run a fraction of the storage network. A dishonest Service Node operator would be able to perform a range of active or passive attacks. Such passive attacks could include passively reading message headers, logging timestamps of when messages were relayed/received, saving the encrypted contents of a message, and assessing the size of a message. Active attacks could include failing to relay messages, failing to store messages, providing clients with modified messages, and refusing to respond to requests for messages belonging to public keys. Service Nodes also operate the onion request system and thus could also attack it. Active attacks on the onion request system could include dropping arbitrary packets, modifying latency between hops, and modifying packets. Malicious Service Nodes would be able to continue performing these active attacks for as long as they continued to pass inter-Service Node tests. Passive attacks may involve a malicious Service Node collecting and storing all data that passes through it and logging all connections with other Service Nodes. Network adversary - Passive attacks \u00b6 Session\u2019s threat model also considers a local network adversary such as an ISP or local network provider. This adversary can perform passive attacks such as monitoring all traffic it relays, conducting deep packet inspection, or saving relayed packets for later inspection. Out of Scope \u00b6 Attackers who are out of the scope of Session\u2019s threat model may be able to break some of the protections Session aims to provide. Network Adversary \u2014 Active Attacks \u00b6 A network adversary could conduct active attacks including corrupting or rerouting packets, or adding delays. These attacks could compromise the storage and retrieval of messages. This is primarily addressed by encrypting data and using onion requests to store and retrieve messages, making targeted attacks by network adversaries difficult. Global Passive Adversary \u00b6 A global passive adversary (GPA) that can monitor the first and last hops in an onion request path could use traffic analysis to reveal the true IP address of a Session client and the destination that Session client is talking to. This potential attack is a property of the onion request system; onion requests are a low-latency onion routing network, meaning that packets are forwarded to their destinations as fast as possible, with no delays or batching. This behaviour, while beneficial for user experience, makes traffic analysis trivial in the case of a GPA. Out of Band Key Discovery \u00b6 Session cannot protect users from exposing the pseudonymity provided by the public key-based account system. If a user associates their real world identity with their public key, then other parties will be able to discover if they receive new friend requests.","title":"Threat Models"},{"location":"LokiServices/Messenger/threat_model/#threat-model","text":"It is useful to understand the protections Session provides to users, and the threat model which it is effective in defending against.","title":"Threat Model"},{"location":"LokiServices/Messenger/threat_model/#protections","text":"Session aims to provide the following protections against attackers within the scope of the threat model: Sender Anonymity : The long-term identity key of the sender is only knowable to the member(s) of the conversation, and the IP address of the sender is unknown to all parties except the first hop in the onion routing path. Recipient Anonymity : The IP address of the recipient is unknown to all parties except the first hop in the onion routing path. Data Integrity : Messages are received intact and unmodified, and if messages are modified they appear as corrupted and are discarded. Storage : Messages are stored and available for the duration of their specified time to live. End-to-end encryption : Messages (with the exception of friend requests) maintain the properties of the Off the Record (OTR) messaging protocol, namely Perfect Forward Secrecy and Deniable Authentication.","title":"Protections"},{"location":"LokiServices/Messenger/threat_model/#in-scope","text":"","title":"In Scope"},{"location":"LokiServices/Messenger/threat_model/#service-node-operators-passiveaction-attacks","text":"Storage of messages in Session is handled by Service Node operators. Since the Service Node network is permissionless (only sufficient stake is required to join), our threat model considers a highly resourced attacker that has limited financial resources and can only run a fraction of the storage network. A dishonest Service Node operator would be able to perform a range of active or passive attacks. Such passive attacks could include passively reading message headers, logging timestamps of when messages were relayed/received, saving the encrypted contents of a message, and assessing the size of a message. Active attacks could include failing to relay messages, failing to store messages, providing clients with modified messages, and refusing to respond to requests for messages belonging to public keys. Service Nodes also operate the onion request system and thus could also attack it. Active attacks on the onion request system could include dropping arbitrary packets, modifying latency between hops, and modifying packets. Malicious Service Nodes would be able to continue performing these active attacks for as long as they continued to pass inter-Service Node tests. Passive attacks may involve a malicious Service Node collecting and storing all data that passes through it and logging all connections with other Service Nodes.","title":"Service Node Operators - Passive/Action attacks"},{"location":"LokiServices/Messenger/threat_model/#network-adversary-passive-attacks","text":"Session\u2019s threat model also considers a local network adversary such as an ISP or local network provider. This adversary can perform passive attacks such as monitoring all traffic it relays, conducting deep packet inspection, or saving relayed packets for later inspection.","title":"Network adversary - Passive attacks"},{"location":"LokiServices/Messenger/threat_model/#out-of-scope","text":"Attackers who are out of the scope of Session\u2019s threat model may be able to break some of the protections Session aims to provide.","title":"Out of Scope"},{"location":"LokiServices/Messenger/threat_model/#network-adversary-active-attacks","text":"A network adversary could conduct active attacks including corrupting or rerouting packets, or adding delays. These attacks could compromise the storage and retrieval of messages. This is primarily addressed by encrypting data and using onion requests to store and retrieve messages, making targeted attacks by network adversaries difficult.","title":"Network Adversary \u2014 Active Attacks"},{"location":"LokiServices/Messenger/threat_model/#global-passive-adversary","text":"A global passive adversary (GPA) that can monitor the first and last hops in an onion request path could use traffic analysis to reveal the true IP address of a Session client and the destination that Session client is talking to. This potential attack is a property of the onion request system; onion requests are a low-latency onion routing network, meaning that packets are forwarded to their destinations as fast as possible, with no delays or batching. This behaviour, while beneficial for user experience, makes traffic analysis trivial in the case of a GPA.","title":"Global Passive Adversary"},{"location":"LokiServices/Messenger/threat_model/#out-of-band-key-discovery","text":"Session cannot protect users from exposing the pseudonymity provided by the public key-based account system. If a user associates their real world identity with their public key, then other parties will be able to discover if they receive new friend requests.","title":"Out of Band Key Discovery"},{"location":"Lokinet/DeveloperInfo/","text":"Developer Info \u00b6 DHT entities \u00b6 Intro : Router Identity Key + Path ID + expiration timestamp + extra metadata, advertised by a hidden service as a middle point for communication. Introset : A set of intros and related metadata signed by the hidden service's public signing key , used to advertise how to access a hidden service to the LokiNET DHT. Link Layer entities \u00b6 Router Contact : self signed metadata associated with a Service Node, includes public key address of a SN (Service Node), and AddressInfos Address Info : // TODO Exit Info : // TODO","title":"DeveloperInfo"},{"location":"Lokinet/DeveloperInfo/#developer-info","text":"","title":"Developer Info"},{"location":"Lokinet/DeveloperInfo/#dht-entities","text":"Intro : Router Identity Key + Path ID + expiration timestamp + extra metadata, advertised by a hidden service as a middle point for communication. Introset : A set of intros and related metadata signed by the hidden service's public signing key , used to advertise how to access a hidden service to the LokiNET DHT.","title":"DHT entities"},{"location":"Lokinet/DeveloperInfo/#link-layer-entities","text":"Router Contact : self signed metadata associated with a Service Node, includes public key address of a SN (Service Node), and AddressInfos Address Info : // TODO Exit Info : // TODO","title":"Link Layer entities"},{"location":"Lokinet/LLARP/","text":"Low Latency Anonymous Routing Protocol (LLARP) \u00b6 Underlying all applications for Service Nodes is an anonymous routing protocol, which defines the way each Service Node communicates with its peers. Loki proposes a new routing protocol called LLARP which is designed as a hybrid between Tor and I2P to provide additional desirable properties versus any existing routing protocol. LLARP is built specifically to run on top of the Loki Service Nodes network and all LLARP optimisations consider this architecture. To understand the goals of LLARP, it is best to conduct an analysis of existing routing protocols and consider how LLARP improves upon them. LLARP operates without the need to make use of directory authorities and, instead, relies on a DHT built from blockchain staking transactions, which allows Service Nodes to act as routers in the network. Bandwidth is not monitored or recorded in the DHT. Instead, bandwidth measurement and triage result from swarms that assess each node and make a judgement on the nodes ability to provide appropriate bandwidth to the network. In the Open Systems Interconnection model (OSI model), LLARP only attempts to provide an anonymous network layer. This means that it supports a larger range of internet protocols and it also minimises the overhead for storing file descriptors should exit nodes pass through User Datagram Protocol (UDP) traffic. Additionally, LLARP opts for packet-switched based routing instead of tunnel-based routing, allowing for better load balancing and redundancy across the network. End users of Lokinet are not expected (or even allowed) to route packets, this means that Lokinet exposes itself to a much lower attack surface for a Sybil attack due to the significant capital outlay required to begin Service Nodes operation. The Onion Router (Tor) \u00b6 In recent years, Tor has been the most popular anonymous mixnet. The Tor network maintains a high-level of censorship resistance and has proved a valuable tool for preserving internet privacy. However,Tor is not a decentralised network as much as it is a hierarchical one. Tor is reliant on a group of directory authorities which are centralised servers operated by a group of volunteers close to the Tor Foundation . These directory authorities perform two main functions. Firstly, they act as trusted reporters on the state of nodes in the network. When a Tor user (or relay) connects to the network for the first time they can connect to one of ten hard-coded directory authorities. These directory authorities provide the user or relay with a file called the consensus. This file provides a list of all of the relays, guard nodes, and exit nodes currently in operation (excluding bridges) on the Tor network. Secondly, the directory authorities also measure the bandwidth that each relay can provide to the network. They use this information to triage relays into categories, deciding whether nodes can operate as relays, guard nodes, or exit nodes. Tor has potential problems with Centralisation \u00b6 This high level of centralisation creates points of failure that leaves Tor vulnerable. In 2014, Tor received information of a credible threat to take down the directory authority servers . If the directory authorities in the United States and either Germany or the Netherlands were to be shut down, that would be enough to shut down five of the ten directory authority servers. This would result in a highly unstable Tor network, with new relays being greatly diminished in their ability to interact with the network. Methods of communication in Tor are also limited, as Tor only allows communication overTCP. IP over Tor is possible, but it lacks support for UDP based protocols (such as VoIP). Invisible Internet Project (I2P) \u00b6 I2P takes a different approach to mixnet architecture, maintaining a higher level of trust agility by referring to a Distributed Hashing Table (DHT) to ascertain the network state instead of trusted directory authorities [15]. I2P also allows for both TCP and UDP traffic, supporting a larger scope of protocol interactions. However, I2P has not had a steady development process and over time it has accumulated technical debt, specifically in its cryptography usage. I2P uses 2048 bit ElGamal, which makes encryption and decryption slow in contrast to elliptic curve operations. While plans to migrate away from ElGamal exist in the I2P roadmap, progress has been slow. I2P has a lack of formal exit node support. \u00b6 Additionally, I2P lacks formal support for exit nodes , meaning the majority of traffic on the network is accessing internally hosted websites, called Eepsites. This has greatly reduced the ability for the I2P network to reach users whose main purpose for using anonymising networks is to access the wider internet. Furthermore, the manner in which I2P is built means that the majority of users that connect to the network also become routers, which is problematic as the resulting network often lacks sufficient bandwidth to be able to build fast paths. Network speeds in mixnets are bottlenecked by the least capable node in each circuit, and as a result of low-performance users becoming relays in I2P, a reduction in overall performance is seen. How does Tor compare with I2P \u00b6 Finally, I2P differs from Tor in that it offers a packet-switched (rather than circuit-switched) network. Instead of establishing a single longer-term tunnel which all traffic travels through, I2P establishes multiple paths that each packet being communicated can use to use to take a different route through the network. This gives I2P the ability to transparently route around network congestion and node failures. Cheap Node Attack \u00b6 Both I2P and Tor have not fully mitigated Sybil attacks. A sufficiently motivated attacker that has enough time and capital to buy large amounts of relays can perform temporal analysis which undermines user privacy. The effectiveness of this analysis increases the more exit nodes, relays and guard nodes the attacker operates . Tor and I2P are operated entirely by volunteers that donate both their time and money to the operation of nodes. We surmise that a network constructed from financial incentives rather than altruism can achieve a greater resilience against attacks, while providing a more reliable service.","title":"LLARP"},{"location":"Lokinet/LLARP/#low-latency-anonymous-routing-protocol-llarp","text":"Underlying all applications for Service Nodes is an anonymous routing protocol, which defines the way each Service Node communicates with its peers. Loki proposes a new routing protocol called LLARP which is designed as a hybrid between Tor and I2P to provide additional desirable properties versus any existing routing protocol. LLARP is built specifically to run on top of the Loki Service Nodes network and all LLARP optimisations consider this architecture. To understand the goals of LLARP, it is best to conduct an analysis of existing routing protocols and consider how LLARP improves upon them. LLARP operates without the need to make use of directory authorities and, instead, relies on a DHT built from blockchain staking transactions, which allows Service Nodes to act as routers in the network. Bandwidth is not monitored or recorded in the DHT. Instead, bandwidth measurement and triage result from swarms that assess each node and make a judgement on the nodes ability to provide appropriate bandwidth to the network. In the Open Systems Interconnection model (OSI model), LLARP only attempts to provide an anonymous network layer. This means that it supports a larger range of internet protocols and it also minimises the overhead for storing file descriptors should exit nodes pass through User Datagram Protocol (UDP) traffic. Additionally, LLARP opts for packet-switched based routing instead of tunnel-based routing, allowing for better load balancing and redundancy across the network. End users of Lokinet are not expected (or even allowed) to route packets, this means that Lokinet exposes itself to a much lower attack surface for a Sybil attack due to the significant capital outlay required to begin Service Nodes operation.","title":"Low Latency Anonymous Routing Protocol (LLARP)"},{"location":"Lokinet/LLARP/#the-onion-router-tor","text":"In recent years, Tor has been the most popular anonymous mixnet. The Tor network maintains a high-level of censorship resistance and has proved a valuable tool for preserving internet privacy. However,Tor is not a decentralised network as much as it is a hierarchical one. Tor is reliant on a group of directory authorities which are centralised servers operated by a group of volunteers close to the Tor Foundation . These directory authorities perform two main functions. Firstly, they act as trusted reporters on the state of nodes in the network. When a Tor user (or relay) connects to the network for the first time they can connect to one of ten hard-coded directory authorities. These directory authorities provide the user or relay with a file called the consensus. This file provides a list of all of the relays, guard nodes, and exit nodes currently in operation (excluding bridges) on the Tor network. Secondly, the directory authorities also measure the bandwidth that each relay can provide to the network. They use this information to triage relays into categories, deciding whether nodes can operate as relays, guard nodes, or exit nodes.","title":"The Onion Router (Tor)"},{"location":"Lokinet/LLARP/#tor-has-potential-problems-with-centralisation","text":"This high level of centralisation creates points of failure that leaves Tor vulnerable. In 2014, Tor received information of a credible threat to take down the directory authority servers . If the directory authorities in the United States and either Germany or the Netherlands were to be shut down, that would be enough to shut down five of the ten directory authority servers. This would result in a highly unstable Tor network, with new relays being greatly diminished in their ability to interact with the network. Methods of communication in Tor are also limited, as Tor only allows communication overTCP. IP over Tor is possible, but it lacks support for UDP based protocols (such as VoIP).","title":"Tor has potential problems with Centralisation"},{"location":"Lokinet/LLARP/#invisible-internet-project-i2p","text":"I2P takes a different approach to mixnet architecture, maintaining a higher level of trust agility by referring to a Distributed Hashing Table (DHT) to ascertain the network state instead of trusted directory authorities [15]. I2P also allows for both TCP and UDP traffic, supporting a larger scope of protocol interactions. However, I2P has not had a steady development process and over time it has accumulated technical debt, specifically in its cryptography usage. I2P uses 2048 bit ElGamal, which makes encryption and decryption slow in contrast to elliptic curve operations. While plans to migrate away from ElGamal exist in the I2P roadmap, progress has been slow.","title":"Invisible Internet Project (I2P)"},{"location":"Lokinet/LLARP/#i2p-has-a-lack-of-formal-exit-node-support","text":"Additionally, I2P lacks formal support for exit nodes , meaning the majority of traffic on the network is accessing internally hosted websites, called Eepsites. This has greatly reduced the ability for the I2P network to reach users whose main purpose for using anonymising networks is to access the wider internet. Furthermore, the manner in which I2P is built means that the majority of users that connect to the network also become routers, which is problematic as the resulting network often lacks sufficient bandwidth to be able to build fast paths. Network speeds in mixnets are bottlenecked by the least capable node in each circuit, and as a result of low-performance users becoming relays in I2P, a reduction in overall performance is seen.","title":"I2P has a lack of formal exit node support."},{"location":"Lokinet/LLARP/#how-does-tor-compare-with-i2p","text":"Finally, I2P differs from Tor in that it offers a packet-switched (rather than circuit-switched) network. Instead of establishing a single longer-term tunnel which all traffic travels through, I2P establishes multiple paths that each packet being communicated can use to use to take a different route through the network. This gives I2P the ability to transparently route around network congestion and node failures.","title":"How does Tor compare with I2P"},{"location":"Lokinet/LLARP/#cheap-node-attack","text":"Both I2P and Tor have not fully mitigated Sybil attacks. A sufficiently motivated attacker that has enough time and capital to buy large amounts of relays can perform temporal analysis which undermines user privacy. The effectiveness of this analysis increases the more exit nodes, relays and guard nodes the attacker operates . Tor and I2P are operated entirely by volunteers that donate both their time and money to the operation of nodes. We surmise that a network constructed from financial incentives rather than altruism can achieve a greater resilience against attacks, while providing a more reliable service.","title":"Cheap Node Attack"},{"location":"Lokinet/LokinetOverview/","text":"Lokinet Overview \u00b6 Service Nodes on the Loki network will operate a low latency onion routing protocol , forming a fully decentralised overlay network, called Lokinet. Onion routing protocols allow for users to form tunnels or paths through a distributed network, using multiple nodes as hops to obfuscate the destination and origin of data packets. The network does not rely on trusted authorities and its state is fully derived from the blockchain. Users can connect to individual Service Nodes and create bidirectional paths for packets to be routed through. The network can be used to access internally hosted services called SNApps . Users can utilise Service Nodes exit functionality to browse the external internet without their IP address being exposed. Guides & Resources \u00b6 Guide/Resource Description Linux Gui Guide Easiest way to access Lokinet and SNApps on Linux. macOS Gui Guide Easiest way to access Lokinet and SNApps on macOS. Anonymous Reverse SSH Guide Simple and easy way to SSH into a VPS through lokinet. Lokinet Public Testing Guide Full Lokinet public testing guide. Linux Setup Guide Linux preperation for accessing Lokinet. Linux - Build it yourself How to build Lokinet from source. Accessing SNApps How to access SNApps. Joining a Lokinet IRC Connect to an IRC chat over Lokinet. Hosting SNApps Host your own SNApp/Hidden Service. LLARP Github LLARP (low latency anonymous routing protocol), a layer 3 onion routing protocol. Setting up a Lokinet Router/Relay How to host a relay on the test network. Lokinet config files This guide shows the different config files and their associated sections, keys and values.","title":"Overview"},{"location":"Lokinet/LokinetOverview/#lokinet-overview","text":"Service Nodes on the Loki network will operate a low latency onion routing protocol , forming a fully decentralised overlay network, called Lokinet. Onion routing protocols allow for users to form tunnels or paths through a distributed network, using multiple nodes as hops to obfuscate the destination and origin of data packets. The network does not rely on trusted authorities and its state is fully derived from the blockchain. Users can connect to individual Service Nodes and create bidirectional paths for packets to be routed through. The network can be used to access internally hosted services called SNApps . Users can utilise Service Nodes exit functionality to browse the external internet without their IP address being exposed.","title":"Lokinet Overview"},{"location":"Lokinet/LokinetOverview/#guides-resources","text":"Guide/Resource Description Linux Gui Guide Easiest way to access Lokinet and SNApps on Linux. macOS Gui Guide Easiest way to access Lokinet and SNApps on macOS. Anonymous Reverse SSH Guide Simple and easy way to SSH into a VPS through lokinet. Lokinet Public Testing Guide Full Lokinet public testing guide. Linux Setup Guide Linux preperation for accessing Lokinet. Linux - Build it yourself How to build Lokinet from source. Accessing SNApps How to access SNApps. Joining a Lokinet IRC Connect to an IRC chat over Lokinet. Hosting SNApps Host your own SNApp/Hidden Service. LLARP Github LLARP (low latency anonymous routing protocol), a layer 3 onion routing protocol. Setting up a Lokinet Router/Relay How to host a relay on the test network. Lokinet config files This guide shows the different config files and their associated sections, keys and values.","title":"Guides &amp; Resources"},{"location":"Lokinet/SNApps/","text":"SNApps \u00b6 The function of SNApps is similar to so-called hidden services in Tor which have flourished. They provide users with a way to interact fully within the onion router environment, providing an even higher-degree of anonymity than can be achieved when accessing externally hosted content. SNApps allow for users to setup and host marketplaces, forums, whistle-blowing websites, social media, and most other internet applications on their own machines or servers while maintaining full-server and user-side anonymity. This greatly expands the scope of the network and allows users to build meaningful communities within Lokinet. SNApp operators use the traditional server-client model with the key difference being that Service Nodes will be intermediaries in a users connection through Lokinet. When a SNApp wishes to register on the network, it must update the DHT with its descriptor. This descriptor contains various introducers, which are specific Service Nodes that users can contact to form a path to the SNApp. When these paths are set up, users can connect to the SNApp without either party knowing where the other is located in the network. Guides & Resources \u00b6 Guide/Resource Description Accessing SNApps How to access SNApps. Setting Up a Lokinet Router/Relay How to host a relay on the test network. Joining a Lokinet IRC Connect to an IRC chat over Lokinet. Hosting SNApps Host your own SNApp/Hidden Service. LLARP Github LLARP (low latency anonymous routing protocol), a layer 3 onion routing protocol. Lokinet config files This guide shows the different config files and their associated sections, keys and values.","title":"SNApps"},{"location":"Lokinet/SNApps/#snapps","text":"The function of SNApps is similar to so-called hidden services in Tor which have flourished. They provide users with a way to interact fully within the onion router environment, providing an even higher-degree of anonymity than can be achieved when accessing externally hosted content. SNApps allow for users to setup and host marketplaces, forums, whistle-blowing websites, social media, and most other internet applications on their own machines or servers while maintaining full-server and user-side anonymity. This greatly expands the scope of the network and allows users to build meaningful communities within Lokinet. SNApp operators use the traditional server-client model with the key difference being that Service Nodes will be intermediaries in a users connection through Lokinet. When a SNApp wishes to register on the network, it must update the DHT with its descriptor. This descriptor contains various introducers, which are specific Service Nodes that users can contact to form a path to the SNApp. When these paths are set up, users can connect to the SNApp without either party knowing where the other is located in the network.","title":"SNApps"},{"location":"Lokinet/SNApps/#guides-resources","text":"Guide/Resource Description Accessing SNApps How to access SNApps. Setting Up a Lokinet Router/Relay How to host a relay on the test network. Joining a Lokinet IRC Connect to an IRC chat over Lokinet. Hosting SNApps Host your own SNApp/Hidden Service. LLARP Github LLARP (low latency anonymous routing protocol), a layer 3 onion routing protocol. Lokinet config files This guide shows the different config files and their associated sections, keys and values.","title":"Guides &amp; Resources"},{"location":"Lokinet/Guides/AccessingSNApps/","text":"LokiNET SNApps/ Hidden Service Setup Guide \u00b6 The function of SNApps is similar to so-called hidden services in Tor which have flourished. They provide users with a way to interact fully within the onion router environment, providing an even higher-degree of anonymity than can be achieved when accessing externally hosted content. SNApps allow for users to setup and host marketplaces, forums, whistle-blowing websites, social media, and most other internet applications on their own machines or servers while maintaining full-server and user-side anonymity. This greatly expands the scope of the network and allows users to build meaningful communities within Lokinet . SNApp operators use the traditional server-client model with the key difference being that Service Nodes will be intermediaries in a users connection through Lokinet. When a SNApp wishes to register on the network, it must update the DHT with its descriptor. This descriptor contains various introducers, which are specific Service Nodes that users can contact to form a path to the SNApp. When these paths are set up, users can connect to the SNApp without either party knowing where the other is located in the network. 1. Installing \u00b6 To install lokinet, see the install guide here . 2. Test services \u00b6 Jump onto a browser such as google chrome or firefox and try and go to one of the following SNApps: Lokinet Wiki http://dw68y1xhptqbhcm5s8aaaip6dbopykagig5q5u1za4c7pzxto77y.loki/wiki/ Congratulations, you now have access to the Lokinet. Finish \u00b6 Well done, you have finished the guide. Jump back into the Lokinet Public Testing Guide here .","title":"Accessing SNApps"},{"location":"Lokinet/Guides/AccessingSNApps/#lokinet-snapps-hidden-service-setup-guide","text":"The function of SNApps is similar to so-called hidden services in Tor which have flourished. They provide users with a way to interact fully within the onion router environment, providing an even higher-degree of anonymity than can be achieved when accessing externally hosted content. SNApps allow for users to setup and host marketplaces, forums, whistle-blowing websites, social media, and most other internet applications on their own machines or servers while maintaining full-server and user-side anonymity. This greatly expands the scope of the network and allows users to build meaningful communities within Lokinet . SNApp operators use the traditional server-client model with the key difference being that Service Nodes will be intermediaries in a users connection through Lokinet. When a SNApp wishes to register on the network, it must update the DHT with its descriptor. This descriptor contains various introducers, which are specific Service Nodes that users can contact to form a path to the SNApp. When these paths are set up, users can connect to the SNApp without either party knowing where the other is located in the network.","title":"LokiNET SNApps/ Hidden Service Setup Guide"},{"location":"Lokinet/Guides/AccessingSNApps/#1-installing","text":"To install lokinet, see the install guide here .","title":"1. Installing"},{"location":"Lokinet/Guides/AccessingSNApps/#2-test-services","text":"Jump onto a browser such as google chrome or firefox and try and go to one of the following SNApps: Lokinet Wiki http://dw68y1xhptqbhcm5s8aaaip6dbopykagig5q5u1za4c7pzxto77y.loki/wiki/ Congratulations, you now have access to the Lokinet.","title":"2. Test services"},{"location":"Lokinet/Guides/AccessingSNApps/#finish","text":"Well done, you have finished the guide. Jump back into the Lokinet Public Testing Guide here .","title":"Finish"},{"location":"Lokinet/Guides/ExitNode/","text":"LokiNET Exit Node Guide \u00b6 Exit nodes allow users to make requests to the wider internet and return those requests through a mixnet or onion router. If used correctly, exit nodes allow users to browse the internet privately and without the users IP address being exposed to the server. Client \u00b6 Lokinet clients can use exit nodes without the need to host a service node. Configuration \u00b6 To use an exit node as a client, add the following option to the [network] section in lokinet.ini exit-node=exitnodehexpublickeygoeshere strict-connect=firsthophexpublickeygoeshere This sets to use an exit node by its public identity key and sets a strict first hop by its public identity key. We set a strict first hope so that we can easily set up the routing table. Toynet exit public key list by region: \u00b6 Romania: b61df944b8547af56201c6c7528ed86289566dcf73358c5ef8e3b4e628671399 Toynet first hop public key list with IP \u00b6 8df8ca1cc9d39d381f0efafdf58e2569457675a1e543189bea8279522aee6461 167.114.185.46 3dcb5a34d015a7bbb4636be83991e00cbeff13fe7834e0d5452ffe9a5af5a5be 162.243.164.223 Set up routes \u00b6 In this example your first hop is at 162.243.164.223 and your network's default gateway is 192.168.0.1 Windows \u00b6 // TODO: document me OS X \u00b6 // TODO: document me Linux \u00b6 Set the route that routes everything over lokinet do the following as root: # ip route add 162.243.164.223 via 192.168.0.1 # ip route del default # ip route add default dev lokitun0 To unset the route everything over lokinet route do the following as root: # ip route del default # ip route add default via 192.168.0.1 Prequesites \u00b6 // TODO: technical prequesites goes here Technical \u00b6 // TODO: technical overview about exit nodes Bandwidth \u00b6 // TODO: notes about bandwidth OS Limits (?) \u00b6 // TODO: talk about OS level limits for IPv4 exits // TODO: talk about ipv6 exit requirements, i.e. a /120 to /64 Legal \u00b6 Running a Lokinet Exit node simply means that you are requesting and relaying packets of data on someone else's behalf, a vast majority of the traffic in mixnets and onion routers comprised of legal and non malicious traffic. Statically over the course of running a Service Node you are likely to run into a few users who abuse their anonymity to send or receive information that may be explicitly malicious, therefor it is important that we discuss the legal implications of this malicious traffic. In most countries Exit nodes are viewed in much the same way as ISP's are, that is that they are usually classed as data transmitters, which makes them exempt from criminal or civil liability based on the data they transmit. This means they are also covered by exceptions in the EUCD and DMCA laws which stipulate content regulation on the internet in the US and Europe respectively. Despite this its important to consider that unlike ISP's exit node operators usually do not have large legal teams and a budget to fight prosecutions in court. Although a legal suit has never been brought against a Tor exit node operator, these are risks that each operator must control for. For this reason you should always check the laws of the relevant country you are operating your Service Node out of. If you run into legal challenges we recommend contacting the EFF who may be interested in hearing a case of Exit Node prosecution. Although all relevant information, it still stands as likely the most contact you are going to receive as you run an exit node is with your ISP or VPS provider who is likely to forward DMCA takedown notices, or abuse requests to the email address you used to sign up with. Disclaimer \u00b6 The Loki foundation or the writers of this guide are not responsible for any legal implications you may face because you operate a Loki Service Node. Email Templates \u00b6 If you decided to run a Service Node with exit functionality there are a couple of common abuse emails you will run into, so its a good idea to reduce the time spent answering emails to use some available templates. Copyright infringement Email Response \u00b6 European ISP Dear [ISP]: Thank you for forwarding me the notice you received from [copyright claimant] regarding [content]. I would like to assure you that I am not hosting the claimed infringing materials, and furthermore, both the Digital Millennium Copyright Act's (\"DMCA\") and the European Union Copyright Directive (\u201cEUCD\u201d) safe harbors likely protect you from liability arising from this complaint. The notice is likely based upon misunderstandings about the law and about some of the software I run. As you may know as part of the European Union Copyright Directive exceptions are provided per Article 5, these exceptions are mandatory for each member state. These exceptions allow for \u201cTemporary acts of reproduction referred to in Article 2, which are transient or incidental [and] an integral and essential part of a technological process and whose sole purpose is to enable: a transmission in a network between third parties by an intermediary\u201d. These Laws protect both Internet Service providers and similar intermediaries who simply relay traffic. The notification you received is certainly not proof of any copyright infringement; a notice claiming infringement is not the same as a determination of infringement. I have not infringed any copyrights and do not intend to do so. Therefore, you should continue to be protected under the EUCD Article 5 without taking any further action. You may be curious about what prompted the faulty notice. It was likely triggered by a program I run called Lokinet. Lokinet is a software that helps users to enhance their privacy, security, and safety online. It does not host any content. Rather, it is part of a network of nodes called Service Nodes that operate on the Internet and simply pass packets among themselves before sending them to their destinations, just as any Internet intermediary does. The difference is that Lokinet tunnels the connections such that no hop can learn both the source and destination of the packets, giving users protection from nefarious snooping on network traffic. The result is that, unlike most other Internet traffic, the final IP address that the recipient receives is not the IP address of the sender. Lokinet protects users against hazards such as harassment, spam, and identity theft. The Lokinet software is developed by the Loki foundation a non for profit organization, and run by community Service Node operators. I hope, as an organization committed to protecting the privacy of its customers, you'll agree that this is a valuable technology. Thank you for working with me on this matter. As a loyal subscriber, I appreciate your notifying me of this issue and hope that the protections of DMCA 512 put any concerns you may have to rest. If not, please contact me with any further questions. Very truly yours, Your customer, [User] American ISP Dear [ISP]: Thank you for forwarding me the notice you received from [copyright claimant] regarding [content]. I would like to assure you that I am not hosting the claimed infringing materials, and furthermore, the Digital Millennium Copyright Act's (\"DMCA\") safe harbors likely protect you from liability arising from this complaint. The notice is likely based upon misunderstandings about the law and about some of the software I run. As you know, the DMCA creates four \"safe harbors\" for service providers to protect them from copyright liability for the acts of their users, when the ISPs fulfill certain requirements. (17 U.S.C. \u00a7 512) The DMCA's requirements vary depending on the ISP's role. You may be familiar with the \"notice and takedown\" provisions of section 512(c) of the DMCA; however, those do not apply when an ISP merely acts as a conduit. Instead, the \"conduit\" safe harbor of section 512(a) of the DMCA has different and less burdensome eligibility requirements, as the D.C. Circuit Court of Appeals held in RIAA v. Verizon (see https://www.eff.org/sites/default/files/filenode/RIAA_v_Verizon/20030121-riaa-v-verizon-order.pdf) and the Eighth Circuit Court of Appeals confirmed in RIAA v. Charter (see https://w2.eff.org/IP/P2P/Charter/033802P.pdf). Under DMCA 512(a), service providers like you are typically protected from damages for copyright infringement claims if you also maintain \"a policy that provides for termination in appropriate circumstances of subscribers and account holders of the service provider's system or network who are repeat infringers.\" If you have and implement such a policy, and you otherwise qualify for the safe harbor, you should be free from fear of copyright damages. As for what makes a reasonable policy, as the law says, it's one that terminates subscribers who are repeat infringers. The notification you received is certainly not proof of the \"repeat infringement\" that is required under the law before you need to terminate my account. In fact, it's not even proof of any copyright infringement; a notice claiming infringement is not the same as a determination of infringement. I have not infringed any copyrights and do not intend to do so. Therefore, you should continue to be protected under the DMCA 512(a) safe harbor without taking any further action. You may be curious about what prompted the faulty notice. It was likely triggered by a program I run called Lokinet. Lokinet is a software that helps users to enhance their privacy, security, and safety online. It does not host any content. Rather, it is part of a network of nodes called Service Nodes that operate on the Internet and simply pass packets among themselves before sending them to their destinations, just as any Internet intermediary does. The difference is that Lokinet tunnels the connections such that no hop can learn both the source and destination of the packets, giving users protection from nefarious snooping on network traffic. The result is that, unlike most other Internet traffic, the final IP address that the recipient receives is not the IP address of the sender. Lokinet protects users against hazards such as harassment, spam, and identity theft. The Lokinet software is developed by the Loki foundation a non for profit organization, and run by community Service Node operators. I hope, as an organization committed to protecting the privacy of its customers, you'll agree that this is a valuable technology. Thank you for working with me on this matter. As a loyal subscriber, I appreciate your notifying me of this issue and hope that the protections of DMCA 512 put any concerns you may have to rest. If not, please contact me with any further questions.``` Very truly yours, Your customer, [User] General Statement The IP address in question is a Loki exit node. https://www.torproject.org/overview.html There is little we can do to trace this matter further. As can be seen from the overview page, Lokinet is designed to make tracing of users impossible. The Loki network is run by hundreds of node operators who use the free software provided by the Loki Foundation to operate Lokinet routers and exit nodes. Client connections are routed through multiple relays, and are multiplexed together on the connections between relays. The system does not record logs of client connections or previous hops. This is because Lokinet is a censorship resistance, privacy, and anonymity system it can be used by whistle blowers, journalists, abuse victims, stalker Targets, law enforcement, just to name a few. Unfortunately, some people misuse the network. However, compared to the rate of legitimate use the fraction of misuse is small and abuse complaints are rare. however because of the nature of anonymity networks little can be done to trace the origin of these malicious users. //TODO: Add additional templates once DNSRBL is added Best Practices \u00b6 // TODO: insert best practices here // TODO: abuse complaints // TODO: Automated DMCA Spam Notices // TODO: traffic shaping (?) // TODO: ipv6 implications Worst Case Emergencies \u00b6 // TODO: link to EFF resources // TODO: insert info about handling police here // TODO: don't talk to the police video goes here","title":"Exit Nodes"},{"location":"Lokinet/Guides/ExitNode/#lokinet-exit-node-guide","text":"Exit nodes allow users to make requests to the wider internet and return those requests through a mixnet or onion router. If used correctly, exit nodes allow users to browse the internet privately and without the users IP address being exposed to the server.","title":"LokiNET Exit Node Guide"},{"location":"Lokinet/Guides/ExitNode/#client","text":"Lokinet clients can use exit nodes without the need to host a service node.","title":"Client"},{"location":"Lokinet/Guides/ExitNode/#configuration","text":"To use an exit node as a client, add the following option to the [network] section in lokinet.ini exit-node=exitnodehexpublickeygoeshere strict-connect=firsthophexpublickeygoeshere This sets to use an exit node by its public identity key and sets a strict first hop by its public identity key. We set a strict first hope so that we can easily set up the routing table.","title":"Configuration"},{"location":"Lokinet/Guides/ExitNode/#toynet-exit-public-key-list-by-region","text":"Romania: b61df944b8547af56201c6c7528ed86289566dcf73358c5ef8e3b4e628671399","title":"Toynet exit public key list by region:"},{"location":"Lokinet/Guides/ExitNode/#toynet-first-hop-public-key-list-with-ip","text":"8df8ca1cc9d39d381f0efafdf58e2569457675a1e543189bea8279522aee6461 167.114.185.46 3dcb5a34d015a7bbb4636be83991e00cbeff13fe7834e0d5452ffe9a5af5a5be 162.243.164.223","title":"Toynet first hop public key list with IP"},{"location":"Lokinet/Guides/ExitNode/#set-up-routes","text":"In this example your first hop is at 162.243.164.223 and your network's default gateway is 192.168.0.1","title":"Set up routes"},{"location":"Lokinet/Guides/ExitNode/#windows","text":"// TODO: document me","title":"Windows"},{"location":"Lokinet/Guides/ExitNode/#os-x","text":"// TODO: document me","title":"OS X"},{"location":"Lokinet/Guides/ExitNode/#linux","text":"Set the route that routes everything over lokinet do the following as root: # ip route add 162.243.164.223 via 192.168.0.1 # ip route del default # ip route add default dev lokitun0 To unset the route everything over lokinet route do the following as root: # ip route del default # ip route add default via 192.168.0.1","title":"Linux"},{"location":"Lokinet/Guides/ExitNode/#prequesites","text":"// TODO: technical prequesites goes here","title":"Prequesites"},{"location":"Lokinet/Guides/ExitNode/#technical","text":"// TODO: technical overview about exit nodes","title":"Technical"},{"location":"Lokinet/Guides/ExitNode/#bandwidth","text":"// TODO: notes about bandwidth","title":"Bandwidth"},{"location":"Lokinet/Guides/ExitNode/#os-limits","text":"// TODO: talk about OS level limits for IPv4 exits // TODO: talk about ipv6 exit requirements, i.e. a /120 to /64","title":"OS Limits (?)"},{"location":"Lokinet/Guides/ExitNode/#legal","text":"Running a Lokinet Exit node simply means that you are requesting and relaying packets of data on someone else's behalf, a vast majority of the traffic in mixnets and onion routers comprised of legal and non malicious traffic. Statically over the course of running a Service Node you are likely to run into a few users who abuse their anonymity to send or receive information that may be explicitly malicious, therefor it is important that we discuss the legal implications of this malicious traffic. In most countries Exit nodes are viewed in much the same way as ISP's are, that is that they are usually classed as data transmitters, which makes them exempt from criminal or civil liability based on the data they transmit. This means they are also covered by exceptions in the EUCD and DMCA laws which stipulate content regulation on the internet in the US and Europe respectively. Despite this its important to consider that unlike ISP's exit node operators usually do not have large legal teams and a budget to fight prosecutions in court. Although a legal suit has never been brought against a Tor exit node operator, these are risks that each operator must control for. For this reason you should always check the laws of the relevant country you are operating your Service Node out of. If you run into legal challenges we recommend contacting the EFF who may be interested in hearing a case of Exit Node prosecution. Although all relevant information, it still stands as likely the most contact you are going to receive as you run an exit node is with your ISP or VPS provider who is likely to forward DMCA takedown notices, or abuse requests to the email address you used to sign up with.","title":"Legal"},{"location":"Lokinet/Guides/ExitNode/#disclaimer","text":"The Loki foundation or the writers of this guide are not responsible for any legal implications you may face because you operate a Loki Service Node.","title":"Disclaimer"},{"location":"Lokinet/Guides/ExitNode/#email-templates","text":"If you decided to run a Service Node with exit functionality there are a couple of common abuse emails you will run into, so its a good idea to reduce the time spent answering emails to use some available templates.","title":"Email Templates"},{"location":"Lokinet/Guides/ExitNode/#copyright-infringement-email-response","text":"European ISP Dear [ISP]: Thank you for forwarding me the notice you received from [copyright claimant] regarding [content]. I would like to assure you that I am not hosting the claimed infringing materials, and furthermore, both the Digital Millennium Copyright Act's (\"DMCA\") and the European Union Copyright Directive (\u201cEUCD\u201d) safe harbors likely protect you from liability arising from this complaint. The notice is likely based upon misunderstandings about the law and about some of the software I run. As you may know as part of the European Union Copyright Directive exceptions are provided per Article 5, these exceptions are mandatory for each member state. These exceptions allow for \u201cTemporary acts of reproduction referred to in Article 2, which are transient or incidental [and] an integral and essential part of a technological process and whose sole purpose is to enable: a transmission in a network between third parties by an intermediary\u201d. These Laws protect both Internet Service providers and similar intermediaries who simply relay traffic. The notification you received is certainly not proof of any copyright infringement; a notice claiming infringement is not the same as a determination of infringement. I have not infringed any copyrights and do not intend to do so. Therefore, you should continue to be protected under the EUCD Article 5 without taking any further action. You may be curious about what prompted the faulty notice. It was likely triggered by a program I run called Lokinet. Lokinet is a software that helps users to enhance their privacy, security, and safety online. It does not host any content. Rather, it is part of a network of nodes called Service Nodes that operate on the Internet and simply pass packets among themselves before sending them to their destinations, just as any Internet intermediary does. The difference is that Lokinet tunnels the connections such that no hop can learn both the source and destination of the packets, giving users protection from nefarious snooping on network traffic. The result is that, unlike most other Internet traffic, the final IP address that the recipient receives is not the IP address of the sender. Lokinet protects users against hazards such as harassment, spam, and identity theft. The Lokinet software is developed by the Loki foundation a non for profit organization, and run by community Service Node operators. I hope, as an organization committed to protecting the privacy of its customers, you'll agree that this is a valuable technology. Thank you for working with me on this matter. As a loyal subscriber, I appreciate your notifying me of this issue and hope that the protections of DMCA 512 put any concerns you may have to rest. If not, please contact me with any further questions. Very truly yours, Your customer, [User] American ISP Dear [ISP]: Thank you for forwarding me the notice you received from [copyright claimant] regarding [content]. I would like to assure you that I am not hosting the claimed infringing materials, and furthermore, the Digital Millennium Copyright Act's (\"DMCA\") safe harbors likely protect you from liability arising from this complaint. The notice is likely based upon misunderstandings about the law and about some of the software I run. As you know, the DMCA creates four \"safe harbors\" for service providers to protect them from copyright liability for the acts of their users, when the ISPs fulfill certain requirements. (17 U.S.C. \u00a7 512) The DMCA's requirements vary depending on the ISP's role. You may be familiar with the \"notice and takedown\" provisions of section 512(c) of the DMCA; however, those do not apply when an ISP merely acts as a conduit. Instead, the \"conduit\" safe harbor of section 512(a) of the DMCA has different and less burdensome eligibility requirements, as the D.C. Circuit Court of Appeals held in RIAA v. Verizon (see https://www.eff.org/sites/default/files/filenode/RIAA_v_Verizon/20030121-riaa-v-verizon-order.pdf) and the Eighth Circuit Court of Appeals confirmed in RIAA v. Charter (see https://w2.eff.org/IP/P2P/Charter/033802P.pdf). Under DMCA 512(a), service providers like you are typically protected from damages for copyright infringement claims if you also maintain \"a policy that provides for termination in appropriate circumstances of subscribers and account holders of the service provider's system or network who are repeat infringers.\" If you have and implement such a policy, and you otherwise qualify for the safe harbor, you should be free from fear of copyright damages. As for what makes a reasonable policy, as the law says, it's one that terminates subscribers who are repeat infringers. The notification you received is certainly not proof of the \"repeat infringement\" that is required under the law before you need to terminate my account. In fact, it's not even proof of any copyright infringement; a notice claiming infringement is not the same as a determination of infringement. I have not infringed any copyrights and do not intend to do so. Therefore, you should continue to be protected under the DMCA 512(a) safe harbor without taking any further action. You may be curious about what prompted the faulty notice. It was likely triggered by a program I run called Lokinet. Lokinet is a software that helps users to enhance their privacy, security, and safety online. It does not host any content. Rather, it is part of a network of nodes called Service Nodes that operate on the Internet and simply pass packets among themselves before sending them to their destinations, just as any Internet intermediary does. The difference is that Lokinet tunnels the connections such that no hop can learn both the source and destination of the packets, giving users protection from nefarious snooping on network traffic. The result is that, unlike most other Internet traffic, the final IP address that the recipient receives is not the IP address of the sender. Lokinet protects users against hazards such as harassment, spam, and identity theft. The Lokinet software is developed by the Loki foundation a non for profit organization, and run by community Service Node operators. I hope, as an organization committed to protecting the privacy of its customers, you'll agree that this is a valuable technology. Thank you for working with me on this matter. As a loyal subscriber, I appreciate your notifying me of this issue and hope that the protections of DMCA 512 put any concerns you may have to rest. If not, please contact me with any further questions.``` Very truly yours, Your customer, [User] General Statement The IP address in question is a Loki exit node. https://www.torproject.org/overview.html There is little we can do to trace this matter further. As can be seen from the overview page, Lokinet is designed to make tracing of users impossible. The Loki network is run by hundreds of node operators who use the free software provided by the Loki Foundation to operate Lokinet routers and exit nodes. Client connections are routed through multiple relays, and are multiplexed together on the connections between relays. The system does not record logs of client connections or previous hops. This is because Lokinet is a censorship resistance, privacy, and anonymity system it can be used by whistle blowers, journalists, abuse victims, stalker Targets, law enforcement, just to name a few. Unfortunately, some people misuse the network. However, compared to the rate of legitimate use the fraction of misuse is small and abuse complaints are rare. however because of the nature of anonymity networks little can be done to trace the origin of these malicious users. //TODO: Add additional templates once DNSRBL is added","title":"Copyright infringement Email Response"},{"location":"Lokinet/Guides/ExitNode/#best-practices","text":"// TODO: insert best practices here // TODO: abuse complaints // TODO: Automated DMCA Spam Notices // TODO: traffic shaping (?) // TODO: ipv6 implications","title":"Best Practices"},{"location":"Lokinet/Guides/ExitNode/#worst-case-emergencies","text":"// TODO: link to EFF resources // TODO: insert info about handling police here // TODO: don't talk to the police video goes here","title":"Worst Case Emergencies"},{"location":"Lokinet/Guides/HostingSNApps/","text":"Hosting a SNApp \u00b6 1. Preparing your lokinet address \u00b6 Depending on your desired outcome you may want to only run a one time SNApp or a SNApp that continues to persistently use the same .loki pubkey. 1.1 Temporary SNApp \u00b6 A temporary SNApp is a hidden service on lokinet that does not have a permanent public key. This means that the public key we supply to others will not work once the server that is hosting the SNApp is restarted. This SNapp will require no additional setup. You can continue to step 2 if you only want to host a temporary SNApp. 1.2 Persistent SNApp \u00b6 Open up your lokinet.ini file and add a path to where your SNApp key files will be stored. If you have built Lokinet from the Deb packages you will find your lokinet.ini file with the following command: sudo nano /etc/loki/lokinet.ini Otherwise, if you have built Lokinet from source your lokinet.ini file will be in the following folder: ~/.lokinet/lokinet.ini Scroll down to your [network] section and add the following line: keyfile=/var/lib/lokinet/snappkey.private Replacing <user> with your computer username, alternatively you can set the filepath to wherever you want your SNApp private key to be stored. Now when you restart lokinet it will generate your snappkey.private file in the directory you have set. sudo systemctl restart lokinet 2. Finding your SNApps lokinet address. \u00b6 You can find your current snapp address using a host lookup tool: nslookup -type=cname localhost.loki 127.0.0.1 on linux you can use host , the loki address to query is the same but the resolver uses the address 127.3.2.1 as to not conflict with other resolvers you may have installed. host -t cname localhost.loki 127.3.2.1 3. Creating your SNApp \u00b6 Create a new directory within your home folder by running the following command in a terminal: mkdir ~/snapp/ Create an index file within your new folder. touch ~/snapp/index.html This file will hold the content of what will be served on your SNApp. Run the following command to access your new index.html file. vi ~/snapp/index.html Click a to start adding text to your index.html file. Type out Hello Lokinet and click the escape button. Once the escape button is clicked it will allow for commands to be inputed again. Now type :w and click enter to write to the file. Then type :q and click enter to quit editing the file, this will take you back to the directory you were in before ~/snapp/ . 4. Serving your SNApp \u00b6 Now we will serve our index.html file to the lokinet by running the following command within our snapp folder. sudo python3 -m http.server --bind <ip> <port> For this example our pubkey is set to lokitun0 which has address 172.16.10.1 . The <port> number can be whatever we define it. Therefor the command we would run for this example would be: sudo python3 -m http.server --bind 172.16.10.1 80 Now if you go to the .loki address you saved before your message \u201chello lokinet\u201d will be displayed. Jump onto the lokinet irc and see if others can access your SNApp. Finish \u00b6 Well done, you have finished the guide. Jump back into the Lokinet Public Testing Guide here .","title":"Hosting SNApps"},{"location":"Lokinet/Guides/HostingSNApps/#hosting-a-snapp","text":"","title":"Hosting a SNApp"},{"location":"Lokinet/Guides/HostingSNApps/#1-preparing-your-lokinet-address","text":"Depending on your desired outcome you may want to only run a one time SNApp or a SNApp that continues to persistently use the same .loki pubkey.","title":"1. Preparing your lokinet address"},{"location":"Lokinet/Guides/HostingSNApps/#11-temporary-snapp","text":"A temporary SNApp is a hidden service on lokinet that does not have a permanent public key. This means that the public key we supply to others will not work once the server that is hosting the SNApp is restarted. This SNapp will require no additional setup. You can continue to step 2 if you only want to host a temporary SNApp.","title":"1.1 Temporary SNApp"},{"location":"Lokinet/Guides/HostingSNApps/#12-persistent-snapp","text":"Open up your lokinet.ini file and add a path to where your SNApp key files will be stored. If you have built Lokinet from the Deb packages you will find your lokinet.ini file with the following command: sudo nano /etc/loki/lokinet.ini Otherwise, if you have built Lokinet from source your lokinet.ini file will be in the following folder: ~/.lokinet/lokinet.ini Scroll down to your [network] section and add the following line: keyfile=/var/lib/lokinet/snappkey.private Replacing <user> with your computer username, alternatively you can set the filepath to wherever you want your SNApp private key to be stored. Now when you restart lokinet it will generate your snappkey.private file in the directory you have set. sudo systemctl restart lokinet","title":"1.2 Persistent SNApp"},{"location":"Lokinet/Guides/HostingSNApps/#2-finding-your-snapps-lokinet-address","text":"You can find your current snapp address using a host lookup tool: nslookup -type=cname localhost.loki 127.0.0.1 on linux you can use host , the loki address to query is the same but the resolver uses the address 127.3.2.1 as to not conflict with other resolvers you may have installed. host -t cname localhost.loki 127.3.2.1","title":"2. Finding your SNApps lokinet address."},{"location":"Lokinet/Guides/HostingSNApps/#3-creating-your-snapp","text":"Create a new directory within your home folder by running the following command in a terminal: mkdir ~/snapp/ Create an index file within your new folder. touch ~/snapp/index.html This file will hold the content of what will be served on your SNApp. Run the following command to access your new index.html file. vi ~/snapp/index.html Click a to start adding text to your index.html file. Type out Hello Lokinet and click the escape button. Once the escape button is clicked it will allow for commands to be inputed again. Now type :w and click enter to write to the file. Then type :q and click enter to quit editing the file, this will take you back to the directory you were in before ~/snapp/ .","title":"3. Creating your SNApp"},{"location":"Lokinet/Guides/HostingSNApps/#4-serving-your-snapp","text":"Now we will serve our index.html file to the lokinet by running the following command within our snapp folder. sudo python3 -m http.server --bind <ip> <port> For this example our pubkey is set to lokitun0 which has address 172.16.10.1 . The <port> number can be whatever we define it. Therefor the command we would run for this example would be: sudo python3 -m http.server --bind 172.16.10.1 80 Now if you go to the .loki address you saved before your message \u201chello lokinet\u201d will be displayed. Jump onto the lokinet irc and see if others can access your SNApp.","title":"4. Serving your SNApp"},{"location":"Lokinet/Guides/HostingSNApps/#finish","text":"Well done, you have finished the guide. Jump back into the Lokinet Public Testing Guide here .","title":"Finish"},{"location":"Lokinet/Guides/Install/","text":"LokiNET install guide - Linux \u00b6 This guide describes building linux binaries from source. To download built binaries, head to lokinet.org for release files. To Compile, download the lastest release of Lokinet for your platform. If you encounter a compiler error, report it here using the following template found here Initial Setup for Linux \u00b6 1. Set up Non-root User \u00b6 Best practice when running a public server is to not run your software as the root user. We will create a non-root user to our server by running the following command. sudo adduser <username> Replacing <username> with a name you will log-in with. For this user-guide we will use lokitestnet as our username. If you use the same username the command will look like: sudo adduser lokitestnet Once ran the terminal will prompt you for a new password for your newly created user. Use a different password to the root password. Once the password has been set, the terminal will prompt for a few details about the individual running the user. You can hit enter through each of the inputs as the details are not important for the purposes of accessing Lokinet. Once that\u2019s done, run the following two commands to give our new account admin privileges and to change to such account. sudo usermod -aG sudo lokitestnet su - lokitestnet 2. Computer Preparation \u00b6 We should update our package lists, the below command downloads the package lists from the repositories and \"updates\" them to get information on the newest versions of packages and their dependencies. It will do this for all repositories and PPAs. Run the following command: sudo apt-get update You will notice a bunch of package lists were downloaded, once this is complete run the below command to fetch new versions of any packages we currently have installed on the system. sudo apt-get upgrade You will be prompted to authorise the use of disk space, type y and enter to authorise. Note: If you are prompted at any time that a version of any file is available then click the up and down arrows until you are hovering over install the package maintainer\u2019s version and click enter. 3. Dependencies \u00b6 You will need to install some build dependencies, run the following command to install all the build dependencies required for Lokinet: sudo apt install build-essential cmake libcap-dev wget git resolvconf curl libuv1-dev libsodium-dev libcurl4-openssl-dev Once you\u2019ve installed the dependencies we will now clone the loki-network repository: git clone https://github.com/loki-project/loki-network cd loki-network 4. Build for normal operation \u00b6 Run the following two commands to build for operation: make sudo make install 5. Setting your DNS \u00b6 Next we need to edit our resolv.conf files and add our dns resolver. Run the following command: sudo nano /etc/resolvconf/resolv.conf.d/head Add the following at the bottom of this file: nameserver 127.3.2.1 Once that line is added hold CTRL and click x. Click enter to confirm the file changes. Next we need to update our /etc/resolv.conf file by running the command: sudo resolvconf -u Optional: Building a debian package \u00b6 If you want a debian package install the debian maintainer packages needed $ sudo apt install debuild ...and then build one like so: $ debuild -us -b Finish \u00b6 Well done, you have finished the guide. Jump back into the Lokinet Public Testing Guide here .","title":"Linux - Build-It-Yourself"},{"location":"Lokinet/Guides/Install/#lokinet-install-guide-linux","text":"This guide describes building linux binaries from source. To download built binaries, head to lokinet.org for release files. To Compile, download the lastest release of Lokinet for your platform. If you encounter a compiler error, report it here using the following template found here","title":"LokiNET install guide - Linux"},{"location":"Lokinet/Guides/Install/#initial-setup-for-linux","text":"","title":"Initial Setup for Linux"},{"location":"Lokinet/Guides/Install/#1-set-up-non-root-user","text":"Best practice when running a public server is to not run your software as the root user. We will create a non-root user to our server by running the following command. sudo adduser <username> Replacing <username> with a name you will log-in with. For this user-guide we will use lokitestnet as our username. If you use the same username the command will look like: sudo adduser lokitestnet Once ran the terminal will prompt you for a new password for your newly created user. Use a different password to the root password. Once the password has been set, the terminal will prompt for a few details about the individual running the user. You can hit enter through each of the inputs as the details are not important for the purposes of accessing Lokinet. Once that\u2019s done, run the following two commands to give our new account admin privileges and to change to such account. sudo usermod -aG sudo lokitestnet su - lokitestnet","title":"1. Set up Non-root User"},{"location":"Lokinet/Guides/Install/#2-computer-preparation","text":"We should update our package lists, the below command downloads the package lists from the repositories and \"updates\" them to get information on the newest versions of packages and their dependencies. It will do this for all repositories and PPAs. Run the following command: sudo apt-get update You will notice a bunch of package lists were downloaded, once this is complete run the below command to fetch new versions of any packages we currently have installed on the system. sudo apt-get upgrade You will be prompted to authorise the use of disk space, type y and enter to authorise. Note: If you are prompted at any time that a version of any file is available then click the up and down arrows until you are hovering over install the package maintainer\u2019s version and click enter.","title":"2. Computer Preparation"},{"location":"Lokinet/Guides/Install/#3-dependencies","text":"You will need to install some build dependencies, run the following command to install all the build dependencies required for Lokinet: sudo apt install build-essential cmake libcap-dev wget git resolvconf curl libuv1-dev libsodium-dev libcurl4-openssl-dev Once you\u2019ve installed the dependencies we will now clone the loki-network repository: git clone https://github.com/loki-project/loki-network cd loki-network","title":"3.  Dependencies"},{"location":"Lokinet/Guides/Install/#4-build-for-normal-operation","text":"Run the following two commands to build for operation: make sudo make install","title":"4. Build for normal operation"},{"location":"Lokinet/Guides/Install/#5-setting-your-dns","text":"Next we need to edit our resolv.conf files and add our dns resolver. Run the following command: sudo nano /etc/resolvconf/resolv.conf.d/head Add the following at the bottom of this file: nameserver 127.3.2.1 Once that line is added hold CTRL and click x. Click enter to confirm the file changes. Next we need to update our /etc/resolv.conf file by running the command: sudo resolvconf -u","title":"5. Setting your DNS"},{"location":"Lokinet/Guides/Install/#optional-building-a-debian-package","text":"If you want a debian package install the debian maintainer packages needed $ sudo apt install debuild ...and then build one like so: $ debuild -us -b","title":"Optional: Building a debian package"},{"location":"Lokinet/Guides/Install/#finish","text":"Well done, you have finished the guide. Jump back into the Lokinet Public Testing Guide here .","title":"Finish"},{"location":"Lokinet/Guides/LokinetConfig/","text":"Lokinet config files \u00b6 This guide shows the different config files and their associated sections, keys and values. Table of contents: \u00b6 lokinet.ini Example lokinet.ini files [router] [api] [system] [dns] [netdb] [bootstrap] [network] [bind] [services] service.ini Example service.ini files [ <any_string> ] lokinet.ini \u00b6 Example lokinet.ini files \u00b6 Windows \u00b6 Expand for Windows example Default file location: C:\\Users\\Username\\AppData\\Roaming\\.lokinet\\lokinet.ini # this configuration was auto generated with 'sane' defaults # change these values as desired [router] # number of crypto worker threads threads=4 # path to store signed RC contact-file=C:\\Users\\Goose\\AppData\\Roaming\\.lokinet\\self.signed # path to store transport private key transport-privkey=C:\\Users\\Goose\\AppData\\Roaming\\.lokinet\\transport.private # path to store identity signing key ident-privkey=C:\\Users\\Goose\\AppData\\Roaming\\.lokinet\\identity.private # encryption key for onion routing encryption-privkey=C:\\Users\\Goose\\AppData\\Roaming\\.lokinet\\encryption.private # uncomment following line to set router nickname to 'lokinet' # nickname=lokinet # admin api (disabled by default) [api] enabled=false # authkey=insertpubkey1here # authkey=insertpubkey2here # authkey=insertpubkey3here bind=127.0.0.1:1190 # system settings for priviledges and such [system] # user=lokinet # group=lokinet # dns provider configuration section [dns] # CloudFare + APNIC DNS Resolver upstream=1.1.1.1 # Google DNS resolver upstream=8.8.8.8 bind=127.0.0.1:53 # network database settings block [netdb] # directory for network database skiplist storage dir=C:\\Users\\Goose\\AppData\\Roaming\\.lokinet\\netdb # bootstrap settings [bootstrap] # add a bootstrap node's signed identity to the list of nodes we want to bootstrap from # if we don't have any peers we connect to this router add-node=C:\\Users\\Goose\\AppData\\Roaming\\.lokinet\\bootstrap.signed # add another bootstrap node #add-node=/path/to/alternative/self.signed # network settings [network] profiles=C:\\Users\\Goose\\AppData\\Roaming\\.lokinet\\profiles.dat # uncomment next line to add router with pubkey to list of routers we connect directly to #strict-connect=pubkey # uncomment next line to use router with pubkey as an exit node #exit-node=pubkey ifname=lokitun0 ifaddr=172.16.10.1/24 enabled=true # Store the keyfile of your snapp in specified location. # This enforces the same .loki address when serving a SNApp. keyfile=C:\\Users\\Goose\\AppData\\Roaming\\.lokinet\\example-snap-keyfile.private Linux \u00b6 Expand for Linux example Default file location: /home/username/.lokinet/lokinet.ini # this configuration was auto generated with 'sane' defaults # change these values as desired [router] # number of crypto worker threads threads=4 # path to store signed RC contact-file=/home/goose/.lokinet/self.signed # path to store transport private key transport-privkey=/home/goose/.lokinet/transport.private # path to store identity signing key ident-privkey=/home/goose/.lokinet/identity.private # encryption key for onion routing encryption-privkey=/home/goose/.lokinet/encryption.private # uncomment following line to set router nickname to 'lokinet' # nickname=lokinet # admin api (disabled by default) [api] enabled=false # authkey=insertpubkey1here # authkey=insertpubkey2here # authkey=insertpubkey3here bind=127.0.0.1:1190 # system settings for priviledges and such [system] user=lokinet group=lokinet # dns provider configuration section [dns] # resolver upstream=1.1.1.1 bind=127.3.2.1:53 # network database settings block [netdb] # directory for network database skiplist storage dir=/home/goose/.lokinet/netdb # bootstrap settings [bootstrap] # add a bootstrap node's signed identity to the list of nodes we want to bootstrap from # if we don't have any peers we connect to this router add-node=/home/goose/.lokinet/bootstrap.signed # add another bootstrap node #add-node=/path/to/alternative/self.signed # snapps configuration section [services] #uncomment next line to load a service.ini file. #example-snapp=/home/goose/.lokinet/snapp-example.ini # network settings [network] profiles=/home/modeify/.lokinet/profiles.dat # uncomment next line to add router with pubkey to list of routers we connect d$ strict-connect=3dcb5a34d015a7bbb4636be83991e00cbeff13fe7834e0d5452ffe9a5af5a5be # uncomment next line to use router with pubkey as an exit node exit-node=b61df944b8547af56201c6c7528ed86289566dcf73358c5ef8e3b4e628671399 ifname=lokitun0 ifaddr=172.16.10.1/24 enabled=true #Store the keyfile of your snapp in specified location. #This enforces the same .loki address when serving a SNApp. keyfile=/home/<user>/.lokinet/example-snap-keyfile.private [router] \u00b6 Key Defaults Range Description threads= 4 0 - <#cores> Number of crypto worker threads contact-file= Windows: C:\\Users\\AppData\\Roaming\\.lokinet\\self.signed Linux: /home/.lokinet/self.signed Any filepath Path to store signed RC transport-privkey= Windows: C:\\Users\\AppData\\Roaming\\.lokinet\\transport.private Linux: /home/.lokinet/transport.private Any filepath Path to store transport private key ident-privkey= Windows: C:\\Users\\AppData\\Roaming\\.lokinet\\identity.private Linux: /home/.lokinet/identity.private Any filepath Path to store identity signing key encryption-privkey= Windows: C:\\Users\\AppData\\Roaming\\.lokinet\\encryption.private Linux: /home/.lokinet/encryption.private Any filepath Encryption key for onion routing nickname= lokinet 32 Byte Nickname set for Router [api] \u00b6 Key Defaults Range Description enabled= false false , true Enable API calls to daemon authkey= insertpubkey1here Not implemented Add API authentication key bind= 127.0.0.1:1190 0.0.0.0 (only for testing), 127.0.0.1:<port> (loopback), Any IP bound to an adapter / interface on the computer The IP a machine can connect to the daemon to parse API calls [system] \u00b6 Key Defaults Range Description user lokinet Not implemented Lokinet to drop privileges to this user after performing root tasks. group lokinet Not implemented Lokinet to drop privileges to this group after performing root tasks. [dns] \u00b6 Key Defaults Range Description upstream= 1.1.1.1 Any DNS Directory Resolves clearnet addresses if .loki address is not queried. Choose your DNS directory, multiple directories can be added by adding a new line with upstream=<DNS Directory IP> bind= 127.0.0.1:53 Any IP address that is set within resolv.conf file. Linux has an exception to the default and must be changed, See lokinet installion for further details. Resolves lokinet addresses. Tells Lokinet where to set up the server to receive lokinet address queries. Port should be kept at 53 in most cases. [netdb] \u00b6 Key Defaults Range Description dir= Windows: C:\\Users\\<user>\\AppData\\Roaming\\.lokinet\\netdb Linux: /home/<user>/.lokinet/netdb filepath Directory for network database skiplist storage [bootstrap] \u00b6 Key Defaults Range Description add-node= Windows: C:\\Users\\<user>\\AppData\\Roaming\\.lokinet\\bootstrap.signed Linux: /home/<user>/.lokinet/bootstrap.signed Any filepath If we don't have any peers to connect to add a bootstrap node's signed identity to the list of nodes we want to bootstrap from. Add another bootstrap node by adding another line with add-node=<filepath> [network] \u00b6 Key Defaults Range Description profiles= Windows: C:\\Users\\<user>\\AppData\\Roaming\\.lokinet\\profiles.dat Linux: /home/<user>/.lokinet/profiles.dat Any filepath Location to save the log of up-time about routers you connect to. strict-connect= pubkey Any lokinet relay node pubkey Enforce a strict first hop router with it's pubkey. exit-node= pubkey Any lokinet exit node pubkey Enforce a strict exit node with it's pubkey. ifname= lokitun0 Character limit based on OS Set the interface name of the IP set in the ifaddr= in the next line of the config file. ifaddr= 172.16.10.1/24 Any IP can be set that is not in use. Set the IP connected to the interface name set in ifname= in the previous line of the config file. keyfile= Windows: C:\\Users\\<user>\\AppData\\Roaming\\.lokinet\\example-snap-keyfile.private Linux: /home/<user>/.lokinet/example-snap-keyfile.private Any filepath Set a persistent SNApp by saving the private key into a local file. enabled= True True, False Enable this network section [bind] \u00b6 Key Defaults Range Description <network_interface_name>= 1090 <port> you listen on that adapter. ROUTERS ONLY: publish network interfaces for handling inbound traffic Example: eth0=1090 [services] \u00b6 Key Defaults Range Description <name>= Windows: C:\\Users\\<user>\\AppData\\Roaming\\.lokinet\\service.ini Linux: /home/<user>/.lokinet/service.ini Any filepath Load services file. Can run multiple lines of this Key to run multiple services. See service.ini for more details. service.ini \u00b6 The service.ini is being pulled from the [services] section of lokinet.ini . The section title can be anything for example: [any_string] Example service.ini files \u00b6 Windows \u00b6 Expand for Windows example Default file location: Path is set within your lokinet.ini file # this is an example configuration for a snapp [example-snapp] # keyfile is the path to the private key of the snapp keyfile=C:\\Users\\Username\\AppData\\Roaming\\.lokinet\\example-snap-keyfile.private # ifaddr is the ip range to allocate to this snapp ifaddr=10.55.0.0/16 # ifname is the name to try and give to the network interface this snap owns ifname=snapp-tun0 Linux \u00b6 Expand for Linux example Default file location: Path is set within your lokinet.ini file # this is an example configuration for a snapp [example-snapp] # keyfile is the path to the private key of the snapp keyfile=/home/goose/.lokinet/example-snap-keyfile.private # ifaddr is the ip range to allocate to this snapp ifaddr=10.55.0.0/16 # ifname is the name to try and give to the network interface this snap owns ifname=snapp-tun0 [ any_string ] \u00b6 Key Defaults Range Description profiles= Windows: C:\\Users\\<user>\\AppData\\Roaming\\.lokinet\\profiles.dat Linux: /home/<user>/.lokinet/profiles.dat Any filepath Location to save the log of up-time about routers you connect to. strict-connect= pubkey Any lokinet relay node pubkey Enforce a strict first hop router with it's pubkey. exit-node= pubkey Any lokinet exit node pubkey Enforce a strict exit node with it's pubkey. ifname= lokitun0 Character limit based on OS Set the interface name of the IP set in the ifaddr= in the next line of the config file. ifaddr= 172.16.10.1/24 Any IP can be set that is not in use. Set the IP connected to the interface name set in ifname= in the previous line of the config file. keyfile= Windows: C:\\Users\\<user>\\AppData\\Roaming\\.lokinet\\example-snap-keyfile.private Linux: /home/<user>/.lokinet/example-snap-keyfile.private Any filepath Set a persistent SNApp by saving the private key into a local file. upstream= 1.1.1.1 Any DNS Directory Resolves clearnet addresses if .loki address is not queried. Choose your DNS directory, multiple directories can be added by adding a new line with upstream=<DNS Directory IP> bind= 127.0.0.1:53 Any IP address that is set within resolv.conf file. Linux has an exception to the default and must be changed, See lokinet installion for further details. Resolves lokinet addresses. Tells Lokinet where to set up the server to receive lokinet address queries. Port should be kept at 53 in most cases. enabled= True True, False Enable this network section","title":"Lokinet config files"},{"location":"Lokinet/Guides/LokinetConfig/#lokinet-config-files","text":"This guide shows the different config files and their associated sections, keys and values.","title":"Lokinet config files"},{"location":"Lokinet/Guides/LokinetConfig/#table-of-contents","text":"lokinet.ini Example lokinet.ini files [router] [api] [system] [dns] [netdb] [bootstrap] [network] [bind] [services] service.ini Example service.ini files [ <any_string> ]","title":"Table of contents:"},{"location":"Lokinet/Guides/LokinetConfig/#lokinetini","text":"","title":"lokinet.ini"},{"location":"Lokinet/Guides/LokinetConfig/#example-lokinetini-files","text":"","title":"Example lokinet.ini files"},{"location":"Lokinet/Guides/LokinetConfig/#windows","text":"Expand for Windows example Default file location: C:\\Users\\Username\\AppData\\Roaming\\.lokinet\\lokinet.ini # this configuration was auto generated with 'sane' defaults # change these values as desired [router] # number of crypto worker threads threads=4 # path to store signed RC contact-file=C:\\Users\\Goose\\AppData\\Roaming\\.lokinet\\self.signed # path to store transport private key transport-privkey=C:\\Users\\Goose\\AppData\\Roaming\\.lokinet\\transport.private # path to store identity signing key ident-privkey=C:\\Users\\Goose\\AppData\\Roaming\\.lokinet\\identity.private # encryption key for onion routing encryption-privkey=C:\\Users\\Goose\\AppData\\Roaming\\.lokinet\\encryption.private # uncomment following line to set router nickname to 'lokinet' # nickname=lokinet # admin api (disabled by default) [api] enabled=false # authkey=insertpubkey1here # authkey=insertpubkey2here # authkey=insertpubkey3here bind=127.0.0.1:1190 # system settings for priviledges and such [system] # user=lokinet # group=lokinet # dns provider configuration section [dns] # CloudFare + APNIC DNS Resolver upstream=1.1.1.1 # Google DNS resolver upstream=8.8.8.8 bind=127.0.0.1:53 # network database settings block [netdb] # directory for network database skiplist storage dir=C:\\Users\\Goose\\AppData\\Roaming\\.lokinet\\netdb # bootstrap settings [bootstrap] # add a bootstrap node's signed identity to the list of nodes we want to bootstrap from # if we don't have any peers we connect to this router add-node=C:\\Users\\Goose\\AppData\\Roaming\\.lokinet\\bootstrap.signed # add another bootstrap node #add-node=/path/to/alternative/self.signed # network settings [network] profiles=C:\\Users\\Goose\\AppData\\Roaming\\.lokinet\\profiles.dat # uncomment next line to add router with pubkey to list of routers we connect directly to #strict-connect=pubkey # uncomment next line to use router with pubkey as an exit node #exit-node=pubkey ifname=lokitun0 ifaddr=172.16.10.1/24 enabled=true # Store the keyfile of your snapp in specified location. # This enforces the same .loki address when serving a SNApp. keyfile=C:\\Users\\Goose\\AppData\\Roaming\\.lokinet\\example-snap-keyfile.private","title":"Windows"},{"location":"Lokinet/Guides/LokinetConfig/#linux","text":"Expand for Linux example Default file location: /home/username/.lokinet/lokinet.ini # this configuration was auto generated with 'sane' defaults # change these values as desired [router] # number of crypto worker threads threads=4 # path to store signed RC contact-file=/home/goose/.lokinet/self.signed # path to store transport private key transport-privkey=/home/goose/.lokinet/transport.private # path to store identity signing key ident-privkey=/home/goose/.lokinet/identity.private # encryption key for onion routing encryption-privkey=/home/goose/.lokinet/encryption.private # uncomment following line to set router nickname to 'lokinet' # nickname=lokinet # admin api (disabled by default) [api] enabled=false # authkey=insertpubkey1here # authkey=insertpubkey2here # authkey=insertpubkey3here bind=127.0.0.1:1190 # system settings for priviledges and such [system] user=lokinet group=lokinet # dns provider configuration section [dns] # resolver upstream=1.1.1.1 bind=127.3.2.1:53 # network database settings block [netdb] # directory for network database skiplist storage dir=/home/goose/.lokinet/netdb # bootstrap settings [bootstrap] # add a bootstrap node's signed identity to the list of nodes we want to bootstrap from # if we don't have any peers we connect to this router add-node=/home/goose/.lokinet/bootstrap.signed # add another bootstrap node #add-node=/path/to/alternative/self.signed # snapps configuration section [services] #uncomment next line to load a service.ini file. #example-snapp=/home/goose/.lokinet/snapp-example.ini # network settings [network] profiles=/home/modeify/.lokinet/profiles.dat # uncomment next line to add router with pubkey to list of routers we connect d$ strict-connect=3dcb5a34d015a7bbb4636be83991e00cbeff13fe7834e0d5452ffe9a5af5a5be # uncomment next line to use router with pubkey as an exit node exit-node=b61df944b8547af56201c6c7528ed86289566dcf73358c5ef8e3b4e628671399 ifname=lokitun0 ifaddr=172.16.10.1/24 enabled=true #Store the keyfile of your snapp in specified location. #This enforces the same .loki address when serving a SNApp. keyfile=/home/<user>/.lokinet/example-snap-keyfile.private","title":"Linux"},{"location":"Lokinet/Guides/LokinetConfig/#router","text":"Key Defaults Range Description threads= 4 0 - <#cores> Number of crypto worker threads contact-file= Windows: C:\\Users\\AppData\\Roaming\\.lokinet\\self.signed Linux: /home/.lokinet/self.signed Any filepath Path to store signed RC transport-privkey= Windows: C:\\Users\\AppData\\Roaming\\.lokinet\\transport.private Linux: /home/.lokinet/transport.private Any filepath Path to store transport private key ident-privkey= Windows: C:\\Users\\AppData\\Roaming\\.lokinet\\identity.private Linux: /home/.lokinet/identity.private Any filepath Path to store identity signing key encryption-privkey= Windows: C:\\Users\\AppData\\Roaming\\.lokinet\\encryption.private Linux: /home/.lokinet/encryption.private Any filepath Encryption key for onion routing nickname= lokinet 32 Byte Nickname set for Router","title":"[router]"},{"location":"Lokinet/Guides/LokinetConfig/#api","text":"Key Defaults Range Description enabled= false false , true Enable API calls to daemon authkey= insertpubkey1here Not implemented Add API authentication key bind= 127.0.0.1:1190 0.0.0.0 (only for testing), 127.0.0.1:<port> (loopback), Any IP bound to an adapter / interface on the computer The IP a machine can connect to the daemon to parse API calls","title":"[api]"},{"location":"Lokinet/Guides/LokinetConfig/#system","text":"Key Defaults Range Description user lokinet Not implemented Lokinet to drop privileges to this user after performing root tasks. group lokinet Not implemented Lokinet to drop privileges to this group after performing root tasks.","title":"[system]"},{"location":"Lokinet/Guides/LokinetConfig/#dns","text":"Key Defaults Range Description upstream= 1.1.1.1 Any DNS Directory Resolves clearnet addresses if .loki address is not queried. Choose your DNS directory, multiple directories can be added by adding a new line with upstream=<DNS Directory IP> bind= 127.0.0.1:53 Any IP address that is set within resolv.conf file. Linux has an exception to the default and must be changed, See lokinet installion for further details. Resolves lokinet addresses. Tells Lokinet where to set up the server to receive lokinet address queries. Port should be kept at 53 in most cases.","title":"[dns]"},{"location":"Lokinet/Guides/LokinetConfig/#netdb","text":"Key Defaults Range Description dir= Windows: C:\\Users\\<user>\\AppData\\Roaming\\.lokinet\\netdb Linux: /home/<user>/.lokinet/netdb filepath Directory for network database skiplist storage","title":"[netdb]"},{"location":"Lokinet/Guides/LokinetConfig/#bootstrap","text":"Key Defaults Range Description add-node= Windows: C:\\Users\\<user>\\AppData\\Roaming\\.lokinet\\bootstrap.signed Linux: /home/<user>/.lokinet/bootstrap.signed Any filepath If we don't have any peers to connect to add a bootstrap node's signed identity to the list of nodes we want to bootstrap from. Add another bootstrap node by adding another line with add-node=<filepath>","title":"[bootstrap]"},{"location":"Lokinet/Guides/LokinetConfig/#network","text":"Key Defaults Range Description profiles= Windows: C:\\Users\\<user>\\AppData\\Roaming\\.lokinet\\profiles.dat Linux: /home/<user>/.lokinet/profiles.dat Any filepath Location to save the log of up-time about routers you connect to. strict-connect= pubkey Any lokinet relay node pubkey Enforce a strict first hop router with it's pubkey. exit-node= pubkey Any lokinet exit node pubkey Enforce a strict exit node with it's pubkey. ifname= lokitun0 Character limit based on OS Set the interface name of the IP set in the ifaddr= in the next line of the config file. ifaddr= 172.16.10.1/24 Any IP can be set that is not in use. Set the IP connected to the interface name set in ifname= in the previous line of the config file. keyfile= Windows: C:\\Users\\<user>\\AppData\\Roaming\\.lokinet\\example-snap-keyfile.private Linux: /home/<user>/.lokinet/example-snap-keyfile.private Any filepath Set a persistent SNApp by saving the private key into a local file. enabled= True True, False Enable this network section","title":"[network]"},{"location":"Lokinet/Guides/LokinetConfig/#bind","text":"Key Defaults Range Description <network_interface_name>= 1090 <port> you listen on that adapter. ROUTERS ONLY: publish network interfaces for handling inbound traffic Example: eth0=1090","title":"[bind]"},{"location":"Lokinet/Guides/LokinetConfig/#services","text":"Key Defaults Range Description <name>= Windows: C:\\Users\\<user>\\AppData\\Roaming\\.lokinet\\service.ini Linux: /home/<user>/.lokinet/service.ini Any filepath Load services file. Can run multiple lines of this Key to run multiple services. See service.ini for more details.","title":"[services]"},{"location":"Lokinet/Guides/LokinetConfig/#serviceini","text":"The service.ini is being pulled from the [services] section of lokinet.ini . The section title can be anything for example: [any_string]","title":"service.ini"},{"location":"Lokinet/Guides/LokinetConfig/#example-serviceini-files","text":"","title":"Example service.ini files"},{"location":"Lokinet/Guides/LokinetConfig/#windows_1","text":"Expand for Windows example Default file location: Path is set within your lokinet.ini file # this is an example configuration for a snapp [example-snapp] # keyfile is the path to the private key of the snapp keyfile=C:\\Users\\Username\\AppData\\Roaming\\.lokinet\\example-snap-keyfile.private # ifaddr is the ip range to allocate to this snapp ifaddr=10.55.0.0/16 # ifname is the name to try and give to the network interface this snap owns ifname=snapp-tun0","title":"Windows"},{"location":"Lokinet/Guides/LokinetConfig/#linux_1","text":"Expand for Linux example Default file location: Path is set within your lokinet.ini file # this is an example configuration for a snapp [example-snapp] # keyfile is the path to the private key of the snapp keyfile=/home/goose/.lokinet/example-snap-keyfile.private # ifaddr is the ip range to allocate to this snapp ifaddr=10.55.0.0/16 # ifname is the name to try and give to the network interface this snap owns ifname=snapp-tun0","title":"Linux"},{"location":"Lokinet/Guides/LokinetConfig/#any_string","text":"Key Defaults Range Description profiles= Windows: C:\\Users\\<user>\\AppData\\Roaming\\.lokinet\\profiles.dat Linux: /home/<user>/.lokinet/profiles.dat Any filepath Location to save the log of up-time about routers you connect to. strict-connect= pubkey Any lokinet relay node pubkey Enforce a strict first hop router with it's pubkey. exit-node= pubkey Any lokinet exit node pubkey Enforce a strict exit node with it's pubkey. ifname= lokitun0 Character limit based on OS Set the interface name of the IP set in the ifaddr= in the next line of the config file. ifaddr= 172.16.10.1/24 Any IP can be set that is not in use. Set the IP connected to the interface name set in ifname= in the previous line of the config file. keyfile= Windows: C:\\Users\\<user>\\AppData\\Roaming\\.lokinet\\example-snap-keyfile.private Linux: /home/<user>/.lokinet/example-snap-keyfile.private Any filepath Set a persistent SNApp by saving the private key into a local file. upstream= 1.1.1.1 Any DNS Directory Resolves clearnet addresses if .loki address is not queried. Choose your DNS directory, multiple directories can be added by adding a new line with upstream=<DNS Directory IP> bind= 127.0.0.1:53 Any IP address that is set within resolv.conf file. Linux has an exception to the default and must be changed, See lokinet installion for further details. Resolves lokinet addresses. Tells Lokinet where to set up the server to receive lokinet address queries. Port should be kept at 53 in most cases. enabled= True True, False Enable this network section","title":"[any_string]"},{"location":"Lokinet/Guides/LokinetGuiGuide/","text":"Lokinet GUI install guide - Linux \u00b6 Author: Jason (jagerman), Johnathan (SonOfOtis) Source: https://deb.imaginary.stream/ To download Lokinet Gui on Windows or Mac just head over to lokinet.org or loki.network and click the download button. Initial Setup for Linux \u00b6 1. Computer Preparation \u00b6 We should update our package lists, the below command downloads the package lists from the repositories and \"updates\" them to get information on the newest versions of packages and their dependencies. It will do this for all repositories and PPAs. Run the following command: sudo apt-get update You will notice a bunch of package lists were downloaded, once this is complete run the below command to fetch new versions of any packages we currently have installed on the system. sudo apt-get upgrade You will be prompted to authorise the use of disk space, type y and enter to authorise. Note: If you are prompted at any time that a version of any file is available then click the up and down arrows until you are hovering over install the package maintainer\u2019s version and click enter. If you do not have curl installed on your computer then let's install it as we will use it later: sudo apt install curl 2. Installation \u00b6 You only need to do this step the first time you want to set up the repository; when you've done it once, the repository will automatically update whenever you fetch new system updates. To add the Loki apt repository run the following commands: The following command installed Jagermans public key used to sign the Binaries. curl -s https://deb.imaginary.stream/public.gpg | sudo apt-key add - The next command tells apt where to find the packages: echo \"deb https://deb.imaginary.stream $(lsb_release -sc) main\" | sudo tee /etc/apt/sources.list.d/imaginary.stream.list Then resync your package repositories with: sudo apt update Now install lokinet: sudo apt install lokinet-gui Congratulations, Lokinet is now installed and running in the background. To access the GUI client all you need to do is open up the lokinet-gui application. Turn Lokinet off and on \u00b6 Simply jump into the lokinet-gui client and click the power button. Browse Lokinet - Stay Private \u00b6 Jump onto a browser and head over to the Lokinet wiki SNApp: Lokinet Wiki http://dw68y1xhptqbhcm5s8aaaip6dbopykagig5q5u1za4c7pzxto77y.loki/wiki/ Congratulations, you're browsing Lokinet. Troubleshooting \u00b6 Setting your DNS \u00b6 If you are having issues with resolving .loki addresses then we need to edit your resolv.conf files and add your dns resolver. Method 1 \u00b6 Run the following command: apt install resolvconf Then restart lokinet: systemctl restart lokinet Method 2 \u00b6 If Method 1 does not work we will need to add our nameserver manually. Run the following command: sudo nano /etc/resolvconf/resolv.conf.d/head Add the following at the bottom of this file: nameserver 127.3.2.1 Once that line is added hold CTRL and click x. Click enter to confirm the file changes. Next we need to update our /etc/resolv.conf file by running the command: sudo resolvconf -u Then restart lokinet: systemctl restart lokinet Finish \u00b6 Well done, you have finished the guide. Jump into the Accessing SNApps guide .","title":"Linux GUI Guide"},{"location":"Lokinet/Guides/LokinetGuiGuide/#lokinet-gui-install-guide-linux","text":"Author: Jason (jagerman), Johnathan (SonOfOtis) Source: https://deb.imaginary.stream/ To download Lokinet Gui on Windows or Mac just head over to lokinet.org or loki.network and click the download button.","title":"Lokinet GUI install guide - Linux"},{"location":"Lokinet/Guides/LokinetGuiGuide/#initial-setup-for-linux","text":"","title":"Initial Setup for Linux"},{"location":"Lokinet/Guides/LokinetGuiGuide/#1-computer-preparation","text":"We should update our package lists, the below command downloads the package lists from the repositories and \"updates\" them to get information on the newest versions of packages and their dependencies. It will do this for all repositories and PPAs. Run the following command: sudo apt-get update You will notice a bunch of package lists were downloaded, once this is complete run the below command to fetch new versions of any packages we currently have installed on the system. sudo apt-get upgrade You will be prompted to authorise the use of disk space, type y and enter to authorise. Note: If you are prompted at any time that a version of any file is available then click the up and down arrows until you are hovering over install the package maintainer\u2019s version and click enter. If you do not have curl installed on your computer then let's install it as we will use it later: sudo apt install curl","title":"1. Computer Preparation"},{"location":"Lokinet/Guides/LokinetGuiGuide/#2-installation","text":"You only need to do this step the first time you want to set up the repository; when you've done it once, the repository will automatically update whenever you fetch new system updates. To add the Loki apt repository run the following commands: The following command installed Jagermans public key used to sign the Binaries. curl -s https://deb.imaginary.stream/public.gpg | sudo apt-key add - The next command tells apt where to find the packages: echo \"deb https://deb.imaginary.stream $(lsb_release -sc) main\" | sudo tee /etc/apt/sources.list.d/imaginary.stream.list Then resync your package repositories with: sudo apt update Now install lokinet: sudo apt install lokinet-gui Congratulations, Lokinet is now installed and running in the background. To access the GUI client all you need to do is open up the lokinet-gui application.","title":"2. Installation"},{"location":"Lokinet/Guides/LokinetGuiGuide/#turn-lokinet-off-and-on","text":"Simply jump into the lokinet-gui client and click the power button.","title":"Turn Lokinet off and on"},{"location":"Lokinet/Guides/LokinetGuiGuide/#browse-lokinet-stay-private","text":"Jump onto a browser and head over to the Lokinet wiki SNApp: Lokinet Wiki http://dw68y1xhptqbhcm5s8aaaip6dbopykagig5q5u1za4c7pzxto77y.loki/wiki/ Congratulations, you're browsing Lokinet.","title":"Browse Lokinet - Stay Private"},{"location":"Lokinet/Guides/LokinetGuiGuide/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"Lokinet/Guides/LokinetGuiGuide/#setting-your-dns","text":"If you are having issues with resolving .loki addresses then we need to edit your resolv.conf files and add your dns resolver.","title":"Setting your DNS"},{"location":"Lokinet/Guides/LokinetGuiGuide/#method-1","text":"Run the following command: apt install resolvconf Then restart lokinet: systemctl restart lokinet","title":"Method 1"},{"location":"Lokinet/Guides/LokinetGuiGuide/#method-2","text":"If Method 1 does not work we will need to add our nameserver manually. Run the following command: sudo nano /etc/resolvconf/resolv.conf.d/head Add the following at the bottom of this file: nameserver 127.3.2.1 Once that line is added hold CTRL and click x. Click enter to confirm the file changes. Next we need to update our /etc/resolv.conf file by running the command: sudo resolvconf -u Then restart lokinet: systemctl restart lokinet","title":"Method 2"},{"location":"Lokinet/Guides/LokinetGuiGuide/#finish","text":"Well done, you have finished the guide. Jump into the Accessing SNApps guide .","title":"Finish"},{"location":"Lokinet/Guides/LokinetIRC/","text":"Hosting a SNApp \u00b6 1. Downloading an IRC client \u00b6 For this guide, we will be downloading and using the konversation IRC client. Go into Ubuntu Software application and search for konversation . Once found click the install button. Once Konversation has been downloaded and installed you can then launch the software. Note: You must be running lokinet to be able to access any IRC chats hosted on the Lokinet. If you do not have lokinet running, check out the installation guide here . 2. Connecting to a Lokinet IRC \u00b6 On first startup of Konversation a window will pop up with the heading Server List . From this window, we will click the New... button. Next to Network name: add the text Lokinet Chat . 2.1 Server details \u00b6 In this window, underneath the Servers: section click the Add... button. Copy and paste the following loki address into servers: irc.dw68y1xhptqbhcm5s8aaaip6dbopykagig5q5u1za4c7pzxto77y.loki Leave Port: as 6667 and Password: blank. This window should look similar to the below before clicking the OK button. 2.2 Channel details \u00b6 Next we will add the details of the lokinet channel to automatically join the chat when accessing the server. Click the Add... button underneith the Auto Join Channels: section. In the Channel: section add the text #lokinet and click the OK button. Once all the server and channel details have been entered your window should look like the following: Lets click the OK button. The Server List window will reappear, make sure the server we added is highlighted and click the Connect button. Congratulations, at this point you should be connected and have joined a channel hosted on the Lokinet. Finish \u00b6 Well done, you have finished the guide. Jump back into the Lokinet Public Testing Guide here .","title":"Joining a Lokinet IRC Chat"},{"location":"Lokinet/Guides/LokinetIRC/#hosting-a-snapp","text":"","title":"Hosting a SNApp"},{"location":"Lokinet/Guides/LokinetIRC/#1-downloading-an-irc-client","text":"For this guide, we will be downloading and using the konversation IRC client. Go into Ubuntu Software application and search for konversation . Once found click the install button. Once Konversation has been downloaded and installed you can then launch the software. Note: You must be running lokinet to be able to access any IRC chats hosted on the Lokinet. If you do not have lokinet running, check out the installation guide here .","title":"1. Downloading an IRC client"},{"location":"Lokinet/Guides/LokinetIRC/#2-connecting-to-a-lokinet-irc","text":"On first startup of Konversation a window will pop up with the heading Server List . From this window, we will click the New... button. Next to Network name: add the text Lokinet Chat .","title":"2. Connecting to a Lokinet IRC"},{"location":"Lokinet/Guides/LokinetIRC/#21-server-details","text":"In this window, underneath the Servers: section click the Add... button. Copy and paste the following loki address into servers: irc.dw68y1xhptqbhcm5s8aaaip6dbopykagig5q5u1za4c7pzxto77y.loki Leave Port: as 6667 and Password: blank. This window should look similar to the below before clicking the OK button.","title":"2.1 Server details"},{"location":"Lokinet/Guides/LokinetIRC/#22-channel-details","text":"Next we will add the details of the lokinet channel to automatically join the chat when accessing the server. Click the Add... button underneith the Auto Join Channels: section. In the Channel: section add the text #lokinet and click the OK button. Once all the server and channel details have been entered your window should look like the following: Lets click the OK button. The Server List window will reappear, make sure the server we added is highlighted and click the Connect button. Congratulations, at this point you should be connected and have joined a channel hosted on the Lokinet.","title":"2.2 Channel details"},{"location":"Lokinet/Guides/LokinetIRC/#finish","text":"Well done, you have finished the guide. Jump back into the Lokinet Public Testing Guide here .","title":"Finish"},{"location":"Lokinet/Guides/LokinetRouter/","text":"Lokinet Router Guide \u00b6 Author: Jason (jagerman), Johnathan (SonOfOtis) Source: https://deb.imaginary.stream/ Introduction \u00b6 This document will tell you exactly how to set up and operate a Lokinet router. This document was written with non-developers in mind, so people new to linux or command line operations should be able to follow along without any trouble. If you feel confident around servers and the CLI, then skip to the Express Setup Guide You can of course run the Loki software on any operating system that you can get it to build on. Initial Setup for Linux \u00b6 1. Create a non-root User \u00b6 Best practice when running a public server is to not run your software as the root user. Although it is possible to do everything as root, it is strongly recommended that you create a non-root user on our VPS by running the following command: adduser <username> Replacing <username> with a name you will log-in with. For this user-guide we will use lokinetRouter as our username. adduser lokinetRouter The terminal will prompt you for a new password for our newly created user. Use a secure password that is different password from the root password. Once the password has been set, the terminal will prompt for a few details about the individual running the user. You can just hit enter through each of the inputs as the details are not important for the purposes of running a Service Node. Once that\u2019s done, run the following two commands to give our new account admin privileges and to change to such account. usermod -aG sudo lokinetRelay sudo su - lokinetRelay 2. Server Preparation \u00b6 We should update our package lists, the below command downloads the package lists from the repositories and \"updates\" them to get information on the newest versions of packages and their dependencies. It will do this for all repositories and PPAs. Run the following command: sudo apt-get update You will notice a bunch of package lists were downloaded, once this is complete run the below command to fetch new versions of any packages we currently have installed on the system. sudo apt-get upgrade You will be prompted to authorise the use of disk space, type y and enter to authorise. Note: If you are prompted at any time that a version of any file is available then click the up and down arrows until you are hovering over install the package maintainer\u2019s version and click enter. If you do not have curl installed on your computer then let's install it as we will use it later: sudo apt install curl 3. Lokinet Router Installation \u00b6 You only need to do this step the first time you want to set up the repository; when you've done it once, the repository will automatically update whenever you fetch new system updates. To add the Loki apt repository run the following commands: The following command installed Jagermans public key used to sign the Binaries. curl -s https://deb.imaginary.stream/public.gpg | sudo apt-key add - The next command tells apt where to find the packages: echo \"deb https://deb.imaginary.stream $(lsb_release -sc) main\" | sudo tee /etc/apt/sources.list.d/imaginary.stream.list Then resync your package repositories with: sudo apt update Now install the lokinet router software: sudo apt install lokinet-router Congratulations, your server is running as a relay in the Lokinet! Starting and Stopping Lokinet router. \u00b6 To start lokinet router manually run the following command: sudo systemctl start lokinet-router and to stop lokinet manually run the following command: sudo systemctl stop lokinet-router Express Setup Guide \u00b6 adduser lokinetRouter usermod -aG sudo lokinetRelay sudo su - lokinetRelay sudo apt install curl curl -s https://deb.imaginary.stream/public.gpg | sudo apt-key add - echo \"deb https://deb.imaginary.stream $(lsb_release -sc) main\" | sudo tee /etc/apt/sources.list.d/imaginary.stream.list sudo apt update sudo apt install lokinet-router","title":"Set up a Lokinet Router"},{"location":"Lokinet/Guides/LokinetRouter/#lokinet-router-guide","text":"Author: Jason (jagerman), Johnathan (SonOfOtis) Source: https://deb.imaginary.stream/","title":"Lokinet Router Guide"},{"location":"Lokinet/Guides/LokinetRouter/#introduction","text":"This document will tell you exactly how to set up and operate a Lokinet router. This document was written with non-developers in mind, so people new to linux or command line operations should be able to follow along without any trouble. If you feel confident around servers and the CLI, then skip to the Express Setup Guide You can of course run the Loki software on any operating system that you can get it to build on.","title":"Introduction"},{"location":"Lokinet/Guides/LokinetRouter/#initial-setup-for-linux","text":"","title":"Initial Setup for Linux"},{"location":"Lokinet/Guides/LokinetRouter/#1-create-a-non-root-user","text":"Best practice when running a public server is to not run your software as the root user. Although it is possible to do everything as root, it is strongly recommended that you create a non-root user on our VPS by running the following command: adduser <username> Replacing <username> with a name you will log-in with. For this user-guide we will use lokinetRouter as our username. adduser lokinetRouter The terminal will prompt you for a new password for our newly created user. Use a secure password that is different password from the root password. Once the password has been set, the terminal will prompt for a few details about the individual running the user. You can just hit enter through each of the inputs as the details are not important for the purposes of running a Service Node. Once that\u2019s done, run the following two commands to give our new account admin privileges and to change to such account. usermod -aG sudo lokinetRelay sudo su - lokinetRelay","title":"1. Create a non-root User"},{"location":"Lokinet/Guides/LokinetRouter/#2-server-preparation","text":"We should update our package lists, the below command downloads the package lists from the repositories and \"updates\" them to get information on the newest versions of packages and their dependencies. It will do this for all repositories and PPAs. Run the following command: sudo apt-get update You will notice a bunch of package lists were downloaded, once this is complete run the below command to fetch new versions of any packages we currently have installed on the system. sudo apt-get upgrade You will be prompted to authorise the use of disk space, type y and enter to authorise. Note: If you are prompted at any time that a version of any file is available then click the up and down arrows until you are hovering over install the package maintainer\u2019s version and click enter. If you do not have curl installed on your computer then let's install it as we will use it later: sudo apt install curl","title":"2. Server Preparation"},{"location":"Lokinet/Guides/LokinetRouter/#3-lokinet-router-installation","text":"You only need to do this step the first time you want to set up the repository; when you've done it once, the repository will automatically update whenever you fetch new system updates. To add the Loki apt repository run the following commands: The following command installed Jagermans public key used to sign the Binaries. curl -s https://deb.imaginary.stream/public.gpg | sudo apt-key add - The next command tells apt where to find the packages: echo \"deb https://deb.imaginary.stream $(lsb_release -sc) main\" | sudo tee /etc/apt/sources.list.d/imaginary.stream.list Then resync your package repositories with: sudo apt update Now install the lokinet router software: sudo apt install lokinet-router Congratulations, your server is running as a relay in the Lokinet!","title":"3. Lokinet Router Installation"},{"location":"Lokinet/Guides/LokinetRouter/#starting-and-stopping-lokinet-router","text":"To start lokinet router manually run the following command: sudo systemctl start lokinet-router and to stop lokinet manually run the following command: sudo systemctl stop lokinet-router","title":"Starting and Stopping Lokinet router."},{"location":"Lokinet/Guides/LokinetRouter/#express-setup-guide","text":"adduser lokinetRouter usermod -aG sudo lokinetRelay sudo su - lokinetRelay sudo apt install curl curl -s https://deb.imaginary.stream/public.gpg | sudo apt-key add - echo \"deb https://deb.imaginary.stream $(lsb_release -sc) main\" | sudo tee /etc/apt/sources.list.d/imaginary.stream.list sudo apt update sudo apt install lokinet-router","title":"Express Setup Guide"},{"location":"Lokinet/Guides/PublicTestingGuide/","text":"Lokinet Public Testing Guide \u00b6 Thanks for your interest in the public testing phase of the Lokinet alpha. It\u2019s taken many months to get to this point, but we\u2019re grateful to everyone who wants to give this new type of onion router a spin. This guide will help you get Lokinet running on your machine, and give you some example tasks on things you can do to help put the software through its paces and help us find places where it needs to be fixed or can be improved. The more machines we get this running on, and the more traffic (and types of traffic) we can push through this alpha network, the better. You can run the Loki software on any operating system. The binaries available for Linux (as .deb package), Windows 32 and 64-bit, OSX on lokinet.org website. Table of Contents \u00b6 Overview of Lokinet Getting Help and Reporting Bugs Guidelines Getting Help Reporting Bugs User Guide Step 1 Lokinet Installation Step 2 Accessing SNApps Step 3 Joining the lokinet IRC Chat Step 4 Hosting a SNApp Getting Help and Reporting Bugs Guidelines \u00b6 The purpose of doing a public testing phase is to collect as much feedback as possible. To make this easier for both our testers and the Lokinet team, we ask that our testers stick to the following guidelines. Getting Help \u00b6 If something in this guide isn\u2019t making sense, or if you\u2019re running into issues that you can\u2019t identify on your own, the first place to go would be the #lokinet-help channel on discord . Alternatively, you can find help on our other communication channels such as telegram , twitter , or reddit . Reporting Bugs \u00b6 After you have sought out for help through our communication channels and have not come to any solutions we recommend opening up a issue ticket on the Loki-network repository. Please use the following Github Issue Template for any github issues created: Github Issue Template Example . User Guide \u00b6 We have laid out a set of guides which will take you through the installation of Lokinet to hosting your own SNApp . We suggest going through each guide in the following order: 1. Lokinet Installation \u00b6 This guide will help prepare your computer to run Lokinet, depending on your system jump into the following guide: Linux Installation \u00b6 To access the guide click here The guide will cover: Setting up a non root user and giving this user admin access. Updating your Package lists and installing required updates. Install Lokinet Windows Installation \u00b6 To access the guide click here . This guide will cover: Setting up a non root user. Downloading the latest windows installer. Installing the Lokinet Launcher. Configuring DNS server. Follow the guide and report to the moderators with any issues on the #lokinet-help channel on discord . Dont forget to report any build issues if you find them, especially if you solved the issue. Mac OSX Installation \u00b6 To access the guide click here . This guide will cover: Downloading the latest Mac OSX installer. Installing the Lokinet Launcher. Configuring DNS server. Follow the guide and report to the moderators with any issues on the #lokinet-help channel on discord . Dont forget to report any build issues if you find them, especially if you solved the issue. 2. Accessing SNApps \u00b6 This guide will help you gain access to SNApps, to access the guide click here . The guide will cover: Initialising Lokinet for the first time. Running ./lokinet . Accessing your first SNApp. Follow the guide and report to the moderators with any issues on the #lokinet-help channel on discord . Dont forget to report your issues to the Loki-network repository if you find them, especially if you solved the issue. 3. Joining a Lokinet IRC Chat \u00b6 This guide will help you gain access to lokinet IRC channels, to access the guide click here . Alternatively, all you need to do is download your favourite IRC client, have ./lokinet running and connect to a server with the following address http://dw68y1xhptqbhcm5s8aaaip6dbopykagig5q5u1za4c7pzxto77y.loki with port 6667 and join channel #lokinet . 4. Hosting a SNApp \u00b6 This guide will help you host your own SNApp, to access the guide click here . The guide will cover: Finding your Lokinet pubkey. Editing our lokinet.ini file to enable persistent SNApps. Creating a directory for your SNApp's code. Creating an index.html file with Hello Lokinet to display to the network. Serving your SNApp directory to the Lokinet and accessing it through your browser. Follow the guide and report to the moderators with any issues on the #lokinet-help channel on discord . Dont forget to report your issues to the Loki-network repository if you find them, especially if you solved the issue.","title":"Public Testing Overview"},{"location":"Lokinet/Guides/PublicTestingGuide/#lokinet-public-testing-guide","text":"Thanks for your interest in the public testing phase of the Lokinet alpha. It\u2019s taken many months to get to this point, but we\u2019re grateful to everyone who wants to give this new type of onion router a spin. This guide will help you get Lokinet running on your machine, and give you some example tasks on things you can do to help put the software through its paces and help us find places where it needs to be fixed or can be improved. The more machines we get this running on, and the more traffic (and types of traffic) we can push through this alpha network, the better. You can run the Loki software on any operating system. The binaries available for Linux (as .deb package), Windows 32 and 64-bit, OSX on lokinet.org website.","title":"Lokinet Public Testing Guide"},{"location":"Lokinet/Guides/PublicTestingGuide/#table-of-contents","text":"Overview of Lokinet Getting Help and Reporting Bugs Guidelines Getting Help Reporting Bugs User Guide Step 1 Lokinet Installation Step 2 Accessing SNApps Step 3 Joining the lokinet IRC Chat Step 4 Hosting a SNApp","title":"Table of Contents"},{"location":"Lokinet/Guides/PublicTestingGuide/#getting-help-and-reporting-bugs-guidelines","text":"The purpose of doing a public testing phase is to collect as much feedback as possible. To make this easier for both our testers and the Lokinet team, we ask that our testers stick to the following guidelines.","title":"Getting Help and Reporting Bugs Guidelines"},{"location":"Lokinet/Guides/PublicTestingGuide/#getting-help","text":"If something in this guide isn\u2019t making sense, or if you\u2019re running into issues that you can\u2019t identify on your own, the first place to go would be the #lokinet-help channel on discord . Alternatively, you can find help on our other communication channels such as telegram , twitter , or reddit .","title":"Getting Help"},{"location":"Lokinet/Guides/PublicTestingGuide/#reporting-bugs","text":"After you have sought out for help through our communication channels and have not come to any solutions we recommend opening up a issue ticket on the Loki-network repository. Please use the following Github Issue Template for any github issues created: Github Issue Template Example .","title":"Reporting Bugs"},{"location":"Lokinet/Guides/PublicTestingGuide/#user-guide","text":"We have laid out a set of guides which will take you through the installation of Lokinet to hosting your own SNApp . We suggest going through each guide in the following order:","title":"User Guide"},{"location":"Lokinet/Guides/PublicTestingGuide/#1-lokinet-installation","text":"This guide will help prepare your computer to run Lokinet, depending on your system jump into the following guide:","title":"1. Lokinet Installation"},{"location":"Lokinet/Guides/PublicTestingGuide/#linux-installation","text":"To access the guide click here The guide will cover: Setting up a non root user and giving this user admin access. Updating your Package lists and installing required updates. Install Lokinet","title":"Linux Installation"},{"location":"Lokinet/Guides/PublicTestingGuide/#windows-installation","text":"To access the guide click here . This guide will cover: Setting up a non root user. Downloading the latest windows installer. Installing the Lokinet Launcher. Configuring DNS server. Follow the guide and report to the moderators with any issues on the #lokinet-help channel on discord . Dont forget to report any build issues if you find them, especially if you solved the issue.","title":"Windows Installation"},{"location":"Lokinet/Guides/PublicTestingGuide/#mac-osx-installation","text":"To access the guide click here . This guide will cover: Downloading the latest Mac OSX installer. Installing the Lokinet Launcher. Configuring DNS server. Follow the guide and report to the moderators with any issues on the #lokinet-help channel on discord . Dont forget to report any build issues if you find them, especially if you solved the issue.","title":"Mac OSX Installation"},{"location":"Lokinet/Guides/PublicTestingGuide/#2-accessing-snapps","text":"This guide will help you gain access to SNApps, to access the guide click here . The guide will cover: Initialising Lokinet for the first time. Running ./lokinet . Accessing your first SNApp. Follow the guide and report to the moderators with any issues on the #lokinet-help channel on discord . Dont forget to report your issues to the Loki-network repository if you find them, especially if you solved the issue.","title":"2. Accessing SNApps"},{"location":"Lokinet/Guides/PublicTestingGuide/#3-joining-a-lokinet-irc-chat","text":"This guide will help you gain access to lokinet IRC channels, to access the guide click here . Alternatively, all you need to do is download your favourite IRC client, have ./lokinet running and connect to a server with the following address http://dw68y1xhptqbhcm5s8aaaip6dbopykagig5q5u1za4c7pzxto77y.loki with port 6667 and join channel #lokinet .","title":"3. Joining a Lokinet IRC Chat"},{"location":"Lokinet/Guides/PublicTestingGuide/#4-hosting-a-snapp","text":"This guide will help you host your own SNApp, to access the guide click here . The guide will cover: Finding your Lokinet pubkey. Editing our lokinet.ini file to enable persistent SNApps. Creating a directory for your SNApp's code. Creating an index.html file with Hello Lokinet to display to the network. Serving your SNApp directory to the Lokinet and accessing it through your browser. Follow the guide and report to the moderators with any issues on the #lokinet-help channel on discord . Dont forget to report your issues to the Loki-network repository if you find them, especially if you solved the issue.","title":"4. Hosting a SNApp"},{"location":"Lokinet/Guides/ReverseSSHGuide/","text":"How to set up free, anonymous reverse SSH \u00b6 Have you ever wanted to be able to access a computer behind a firewall or NAT, but didn't want to pay for (or set up) a complicated reverse SSH proxy? Have you ever wanted to set up your VPS or virtual machine so that you can access it anonymously via SSH? Lokinet lets you accomplish both these goals simultaneously. This guide will walk you through the process. Step 1 - Install Lokinet on the computer you want to SSH into (the \u2018host\u2019) \u00b6 Note: This guide currently covers Linux operating systems, but we will add macOS instructions soon. Install curl if you don\u2019t have it already (this will let us download and verify Lokinet): sudo apt install curl Add the Lokinet debian repo GPG Keys: curl -s https://deb.imaginary.stream/public.gpg | sudo apt-key add - Confirm which release you need to download: echo \"deb https://deb.imaginary.stream $(lsb_release -sc) main\" | sudo tee /etc/apt/sources.list.d/imaginary.stream.list Resync your package repositories: sudo apt update Install Lokinet: sudo apt install lokinet Make your .loki address static (you might have to remove the ~ from this command depending on which user you are logged in as): sudo nano ~/etc/loki/lokinet.ini Scroll to the bottom of the file in the [Network] section and add the following line: keyfile=/var/lib/lokinet/snappkey.private Restart Lokinet: sudo systemctl restart lokinet Step 2 - Get your .loki address \u00b6 Get your Lokinet address by running the following command. Once you run the command, look for an address in a format similar to m7zy3dpi1dyui91enond31a6acgd538934k6kpasati4yfrku5oy.loki (this will be your .loki address). dig @127.3.2.1 -t cname localhost.loki Step 3. Configure the computer you want to access your machine from (the \u2018client\u2019) \u00b6 On the client computer, download a Lokinet client from here . Once you have downloaded, launch the client, press the big green button, and Lokinet will start intercepting requests to .loki addresses Step 4 - Connect with your favourite SSH client \u00b6 Open your SSH client (any SSH client should do fine; I\u2019m using Putty for demonstration purposes) and enter the .loki address instead of the IP address/hostname. You should connect anonymously, bypassing NAT and firewalls. What\u2019s going on behind the scenes? \u00b6 When you install Lokinet on the host computer, Lokinet creates a type of multi-hop tunnel to a number of nodes in the Loki Service Node network. Functionally, this is very similar to how Tor hidden services work, except instead of getting a .onion address, you get a .loki address. On the SSH client side, when you enter the .loki address and start the connection process, your Lokinet client intercepts the DNS call to your system resolver and uses Lokinet to construct a DHT lookup for that .loki address. Once Lokinet finds the right introset, it creates a path from itself to the host computer\u2019s endpoint, represented as D in the diagram below: Client -> A -> B -> C -> D <- E <- F <-G <- Host Once a client is communicating with D successfully over Lokinet, all SSH commands follow this path back to the host. Anonymity is maintained on both client and server sides: both the SSH host\u2019s IP address and the client\u2019s IP address are kept secret at all times. Lokinet is a powerful tool for traversing NAT and firewalls, and for maintaining anonymity when connecting to remote servers. Because Lokinet operates on Layer 3 (the network layer) \u2014 instead of Layer 4 (the transport Layer) like Tor \u2014 Lokinet can carry any IP based protocol, including UDP, TCP and ICMP packets.","title":"Anonymous Reverse SSH Guide"},{"location":"Lokinet/Guides/ReverseSSHGuide/#how-to-set-up-free-anonymous-reverse-ssh","text":"Have you ever wanted to be able to access a computer behind a firewall or NAT, but didn't want to pay for (or set up) a complicated reverse SSH proxy? Have you ever wanted to set up your VPS or virtual machine so that you can access it anonymously via SSH? Lokinet lets you accomplish both these goals simultaneously. This guide will walk you through the process.","title":"How to set up free, anonymous reverse SSH"},{"location":"Lokinet/Guides/ReverseSSHGuide/#step-1-install-lokinet-on-the-computer-you-want-to-ssh-into-the-host","text":"Note: This guide currently covers Linux operating systems, but we will add macOS instructions soon. Install curl if you don\u2019t have it already (this will let us download and verify Lokinet): sudo apt install curl Add the Lokinet debian repo GPG Keys: curl -s https://deb.imaginary.stream/public.gpg | sudo apt-key add - Confirm which release you need to download: echo \"deb https://deb.imaginary.stream $(lsb_release -sc) main\" | sudo tee /etc/apt/sources.list.d/imaginary.stream.list Resync your package repositories: sudo apt update Install Lokinet: sudo apt install lokinet Make your .loki address static (you might have to remove the ~ from this command depending on which user you are logged in as): sudo nano ~/etc/loki/lokinet.ini Scroll to the bottom of the file in the [Network] section and add the following line: keyfile=/var/lib/lokinet/snappkey.private Restart Lokinet: sudo systemctl restart lokinet","title":"Step 1 - Install Lokinet on the computer you want to SSH into (the \u2018host\u2019)"},{"location":"Lokinet/Guides/ReverseSSHGuide/#step-2-get-your-loki-address","text":"Get your Lokinet address by running the following command. Once you run the command, look for an address in a format similar to m7zy3dpi1dyui91enond31a6acgd538934k6kpasati4yfrku5oy.loki (this will be your .loki address). dig @127.3.2.1 -t cname localhost.loki","title":"Step 2 - Get your .loki address"},{"location":"Lokinet/Guides/ReverseSSHGuide/#step-3-configure-the-computer-you-want-to-access-your-machine-from-the-client","text":"On the client computer, download a Lokinet client from here . Once you have downloaded, launch the client, press the big green button, and Lokinet will start intercepting requests to .loki addresses","title":"Step 3. Configure the computer you want to access your machine from (the \u2018client\u2019)"},{"location":"Lokinet/Guides/ReverseSSHGuide/#step-4-connect-with-your-favourite-ssh-client","text":"Open your SSH client (any SSH client should do fine; I\u2019m using Putty for demonstration purposes) and enter the .loki address instead of the IP address/hostname. You should connect anonymously, bypassing NAT and firewalls.","title":"Step 4 - Connect with your favourite SSH client"},{"location":"Lokinet/Guides/ReverseSSHGuide/#whats-going-on-behind-the-scenes","text":"When you install Lokinet on the host computer, Lokinet creates a type of multi-hop tunnel to a number of nodes in the Loki Service Node network. Functionally, this is very similar to how Tor hidden services work, except instead of getting a .onion address, you get a .loki address. On the SSH client side, when you enter the .loki address and start the connection process, your Lokinet client intercepts the DNS call to your system resolver and uses Lokinet to construct a DHT lookup for that .loki address. Once Lokinet finds the right introset, it creates a path from itself to the host computer\u2019s endpoint, represented as D in the diagram below: Client -> A -> B -> C -> D <- E <- F <-G <- Host Once a client is communicating with D successfully over Lokinet, all SSH commands follow this path back to the host. Anonymity is maintained on both client and server sides: both the SSH host\u2019s IP address and the client\u2019s IP address are kept secret at all times. Lokinet is a powerful tool for traversing NAT and firewalls, and for maintaining anonymity when connecting to remote servers. Because Lokinet operates on Layer 3 (the network layer) \u2014 instead of Layer 4 (the transport Layer) like Tor \u2014 Lokinet can carry any IP based protocol, including UDP, TCP and ICMP packets.","title":"What\u2019s going on behind the scenes?"},{"location":"Lokinet/Guides/RouteThroughExitNode/","text":"Route through Exit Node \u00b6 1. Lokinet Installation \u00b6 To install Lokinet, see the install guide here . After the guide is finished you should have installed the dependencies and built Lokinet. 2. Lokinet Setup \u00b6 To setup and run Lokinet, see the accessing SNApps guide here . After the above guide is finished you should be able to run lokinet and be able to access SNApps. 3. Route Configuration \u00b6 To use an exit node as a client, you need to change the [network] section in ~/.lokinet/lokinet.ini Use the following command to access your lokinet.ini file. nano ~/.lokinet/lokinet.ini Use your arrow keys to to scroll down to the network settings. # network settings [network] profiles=/home/modeify/.lokinet/profiles.dat # uncomment next line to add router with pubkey to list of routers we connect directly to #strict-connect=pubkey # uncomment next line to use router with pubkey as an exit node #exit-node=pubkey ifname=lokitun0 ifaddr=172.16.10.1/24 enabled=true Delete the # in front of strict-connect and exit-node . Replace pubkey next to strict-connect with one of the following pubkeys, also take note of the IP address attached to the pubkey. 8df8ca1cc9d39d381f0efafdf58e2569457675a1e543189bea8279522aee6461 167.114.185.46 3dcb5a34d015a7bbb4636be83991e00cbeff13fe7834e0d5452ffe9a5af5a5be 162.243.164.223 Next replace pubkey next to exit-node with the following pubkey: b61df944b8547af56201c6c7528ed86289566dcf73358c5ef8e3b4e628671399 Your network settings section should now look like the following: # network settings [network] profiles=/home/modeify/.lokinet/profiles.dat # uncomment next line to add router with pubkey to list of routers we connect d$ strict-connect=3dcb5a34d015a7bbb4636be83991e00cbeff13fe7834e0d5452ffe9a5af5a5be # uncomment next line to use router with pubkey as an exit node exit-node=b61df944b8547af56201c6c7528ed86289566dcf73358c5ef8e3b4e628671399 ifname=lokitun0 ifaddr=172.16.10.1/24 enabled=true Hold Ctrl and click x , the terminal will prompt you to confirm changes. Click y and then enter to continue. This sets our computer to use an exit node by its public identity key and sets a strict first hop by its public identity key. Setting a strict first allows for the routing table to be set up easily. 4. Finding your Default Gateway \u00b6 On linux, run the following command: ip route | grep default On macOS, run the following command: route get default | grep gateway The IP address shown is your default gateway, for our example our IP is 10.0.2.2 . 5. Set up Routes \u00b6 In the following example the first hop is 162.243.164.223 which is connected to the pubkey 3dcb5a34d015a7bbb4636be83991e00cbeff13fe7834e0d5452ffe9a5af5a5be . If you used a different pubkey as your first hop you must replace the IP address in the example with the one associated with it. Linux \u00b6 To route everything through a Lokinet Exit Node run the following command. Replacing <first hop> with your first hop IP address and <default gateway> with your default gateway. sudo ip route add <first hop> via <default gateway> For this example the command is: sudo ip route add 162.243.164.223 via 10.0.2.2 Next run the following command to remove your default: sudo ip route del default At this point make sure you are running lokinet , you should have lokinet running from section 2 . While lokinet is running open up a new terminal and run the following command: sudo ip route add default dev lokitun0 If you want to unset the route everything over lokinet route do the following as root: sudo ip route del default sudo ip route add default via <default gateway> macOS \u00b6 To route everything through a Lokinet Exit Node run the following command. Replacing <first hop> with your first hop IP address and <default gateway> with your default gateway. sudo route add <first hop> <default gateway> For this example the command is: sudo route add 162.243.164.223 10.0.2.2 Next run the following command to remove your default: sudo route delete default At this point make sure you are running lokinet , you should have lokinet running from section 2 . While lokinet is running open up a new terminal and run the following command: sudo route add default -interface lokitun0 If you want to unset the route everything over lokinet route do the following as root: sudo route delete default sudo route add default <default gateway> Done \u00b6 Now when you browse the internet your IP address will be obfuscated. Go to a \"where is my location\" website to see if your IP appears to be in Romania. Finish \u00b6 Well done, you have finished the guide. Jump back into the Lokinet Public Testing Guide here .","title":"Route through Exit Node"},{"location":"Lokinet/Guides/RouteThroughExitNode/#route-through-exit-node","text":"","title":"Route through Exit Node"},{"location":"Lokinet/Guides/RouteThroughExitNode/#1-lokinet-installation","text":"To install Lokinet, see the install guide here . After the guide is finished you should have installed the dependencies and built Lokinet.","title":"1. Lokinet Installation"},{"location":"Lokinet/Guides/RouteThroughExitNode/#2-lokinet-setup","text":"To setup and run Lokinet, see the accessing SNApps guide here . After the above guide is finished you should be able to run lokinet and be able to access SNApps.","title":"2. Lokinet Setup"},{"location":"Lokinet/Guides/RouteThroughExitNode/#3-route-configuration","text":"To use an exit node as a client, you need to change the [network] section in ~/.lokinet/lokinet.ini Use the following command to access your lokinet.ini file. nano ~/.lokinet/lokinet.ini Use your arrow keys to to scroll down to the network settings. # network settings [network] profiles=/home/modeify/.lokinet/profiles.dat # uncomment next line to add router with pubkey to list of routers we connect directly to #strict-connect=pubkey # uncomment next line to use router with pubkey as an exit node #exit-node=pubkey ifname=lokitun0 ifaddr=172.16.10.1/24 enabled=true Delete the # in front of strict-connect and exit-node . Replace pubkey next to strict-connect with one of the following pubkeys, also take note of the IP address attached to the pubkey. 8df8ca1cc9d39d381f0efafdf58e2569457675a1e543189bea8279522aee6461 167.114.185.46 3dcb5a34d015a7bbb4636be83991e00cbeff13fe7834e0d5452ffe9a5af5a5be 162.243.164.223 Next replace pubkey next to exit-node with the following pubkey: b61df944b8547af56201c6c7528ed86289566dcf73358c5ef8e3b4e628671399 Your network settings section should now look like the following: # network settings [network] profiles=/home/modeify/.lokinet/profiles.dat # uncomment next line to add router with pubkey to list of routers we connect d$ strict-connect=3dcb5a34d015a7bbb4636be83991e00cbeff13fe7834e0d5452ffe9a5af5a5be # uncomment next line to use router with pubkey as an exit node exit-node=b61df944b8547af56201c6c7528ed86289566dcf73358c5ef8e3b4e628671399 ifname=lokitun0 ifaddr=172.16.10.1/24 enabled=true Hold Ctrl and click x , the terminal will prompt you to confirm changes. Click y and then enter to continue. This sets our computer to use an exit node by its public identity key and sets a strict first hop by its public identity key. Setting a strict first allows for the routing table to be set up easily.","title":"3. Route Configuration"},{"location":"Lokinet/Guides/RouteThroughExitNode/#4-finding-your-default-gateway","text":"On linux, run the following command: ip route | grep default On macOS, run the following command: route get default | grep gateway The IP address shown is your default gateway, for our example our IP is 10.0.2.2 .","title":"4. Finding your Default Gateway"},{"location":"Lokinet/Guides/RouteThroughExitNode/#5-set-up-routes","text":"In the following example the first hop is 162.243.164.223 which is connected to the pubkey 3dcb5a34d015a7bbb4636be83991e00cbeff13fe7834e0d5452ffe9a5af5a5be . If you used a different pubkey as your first hop you must replace the IP address in the example with the one associated with it.","title":"5. Set up Routes"},{"location":"Lokinet/Guides/RouteThroughExitNode/#linux","text":"To route everything through a Lokinet Exit Node run the following command. Replacing <first hop> with your first hop IP address and <default gateway> with your default gateway. sudo ip route add <first hop> via <default gateway> For this example the command is: sudo ip route add 162.243.164.223 via 10.0.2.2 Next run the following command to remove your default: sudo ip route del default At this point make sure you are running lokinet , you should have lokinet running from section 2 . While lokinet is running open up a new terminal and run the following command: sudo ip route add default dev lokitun0 If you want to unset the route everything over lokinet route do the following as root: sudo ip route del default sudo ip route add default via <default gateway>","title":"Linux"},{"location":"Lokinet/Guides/RouteThroughExitNode/#macos","text":"To route everything through a Lokinet Exit Node run the following command. Replacing <first hop> with your first hop IP address and <default gateway> with your default gateway. sudo route add <first hop> <default gateway> For this example the command is: sudo route add 162.243.164.223 10.0.2.2 Next run the following command to remove your default: sudo route delete default At this point make sure you are running lokinet , you should have lokinet running from section 2 . While lokinet is running open up a new terminal and run the following command: sudo route add default -interface lokitun0 If you want to unset the route everything over lokinet route do the following as root: sudo route delete default sudo route add default <default gateway>","title":"macOS"},{"location":"Lokinet/Guides/RouteThroughExitNode/#done","text":"Now when you browse the internet your IP address will be obfuscated. Go to a \"where is my location\" website to see if your IP appears to be in Romania.","title":"Done"},{"location":"Lokinet/Guides/RouteThroughExitNode/#finish","text":"Well done, you have finished the guide. Jump back into the Lokinet Public Testing Guide here .","title":"Finish"},{"location":"Lokinet/Guides/lokinet-linux-guide/","text":"LokiNET install guide - Linux \u00b6 Author: Jason (jagerman), Johnathan (SonOfOtis) Source: https://deb.imaginary.stream/ Initial Setup for Linux \u00b6 1. Computer Preparation \u00b6 We should update our package lists, the below command downloads the package lists from the repositories and \"updates\" them to get information on the newest versions of packages and their dependencies. It will do this for all repositories and PPAs. Run the following command: sudo apt-get update You will notice a bunch of package lists were downloaded, once this is complete run the below command to fetch new versions of any packages we currently have installed on the system. sudo apt-get upgrade You will be prompted to authorise the use of disk space, type y and enter to authorise. Note: If you are prompted at any time that a version of any file is available then click the up and down arrows until you are hovering over install the package maintainer\u2019s version and click enter. If you do not have curl installed on your computer then let's install it as we will use it later: sudo apt install curl 2. Installation \u00b6 You only need to do this step the first time you want to set up the repository; when you've done it once, the repository will automatically update whenever you fetch new system updates. To add the Loki apt repository run the following commands: The following command installed Jagermans public key used to sign the Binaries. curl -s https://deb.imaginary.stream/public.gpg | sudo apt-key add - The next command tells apt where to find the packages: echo \"deb https://deb.imaginary.stream $(lsb_release -sc) main\" | sudo tee /etc/apt/sources.list.d/imaginary.stream.list If your deb is not recognised then check out troubleshooting . Then resync your package repositories with: sudo apt update Now install lokinet: sudo apt install lokinet Congratulations, Lokinet is now installed and running in the background. Head over to the accessing SNApps guide here to access a SNApp. Next steps will teach us how to stop and start lokinet manually. Starting and Stopping lokinet. \u00b6 To start lokinet manually run the following command: sudo systemctl start lokinet and to stop lokinet manually run the following command: sudo systemctl stop lokinet Troubleshooting \u00b6 Failed to decode boostrap RC \u00b6 If you find your bootstrap has not configured properly run the following command: sudo lokinet-bootstrap and then restart your lokinet sudo systemctl restart lokinet Linux Mint does not work with (lsb-release) \u00b6 It has been reported that Linux Mint users can use the following command instead of the second command in 2. Installation : echo \"deb https://deb.imaginary.stream bionic main\" | sudo tee /etc/apt/sources.list.d/imaginary.stream.list Setting your DNS \u00b6 If you are having issues with resolving .loki addresses then we need to edit your resolv.conf files and add your dns resolver. Method 1 \u00b6 Run the following command: apt install resolvconf Then restart lokinet: systemctl restart lokinet Method 2 \u00b6 If Method 1 does not work we will need to add our nameserver manually. Run the following command: sudo nano /etc/resolvconf/resolv.conf.d/head Add the following at the bottom of this file: nameserver 127.3.2.1 Once that line is added hold CTRL and click x. Click enter to confirm the file changes. Next we need to update our /etc/resolv.conf file by running the command: sudo resolvconf -u Then restart lokinet: systemctl restart lokinet Updating Lokinet \u00b6 To update lokinet run the following command: sudo apt update && sudo apt install lokinet && sudo lokinet-bootstrap && sudo systemctl restart lokinet Finish \u00b6 Well done, you have finished the guide. Jump back into the Lokinet Public Testing Guide here .","title":"Linux Command-line Guide"},{"location":"Lokinet/Guides/lokinet-linux-guide/#lokinet-install-guide-linux","text":"Author: Jason (jagerman), Johnathan (SonOfOtis) Source: https://deb.imaginary.stream/","title":"LokiNET install guide - Linux"},{"location":"Lokinet/Guides/lokinet-linux-guide/#initial-setup-for-linux","text":"","title":"Initial Setup for Linux"},{"location":"Lokinet/Guides/lokinet-linux-guide/#1-computer-preparation","text":"We should update our package lists, the below command downloads the package lists from the repositories and \"updates\" them to get information on the newest versions of packages and their dependencies. It will do this for all repositories and PPAs. Run the following command: sudo apt-get update You will notice a bunch of package lists were downloaded, once this is complete run the below command to fetch new versions of any packages we currently have installed on the system. sudo apt-get upgrade You will be prompted to authorise the use of disk space, type y and enter to authorise. Note: If you are prompted at any time that a version of any file is available then click the up and down arrows until you are hovering over install the package maintainer\u2019s version and click enter. If you do not have curl installed on your computer then let's install it as we will use it later: sudo apt install curl","title":"1. Computer Preparation"},{"location":"Lokinet/Guides/lokinet-linux-guide/#2-installation","text":"You only need to do this step the first time you want to set up the repository; when you've done it once, the repository will automatically update whenever you fetch new system updates. To add the Loki apt repository run the following commands: The following command installed Jagermans public key used to sign the Binaries. curl -s https://deb.imaginary.stream/public.gpg | sudo apt-key add - The next command tells apt where to find the packages: echo \"deb https://deb.imaginary.stream $(lsb_release -sc) main\" | sudo tee /etc/apt/sources.list.d/imaginary.stream.list If your deb is not recognised then check out troubleshooting . Then resync your package repositories with: sudo apt update Now install lokinet: sudo apt install lokinet Congratulations, Lokinet is now installed and running in the background. Head over to the accessing SNApps guide here to access a SNApp. Next steps will teach us how to stop and start lokinet manually.","title":"2. Installation"},{"location":"Lokinet/Guides/lokinet-linux-guide/#starting-and-stopping-lokinet","text":"To start lokinet manually run the following command: sudo systemctl start lokinet and to stop lokinet manually run the following command: sudo systemctl stop lokinet","title":"Starting and Stopping lokinet."},{"location":"Lokinet/Guides/lokinet-linux-guide/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"Lokinet/Guides/lokinet-linux-guide/#failed-to-decode-boostrap-rc","text":"If you find your bootstrap has not configured properly run the following command: sudo lokinet-bootstrap and then restart your lokinet sudo systemctl restart lokinet","title":"Failed to decode boostrap RC"},{"location":"Lokinet/Guides/lokinet-linux-guide/#linux-mint-does-not-work-with-lsb-release","text":"It has been reported that Linux Mint users can use the following command instead of the second command in 2. Installation : echo \"deb https://deb.imaginary.stream bionic main\" | sudo tee /etc/apt/sources.list.d/imaginary.stream.list","title":"Linux Mint does not work with (lsb-release)"},{"location":"Lokinet/Guides/lokinet-linux-guide/#setting-your-dns","text":"If you are having issues with resolving .loki addresses then we need to edit your resolv.conf files and add your dns resolver.","title":"Setting your DNS"},{"location":"Lokinet/Guides/lokinet-linux-guide/#method-1","text":"Run the following command: apt install resolvconf Then restart lokinet: systemctl restart lokinet","title":"Method 1"},{"location":"Lokinet/Guides/lokinet-linux-guide/#method-2","text":"If Method 1 does not work we will need to add our nameserver manually. Run the following command: sudo nano /etc/resolvconf/resolv.conf.d/head Add the following at the bottom of this file: nameserver 127.3.2.1 Once that line is added hold CTRL and click x. Click enter to confirm the file changes. Next we need to update our /etc/resolv.conf file by running the command: sudo resolvconf -u Then restart lokinet: systemctl restart lokinet","title":"Method 2"},{"location":"Lokinet/Guides/lokinet-linux-guide/#updating-lokinet","text":"To update lokinet run the following command: sudo apt update && sudo apt install lokinet && sudo lokinet-bootstrap && sudo systemctl restart lokinet","title":"Updating Lokinet"},{"location":"Lokinet/Guides/lokinet-linux-guide/#finish","text":"Well done, you have finished the guide. Jump back into the Lokinet Public Testing Guide here .","title":"Finish"},{"location":"Lokinet/Guides/lokinet-mac-guide/","text":"Lokinet install guide - MacOS \u00b6 Install \u00b6 Download the latest mac installer here . Run the .PKG file After the installer is finished you should find the LokinetGUI application in your applications folder Run the Lokinet gui by double clicking on it Press the big green button to start or stop Lokinet Uninstalling \u00b6 To uninstall Lokinet run the following command in the Mac terminal: sudo /opt/lokinet/bin/lokinet_uninstall.sh Done! \u00b6 Well done, you have finished the guide. Jump back into the Lokinet Public Testing Guide here .","title":"macOS Gui Guide"},{"location":"Lokinet/Guides/lokinet-mac-guide/#lokinet-install-guide-macos","text":"","title":"Lokinet install guide - MacOS"},{"location":"Lokinet/Guides/lokinet-mac-guide/#install","text":"Download the latest mac installer here . Run the .PKG file After the installer is finished you should find the LokinetGUI application in your applications folder Run the Lokinet gui by double clicking on it Press the big green button to start or stop Lokinet","title":"Install"},{"location":"Lokinet/Guides/lokinet-mac-guide/#uninstalling","text":"To uninstall Lokinet run the following command in the Mac terminal: sudo /opt/lokinet/bin/lokinet_uninstall.sh","title":"Uninstalling"},{"location":"Lokinet/Guides/lokinet-mac-guide/#done","text":"Well done, you have finished the guide. Jump back into the Lokinet Public Testing Guide here .","title":"Done!"},{"location":"Lokinet/Guides/lokinet-windows-guide/","text":"Lokinet install guide - Windows 10 \u00b6 1. Download the latest Lokinet Windows Installer \u00b6 Head to lokinet.org , download the latest Windows Lokinet. 2. Run the installer \u00b6 Run Lokinet-win32.exe installer and allow permission as prompted. Please make note to set an exclusion or turn off Windows Defender/ Antivirus for this step. 3. Click install \u00b6 After reading through the dialogue boxes, hit install. 4. Click 'Finish' and start the launcher \u00b6 5. Hit the 'connect' button on the LokiNet Launcher \u00b6 6. You're done! \u00b6 You should now be connected. Troubleshooting \u00b6 Re-bootstrap \u00b6 If you are getting a bootstrap error code then go into Settings > Bootstrap Client from Web... > and then paste in the following url: https://seed.lokinet.org/bootstrap.signed Click OK and then reconnect to Lokinet.","title":"Loki Documentation | Lokinet Windows Install Guide | Onion Routing"},{"location":"Lokinet/Guides/lokinet-windows-guide/#lokinet-install-guide-windows-10","text":"","title":"Lokinet install guide - Windows 10"},{"location":"Lokinet/Guides/lokinet-windows-guide/#1-download-the-latest-lokinet-windows-installer","text":"Head to lokinet.org , download the latest Windows Lokinet.","title":"1. Download the latest Lokinet Windows Installer"},{"location":"Lokinet/Guides/lokinet-windows-guide/#2-run-the-installer","text":"Run Lokinet-win32.exe installer and allow permission as prompted. Please make note to set an exclusion or turn off Windows Defender/ Antivirus for this step.","title":"2. Run the installer"},{"location":"Lokinet/Guides/lokinet-windows-guide/#3-click-install","text":"After reading through the dialogue boxes, hit install.","title":"3. Click install"},{"location":"Lokinet/Guides/lokinet-windows-guide/#4-click-finish-and-start-the-launcher","text":"","title":"4. Click 'Finish' and start the launcher"},{"location":"Lokinet/Guides/lokinet-windows-guide/#5-hit-the-connect-button-on-the-lokinet-launcher","text":"","title":"5. Hit the 'connect' button on the LokiNet Launcher"},{"location":"Lokinet/Guides/lokinet-windows-guide/#6-youre-done","text":"You should now be connected.","title":"6. You're done!"},{"location":"Lokinet/Guides/lokinet-windows-guide/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"Lokinet/Guides/lokinet-windows-guide/#re-bootstrap","text":"If you are getting a bootstrap error code then go into Settings > Bootstrap Client from Web... > and then paste in the following url: https://seed.lokinet.org/bootstrap.signed Click OK and then reconnect to Lokinet.","title":"Re-bootstrap"},{"location":"Mining/ASICResistance/","text":"ASIC Resistance \u00b6 What is an ASIC? \u00b6 An Application-Specific Integrated Circuit (ASIC) is a computer chip that is built specifically for a single function. In the context of mining, ASICs are used to compute for specific hashing algorithms. They pose a risk to decentralisation because they outpace all other mining methods, are manufactured by specific companies, have very limited distribution channels due to the specialised nature of the hardware, and they require significant capital costs to develop and operate profitably. There are potential benefits to ASICs, such as the capital cost requirements that miners must undertake to invest in algorithm specific hardware which makes it less likely that they would behave in a manner that undermines their own investment by acting dishonestly. However, the distribution and manufacture of ASIC chips, with mature hashing algorithms, is still centralised around a few large companies. These companies can refuse shipment to certain areas, decide what regions and customers get the best performing ASICs, and they can structure limited runs and manipulate prices. Preventing ASIC Miners \u00b6 To prevent ASIC miners from monopolising the network hashrate, many cryptocurrencies developed ASIC resistant hashing algorithms, like Scrypt and Ethash . Until recently, Monero used the CryptoNight hashing algorithm, which requires large amounts of L3 cache to operate. In theory, this should have made it difficult to produce an ASIC chip due to large memory requirements. However in 2018 Bitmain released the X3, a CryptoNight specific ASIC that could effectively mine at ten times the speed of a graphics processing unit (GPU). Other hashing algorithms have suffered similar fates, with Scrypt, Ethash, and Equihash all now being mined by ASICs. How Monero and Loki combats ASIC resistance \u00b6 To combat the use of ASICs, Monero proposed a strategy of hard forking every 3-6 months to slightly change the CryptoNight hashing algorithm ( the first fork moving to CryptoNightV7 ). The capital and time required to build an ASIC is significant, and with highly specific hardware designs, slight tweaks in a hashing algorithm should invalidate the chip design, wasting the time and capital investment of ASIC manufacturers. However, this approach introduces its own issues. If changes made to the algorithm are insufficient to prevent ASICs being reprogrammed, then the network can become vulnerable to hashrate centralisation until another hard fork is possible. Field Programmable Gate Arrays (FPGAs) should also 12 be considered in ASIC resistance strategies, where infrequent, slight changes to hashing algorithms can be easily reprogrammed for FPGAs. Another concern is that regular changes to core consensus mechanisms introduce the chance of unintended bugs and generally centralise the development of such changes around the core team of developers. A number of alternative proof-of-work algorithms have been proposed to combat the need to hard fork regularly, including provably memory-hard hashing algorithms like Argon2 , Balloon hash , and polymorphic hashing algorithms like ProgPoW and RandProg . The Loki team will be publishing additional research on the aforementioned algorithms to develop a long-term solution to ASIC resistance.","title":"ASIC Resistance"},{"location":"Mining/ASICResistance/#asic-resistance","text":"","title":"ASIC Resistance"},{"location":"Mining/ASICResistance/#what-is-an-asic","text":"An Application-Specific Integrated Circuit (ASIC) is a computer chip that is built specifically for a single function. In the context of mining, ASICs are used to compute for specific hashing algorithms. They pose a risk to decentralisation because they outpace all other mining methods, are manufactured by specific companies, have very limited distribution channels due to the specialised nature of the hardware, and they require significant capital costs to develop and operate profitably. There are potential benefits to ASICs, such as the capital cost requirements that miners must undertake to invest in algorithm specific hardware which makes it less likely that they would behave in a manner that undermines their own investment by acting dishonestly. However, the distribution and manufacture of ASIC chips, with mature hashing algorithms, is still centralised around a few large companies. These companies can refuse shipment to certain areas, decide what regions and customers get the best performing ASICs, and they can structure limited runs and manipulate prices.","title":"What is an ASIC?"},{"location":"Mining/ASICResistance/#preventing-asic-miners","text":"To prevent ASIC miners from monopolising the network hashrate, many cryptocurrencies developed ASIC resistant hashing algorithms, like Scrypt and Ethash . Until recently, Monero used the CryptoNight hashing algorithm, which requires large amounts of L3 cache to operate. In theory, this should have made it difficult to produce an ASIC chip due to large memory requirements. However in 2018 Bitmain released the X3, a CryptoNight specific ASIC that could effectively mine at ten times the speed of a graphics processing unit (GPU). Other hashing algorithms have suffered similar fates, with Scrypt, Ethash, and Equihash all now being mined by ASICs.","title":"Preventing ASIC Miners"},{"location":"Mining/ASICResistance/#how-monero-and-loki-combats-asic-resistance","text":"To combat the use of ASICs, Monero proposed a strategy of hard forking every 3-6 months to slightly change the CryptoNight hashing algorithm ( the first fork moving to CryptoNightV7 ). The capital and time required to build an ASIC is significant, and with highly specific hardware designs, slight tweaks in a hashing algorithm should invalidate the chip design, wasting the time and capital investment of ASIC manufacturers. However, this approach introduces its own issues. If changes made to the algorithm are insufficient to prevent ASICs being reprogrammed, then the network can become vulnerable to hashrate centralisation until another hard fork is possible. Field Programmable Gate Arrays (FPGAs) should also 12 be considered in ASIC resistance strategies, where infrequent, slight changes to hashing algorithms can be easily reprogrammed for FPGAs. Another concern is that regular changes to core consensus mechanisms introduce the chance of unintended bugs and generally centralise the development of such changes around the core team of developers. A number of alternative proof-of-work algorithms have been proposed to combat the need to hard fork regularly, including provably memory-hard hashing algorithms like Argon2 , Balloon hash , and polymorphic hashing algorithms like ProgPoW and RandProg . The Loki team will be publishing additional research on the aforementioned algorithms to develop a long-term solution to ASIC resistance.","title":"How Monero and Loki combats ASIC resistance"},{"location":"Mining/Mining-With-SBC/","text":"Outdated Guide - To be rewritten for RandomX algo How to Mine Loki with an SBC \u00b6 This guide will get you started mining Loki on a Raspberry Pi or similar SBC (single-board computer). Setup \u00b6 Make sure you've already created a wallet on your PC. You'll need the wallet address to store any coins you mine. Follow the guide here to get started (follow the guide for Linux). For the SBC, download the latest non-desktop version of Raspbian . Follow their installation guide on how to write the OS image onto the MicroSD card. Once you've plugged in the SD Card, booted the Raspberry Pi, and connected it to the internet, run the following commands: sudo apt-get update && sudo apt-get upgrade This may take a few minutes. Next, we'll have to install some required tools to compile and run the miner. Enter this command: sudo apt-get install git automake autoconf pkg-config libcurl4-openssl-dev libjansson-dev libssl-dev libgmp-dev make g++ unzip Install the Miner \u00b6 Next, we need to obtain a CPU miner. We'll use rPi-xmrig-gcc7.3.0 Download the .zip source code from the Releases page wget https://github.com/auto-joe/rPi-xmrig-gcc7.3.0/archive/2.6.4.zip Download it to a directory of your choice and extract it to a folder called rPi-xmrig , or anything of your choice. unzip 2.6.4.zip Configure and Run the Miner \u00b6 Open the file start.sh with a text editor and replace the existing parameters with these: ./xmrig -a cryptonight-turtle -u [wallet address] -p x -o [pool address] Instead of [wallet address] , simply paste your Loki wallet address. If you don't have one yet, you can generate a paper wallet to mine towards for now, and later import into a CLI or GUI wallet. In place of [pool address] , you'll need to choose a pool to mine towards. You can check the full list here . Make the start file executable by running the following command: chmod +x start.sh Then start the miner- ./start.sh After entering this command, the miner will start scanning your hardware and begin to mine. Happy mining! :)","title":"Mining With SBC"},{"location":"Mining/Mining-With-SBC/#how-to-mine-loki-with-an-sbc","text":"This guide will get you started mining Loki on a Raspberry Pi or similar SBC (single-board computer).","title":"How to Mine Loki with an SBC"},{"location":"Mining/Mining-With-SBC/#setup","text":"Make sure you've already created a wallet on your PC. You'll need the wallet address to store any coins you mine. Follow the guide here to get started (follow the guide for Linux). For the SBC, download the latest non-desktop version of Raspbian . Follow their installation guide on how to write the OS image onto the MicroSD card. Once you've plugged in the SD Card, booted the Raspberry Pi, and connected it to the internet, run the following commands: sudo apt-get update && sudo apt-get upgrade This may take a few minutes. Next, we'll have to install some required tools to compile and run the miner. Enter this command: sudo apt-get install git automake autoconf pkg-config libcurl4-openssl-dev libjansson-dev libssl-dev libgmp-dev make g++ unzip","title":"Setup"},{"location":"Mining/Mining-With-SBC/#install-the-miner","text":"Next, we need to obtain a CPU miner. We'll use rPi-xmrig-gcc7.3.0 Download the .zip source code from the Releases page wget https://github.com/auto-joe/rPi-xmrig-gcc7.3.0/archive/2.6.4.zip Download it to a directory of your choice and extract it to a folder called rPi-xmrig , or anything of your choice. unzip 2.6.4.zip","title":"Install the Miner"},{"location":"Mining/Mining-With-SBC/#configure-and-run-the-miner","text":"Open the file start.sh with a text editor and replace the existing parameters with these: ./xmrig -a cryptonight-turtle -u [wallet address] -p x -o [pool address] Instead of [wallet address] , simply paste your Loki wallet address. If you don't have one yet, you can generate a paper wallet to mine towards for now, and later import into a CLI or GUI wallet. In place of [pool address] , you'll need to choose a pool to mine towards. You can check the full list here . Make the start file executable by running the following command: chmod +x start.sh Then start the miner- ./start.sh After entering this command, the miner will start scanning your hardware and begin to mine. Happy mining! :)","title":"Configure and Run the Miner"},{"location":"Mining/MiningOverview/","text":"What is Cryptocurrency Mining? \u00b6 Cryptocurrency Mining is the process of extracting Cryptocurrencies as a reward for securing and verifying transactions made on the blockchain. Miners use computers to work on computational puzzles that change in difficulty depending on the number of miners on the network. The difficulty changes in order to enforce that the blocks are mined at similar time intervals, also known as the Block Generation Time. Each generated block provides a reward in the form of a predetermined amount of cryptocurrency to the individual or party who found the solution to the puzzle. This reward is commonly known as the Block Reward and is coded to reduce its emission over time. Mining Loki \u00b6 The Loki cryptocurrency can be mined through the RandomXL hashing algorithm. How to mine Loki. \u00b6 Please note: Unfortunately (because of some bad people using mining software in malware), most antivirus software will detect the programs below as unsafe. It is likely you will need to add exceptions and exclusions to your antivirus software in order to make things work properly. Unless you know what you are doing, please only download from the links below. You can currently use XMR-Stak to mine Loki. Mining Pools \u00b6 A mining pool is a hub where a group of miners share their processing power to the network. The rewards are split equally based on the amount of hashing power each individual adds to the block. In the early days of Bitcoin mining it was viable to mine as an individual. However, because there now exists tens of thousands of miners it has become less viable to mine individually due to the share of each individual being minute compared to the overal hash of the network. Loki has a number of different mining pools to choose from: Pool Total Fee Min. Payout (Loki) aussie-pools.com 0.5% 1 miner.rocks 0.9% 0.5 hashvault.pro 0.9% 2 fairpool.xyz 1% 1 elasticpool.com 0.5% 2 Mining Loki in a mining pool requires the use of specific software such as XMR-STAK or XMRig. Resources \u00b6 The following are useful guides or resources for mining: List of Loki mining pools : Comprehensive list of all Loki mining pools. ASIC Resistance : Information on Loki's ASIC resistance.","title":"Overview"},{"location":"Mining/MiningOverview/#what-is-cryptocurrency-mining","text":"Cryptocurrency Mining is the process of extracting Cryptocurrencies as a reward for securing and verifying transactions made on the blockchain. Miners use computers to work on computational puzzles that change in difficulty depending on the number of miners on the network. The difficulty changes in order to enforce that the blocks are mined at similar time intervals, also known as the Block Generation Time. Each generated block provides a reward in the form of a predetermined amount of cryptocurrency to the individual or party who found the solution to the puzzle. This reward is commonly known as the Block Reward and is coded to reduce its emission over time.","title":"What is Cryptocurrency Mining?"},{"location":"Mining/MiningOverview/#mining-loki","text":"The Loki cryptocurrency can be mined through the RandomXL hashing algorithm.","title":"Mining Loki"},{"location":"Mining/MiningOverview/#how-to-mine-loki","text":"Please note: Unfortunately (because of some bad people using mining software in malware), most antivirus software will detect the programs below as unsafe. It is likely you will need to add exceptions and exclusions to your antivirus software in order to make things work properly. Unless you know what you are doing, please only download from the links below. You can currently use XMR-Stak to mine Loki.","title":"How to mine Loki."},{"location":"Mining/MiningOverview/#mining-pools","text":"A mining pool is a hub where a group of miners share their processing power to the network. The rewards are split equally based on the amount of hashing power each individual adds to the block. In the early days of Bitcoin mining it was viable to mine as an individual. However, because there now exists tens of thousands of miners it has become less viable to mine individually due to the share of each individual being minute compared to the overal hash of the network. Loki has a number of different mining pools to choose from: Pool Total Fee Min. Payout (Loki) aussie-pools.com 0.5% 1 miner.rocks 0.9% 0.5 hashvault.pro 0.9% 2 fairpool.xyz 1% 1 elasticpool.com 0.5% 2 Mining Loki in a mining pool requires the use of specific software such as XMR-STAK or XMRig.","title":"Mining Pools"},{"location":"Mining/MiningOverview/#resources","text":"The following are useful guides or resources for mining: List of Loki mining pools : Comprehensive list of all Loki mining pools. ASIC Resistance : Information on Loki's ASIC resistance.","title":"Resources"},{"location":"Mining/XMR-Stak-Linux-Guide/","text":"Outdated Guide - To be rewritten for RandomX algo How to Set Up XMR-Stak on Linux \u00b6 Native binaries may be available for your distribution's package manager. If no binaries are available, or you prefer to compile, follow these instructions: Ubuntu 16.04 \u00b6 Guide sponsored by Monerise & TurtleCoin If you want to use your GPU for mining, do the following: For AMD GPU\u2019s: Install drivers for your card download the latest APP SDK from here . It should have the name AMD-APP-SDKInstaller-v(version number)-GA-linux64.tar.bz2 Extract it Open the terminal wherever it is located (optional) name it to something simpler In the terminal, type ./(name).sh After installing, you should be good. For nVidia GPU\u2019s: Install drivers for your card Download the latest CUDA Toolkit from here . Download the base installer and follow the compilation instructions Download every patch one-by-one in order and apply the patches After that, you should be good. Open the terminal and install dependencies by running this command: sudo apt install libmicrohttpd-dev libssl-dev cmake build-essential libhwloc-dev Clone the package: git clone https://github.com/fireice-uk/xmr-stak.git Make a directory: mkdir xmr-stak/build Move over there: cd xmr-stak/build Run cmake: cmake .. If you don\u2019t have nVidia GPUs, type: cmake .. -DCUDA_ENABLE=OFF If you don\u2019t have AMD GPUs, type: cmake .. -DOpenCL_ENABLE=OFF If you have neither (only CPU mining) type: cmake .. -DCUDA_ENABLE=OFF -DOpenCL_ENABLE=OFF Finish building it: make install XMR-Stak will now be located in /home/user/xmr-stak/build/bin Type: ./xmr-stak Check XMR-Stak Setup and Configuration If you see something like this, that means it\u2019s working! XMR-Stak Setup and Configuration \u00b6 Upon first launching XMR-Stak, the software will ask you several setup and configuration questions. Please enter: - Do you want to use the HTTP interface? Unlike the screen display, browser interface is not affected by the GPU lag. If you don't want to use it, please enter 0, otherwise enter port number that the miner should listen on Enter 0 , if you do not need to remotely check your hashrate. If you do need to, then enter a port number. Let's take the port number as 0101 and your IP address as 26.24.105.14 as an example. To check the hashrate, enter in the address bar of your web browser, <26.24.105.14>:<0101> . It should show a page with your rig's hashrate. If you are checking from the same IP address, you can alternatively enter, localhost:<0101> Make sure to enter your own IP address if you enable this feature. You can choose any port you want! - Please enter the currency that you want to mine: - aeon7 - bbscoin - bittube - cryptonight - cryptonight_bittube2 - cryptonight_masari - cryptonight_haven - cryptonight_heavy - cryptonight_lite - cryptonight_lite_v7 - cryptonight_lite_v7_xor - cryptonight_superfast - cryptonight_turtle - cryptonight_v7 - cryptonight_v8 - cryptonight_v7_stellite - freehaven - graft - haven - intense - masari - monero - qrl - ryo - stellite - turtlecoin - plenteum Enter cryptonight_turtle Pool address: e.g. pool.example.com:3333 Choose a pool from any of the available pools that is closest to you and enter its URL (you will be able to add more later). Username (Wallet address or pool login): If you have not yet downloaded and ran the Loki core software to sync the blockchain and create a wallet, you can make a paper wallet to start mining towards now, and import the wallet later. Password (mostly empty or x): Enter x . Rig identifier for pool-side statistics (needs pool support). Can be empty: Leave it empty and press enter. Does this pool port support TLS/SSL? Use no if unknown. (y/n) In most cases, N is fine. Do you want to use nicehash on this pool? (y/n) Enter n (in case you do, enter y ). Do you want to use multiple pools? (y/n) Enter y if you would like to add more pools. Give them all a weight of 10 if you're tired of reading, or if you want the best experience, give the pools nearest to you a higher number, and the ones further from you a lower number. XMR-Stak will prioritize the highest weight pool, and fall back to the others if it cannot connect. If they are all given the same weight, it will connect to them in order of how they are listed, form top to bottom, in the configuration file. If you are on Windows 7/8, it will ask for administrator permission again. Click Yes to grant it permission. If you are on Windows 10, it will not ask for it again. Done! The miner will now start scanning your hardware and will begin mining. Awesome! XMR-Stak will save your configuration in config.txt in the same directory from which it was first run. Your configuration for pools(algorithm to mine, address, port etc) will be saved in pools.txt The configuration of the device it mines(CPU/AMD/NVIDIA) will be saved in cpu.txt , amd.txt or nvidia.txt , respectively. Run XMR-Stak again from the same directory to reuse the configuration. Source: \u00b6 TurtleCoin Wiki","title":"XMR Stak Linux Guide"},{"location":"Mining/XMR-Stak-Linux-Guide/#how-to-set-up-xmr-stak-on-linux","text":"Native binaries may be available for your distribution's package manager. If no binaries are available, or you prefer to compile, follow these instructions:","title":"How to Set Up XMR-Stak on Linux"},{"location":"Mining/XMR-Stak-Linux-Guide/#ubuntu-1604","text":"Guide sponsored by Monerise & TurtleCoin If you want to use your GPU for mining, do the following: For AMD GPU\u2019s: Install drivers for your card download the latest APP SDK from here . It should have the name AMD-APP-SDKInstaller-v(version number)-GA-linux64.tar.bz2 Extract it Open the terminal wherever it is located (optional) name it to something simpler In the terminal, type ./(name).sh After installing, you should be good. For nVidia GPU\u2019s: Install drivers for your card Download the latest CUDA Toolkit from here . Download the base installer and follow the compilation instructions Download every patch one-by-one in order and apply the patches After that, you should be good. Open the terminal and install dependencies by running this command: sudo apt install libmicrohttpd-dev libssl-dev cmake build-essential libhwloc-dev Clone the package: git clone https://github.com/fireice-uk/xmr-stak.git Make a directory: mkdir xmr-stak/build Move over there: cd xmr-stak/build Run cmake: cmake .. If you don\u2019t have nVidia GPUs, type: cmake .. -DCUDA_ENABLE=OFF If you don\u2019t have AMD GPUs, type: cmake .. -DOpenCL_ENABLE=OFF If you have neither (only CPU mining) type: cmake .. -DCUDA_ENABLE=OFF -DOpenCL_ENABLE=OFF Finish building it: make install XMR-Stak will now be located in /home/user/xmr-stak/build/bin Type: ./xmr-stak Check XMR-Stak Setup and Configuration If you see something like this, that means it\u2019s working!","title":"Ubuntu 16.04"},{"location":"Mining/XMR-Stak-Linux-Guide/#xmr-stak-setup-and-configuration","text":"Upon first launching XMR-Stak, the software will ask you several setup and configuration questions. Please enter: - Do you want to use the HTTP interface? Unlike the screen display, browser interface is not affected by the GPU lag. If you don't want to use it, please enter 0, otherwise enter port number that the miner should listen on Enter 0 , if you do not need to remotely check your hashrate. If you do need to, then enter a port number. Let's take the port number as 0101 and your IP address as 26.24.105.14 as an example. To check the hashrate, enter in the address bar of your web browser, <26.24.105.14>:<0101> . It should show a page with your rig's hashrate. If you are checking from the same IP address, you can alternatively enter, localhost:<0101> Make sure to enter your own IP address if you enable this feature. You can choose any port you want! - Please enter the currency that you want to mine: - aeon7 - bbscoin - bittube - cryptonight - cryptonight_bittube2 - cryptonight_masari - cryptonight_haven - cryptonight_heavy - cryptonight_lite - cryptonight_lite_v7 - cryptonight_lite_v7_xor - cryptonight_superfast - cryptonight_turtle - cryptonight_v7 - cryptonight_v8 - cryptonight_v7_stellite - freehaven - graft - haven - intense - masari - monero - qrl - ryo - stellite - turtlecoin - plenteum Enter cryptonight_turtle Pool address: e.g. pool.example.com:3333 Choose a pool from any of the available pools that is closest to you and enter its URL (you will be able to add more later). Username (Wallet address or pool login): If you have not yet downloaded and ran the Loki core software to sync the blockchain and create a wallet, you can make a paper wallet to start mining towards now, and import the wallet later. Password (mostly empty or x): Enter x . Rig identifier for pool-side statistics (needs pool support). Can be empty: Leave it empty and press enter. Does this pool port support TLS/SSL? Use no if unknown. (y/n) In most cases, N is fine. Do you want to use nicehash on this pool? (y/n) Enter n (in case you do, enter y ). Do you want to use multiple pools? (y/n) Enter y if you would like to add more pools. Give them all a weight of 10 if you're tired of reading, or if you want the best experience, give the pools nearest to you a higher number, and the ones further from you a lower number. XMR-Stak will prioritize the highest weight pool, and fall back to the others if it cannot connect. If they are all given the same weight, it will connect to them in order of how they are listed, form top to bottom, in the configuration file. If you are on Windows 7/8, it will ask for administrator permission again. Click Yes to grant it permission. If you are on Windows 10, it will not ask for it again. Done! The miner will now start scanning your hardware and will begin mining. Awesome! XMR-Stak will save your configuration in config.txt in the same directory from which it was first run. Your configuration for pools(algorithm to mine, address, port etc) will be saved in pools.txt The configuration of the device it mines(CPU/AMD/NVIDIA) will be saved in cpu.txt , amd.txt or nvidia.txt , respectively. Run XMR-Stak again from the same directory to reuse the configuration.","title":"XMR-Stak Setup and Configuration"},{"location":"Mining/XMR-Stak-Linux-Guide/#source","text":"TurtleCoin Wiki","title":"Source:"},{"location":"Mining/XMR-StakGuide/","text":"Outdated Guide - To be rewritten for RandomX algo How to setup XMR-Stak \u00b6 XMR-Stak is a unified miner, which means the same program will be used to mine with both your CPU and your GPU. It will automatically detect your hardware and adjust the settings accordingly. Downloading and Installing for Windows \u00b6 Download and install XMR-Stak Unified Miner . It will auto-detect your hardware, and tune everything for you. Make a folder called Loki Miner on your Desktop and unzip the files you just downloaded for XMR-Stak in there. Double-click on xmr-stak.exe . To start XMR-Stak without using your CPU/GPU, follow these steps \u00b6 Open Command Prompt Type cd Desktop\\Loki Miner To start XMR-Stak without utilising the CPU, type xmr-stak.exe --noCPU To start XMR-Stak without utilizing your nVidia GPU, type xmr-stak.exe --noNVIDIA To start XMR-Stak without utilizing your AMD GPU, type xmr-stak.exe --noAMD To start XMR-Stak without utilizing either of your GPU's, type xmr-stak.exe --noAMD --noNVIDIA If you want to use both your CPU and your GPU, ignore these steps. Just launch xmr-stak.exe Click Yes when it asks if you want to run as Administrator. This is so that the program can see what hardware you're running. Check XMR-Stak Setup and Configuration Downloading and Installing for Mac \u00b6 See here and here . Downloading and Installing for Linux \u00b6 View this guide to get started with XMR-Stak on Linux. XMR-Stak Setup and Configuration \u00b6 Upon first launching XMR-Stak, the software will ask you several setup and configuration questions. Please enter: - Do you want to use the HTTP interface? Unlike the screen display, browser interface is not affected by the GPU lag. If you don't want to use it, please enter 0, otherwise enter port number that the miner should listen on Enter 0 , if you are like most people, and do not need to remotely check your hashrate. If you do need to, then enter a port number. Let's take the port number as 0101 and your IP address as 26.24.105.14 as an example. To check the hashrate, enter in the address bar of your web browser, <26.24.105.14>:<0101> . It should show a page with your rig's hashrate. If you are checking from the same IP address, you can alternatively enter, localhost:<0101> Make sure to enter your own IP address if you enable this feature. You can choose any port you want(uptil 9999)! Please enter the currency that you want to mine: - aeon7 - bbscoin - bittube - cryptonight - cryptonight_bittube2 - cryptonight_masari - cryptonight_haven - cryptonight_heavy - cryptonight_lite - cryptonight_lite_v7 - cryptonight_lite_v7_xor - cryptonight_superfast - cryptonight_turtle - cryptonight_v7 - cryptonight_v8 - cryptonight_v7_stellite - freehaven - graft - haven - intense - masari - monero - qrl - ryo - stellite - turtlecoin - plenteum Enter cryptonight_turtle Pool address: e.g. pool.example.com:3333 Choose a pool from any of the available pools that is closest to you and enter its URL (you will be able to add more later). Username (Wallet address or pool login): If you have not yet downloaded and ran the Loki core software to sync the blockchain and create a wallet, you can make a paper wallet to start mining towards now, and import the wallet later. Password (mostly empty or x): Enter x . Rig identifier for pool-side statistics (needs pool support). Can be empty: Leave it empty and press enter. Does this pool port support TLS/SSL? Use no if unknown. (y/n) In most cases, N is fine. Do you want to use nicehash on this pool? (y/n) Enter n (in case you do, enter y ). Do you want to use multiple pools? (y/n) Enter y if you would like to add more pools. Give them all a weight of 10 if you're tired of reading, or if you want the best experience, give the pools nearest to you a higher number, and the ones further from you a lower number. XMR-Stak will prioritize the highest weight pool, and fall back to the others if it cannot connect. If they are all given the same weight, it will connect to them in order of how they are listed, form top to bottom, in the configuration file. If you are on Windows 7 or 8, it will ask for administrator permission again. Click Yes to grant it permission. If you are on Windows 10, it will not ask for it again. Done! The miner will now start scanning your hardware and will begin mining. Awesome! XMR-Stak will save your configuration in config.txt in the same directory from which it was first run. Your configuration for pools(algorithm to mine, address, port etc) will be saved in pools.txt . The configuration of the device it mines(CPU/AMD/NVIDIA) will be saved in cpu.txt , amd.txt or nvidia.txt , respectively. Run XMR-Stak again from the same directory to reuse the configuration. Source: \u00b6 TurtleCoin Wiki","title":"XMR StakGuide"},{"location":"Mining/XMR-StakGuide/#how-to-setup-xmr-stak","text":"XMR-Stak is a unified miner, which means the same program will be used to mine with both your CPU and your GPU. It will automatically detect your hardware and adjust the settings accordingly.","title":"How to setup XMR-Stak"},{"location":"Mining/XMR-StakGuide/#downloading-and-installing-for-windows","text":"Download and install XMR-Stak Unified Miner . It will auto-detect your hardware, and tune everything for you. Make a folder called Loki Miner on your Desktop and unzip the files you just downloaded for XMR-Stak in there. Double-click on xmr-stak.exe .","title":"Downloading and Installing for Windows"},{"location":"Mining/XMR-StakGuide/#to-start-xmr-stak-without-using-your-cpugpu-follow-these-steps","text":"Open Command Prompt Type cd Desktop\\Loki Miner To start XMR-Stak without utilising the CPU, type xmr-stak.exe --noCPU To start XMR-Stak without utilizing your nVidia GPU, type xmr-stak.exe --noNVIDIA To start XMR-Stak without utilizing your AMD GPU, type xmr-stak.exe --noAMD To start XMR-Stak without utilizing either of your GPU's, type xmr-stak.exe --noAMD --noNVIDIA If you want to use both your CPU and your GPU, ignore these steps. Just launch xmr-stak.exe Click Yes when it asks if you want to run as Administrator. This is so that the program can see what hardware you're running. Check XMR-Stak Setup and Configuration","title":"To start XMR-Stak without using your CPU/GPU, follow these steps  "},{"location":"Mining/XMR-StakGuide/#downloading-and-installing-for-mac","text":"See here and here .","title":"Downloading and Installing for Mac"},{"location":"Mining/XMR-StakGuide/#downloading-and-installing-for-linux","text":"View this guide to get started with XMR-Stak on Linux.","title":"Downloading and Installing for Linux"},{"location":"Mining/XMR-StakGuide/#xmr-stak-setup-and-configuration","text":"Upon first launching XMR-Stak, the software will ask you several setup and configuration questions. Please enter: - Do you want to use the HTTP interface? Unlike the screen display, browser interface is not affected by the GPU lag. If you don't want to use it, please enter 0, otherwise enter port number that the miner should listen on Enter 0 , if you are like most people, and do not need to remotely check your hashrate. If you do need to, then enter a port number. Let's take the port number as 0101 and your IP address as 26.24.105.14 as an example. To check the hashrate, enter in the address bar of your web browser, <26.24.105.14>:<0101> . It should show a page with your rig's hashrate. If you are checking from the same IP address, you can alternatively enter, localhost:<0101> Make sure to enter your own IP address if you enable this feature. You can choose any port you want(uptil 9999)! Please enter the currency that you want to mine: - aeon7 - bbscoin - bittube - cryptonight - cryptonight_bittube2 - cryptonight_masari - cryptonight_haven - cryptonight_heavy - cryptonight_lite - cryptonight_lite_v7 - cryptonight_lite_v7_xor - cryptonight_superfast - cryptonight_turtle - cryptonight_v7 - cryptonight_v8 - cryptonight_v7_stellite - freehaven - graft - haven - intense - masari - monero - qrl - ryo - stellite - turtlecoin - plenteum Enter cryptonight_turtle Pool address: e.g. pool.example.com:3333 Choose a pool from any of the available pools that is closest to you and enter its URL (you will be able to add more later). Username (Wallet address or pool login): If you have not yet downloaded and ran the Loki core software to sync the blockchain and create a wallet, you can make a paper wallet to start mining towards now, and import the wallet later. Password (mostly empty or x): Enter x . Rig identifier for pool-side statistics (needs pool support). Can be empty: Leave it empty and press enter. Does this pool port support TLS/SSL? Use no if unknown. (y/n) In most cases, N is fine. Do you want to use nicehash on this pool? (y/n) Enter n (in case you do, enter y ). Do you want to use multiple pools? (y/n) Enter y if you would like to add more pools. Give them all a weight of 10 if you're tired of reading, or if you want the best experience, give the pools nearest to you a higher number, and the ones further from you a lower number. XMR-Stak will prioritize the highest weight pool, and fall back to the others if it cannot connect. If they are all given the same weight, it will connect to them in order of how they are listed, form top to bottom, in the configuration file. If you are on Windows 7 or 8, it will ask for administrator permission again. Click Yes to grant it permission. If you are on Windows 10, it will not ask for it again. Done! The miner will now start scanning your hardware and will begin mining. Awesome! XMR-Stak will save your configuration in config.txt in the same directory from which it was first run. Your configuration for pools(algorithm to mine, address, port etc) will be saved in pools.txt . The configuration of the device it mines(CPU/AMD/NVIDIA) will be saved in cpu.txt , amd.txt or nvidia.txt , respectively. Run XMR-Stak again from the same directory to reuse the configuration.","title":"XMR-Stak Setup and Configuration"},{"location":"Mining/XMR-StakGuide/#source","text":"TurtleCoin Wiki","title":"Source:"},{"location":"Mining/XMRig-Guide/","text":"Outdated Guide - To be rewritten for RandomX algo XMRig Guide for TurtleCoin \u00b6 XMRig uses separate miners for CPU and GPU, you need to download a CPU and GPU miner separately and run two separate instances on your computer. Downloading and Installing for Windows \u00b6 XMRig has separate miners for CPU and GPU. You can download them from here: XMRig CPU Miner XMRig GPU Nvidia Miner XMRig GPU AMD Miner Note: You will need to download and run two separate instances if you want to mine with your GPU and CPU at the same time. Downloading and Installing for Linux \u00b6 You can directly use the pre-built binaries for XMRig CPU. Download the xmrig-*-xenial-amd64.tar.gz file here . Run the file using ./xmrig . XMRig needs to be compiled for nVidia and AMD. Instructions for compiling are linked below(Ubuntu): XMRig CPU Miner XMRig GPU Nvidia Miner XMRig GPU AMD Miner Downloading and Installing for Mac \u00b6 Needs to be compiled. Instructions here . XMRig Setup and Configuration \u00b6 XMRig Configuration \u00b6 Unzip the file and extract the files into a new folder (Make sure your anti-virus doesn't delete the files) Open the config.json file with Notepad Find and change the following lines: \"algo: \"cryptonight-turtle\" \"url: \"[pool address]\" \"user: \"[wallet address]\" \"variant\": 1 Instead of [wallet address] , simply paste your Loki wallet's address. Make sure to keep the \" ! If you don't have one yet, you can generate a[paper wallet to mine towards for now, and later import into a CLI or GUI wallet. In place of [pool address] , you'll need to choose a pool to mine towards. You can check the full list here . Make sure to keep the \" s! Save the file and: start xmrig.exe if you're mining with your CPU, xmrig-amd.exe . if you're mining with an AMD GPU, or xmrig-nvidia.exe if you're mining with a nVidia GPU. Remember: if you want to mine with both your CPU and your GPU you must have both programs open at the same time! That's it! You should be mining away now! :) Source: \u00b6 Turtlecoin Wiki","title":"XMRig Guide"},{"location":"Mining/XMRig-Guide/#xmrig-guide-for-turtlecoin","text":"XMRig uses separate miners for CPU and GPU, you need to download a CPU and GPU miner separately and run two separate instances on your computer.","title":"XMRig Guide for TurtleCoin"},{"location":"Mining/XMRig-Guide/#downloading-and-installing-for-windows","text":"XMRig has separate miners for CPU and GPU. You can download them from here: XMRig CPU Miner XMRig GPU Nvidia Miner XMRig GPU AMD Miner Note: You will need to download and run two separate instances if you want to mine with your GPU and CPU at the same time.","title":"Downloading and Installing for Windows"},{"location":"Mining/XMRig-Guide/#downloading-and-installing-for-linux","text":"You can directly use the pre-built binaries for XMRig CPU. Download the xmrig-*-xenial-amd64.tar.gz file here . Run the file using ./xmrig . XMRig needs to be compiled for nVidia and AMD. Instructions for compiling are linked below(Ubuntu): XMRig CPU Miner XMRig GPU Nvidia Miner XMRig GPU AMD Miner","title":"Downloading and Installing for Linux"},{"location":"Mining/XMRig-Guide/#downloading-and-installing-for-mac","text":"Needs to be compiled. Instructions here .","title":"Downloading and Installing for Mac"},{"location":"Mining/XMRig-Guide/#xmrig-setup-and-configuration","text":"","title":"XMRig Setup and Configuration"},{"location":"Mining/XMRig-Guide/#xmrig-configuration","text":"Unzip the file and extract the files into a new folder (Make sure your anti-virus doesn't delete the files) Open the config.json file with Notepad Find and change the following lines: \"algo: \"cryptonight-turtle\" \"url: \"[pool address]\" \"user: \"[wallet address]\" \"variant\": 1 Instead of [wallet address] , simply paste your Loki wallet's address. Make sure to keep the \" ! If you don't have one yet, you can generate a[paper wallet to mine towards for now, and later import into a CLI or GUI wallet. In place of [pool address] , you'll need to choose a pool to mine towards. You can check the full list here . Make sure to keep the \" s! Save the file and: start xmrig.exe if you're mining with your CPU, xmrig-amd.exe . if you're mining with an AMD GPU, or xmrig-nvidia.exe if you're mining with a nVidia GPU. Remember: if you want to mine with both your CPU and your GPU you must have both programs open at the same time! That's it! You should be mining away now! :)","title":"XMRig Configuration"},{"location":"Mining/XMRig-Guide/#source","text":"Turtlecoin Wiki","title":"Source:"},{"location":"ServiceNodes/DebianPackageGuide/","text":"Debian Package Guide \u00b6 Author: Jason (jagerman) Source: https://deb.imaginary.stream/ This repository contains debian/ubuntu builds of the core loki tools (lokid, cli/rpc wallets, blockchain tools) for Debian and Ubuntu. Requirements \u00b6 One of: Debian 9 (\"stretch\") Debian 10 (\"buster\") Debian unstable (\"sid\") Ubuntu 16.04 (\"xenial\") Ubuntu 18.04 (\"bionic\") Ubuntu 19.10 (\"eoan\") Ubuntu 20.04 (\"focal\") Note: Debian 9 and Ubuntu 16.04 are not recommended for new installations as support for them is likely to be deprecated soon. Express Guide \u00b6 Start a new service node by running these four commands: curl -s https://deb.imaginary.stream/public.gpg | sudo apt-key add - echo \"deb https://deb.imaginary.stream $(lsb_release -sc) main\" | sudo tee /etc/apt/sources.list.d/imaginary.stream.list apt update apt install loki-service-node The services will run via systemd as loki-node.service , loki-storage-server.service , and lokinet-router.service . Full Guide \u00b6 1: Initial Repository Setup \u00b6 You only need to do this step the first time you want to set up the repository; when you've done it once, the repository will automatically update whenever you fetch new system updates. To add the apt repository run the following command, replacing <DISTRO> in the second line with the appropriate value (see below). The following command installed Jagermans public key used to sign the Binaries. curl -s https://deb.imaginary.stream/public.gpg | sudo apt-key add - The second command tells apt where to find the packages and needs you to replace <DISTRO> with your distro. To find your <Distro> run the following command: lsb_release -sc Alternatively your <Distro> can be found by using the following list: sid (Debian testing/unstable) stretch (Debian 9) buster (Debian 10) xenial (Ubuntu 16.04) bionic (Ubuntu 18.04) eoan (Ubuntu 19.10) focal (Ubuntu 20.04) echo \"deb https://deb.imaginary.stream <DISTRO> main\" | sudo tee /etc/apt/sources.list.d/imaginary.stream.list Then resync your package repositories with: sudo apt update Now you can install one or more of the following packages as desired: Package Description loki-service-node Metapackage that does everything you need for a running service node. lokid The loki daemon (automatically pulled in by loki-service-node ). loki-storage-server The loki storage server, required for a service node (automatically pulled in by loki-service-node ). lokinet-router The lokinet package configured to run as a router (automatically pulled in by loki-service-node ). loki-wallet-cli The command-line wallet. loki-wallet-rpc The rpc wallet (for script-based wallet interaction such as a pool would need). loki-blockchain-tools the various loki-blockchain-* commands for advanced blockchain management. lokinet-client The lokinet package configured to run as a client to access lokinet. (Not for service nodes). There are also a few library packages such as libloki-core* containing the shared library code, as well as some backports of updated software for the older distributions; these can typically be ignored and will be installed automatically as needed. There is also a libloki-core-dev package containing the loki headers, but it's highly unlikely that you will need that for common use. Installing a Package \u00b6 To install a package run the following command replacing with one of the packages available above: sudo apt install <package> For example: To install loki-service-node package run the following command: sudo apt install loki-service-node 2. Loki Service Node Operation \u00b6 Running a service node requires multiple packages (lokid and loki-storage-server) with synchronized configuration between them. There are two ways to approach this: Automatic : \u00b6 Install the loki-service-node package. sudo apt install loki-service-node This will detect your public IP (or allow you to enter it yourself) and automatically update the loki.conf configuration file with the necessary additional settings to run a service node. Manually : \u00b6 Install the lokid , loki-storage-server , and lokinet-router packages: sudo apt install lokid loki-storage-server lokinet-router Then edit the configuration as desired in /etc/loki/loki.conf , /etc/loki/storage.conf , and /etc/loki/lokinet-router.ini . (See the next section for details). Restart any of these after configuration updates using one or more of: systemctl restart loki-node systemctl restart loki-storage-server systemctl restart lokinet-router Adding flags to config file. \u00b6 Note that you can add any of lokid's command-line arguments as settings in this file rather than needing to change the service file. For example, if you wanted to run lokid as lokid --p2p-bind-ip 1.2.3.4 --p2p-bind-port=22222 --restricted-rpc then you would add: p2p-bind-ip=1.2.3.4 p2p-bind-port=22222 restricted-rpc=1 into /etc/loki/loki.conf and then restart lokid using: sudo systemctl restart loki-node 3. Interacting with the running lokid \u00b6 If you run the lokid binary with a command, it forwards this command to the running lokid. So, for example, to get the current lokid status you can run (note that sudo is not required!): lokid status lokid print_sn_status To prepare a service node registration run the following command: lokid prepare_registration The terminal will show the next steps to conduct to have your Service Node staked and thus receiving rewards. To see the outputs of your node you can run the following command: journalctl -u loki-node -af This is useful to see if your node is syncing with the blockchain. (Press Ctrl-C to stop watching the log). For a full list of supported commands run: lokid help For interacting with a running testnet node, add --testnet into the command, such as: lokid --testnet status lokid --testnet print_sn_status lokid --testnet prepare_registration You can also get basic statistics (such as uptime proof and ping times) on the running daemons from the systemctl status commands: systemctl status loki-node systemctl status loki-storage-server systemctl status lokinet-router Additional/Optional: \u00b6 Upgrading \u00b6 When a new release is available upgrading it as simple as syncing with the repository: sudo apt update Then install any updates using: sudo apt upgrade Note that this will install both updated lokid packages and any available system updates (this is generally a good thing!). During the upgrade, lokid (both mainnet and testnet) will be restarted if they are currently running to switch to the updated lokid. If for some reason you want to install only updated loki package upgrades but not other system packages then instead of the sudo apt upgrade you can use: sudo apt install loki-storage-server lokid lokinet-router (and change the above to whatever packages you want to install updates for). Installing a non-service-node lokid and cli wallet. \u00b6 To install a non-service-node lokid and the cli wallet: sudo apt install lokid loki-wallet-cli Once installed the binaries will be in your path, so you can simply run loki-wallet-cli as an ordinary user to use the command-line wallet. Non-service-node Loki operation \u00b6 Installing the lokid package sets up a loki-node systemd service that runs an ordinary loki node, but not a service node. This node can be used, for example, for wallet synchronization. If you don't want the node to run you can stop it after installation using: sudo systemctl stop loki-node If you want to disable it entirely (so that it doesn't start up automatically at boot) you can use: sudo systemctl disable --now loki-node If you later want to re-enable it you would use: sudo systemctl enable --now loki-node Remove the --now if you want to reenable it but not actually try starting it. For advanced users, lokid creates a _loki user and stores all the files (blockchain, service node key, etc.) owned by this user in /var/lib/loki . Running a Testnet Node \u00b6 The lokid package also installs a second systemd service, loki-testnet-node, for easily running a testnet node (either at the same time or instead of the mainnet node). To enable and start this, simply run: sudo systemctl enable --now loki-testnet-node This will start it and configure systemd to automatically start it when the system boots. The loki-service-node package also updates the testnet.conf file to run as a (testnet) service node; in order to actually run it you need to activate and start the loki-testnet-node.service (as above) and also the testnet storage server and lokinet routers: sudo systemctl enable --now loki-testnet-node loki-testnet-storage-server lokinet-testnet-router Reporting issues \u00b6 Contact me via @jagerman42 (Telegram) or @jagerman#6841 (in the Loki Discord).","title":"Service Node Setup Guide"},{"location":"ServiceNodes/DebianPackageGuide/#debian-package-guide","text":"Author: Jason (jagerman) Source: https://deb.imaginary.stream/ This repository contains debian/ubuntu builds of the core loki tools (lokid, cli/rpc wallets, blockchain tools) for Debian and Ubuntu.","title":"Debian Package Guide"},{"location":"ServiceNodes/DebianPackageGuide/#requirements","text":"One of: Debian 9 (\"stretch\") Debian 10 (\"buster\") Debian unstable (\"sid\") Ubuntu 16.04 (\"xenial\") Ubuntu 18.04 (\"bionic\") Ubuntu 19.10 (\"eoan\") Ubuntu 20.04 (\"focal\") Note: Debian 9 and Ubuntu 16.04 are not recommended for new installations as support for them is likely to be deprecated soon.","title":"Requirements"},{"location":"ServiceNodes/DebianPackageGuide/#express-guide","text":"Start a new service node by running these four commands: curl -s https://deb.imaginary.stream/public.gpg | sudo apt-key add - echo \"deb https://deb.imaginary.stream $(lsb_release -sc) main\" | sudo tee /etc/apt/sources.list.d/imaginary.stream.list apt update apt install loki-service-node The services will run via systemd as loki-node.service , loki-storage-server.service , and lokinet-router.service .","title":"Express Guide"},{"location":"ServiceNodes/DebianPackageGuide/#full-guide","text":"","title":"Full Guide"},{"location":"ServiceNodes/DebianPackageGuide/#1-initial-repository-setup","text":"You only need to do this step the first time you want to set up the repository; when you've done it once, the repository will automatically update whenever you fetch new system updates. To add the apt repository run the following command, replacing <DISTRO> in the second line with the appropriate value (see below). The following command installed Jagermans public key used to sign the Binaries. curl -s https://deb.imaginary.stream/public.gpg | sudo apt-key add - The second command tells apt where to find the packages and needs you to replace <DISTRO> with your distro. To find your <Distro> run the following command: lsb_release -sc Alternatively your <Distro> can be found by using the following list: sid (Debian testing/unstable) stretch (Debian 9) buster (Debian 10) xenial (Ubuntu 16.04) bionic (Ubuntu 18.04) eoan (Ubuntu 19.10) focal (Ubuntu 20.04) echo \"deb https://deb.imaginary.stream <DISTRO> main\" | sudo tee /etc/apt/sources.list.d/imaginary.stream.list Then resync your package repositories with: sudo apt update Now you can install one or more of the following packages as desired: Package Description loki-service-node Metapackage that does everything you need for a running service node. lokid The loki daemon (automatically pulled in by loki-service-node ). loki-storage-server The loki storage server, required for a service node (automatically pulled in by loki-service-node ). lokinet-router The lokinet package configured to run as a router (automatically pulled in by loki-service-node ). loki-wallet-cli The command-line wallet. loki-wallet-rpc The rpc wallet (for script-based wallet interaction such as a pool would need). loki-blockchain-tools the various loki-blockchain-* commands for advanced blockchain management. lokinet-client The lokinet package configured to run as a client to access lokinet. (Not for service nodes). There are also a few library packages such as libloki-core* containing the shared library code, as well as some backports of updated software for the older distributions; these can typically be ignored and will be installed automatically as needed. There is also a libloki-core-dev package containing the loki headers, but it's highly unlikely that you will need that for common use.","title":"1: Initial Repository Setup"},{"location":"ServiceNodes/DebianPackageGuide/#installing-a-package","text":"To install a package run the following command replacing with one of the packages available above: sudo apt install <package> For example: To install loki-service-node package run the following command: sudo apt install loki-service-node","title":"Installing a Package"},{"location":"ServiceNodes/DebianPackageGuide/#2-loki-service-node-operation","text":"Running a service node requires multiple packages (lokid and loki-storage-server) with synchronized configuration between them. There are two ways to approach this:","title":"2. Loki Service Node Operation"},{"location":"ServiceNodes/DebianPackageGuide/#automatic","text":"Install the loki-service-node package. sudo apt install loki-service-node This will detect your public IP (or allow you to enter it yourself) and automatically update the loki.conf configuration file with the necessary additional settings to run a service node.","title":"Automatic:"},{"location":"ServiceNodes/DebianPackageGuide/#manually","text":"Install the lokid , loki-storage-server , and lokinet-router packages: sudo apt install lokid loki-storage-server lokinet-router Then edit the configuration as desired in /etc/loki/loki.conf , /etc/loki/storage.conf , and /etc/loki/lokinet-router.ini . (See the next section for details). Restart any of these after configuration updates using one or more of: systemctl restart loki-node systemctl restart loki-storage-server systemctl restart lokinet-router","title":"Manually:"},{"location":"ServiceNodes/DebianPackageGuide/#adding-flags-to-config-file","text":"Note that you can add any of lokid's command-line arguments as settings in this file rather than needing to change the service file. For example, if you wanted to run lokid as lokid --p2p-bind-ip 1.2.3.4 --p2p-bind-port=22222 --restricted-rpc then you would add: p2p-bind-ip=1.2.3.4 p2p-bind-port=22222 restricted-rpc=1 into /etc/loki/loki.conf and then restart lokid using: sudo systemctl restart loki-node","title":"Adding flags to config file."},{"location":"ServiceNodes/DebianPackageGuide/#3-interacting-with-the-running-lokid","text":"If you run the lokid binary with a command, it forwards this command to the running lokid. So, for example, to get the current lokid status you can run (note that sudo is not required!): lokid status lokid print_sn_status To prepare a service node registration run the following command: lokid prepare_registration The terminal will show the next steps to conduct to have your Service Node staked and thus receiving rewards. To see the outputs of your node you can run the following command: journalctl -u loki-node -af This is useful to see if your node is syncing with the blockchain. (Press Ctrl-C to stop watching the log). For a full list of supported commands run: lokid help For interacting with a running testnet node, add --testnet into the command, such as: lokid --testnet status lokid --testnet print_sn_status lokid --testnet prepare_registration You can also get basic statistics (such as uptime proof and ping times) on the running daemons from the systemctl status commands: systemctl status loki-node systemctl status loki-storage-server systemctl status lokinet-router","title":"3. Interacting with the running lokid"},{"location":"ServiceNodes/DebianPackageGuide/#additionaloptional","text":"","title":"Additional/Optional:"},{"location":"ServiceNodes/DebianPackageGuide/#upgrading","text":"When a new release is available upgrading it as simple as syncing with the repository: sudo apt update Then install any updates using: sudo apt upgrade Note that this will install both updated lokid packages and any available system updates (this is generally a good thing!). During the upgrade, lokid (both mainnet and testnet) will be restarted if they are currently running to switch to the updated lokid. If for some reason you want to install only updated loki package upgrades but not other system packages then instead of the sudo apt upgrade you can use: sudo apt install loki-storage-server lokid lokinet-router (and change the above to whatever packages you want to install updates for).","title":"Upgrading"},{"location":"ServiceNodes/DebianPackageGuide/#installing-a-non-service-node-lokid-and-cli-wallet","text":"To install a non-service-node lokid and the cli wallet: sudo apt install lokid loki-wallet-cli Once installed the binaries will be in your path, so you can simply run loki-wallet-cli as an ordinary user to use the command-line wallet.","title":"Installing a non-service-node lokid and cli wallet."},{"location":"ServiceNodes/DebianPackageGuide/#non-service-node-loki-operation","text":"Installing the lokid package sets up a loki-node systemd service that runs an ordinary loki node, but not a service node. This node can be used, for example, for wallet synchronization. If you don't want the node to run you can stop it after installation using: sudo systemctl stop loki-node If you want to disable it entirely (so that it doesn't start up automatically at boot) you can use: sudo systemctl disable --now loki-node If you later want to re-enable it you would use: sudo systemctl enable --now loki-node Remove the --now if you want to reenable it but not actually try starting it. For advanced users, lokid creates a _loki user and stores all the files (blockchain, service node key, etc.) owned by this user in /var/lib/loki .","title":"Non-service-node Loki operation"},{"location":"ServiceNodes/DebianPackageGuide/#running-a-testnet-node","text":"The lokid package also installs a second systemd service, loki-testnet-node, for easily running a testnet node (either at the same time or instead of the mainnet node). To enable and start this, simply run: sudo systemctl enable --now loki-testnet-node This will start it and configure systemd to automatically start it when the system boots. The loki-service-node package also updates the testnet.conf file to run as a (testnet) service node; in order to actually run it you need to activate and start the loki-testnet-node.service (as above) and also the testnet storage server and lokinet routers: sudo systemctl enable --now loki-testnet-node loki-testnet-storage-server lokinet-testnet-router","title":"Running a Testnet Node"},{"location":"ServiceNodes/DebianPackageGuide/#reporting-issues","text":"Contact me via @jagerman42 (Telegram) or @jagerman#6841 (in the Loki Discord).","title":"Reporting issues"},{"location":"ServiceNodes/DeregistrationRules/","text":"Deregistration Rules \u00b6 Deregistration rules are used to manage the network in a decentralised way by having Service Nodes enforce each other to perform adequately on the network. Service Node States \u00b6 Each Service Node is in a state which informs the other Service Nodes in the network if they are awaiting, active, decommissioned or deregistered. A Service Node will be in 1 of 4 different states: State Description Awaiting Service Node is awaiting the staking requirement . Active Service Node is staked, performing tasks as required and receiving rewards . Decommissioned Service Node is not performing required tasks and is put into an inactive state where it does not receive rewards. Deregistered Service Node has been inactive for too long and has been deregistered. Decommission and Credits \u00b6 As a Service Node stays active they earn \"credits\" which are used during potential outages to stop a deregistration from occuring. A new Service Node starts out with INITIAL_CREDIT , and then builds up CREDIT_PER_DAY for each day the Service Node remains active up to a maximum of DECOMMISSION_MAX_CREDIT . Variable Value INITIAL_CREDIT 60 blocks (~2 hours) of decommission time. CREDIT_PER_DAY 24 blocks (~0.8 hours) of decommission time. DECOMMISSION_MAX_CREDIT 1440 blocks (~48 hours) of decommssion time. MINIMUM 60 blocks(~2 hours) of decomission time. Example : If a Service Node stops sending uptime proofs, a quorum will consider whether the Service Node has built up enough credits (at least MINIMUM ): if so, instead of submitting a deregistration, it instead submits a decommission. This removes the Service Node from the list of active Service Nodes both for rewards and for any active network duties. If the Service Node comes back online (i.e. starts sending the required performance proofs again) before the credits run out then a quorum will reinstate the Service Node using a recommission transaction, which adds the Service Node back to the bottom of the service node reward list, and resets its accumulated credits to 0. If it does not come back online within the required number of blocks (i.e. the accumulated credit at the point of decommissioning) then a quorum will send a permanent deregistration transaction to the network, locking that nodes stake for 30-days. Testing Quorum \u00b6 The testing quorum is a random set of 10 Service Nodes that are required to test a portion of the network for uptime proofs and Service Node IP changes. At each block a new quorum is formed and they are required to test 50 Service Nodes or 1% of the network. If 7 of the 10 Service Nodes vote that a Service Node is malicious or not meeting the minimum requirements then they will create a State_Change transaction to decommission, deregister or drop a Service Node to the bottom of the rewards list. Name Details Quorum Size 10 Service Nodes. Supermajority 7 Service Nodes. Tested 50 Service Nodes or 1% of the network. Quorum Tasks \u00b6 Task Description Uptime Proofs The quorum will check to see if a Service Node has provided uptime proofs within the last 2 hours. If a Service Node is found to have not provided an uptime proof it will be decommissioned if it has at least MINIMUM credits, deregistered directly otherwise.. IP Changes The quorum looks to see if the SN has advertised more than one IP to the network in the last 24 hours. If a Service Node IP has changed it will be forced to the bottom of the Service Node reward list. Checkpointing The quorum will check that each Service Node within the quorum has provided a hash of a block for a specific block height. If a Service Node within the quorum does not provide a hash it will be decommissioned if it has at least MINIMUM credits, deregistered directly otherwise. State Change Transactions \u00b6 A state change transaction changes the state of a Service Node. Typically, state change transactions are only created when the supermajority of the quorum come to a consensus about another Service Node activities or lack of activities. The only state change transaction that can be created by anyone is the Register TX which changes the state of a Service Node from awaiting to active . State_Change_Transaction Description Register TX A transaction(lock transfer) created from the client registering the Service Node. > Note this is not a quorum TX. State Change: Awaiting -> Active Decommission TX The Service Node is temporarily deregistered; your Service Node remains in the Service Node list, but is removed from the rewards list and from any network duties. State Change: Active -> Decommissioned Recommission TX The Service Node is added back to the service node list and put to the bottom of the rewards list. Stage Change: Decommissioned -> Active IP Change TX The Service Node is put at the bottom of the Reward List as it has changed it's IP. Stage Change: N/a Deregister TX The Service Node is deregistered. State Change: Active -> Deregistered / Decommissioned -> Deregistered","title":"Deregistration Rules"},{"location":"ServiceNodes/DeregistrationRules/#deregistration-rules","text":"Deregistration rules are used to manage the network in a decentralised way by having Service Nodes enforce each other to perform adequately on the network.","title":"Deregistration Rules"},{"location":"ServiceNodes/DeregistrationRules/#service-node-states","text":"Each Service Node is in a state which informs the other Service Nodes in the network if they are awaiting, active, decommissioned or deregistered. A Service Node will be in 1 of 4 different states: State Description Awaiting Service Node is awaiting the staking requirement . Active Service Node is staked, performing tasks as required and receiving rewards . Decommissioned Service Node is not performing required tasks and is put into an inactive state where it does not receive rewards. Deregistered Service Node has been inactive for too long and has been deregistered.","title":"Service Node States"},{"location":"ServiceNodes/DeregistrationRules/#decommission-and-credits","text":"As a Service Node stays active they earn \"credits\" which are used during potential outages to stop a deregistration from occuring. A new Service Node starts out with INITIAL_CREDIT , and then builds up CREDIT_PER_DAY for each day the Service Node remains active up to a maximum of DECOMMISSION_MAX_CREDIT . Variable Value INITIAL_CREDIT 60 blocks (~2 hours) of decommission time. CREDIT_PER_DAY 24 blocks (~0.8 hours) of decommission time. DECOMMISSION_MAX_CREDIT 1440 blocks (~48 hours) of decommssion time. MINIMUM 60 blocks(~2 hours) of decomission time. Example : If a Service Node stops sending uptime proofs, a quorum will consider whether the Service Node has built up enough credits (at least MINIMUM ): if so, instead of submitting a deregistration, it instead submits a decommission. This removes the Service Node from the list of active Service Nodes both for rewards and for any active network duties. If the Service Node comes back online (i.e. starts sending the required performance proofs again) before the credits run out then a quorum will reinstate the Service Node using a recommission transaction, which adds the Service Node back to the bottom of the service node reward list, and resets its accumulated credits to 0. If it does not come back online within the required number of blocks (i.e. the accumulated credit at the point of decommissioning) then a quorum will send a permanent deregistration transaction to the network, locking that nodes stake for 30-days.","title":"Decommission and Credits"},{"location":"ServiceNodes/DeregistrationRules/#testing-quorum","text":"The testing quorum is a random set of 10 Service Nodes that are required to test a portion of the network for uptime proofs and Service Node IP changes. At each block a new quorum is formed and they are required to test 50 Service Nodes or 1% of the network. If 7 of the 10 Service Nodes vote that a Service Node is malicious or not meeting the minimum requirements then they will create a State_Change transaction to decommission, deregister or drop a Service Node to the bottom of the rewards list. Name Details Quorum Size 10 Service Nodes. Supermajority 7 Service Nodes. Tested 50 Service Nodes or 1% of the network.","title":"Testing Quorum"},{"location":"ServiceNodes/DeregistrationRules/#quorum-tasks","text":"Task Description Uptime Proofs The quorum will check to see if a Service Node has provided uptime proofs within the last 2 hours. If a Service Node is found to have not provided an uptime proof it will be decommissioned if it has at least MINIMUM credits, deregistered directly otherwise.. IP Changes The quorum looks to see if the SN has advertised more than one IP to the network in the last 24 hours. If a Service Node IP has changed it will be forced to the bottom of the Service Node reward list. Checkpointing The quorum will check that each Service Node within the quorum has provided a hash of a block for a specific block height. If a Service Node within the quorum does not provide a hash it will be decommissioned if it has at least MINIMUM credits, deregistered directly otherwise.","title":"Quorum Tasks"},{"location":"ServiceNodes/DeregistrationRules/#state-change-transactions","text":"A state change transaction changes the state of a Service Node. Typically, state change transactions are only created when the supermajority of the quorum come to a consensus about another Service Node activities or lack of activities. The only state change transaction that can be created by anyone is the Register TX which changes the state of a Service Node from awaiting to active . State_Change_Transaction Description Register TX A transaction(lock transfer) created from the client registering the Service Node. > Note this is not a quorum TX. State Change: Awaiting -> Active Decommission TX The Service Node is temporarily deregistered; your Service Node remains in the Service Node list, but is removed from the rewards list and from any network duties. State Change: Active -> Decommissioned Recommission TX The Service Node is added back to the service node list and put to the bottom of the rewards list. Stage Change: Decommissioned -> Active IP Change TX The Service Node is put at the bottom of the Reward List as it has changed it's IP. Stage Change: N/a Deregister TX The Service Node is deregistered. State Change: Active -> Deregistered / Decommissioned -> Deregistered","title":"State Change Transactions"},{"location":"ServiceNodes/GUIStakingGuide/","text":"GUI-Pool-Staking-Guide \u00b6 This document will tell you exactly how to stake via the Loki GUI wallet. The latest version of the wallet can be downloaded here . Please keep in mind, one can only stake via an open pool with the GUI wallet . If you would like to stake your own node or a create pool, please view the full guide on service nodes here . Also, this best done with a primary wallet address that is not receiving mining transactions . A separate primary wallet for Staking is recommended. 1) Open the wallet, enter your password, and let it fully sync to the latest blockheight. 2) Click on the SERVICE NODE button. 3) On this step you will need to enter the service node public key obtained from the node operator or LokiBlocks and the amount of Loki you are contributing to the node. 4) Once that is filled out, simply hit the STAKE button. Please note, if you receive an error at this step you will need to click the SWEEP ALL before you can stake from your wallet. 5) Congratulations, you are now staking! If you have questions or need help with this guide feel free to reach out to us on Discord or Telegram .","title":"Gui Staking Guide"},{"location":"ServiceNodes/GUIStakingGuide/#gui-pool-staking-guide","text":"This document will tell you exactly how to stake via the Loki GUI wallet. The latest version of the wallet can be downloaded here . Please keep in mind, one can only stake via an open pool with the GUI wallet . If you would like to stake your own node or a create pool, please view the full guide on service nodes here . Also, this best done with a primary wallet address that is not receiving mining transactions . A separate primary wallet for Staking is recommended. 1) Open the wallet, enter your password, and let it fully sync to the latest blockheight. 2) Click on the SERVICE NODE button. 3) On this step you will need to enter the service node public key obtained from the node operator or LokiBlocks and the amount of Loki you are contributing to the node. 4) Once that is filled out, simply hit the STAKE button. Please note, if you receive an error at this step you will need to click the SWEEP ALL before you can stake from your wallet. 5) Congratulations, you are now staking! If you have questions or need help with this guide feel free to reach out to us on Discord or Telegram .","title":"GUI-Pool-Staking-Guide"},{"location":"ServiceNodes/InfiniteStakingPrimer/","text":"Infinite Staking Primer \u00b6 Outline For Existing Service Node Participants and Operators \u00b6 Infinite Staking is an incremental upgrade on the existing staking process that was previously available on the Loki network. With Infinite Staking, Service Nodes do not expire and funds remain locked until a contributor or operator explicitly requests the Service Node to unlock the funds. Since Infinite Staking is an incremental upgrade, most of the steps necessary to register and participate in a Service Node remain the same. A quick overview for the new staking process is summarised for quick grokking. (Yes, grokking is a word. Google it.) Updated Staking Process and Commands \u00b6 Operators \u00b6 Operators will still use the following commands when setting up a Service Node. The commands are as follows: prepare_registration in the daemon that is running in --service-node mode. register_service_node with the command returned by the daemon. Auto staking is no longer an option. Contributors \u00b6 Two new commands have been added to stop your Service Node from staking, and both the contributor and operator can execute these commands: stake <service node key> to contribute to the node. Auto staking is no longer an option. Operators & Contributors (When Service Node Active) \u00b6 Two new commands have been added to stop your Service Node from staking, both the contributor and operator can execute these commands: (Optional) print_locked_stakes to preview all the current wallet\u2019s transactions that are locked in a Service Node or blacklisted on the network. request_stake_unlock <service node key> to request to unlock the stake in 15 days (10800 blocks). Unlocking Stakes & Deregistration \u00b6 Service Nodes will continually receive block rewards indefinitely until a stake is unlocked or the Service Node becomes deregistered. Unlocking is available via the request_stake_unlock <service node key> in the command line wallet. Once the unlock is requested and the request is included in a block in the blockchain, the Service Node will then expire in 15 days (10800 blocks) and the funds will become unlocked after expiry. In pooled nodes, any contributor that requests the stake to unlock will schedule the Service Node for expiration. All locked stakes in that Service Node will be unlocked in 15 days (10800 blocks). Once the unlock is requested, this process can not be undone or prolonged. Service Node participants will continue receiving rewards until expiration. Under the new system, deregistrations can be issued at any point during the active lifecycle of the Service Node. This is inclusive of the time period during which the Service Node is scheduled for expiry. Getting deregistered removes your Service Node from the network and your stakes are placed into a list of blacklisted transactions. Blacklisted transactions are locked and unspendable for 30 days (21600 blocks) from the block in which the Service Node was deregistered. Receiving a deregistration after participants have already requested the stake to unlock overrides the 15 day (10800 blocks) unlock time, and resets the unlock time to 30 days (21600 blocks). Minimum Contribution Rules \u00b6 Infinite Staking introduces new limitations on the number of transactions that can be contributed to a Service Node, changing the minimum contribution rules for participating in the Service Node. Service Nodes accept at most 4 contributions, meaning the minimum contribution to a Service Node becomes: In a pooled Service Node with reserved spots, the Minimum Contribution must be either the Reserved Amount or the Contribution determined by the above equation, whichever is larger. A simplistic example being, if the staking requirement is 24,000 Loki then if, Operator contributes 50% of the requirement (12,000 Loki) The next contributor must contribute at least (\u2153 * 12,000) Loki i.e. 4000 Loki to become a participant. If this contributor had reserved a spot for more than 4000 Loki, their Minimum Contribution would be that amount. There are rules in the client software in place to stop users from irreversibly funding a Service Node into an invalid state. Staking Changes \u00b6 Users are no longer allowed to stake on behalf of another participant in the Service Node. All contributions for a participant must come from the same wallet address as the one specified in the Service Node. Developer API Changes \u00b6 get_service_nodes \u00b6 Updated/newly added fields: requested_unlock_height - The height at which the stakes will unlock and the Service Node will expire. contributors locked_contributions - An array of each contribution from the contributor that is locked. key_image - A string representation of the locked key image (stake). key_image_pub_key - A string representation of the public key component of a key image. amount - The amount of Loki locked in this contribution. get_service_node_blacklisted_key_images \u00b6 Retrieve a list of blacklisted transactions from deregistered Service Nodes on the network. blacklist - An array of each blacklisted transaction from deregistered Service Nodes key_image - A string representation of the blacklisted key image (stake). unlock_height - The height at which the stake can be spent again.","title":"Infinite Staking Primer"},{"location":"ServiceNodes/InfiniteStakingPrimer/#infinite-staking-primer","text":"","title":"Infinite Staking Primer"},{"location":"ServiceNodes/InfiniteStakingPrimer/#outline-for-existing-service-node-participants-and-operators","text":"Infinite Staking is an incremental upgrade on the existing staking process that was previously available on the Loki network. With Infinite Staking, Service Nodes do not expire and funds remain locked until a contributor or operator explicitly requests the Service Node to unlock the funds. Since Infinite Staking is an incremental upgrade, most of the steps necessary to register and participate in a Service Node remain the same. A quick overview for the new staking process is summarised for quick grokking. (Yes, grokking is a word. Google it.)","title":"Outline For Existing Service Node Participants and Operators"},{"location":"ServiceNodes/InfiniteStakingPrimer/#updated-staking-process-and-commands","text":"","title":"Updated Staking Process and Commands"},{"location":"ServiceNodes/InfiniteStakingPrimer/#operators","text":"Operators will still use the following commands when setting up a Service Node. The commands are as follows: prepare_registration in the daemon that is running in --service-node mode. register_service_node with the command returned by the daemon. Auto staking is no longer an option.","title":"Operators"},{"location":"ServiceNodes/InfiniteStakingPrimer/#contributors","text":"Two new commands have been added to stop your Service Node from staking, and both the contributor and operator can execute these commands: stake <service node key> to contribute to the node. Auto staking is no longer an option.","title":"Contributors"},{"location":"ServiceNodes/InfiniteStakingPrimer/#operators-contributors-when-service-node-active","text":"Two new commands have been added to stop your Service Node from staking, both the contributor and operator can execute these commands: (Optional) print_locked_stakes to preview all the current wallet\u2019s transactions that are locked in a Service Node or blacklisted on the network. request_stake_unlock <service node key> to request to unlock the stake in 15 days (10800 blocks).","title":"Operators &amp; Contributors (When Service Node Active)"},{"location":"ServiceNodes/InfiniteStakingPrimer/#unlocking-stakes-deregistration","text":"Service Nodes will continually receive block rewards indefinitely until a stake is unlocked or the Service Node becomes deregistered. Unlocking is available via the request_stake_unlock <service node key> in the command line wallet. Once the unlock is requested and the request is included in a block in the blockchain, the Service Node will then expire in 15 days (10800 blocks) and the funds will become unlocked after expiry. In pooled nodes, any contributor that requests the stake to unlock will schedule the Service Node for expiration. All locked stakes in that Service Node will be unlocked in 15 days (10800 blocks). Once the unlock is requested, this process can not be undone or prolonged. Service Node participants will continue receiving rewards until expiration. Under the new system, deregistrations can be issued at any point during the active lifecycle of the Service Node. This is inclusive of the time period during which the Service Node is scheduled for expiry. Getting deregistered removes your Service Node from the network and your stakes are placed into a list of blacklisted transactions. Blacklisted transactions are locked and unspendable for 30 days (21600 blocks) from the block in which the Service Node was deregistered. Receiving a deregistration after participants have already requested the stake to unlock overrides the 15 day (10800 blocks) unlock time, and resets the unlock time to 30 days (21600 blocks).","title":"Unlocking Stakes &amp; Deregistration"},{"location":"ServiceNodes/InfiniteStakingPrimer/#minimum-contribution-rules","text":"Infinite Staking introduces new limitations on the number of transactions that can be contributed to a Service Node, changing the minimum contribution rules for participating in the Service Node. Service Nodes accept at most 4 contributions, meaning the minimum contribution to a Service Node becomes: In a pooled Service Node with reserved spots, the Minimum Contribution must be either the Reserved Amount or the Contribution determined by the above equation, whichever is larger. A simplistic example being, if the staking requirement is 24,000 Loki then if, Operator contributes 50% of the requirement (12,000 Loki) The next contributor must contribute at least (\u2153 * 12,000) Loki i.e. 4000 Loki to become a participant. If this contributor had reserved a spot for more than 4000 Loki, their Minimum Contribution would be that amount. There are rules in the client software in place to stop users from irreversibly funding a Service Node into an invalid state.","title":"Minimum Contribution Rules"},{"location":"ServiceNodes/InfiniteStakingPrimer/#staking-changes","text":"Users are no longer allowed to stake on behalf of another participant in the Service Node. All contributions for a participant must come from the same wallet address as the one specified in the Service Node.","title":"Staking Changes"},{"location":"ServiceNodes/InfiniteStakingPrimer/#developer-api-changes","text":"","title":"Developer API Changes"},{"location":"ServiceNodes/InfiniteStakingPrimer/#get_service_nodes","text":"Updated/newly added fields: requested_unlock_height - The height at which the stakes will unlock and the Service Node will expire. contributors locked_contributions - An array of each contribution from the contributor that is locked. key_image - A string representation of the locked key image (stake). key_image_pub_key - A string representation of the public key component of a key image. amount - The amount of Loki locked in this contribution.","title":"get_service_nodes"},{"location":"ServiceNodes/InfiniteStakingPrimer/#get_service_node_blacklisted_key_images","text":"Retrieve a list of blacklisted transactions from deregistered Service Nodes on the network. blacklist - An array of each blacklisted transaction from deregistered Service Nodes key_image - A string representation of the blacklisted key image (stake). unlock_height - The height at which the stake can be spent again.","title":"get_service_node_blacklisted_key_images"},{"location":"ServiceNodes/OpenPort22023/","text":"Open port 22023 \u00b6 We need to open port 22023 for the loki-launcher to work properly. Run the following command to open port 22023 . sudo iptables -A INPUT -p tcp --dport 22023 -j ACCEPT & sudo iptables -A OUTPUT -p tcp --dport 22023 -j ACCEPT Then run the following command to make this port remain open on reboot. sudo apt-get install iptables-persistent","title":"Port 22023 Not Open"},{"location":"ServiceNodes/OpenPort22023/#open-port-22023","text":"We need to open port 22023 for the loki-launcher to work properly. Run the following command to open port 22023 . sudo iptables -A INPUT -p tcp --dport 22023 -j ACCEPT & sudo iptables -A OUTPUT -p tcp --dport 22023 -j ACCEPT Then run the following command to make this port remain open on reboot. sudo apt-get install iptables-persistent","title":"Open port 22023"},{"location":"ServiceNodes/SNFullGuide/","text":"Full Guide on Service Nodes \u00b6 Please note the loki-launcher is no longer being worked on. Please see the Debian Package Guide . This document will tell you exactly how to set up and operate a Service Node for the Loki Project. This document was written with non-developers in mind, so people new to linux or command line operations should be able to follow along without any trouble. If you feel confident around servers and the CLI, then skip to the Express Setup Guide You can of course run the Loki software on any operating system that you can get it to build on, but for the purposes of this document, the instructions apply to running a Service Node on a remote Ubuntu 18.04 server. If that isn\u2019t what you want to do, syntax and server set up will of course differ according to whatever OS you choose to run your Service Node from. Summary of Loki Service Node Requirements \u00b6 Full summary of Loki Service Node Requirements. This may change depending on Service Node functionality, so you should check here regularly, or follow our Telegram / Discord announcements channel. Spec Note Latest Binary Hefty Heimdall Software Ubuntu 18.04, Ubuntu 19.04 Storage 18gb Ram 2-4 gb Table of Contents \u00b6 Overview of Service Nodes New User Guide Step 1 Server Step 2 Server Prep Step 3 Loki Launcher Step 4 Service File Step 5 Open a Loki Wallet Step 6 Register Node Step 7 Check Registration Step 8 Unlock Stake (optional) Express Setup Guide Important Changes \u00b6 1.0.12(Loki 7.x series) \u00b6 New port 22020 for loki-storage's new LMQ port loki-storage 2.x won't start unless your file descriptors available are over 16k Overview \u00b6 To understand what a Service Node is, you can refer to the whitepaper to get an in depth understanding. For now, all you need to know is that: Service Nodes are full nodes on the Loki network Full nodes become Service Nodes when the owner locks the required amount of Loki and submits a registration transaction. Once accepted by the network, the Service Node is eligible to win block rewards. Multiple participants can be involved in one Service Node and can have the reward automatically distributed. Receive, store and forward encrypted user messages. Act as remote nodes for users. It is also worth noting that Service Nodes are quite basic at the moment, and operators will need to stay up to date with new updates to keep in line with software and hardware requirements. Once all of the updates are out, Service Nodes will also: Route end user\u2019s internet traffic, either as an exit node or relay. Monitor other Service Nodes and vote on their performance. Be called into quorums which give them authority over instant transactions ( Blink ). Once these features come out, Service Node operation will require better servers, particularly when it comes to bandwidth. For the purposes of this guide, however, we will only consider the current requirements. New User Guide \u00b6 This section of this guide is for new users to servers and the CLI interface. Step 1 - Get a Server \u00b6 Righto! Let\u2019s get started. Choosing where to set up a Service Node is the biggest choice you will make when running a Service Node. There are a number of things to consider. Because you will be locking up funds indefinitly, you will want to ensure that your server has: A stable, relatively fast connection to be able to respond to ping requests to avoid being booted off the network. We recommend 2GB of RAM to cope with running the software reliably ( Note: This requirement may be much greater once services are live ). 1GB is fine for testing. At Least a 20GB SSD or Hard disk drive, this will be used to store the blockchain ( Note: to future proof yourself against blockchain growth and message storage we recommend a 30 - 40 GB drive ). A stable power supply. If your server goes down during the staking period, you may get kicked off the network, and not receive rewards while your funds are still locked for the remainder of the staking period. For most users, we assume that your home internet connection is relatively slow (< 4MB/s down and up) and probably lacks support for external connections. If this is the case, you will probably not want to run a Service Node from your home in the long term, as this could cost you if and when you get booted off. Since we\u2019re just testing at the moment, you could run it from home anyway, but for this guide we\u2019ll avoid it. Typically, the easiest and cheapest way to host a server outside of your home is to use a Virtual Private Server (VPS). There are thousands of options when it comes to VPS providers, but for now, just about any one will do. In the future, selection will be made more difficult because most providers will not allow exit node traffic, so we have compiled a list of exit node friendly providers to choose from if you want to stay with your provider for more than a few months. Hosting Provider Product Name Cost Per Month $USD Bandwidth Provided Exit Friendliness Rating Accepts Loki? Netcup VPS 1000 G8 10.50 30 - 35 MiB\u2019s 5 / 10 Evolution Host STARTER 5.50 9 - 1 MiB\u2019s 9/10 YES Online.net Start-2-S-SSD 13.99 15 - 17 MiB\u2019s 9 / 10 Scaleway START1-M 9.33 20 - 25 MiB\u2019s 7 / 10 OVH VPS SSD 2 7.61 9 - 1 MiB\u2019s 9 / 10 Leaseweb Virtual Server XL 34.45 30 - 35 MiB\u2019s 5 / 10 Digital Ocean 2 GB, 2 vCPUs 15 9 - 11 MiB\u2019s 8 / 10 Feral Hosting Neon Capability 19.68 9 - 11 MiB\u2019s 9 / 10 Trabia VDS-8G 38.54 9 - 11 MiB\u2019s 8 / 10 Hetzner EX41-SSD (30 TB) 39.71 40 - 80 MiB\u2019s 4 / 10 Note: We do not officially endorse any of these providers, this list is simply illustrative of some of the options currently available* Try not to pick the first one off the list. Do some digging and see which one looks the best to you, what your budget is, and what the latency is like for you based on the server location that you choose. When selecting your VPS\u2019 operating system, choose Ubuntu 18.04 64 bit or Ubuntu 19.04 64 bit if you want to follow this guide. If you feel more confident or wish to run your server on another distribution or operating system, the Loki commands in this guide will still apply. Step 2 - Prepare your Server \u00b6 Every provider has a slightly different way of issuing you access to your new VPS. Most will send an email with the IP address, root username, and a root password of the VPS. To access your server, you will need a SSH client for your operating system. Because we\u2019re on Windows today, we\u2019ll download PuTTY, Mac users can also use PuTTY. If you\u2019re a Linux user, you probably don\u2019t want us telling you where to get a SSH client from. To connect to our VPS we will need to paste the IP address into the SSH client\u2019s \u201cHost Name (or IP address)\u201d input box and click the \u201cOpen\u201d button. The Port number can usually just be left as 22 . A terminal window will now appear prompting for your log-in details, username(root) and password, which were provided by your VPS provider. When entering your password, nothing will visually appear in the terminal. This is normal. Hit enter when it\u2019s typed or pasted, and you should be logged in to your VPS. 2.1 Create a non-root User \u00b6 Best practice when running a public server is to not run your software as the root user. Although it is possible to do everything as root, it is strongly recommended that you create a non-root user on our VPS by running the following command: adduser <username> Replacing <username> with a name you will log-in with. For this user-guide we will use snode as our username. adduser snode The terminal will prompt you for a new password for our newly created user. Use a secure password that is different password from the root password. Once the password has been set, the terminal will prompt for a few details about the individual running the user. You can just hit enter through each of the inputs as the details are not important for the purposes of running a Service Node. Once that\u2019s done, run the following two commands to give our new account admin privileges and to change to such account. usermod -aG sudo snode sudo su - snode Before we proceed further, it is advised to close your terminal and reopen PuTTY to set up a saved session with our snode user. Your SSH client will have a load and save session function. For PuTTY we will need to type in our VPS IP address again, on the same screen type snode under \u201cSaved Session\u201d. Click on \u201cData\u201d under the drop-down menu \u201cConnection\u201d, and type in snode (or your username defined before) into the input box \u201cAuto-login username\u201d. Go back to your session screen, where we entered the IP address, and click \u201cSave\u201d. You can load this session whenever you want to check on your Service Node. 2.2 Hot Tips for using the Console \u00b6 Consoles don't work like the rest of your computer. Here are some basic tips for navigating your way around the command line! Don't try copying something by using the usual Ctrl + C hotkey! If you want to copy something, do so by highlighting text and then right clicking it. Pasting works by right clicking a blank area in the console. If you want to kill a process or stop something from running, press Ctrl + C. (This is why you shouldn't try copying something with this hotkey.) You can always check the directory you are in by typing pwd and list its contents by typing ls . You can always return to your home directory by typing cd . You can move into a given directory by typing cd <name> or move back up one level by typing cd .. . PuTTY allows you to easily duplicate or restart a session by right clicking the top of the window. Handy if you\u2019re trying to do a few things at once. Once we have logged in correctly to the VPS for the first time, the VPS may be configured to prompt for a new password for the root account. The terminal will require you to enter the new password twice before we can start running commands. If you aren't prompted for a new root password but want to change it anyway, type sudo passwd . Choose something very secure! 2.3 Server Preparation Continued \u00b6 We should update our package lists, the below command downloads the package lists from the repositories and \"updates\" them to get information on the newest versions of packages and their dependencies. It will do this for all repositories and PPAs. sudo apt update You will notice a bunch of package lists were downloaded, once this is complete run the below command to fetch new versions of any packages we currently have installed on the system. sudo apt upgrade You will be prompted to authorise the use of disk space, type y and enter to authorise. If you are prompted during the upgrade that a new version of any file is available then click the up and down arrows until you are hovering over install the package maintainer\u2019s version and click enter. Alright, good to go. Our server is now set up, up to date, and is not running as root. On to the fun part! Step 3 - Loki Launcher \u00b6 3.1 - Install NodeJS and Loki Launcher \u00b6 In order to use the Loki Launcher we first need to install NodeJS. Run the following command to download the package: curl -sL https://deb.nodesource.com/setup_10.x | sudo bash - Then run the following command to install nodejs: sudo apt-get install -y nodejs Next we need to install the launcher with the following command: sudo npm install -g loki-launcher 3.2 - Setting up your Loki-launcher for Service Node \u00b6 We now need to prequalify our server to be ready to run as a service node. To do so run the following command: loki-launcher prequal If all checks have passed you will receive an output similar to the following: Starting open port check on configured blockchain p2p port: 22022 OpenP2pPort: Success ! Starting open port check on configured storage server port: 8080 OpenStoragePort: Success ! Starting disk space check on blockchain partition /home/snode/.loki Creating /home/snode/.loki/storage Starting disk space check on storage server partition /home/snode/.loki/storage DiskSpace_blockchain: Success ! DiskSpace_storage: Success ! Your node successfully passed all tests 3.3 - Download Lokid Binaries \u00b6 We will download the Loki binaries by running the following command: sudo loki-launcher download-binaries 3.4 - Start the Loki Launcher \u00b6 To start the loki launcher run the following command: sudo loki-launcher start At this moment the launcher will output a table showing if everything is working properly: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 (index) \u2502 Values \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 launcher \u2502 'running as 26525' \u2502 \u2502 blockchain \u2502 'running as 26537' \u2502 \u2502 socket \u2502 'running at /opt/loki-launcher/var' \u2502 \u2502 blockchain_rpc \u2502 'running on 127.0.0.1:22023' \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Now the Loki launcher is running we can access the launcher by running the following command: sudo loki-launcher client To exit out of the client click CTRL + C . Note: Loki-launcher will run in the background now and continue to sync with the blockchain. The only problem is if the system reboots we will need to relaunch the loki-launcher software. We can fix this by configuring the Launcher as a system service which makes it automatically start up if the server reboots, and restarts it if the software crashes for some reason. Step 4 - Loki-Launcher as a System Service \u00b6 4.1 - User permissions \u00b6 We are going to need to fix our user \"snode\"s permissions with the loki-launcher. Next run the following command to fix permissions: sudo loki-launcher fix-perms <USER> Replacing <USER> with snode or the username that you created. The terminal should show the following: 3.x series blockchain binary detected, disabling storage server by default running fix-perms requesting launcher stop setting permissions to snode user snode uid is 1000 homedir is /home/snode remember to restart your launcher fixing blockchain.data_dir file /home/snode/.loki/key fixing blockchain.data_dir file /home/snode/.loki/loki.log fixing blockchain.data_dir file /home/snode/.loki/p2pstate.bin fixing blockchain.data_dir file /home/snode/.loki/lmdb/data.mdb fixing blockchain.data_dir file /home/snode/.loki/lmdb/lock.mdb fixing blockchain.data_dir file /home/snode/.loki/lmdb fixing blockchain.data_dir file /home/snode/.loki/storage/storage.logs fixing blockchain.data_dir file /home/snode/.loki/storage fixing blockchain.data_dir file /home/snode/.loki 4.2 - Creating the Service File \u00b6 To create our lokid.service file run the following command: sudo nano /etc/systemd/system/lokid.service Next copy the text below and paste it into your new file. To paste in putty you can right mouse click the terminal screen. [Unit] Description=lokilauncher After=network-online.target [Service] Type=simple User=snode ExecStart=/usr/lib/node_modules/loki-launcher/index.js systemd-start Restart=always RestartSec=30s [Install] WantedBy=multi-user.target If you chose a username other than snode then change snode in the User= line to the alternative username. Once completed, save the file and quit nano: CTRL+X -> Y -> ENTER . 4.3 - Enabling the Service File \u00b6 Enable lokid.service so that it starts automatically upon boot: sudo systemctl enable lokid.service Start lokid.service: sudo systemctl start lokid.service Then reboot your system to check if the service file is working correctly. sudo reboot Log back into your server and run the following command: loki-launcher status The terminal should output something similar to: launcher status: running on 818 blockchain status: running on 891 Well done! You're loki-launcher is now setup. Step 5 - Wallet \u00b6 While we wait for the daemon to sync, we can now get a wallet going. You do not have to run this wallet on the server and you should not! Download the software and run it from elsewhere for security reasons! If you need help with installing the loki-wallet-cli on another machine check out our Wallets Overview section. 5.1 - Run Wallet \u00b6 To open our wallet we are going to change into the directory which we installed loki-wallet-cli and run the following command: ./loki-wallet-cli If you are on testnet run the command with the --testnet flag: ~/loki/loki-wallet-cli --testnet When loki-wallet-cli first runs, it will request for you to specify a wallet name. Assuming we haven't created one yet, we will use the e.g. name MyWallet Because this is the first time we have used the name MyWallet the client will prompt us to create a new wallet. Type y and click return to continue. The loki-wallet-cli has generated us a wallet called MyWallet and is now prompting us for a password. Note : When typing the password, the characters will not appear. It will seem as if you are typing and no text is appearing however the terminal is logging every character you type including if it is capitalised or lowercase. Write down your wallet name and password on a piece of paper as this information will be required every time we want to enter our wallet. Use a password with uppercase letters, lowercase letters, numbers, symbols and make the password at least 9 characters long. Once we have chosen our password for the wallet we must choose our language. For the purposes of this user guide I suggest you use English by typing in 1 and clicking return. The CLI will generate and spit out several lines of text. The first two lines of text show your wallet public address. This address can be shared, will be used to receive Loki to your wallet, and will be used during the preparation and registration of our Service Node. All Mainnet Loki public addresses start with an L and are followed with a string of characters, Testnet Public addresses start with a T. The public address shown will be your primary address, however multiple public addresses can be generated from this primary address. 5.2 - Save Seed Phrase \u00b6 Line 13 to 17 show your 25-word mnemonic (\u201cnew-monic\u201d) seed. The seed is used to easily backup and restore your wallet without needing any other information. At this stage, grab a pen and paper, and write down your 25 words in order. Store the piece of paper in a safe and secure place, if your words are stored in a text file on your computer or stored online, you increase your risk of someone else getting control of your wallet. 5.3 - Store enough $loki in your wallet for staking \u00b6 It is at this point that we should get some Loki in the wallet. The amount of Loki required to run a node is derived from the function shown in Lokis Cryptoeconomic paper . Don't worry if you cant work out the formula, you can use this community created tool or, the daemon will display the amount of Loki required to run the node. If you do not have enough you will have the option to join in or run your own Service Node pool. If you are running a Service Node on the testnet you will only ever require 100 testnet Loki to run the Node. You can ask the Telegram @LokiSNBot for some testnet loki or ask someone in the Loki Discord Community for some. 5.4 - Information required for the Service Node \u00b6 If you are staking please do not use Subaddresses. They are currently unsupported by the Loki wallet. We will need our address to register our Service Node later, to get your primary address type the following command: address Highlight the string of characters that were outputted and save this in a notepad for later use, your public address should look similar to: T6TCCyDgjjbddtzwNGryRJ5HntgGYvqZTagBb2mtHhn7WWz7i5JDeqhFiHqu7ret56411ZJS7Thfeis718bVteBZ2UA6Y7G2d (Note that this is an example testnet wallet address; your address will start with L if it is a mainnet wallet) NOTE: Do not use CTRL + C to copy your address, it will close the wallet down. Simply highlight the address and this will automatically save the portion you highlighted into your clipboard. Once you have enough Loki in this wallet, just leave it open, we\u2019ll come back to it in a minute. Step 6 - Service Node Registration \u00b6 The next part of the guide will split into two sections: If you are an individual staker and do not require any other contributors to run your Service Node jump into 6.1 - individual Staking . If you want to run a pooled Service Node or contribute towards a pool jump into 6.2 - Pool Staking 6.1 - Individual Staking \u00b6 If you want to run the Service Node as an individual you will require the following things. A loki-launcher initialised with loki-launcher prequal . See Step 3.2 A fully synchronized, up-to-date Loki daemon running through the loki-launcher. A loki-wallet-cli primary address with enough Loki in your account to meet the Service Node Staking Requirement. See Step 5 Now if we have the three above items we can proceed to our daemon to register our Service Node. Log in (if not already connected) as the snode user on the VPS running the service node, then connect to the loki-launcher client: loki-launcher client Start the registration process by running the following interactive command: prepare_registration The daemon will output the current staking requirement and prompt you with an input to clarify whether you are an individual staker or you will be running a pool. Type y and click enter as we will be the sole staker. The daemon will now prompt us for the Loki address of the operator. If you followed step 5 you should have this address saved in a notepad, if not run through step 5 again to find your Loki Address. Once we have the Loki Address copied to our clipboard we can then right click the terminal screen to paste the address. Double check the address matches the one of your wallet then click enter if it is the same. The daemon will now ask for a final confirmation, if you agree to the information provided type y and click enter. The daemon will output a command for us to run looking similar to: register_service_node 4294967292 T6TCCyDgjjbddtzwNGryRJ5HntgGYvqZTagBb2mtHhn7WWz7i5JDeqhFiHqu7ret56411ZJS7Thfeis718bVteBZ2UA6Y7G2d 4294967292 100.000000000 1535677391 ec3895ea70a4a91b5ec4b5e1df96a45e07046f1fb0123c754d98fb2d70f4529d 5bb35d7b8ab1acb943bc47913ada8f9d2e6d6e22264e57484a04c1bbfd461f0ee2e5435454cd9b7059b221eb506ce9ea4537ddd9faf1f1757e0ef611a41c0609 NOTE: You must run the command outputed by your daemon and not the command shown above. Copy the whole line of text and paste it into your notepad as we will need to run this command in our loki-wallet-cli . If registering multiple nodes, it will likely be necessary to wait at least 10 blocks between Service Nodes before running the register Service Node command in the wallet. You have 2 weeks from the moment of preparing the registration command on the Service Node to actually run the register_service_node command in the wallet, however it is advised to do it as soon as possible. Run through step 5 once more to open our Loki wallet (if you don't already have it open). Once we are in our wallet run the command the daemon outputted for us when we prepared our Service Node registration. The wallet will prompt us to confirm our password, then the amount of Loki to stake. Confirm this by typing y and clicking enter. Note: At this point you now have locked stakes! To unlock your stake run the following Well done! Let's continue to the next step \" Step 7 - Service Node Check \" to check if our Service Node is running. 6.2 - Pool Staking \u00b6 Minimum Contribution Rules \u00b6 Infinite Staking introduces new limitations on the number of transactions that can be contributed to a Service Node, changing the minimum contribution rules for participating in the Service Node. Service Nodes accept at most 4 contributions, meaning the minimum contribution to a Service Node becomes: In a pooled Service Node with reserved spots, the Minimum Contribution must be either the Reserved Amount or the Contribution determined by the above equation, whichever is larger. A simplistic example being, if the staking requirement is 24,000 Loki then if, Operator contributes 50% of the requirement (12,000 Loki) The next contributor must contribute at least (\u2153 * 12,000) Loki i.e. 4000 Loki to become a participant. If this contributor had reserved a spot for more than 4000 Loki, their Minimum Contribution would be that amount. There are rules in the client software in place to stop users from irreversibly funding a Service Node into an invalid state. Depending on the individual and their circumstance they will need to: Jump into section 6.2.1 - Operator if they are running the daemon and hosting the pool; Jump into section 6.2.2 - Pool Contributor if they are contributing to someone's Service Node. NOTE: It is advised to read both sections of \" 6.2 - Pool Staking \" to have a better understanding of the process. 6.2.1 - Operator \u00b6 The Operator is the individual who will be hosting the pool and running the Service Node daemon, thus incurring the operating expenses encompassed by running a node. The Operator will need to have: A loki-launcher initialised with loki-launcher prequal . See Step 3.2 . A fully synchronized, up-to-date Loki daemon running through the loki-launcher. A loki-wallet-cli primary address with enough Loki in your account to meet the Service Node Staking Requirement. See Step 5 1-3 other contributors who also have a wallet ( loki-wallet-cli or the desktop GUI wallet) with enough Loki in their accounts to meet 25% of the staking requirement. If the operator wants to reserve contribution spots for specific contributors: The address and contribution amounts the 1-3 contributors will stake. NOTE: The other contributors addresses are optional to have as you can create your pool to be open to anyone to contribute to, however they are recommended to have to avoid any issues of other individuals stealing their spots. On the other hand, a reserved contribution spot can only be filled by that contributor: if they change their mind before submitting a stake your service node will be stuck inactive, so it is recommended to use reserved contribution spots only with contributors you trust. Now if we have the three/four above items we can proceed to our daemon to register our Service Node. Log in (if not already connected) as the snode user on the VPS running the service node, then connect to the loki-launcher client: loki-launcher client Start the registration process by running the following interactive command: prepare_registration The terminal will prompt the operator to specify if they will contribute the entire stake, because we are running this as a pooled Service Node we will type n and click enter. Next the terminal will request the input for the operator cut. This value is between 0-100 and represents the percentage of the reward the operator will receive before the reward is distributor to the share holders. If you have agreed to a 10% operator cut with the other contributors you would type 10 and click return. The terminal will now display the minimum reserve the operator can contribute and request the operator to input the amount in Loki they wish to contribute. Type your desired <operator contribution> and click return. Once we have set the operators desired stake amount we have the option to either leave the pool open for anyone to contribute or lock a reserve for individuals that have agreed with us to stake within our Service Node. Reserved Pool \u00b6 If the operator wishes to reserve spots for specific contributors they should type y and click return. The terminal will now prompt the operator for the number of additional contributors they have organised to be apart of this Service Node. Type in the number of reserved contributors, not including themselves, and click return. The daemon will now prompt us for the Loki address of the operator. If you followed step 5 you should have this address saved in a notepad, if not run through step 5 again to find your address. Once we have the Loki Address copied to our clipboard we can then right click the terminal screen to paste the address then click return to confirm your address. Next the operator must input the amount of Loki each contributor will contribute and the contributor's address. NOTE: It is possible to reserve only some of the required stakes for specific contributors while leaving the remaining stake open. You will now be asked to confirm the information above is correct. Open Pool \u00b6 If the operator wishes to leave their pool complete open to contributions they should type n and click return. The terminal will prompt the operator to input their address. Once the address has been inputted the terminal will display the remaining portion that needs to be contributed by others. If you agree click y and hit return. The daemon will display a summary of the information we entered. This is our chance for a final check over to make sure we entered in the right information. If you confirm the information is correct type y and click return. The daemon will output a command for us to run within our wallet, looking similar to: register_service_node 214748364 T6UCEoWvJHCJq5biK3LMQZ4CRXAaqiPda2kCRRYYYEMFfxYoqnUo7Nx88RL3wmENwN4kfjDSp2jMN1g6PSErKrSu2EEp8UMy5 1073741823 T6TCCyDgjjbddtzwNGryRJ5HntgGYvqZTagBb2mtHhn7WWz7i5JDeqhFiHqu7ret56411ZJS7Thfeis718bVteBZ2UA6Y7G2d 3221225469 25.000000000 1535692249 5dac247e90ced2dcd9e51faec8792acb0c11b4c700640d9104b17c868ea167e3 cc11eef804c11d3e93cf8c488c10d97b8cec9ee2b38e6666ff07749c2911aa06ce310edc926a4d2f50a588e9c15afcc20e935a0f188aa7caa764a62058dec80d NOTE: You must run the command outputed by your daemon and not the command shown above. Copy the whole line of text in your daemon and paste it into your notepad as we will need to run this command in our loki-wallet-cli . You have 2 weeks from the moment of registering the Service Node to run the register_service_node command, however it is advised to do it as soon as possible. Before you disconnect from your VPS connect to the loki-launcher client : loki-launcher client and run the following command to get your <Service Node Public Key> and save it in your notepad (your contributors will need it): print_sn_key Run through step 5 once more to open our Loki wallet. Once we are in our wallet run the command the daemon outputted for us when we prepared our Service Node. The wallet will prompt us to confirm our password, then the amount of Loki to stake. Confirm this by typing y and clicking enter. Once this command completes your staking transaction will be sent to be included on the blockchain. It may take a few minutes for the transaction to be mined into a block; you can check the status using the loki-launcher and running the command: print_sn_status or by looking for your <Service Node Public Key> in the \"Service Nodes Awaiting\" section on lokiblocks.com (or lokitestnet.com for a testnet service node). Once the service node registration is received you can send the <Service Node Public Key> to your contributors with the amount of Loki they are required to stake. NOTE: the final amount will typically be slightly lower than what you entered in the prepare_registration command. This is expected: the required amounts are based on the registration block height which has usually advanced by a couple blocks between the time you prepared the registration and the time it gets mined into the blockchain. At this point we will need to wait until all contributors have staked before the service node activates and becomes eligible to receive rewards. 6.2.2 - Pool Contributor \u00b6 The pool contributor must first receive the Service Node Pubkey and the requirements (amount of loki to send) from the Service Node Operator. If you are staking please do not use Subaddresses. They are currently unsupported by the Loki wallet The pool contributor must have downloaded the necessary binaries, is running a daemon or is connected to a remote node, has generated a wallet through either the loki-wallet-cli or the desktop GUI wallet, and has enough Loki to stake. They can then run the following command in their loki-wallet-cli . stake <Service Node Pubkey> <contribution amount> Where the <Service Node Pubkey> is the Pubkey provided from the Service Node operator and <contribution amount> is the amount of Loki they are going to stake which they agreed to with the Service Node Operator. If using the desktop GUI wallet, the Stake command can be found under the Advanced - Service Node menu. Enter the service <Service Node Pubkey> and <contribution amount> and hit the Stake button. At this stage you will need to wait for the other contributors to provide their collateral. Once everyone has staked you can refer to \u201cStep 7 - Service Node Check\u201d to see where your Service Node Operator\u2019s node is in the list. Congratulations, you are now staking. Step 7 - Service Node Check \u00b6 After we have locked our collateral we will need to check if our Service Node Pubkey is sitting in the list with the other Service Node\u2019s on the network. This will prove our Service Node is running, recognised and will receive a reward if it keeps running. Connect to the VPS where the service node is running and run the following command in our loki-launcher client to see our Service Node Public Key: print_sn_key The Service Node Public Key is used to identify our Service Node within the list of Service Nodes currently on the network. If you want more detailed Service Node status you can use the follow command: print_sn_status You can jump onto https://lokiblocks.com/ to see if your Service Node is in the list or we can continue in the terminal to output the same information. If you are running your Service Node on testnet go to https://lokitestnet.com/ instead. To check this information directly with the service node itself, first get the current block height by running status into the terminal with loki-launcher client launched.. Once we have the block height we can then check the current Service Nodes on the network at our specified block height. Run the following command in the loki-launcher : print_quorum_state <block height> Replacing <block height> with the number minus 1 that was outputted when running status command. If your <Service Node Pubkey> is sitting in the list you know you are now staking. Step 8 - Unlock Stake \u00b6 Service Nodes will continually receive block rewards indefinitely until a stake is unlocked or the Service Node becomes deregistered. Unlocking is available via the following command which needs to be run in the command line wallet: request_stake_unlock <service node key> Once the unlock is requested and the request is included in a block in the blockchain, the Service Node will then expire in 15 days (10800 blocks) and the funds will become unlocked after expiry. In pooled nodes, any contributor that requests the stake to unlock will schedule the Service Node for expiration. All locked stakes in that Service Node will be unlocked in 15 days (10800 blocks). Once the unlock is requested, this process can not be undone or prolonged. Service Node participants will continue receiving rewards until expiration. Deregistrations can be issued at any point during the active lifecycle of the Service Node. This is inclusive of the time period during which the Service Node is scheduled for expiry. Getting deregistered removes your Service Node from the network and your stakes are placed into a list of blacklisted transactions. Blacklisted transactions are locked and unspendable for 30 days (21600 blocks) from the block in which the Service Node was deregistered. Receiving a deregistration after participants have already requested the stake to unlock overrides the 15 day (10800 blocks) unlock time, and resets the unlock time to 30 days (21600 blocks). Optional \u00b6 See Locked Stake Amount and Duration \u00b6 We can also view our locked stake by running the following command from our loki-wallet-cli we staked from: print_locked_stakes Updating your Binaries \u00b6 IMPORTANT: Please check the important changes section at the top of this page to see the changes before running your updates. When new binaries are out we need to log into our server as the which we initially set up our loki-launcher on. Run the following command to update our loki-launcher: sudo npm install -g loki-launcher Stop our lokid.service file: sudo systemctl stop lokid.service Then run the following command to download the new binaries: sudo loki-launcher download-binaries Next we'll need to run check-systemd now to upgrade your nofile (file descriptor limit): sudo loki-launcher check-systemd This next command is optional, try it if you run into issues. Fix permissions for Lokinet if you aren't running as root, <USER> should be replaced with the username your Service Node runs under - if you followed this guide it will be snode: sudo loki-launcher fix-perms <USER> Start lokid.service again: sudo systemctl start lokid.service If you are running loki-launcher as a service you can now reboot your computer and the new binaries will be used. sudo reboot Default Directories for Loki Files \u00b6 Name Directory Blockchain Data /home/<user>/.loki/ Lokid Binaries /opt/loki-launcher/bin Launcher Config File /etc/loki-launcher/launcher.ini Lokid Logs /home/<user>/.loki/ Express Setup Guide \u00b6 Step 1: Get a Server Step 2: Prepare your server adduser snode usermod -aG sudo snode sudo su - snode sudo apt update sudo apt upgrade Step 3: Loki-Launcher curl -sL https://deb.nodesource.com/setup_10.x | sudo bash - sudo apt-get install -y nodejs sudo npm install -g loki-launcher loki-launcher prequal sudo loki-launcher download-binaries sudo loki-launcher start sudo loki-launcher client To exit out of the client click CTRL + C . Step 4: Loki-Launcher as a System Service su - root loki-launcher fix-perms snode su - snode sudo loki-launcher start sudo nano /etc/systemd/system/lokid.service Paste the following into your terminal: [Unit] Description=lokilauncher After=network-online.target [Service] Type=simple User=snode ExecStart=/usr/lib/node_modules/loki-launcher/index.js systemd-start Restart=always RestartSec=30s [Install] WantedBy=multi-user.target Save and exit the file by typing CTRL + X -> Y -> Enter . sudo systemctl daemon-reload sudo systemctl enable lokid.service sudo systemctl start lokid.service sudo reboot Log back into your server and check your launcher: loki-launcher status Step 5: Wallet ./loki-wallet-cli Save the address that comes from running: address Step 6: Service Node Registration loki-launcher client prepare_registration Run the register-service-node command in our loki-wallet-cli register_service_node 4294967292 T6TCCyDgjjbddtzwNGryRJ5HntgGYvqZTagBb2mtHhn7WWz7i5JDeqhFiHqu7ret56411ZJS7Thfeis718bVteBZ2UA6Y7G2d 4294967292 100.000000000 1535677391 ec3895ea70a4a91b5ec4b5e1df96a45e07046f1fb0123c754d98fb2d70f4529d 5bb35d7b8ab1acb943bc47913ada8f9d2e6d6e22264e57484a04c1bbfd461f0ee2e5435454cd9b7059b221eb506ce9ea4537ddd9faf1f1757e0ef611a41c0609 NOTE: You must run the command outputed by your daemon and not the command shown above. Conclusion \u00b6 Well done! You will receive a block reward when your Service Node has been active for some time and the network chooses you within the list. Bonus : Use the community-run telegram bot @LokiSNBot to receive on-the-fly updates about your service node. Props to @jagerman42 for building this. Bonus 2 : View https://imaginary.stream/sn/ for more details on Loki Service Node staking requirements. This guide will be regularly updated when new features are added to Snodes. Join the discord for more discussion. If you can improve this guide, please submit a pull request.","title":"Loki Documentation | Loki Service Node Full Guide"},{"location":"ServiceNodes/SNFullGuide/#full-guide-on-service-nodes","text":"Please note the loki-launcher is no longer being worked on. Please see the Debian Package Guide . This document will tell you exactly how to set up and operate a Service Node for the Loki Project. This document was written with non-developers in mind, so people new to linux or command line operations should be able to follow along without any trouble. If you feel confident around servers and the CLI, then skip to the Express Setup Guide You can of course run the Loki software on any operating system that you can get it to build on, but for the purposes of this document, the instructions apply to running a Service Node on a remote Ubuntu 18.04 server. If that isn\u2019t what you want to do, syntax and server set up will of course differ according to whatever OS you choose to run your Service Node from.","title":"Full Guide on Service Nodes"},{"location":"ServiceNodes/SNFullGuide/#summary-of-loki-service-node-requirements","text":"Full summary of Loki Service Node Requirements. This may change depending on Service Node functionality, so you should check here regularly, or follow our Telegram / Discord announcements channel. Spec Note Latest Binary Hefty Heimdall Software Ubuntu 18.04, Ubuntu 19.04 Storage 18gb Ram 2-4 gb","title":"Summary of Loki Service Node Requirements"},{"location":"ServiceNodes/SNFullGuide/#table-of-contents","text":"Overview of Service Nodes New User Guide Step 1 Server Step 2 Server Prep Step 3 Loki Launcher Step 4 Service File Step 5 Open a Loki Wallet Step 6 Register Node Step 7 Check Registration Step 8 Unlock Stake (optional) Express Setup Guide","title":"Table of Contents"},{"location":"ServiceNodes/SNFullGuide/#important-changes","text":"","title":"Important Changes"},{"location":"ServiceNodes/SNFullGuide/#1012loki-7x-series","text":"New port 22020 for loki-storage's new LMQ port loki-storage 2.x won't start unless your file descriptors available are over 16k","title":"1.0.12(Loki 7.x series)"},{"location":"ServiceNodes/SNFullGuide/#overview","text":"To understand what a Service Node is, you can refer to the whitepaper to get an in depth understanding. For now, all you need to know is that: Service Nodes are full nodes on the Loki network Full nodes become Service Nodes when the owner locks the required amount of Loki and submits a registration transaction. Once accepted by the network, the Service Node is eligible to win block rewards. Multiple participants can be involved in one Service Node and can have the reward automatically distributed. Receive, store and forward encrypted user messages. Act as remote nodes for users. It is also worth noting that Service Nodes are quite basic at the moment, and operators will need to stay up to date with new updates to keep in line with software and hardware requirements. Once all of the updates are out, Service Nodes will also: Route end user\u2019s internet traffic, either as an exit node or relay. Monitor other Service Nodes and vote on their performance. Be called into quorums which give them authority over instant transactions ( Blink ). Once these features come out, Service Node operation will require better servers, particularly when it comes to bandwidth. For the purposes of this guide, however, we will only consider the current requirements.","title":"Overview"},{"location":"ServiceNodes/SNFullGuide/#new-user-guide","text":"This section of this guide is for new users to servers and the CLI interface.","title":"New User Guide"},{"location":"ServiceNodes/SNFullGuide/#step-1-get-a-server","text":"Righto! Let\u2019s get started. Choosing where to set up a Service Node is the biggest choice you will make when running a Service Node. There are a number of things to consider. Because you will be locking up funds indefinitly, you will want to ensure that your server has: A stable, relatively fast connection to be able to respond to ping requests to avoid being booted off the network. We recommend 2GB of RAM to cope with running the software reliably ( Note: This requirement may be much greater once services are live ). 1GB is fine for testing. At Least a 20GB SSD or Hard disk drive, this will be used to store the blockchain ( Note: to future proof yourself against blockchain growth and message storage we recommend a 30 - 40 GB drive ). A stable power supply. If your server goes down during the staking period, you may get kicked off the network, and not receive rewards while your funds are still locked for the remainder of the staking period. For most users, we assume that your home internet connection is relatively slow (< 4MB/s down and up) and probably lacks support for external connections. If this is the case, you will probably not want to run a Service Node from your home in the long term, as this could cost you if and when you get booted off. Since we\u2019re just testing at the moment, you could run it from home anyway, but for this guide we\u2019ll avoid it. Typically, the easiest and cheapest way to host a server outside of your home is to use a Virtual Private Server (VPS). There are thousands of options when it comes to VPS providers, but for now, just about any one will do. In the future, selection will be made more difficult because most providers will not allow exit node traffic, so we have compiled a list of exit node friendly providers to choose from if you want to stay with your provider for more than a few months. Hosting Provider Product Name Cost Per Month $USD Bandwidth Provided Exit Friendliness Rating Accepts Loki? Netcup VPS 1000 G8 10.50 30 - 35 MiB\u2019s 5 / 10 Evolution Host STARTER 5.50 9 - 1 MiB\u2019s 9/10 YES Online.net Start-2-S-SSD 13.99 15 - 17 MiB\u2019s 9 / 10 Scaleway START1-M 9.33 20 - 25 MiB\u2019s 7 / 10 OVH VPS SSD 2 7.61 9 - 1 MiB\u2019s 9 / 10 Leaseweb Virtual Server XL 34.45 30 - 35 MiB\u2019s 5 / 10 Digital Ocean 2 GB, 2 vCPUs 15 9 - 11 MiB\u2019s 8 / 10 Feral Hosting Neon Capability 19.68 9 - 11 MiB\u2019s 9 / 10 Trabia VDS-8G 38.54 9 - 11 MiB\u2019s 8 / 10 Hetzner EX41-SSD (30 TB) 39.71 40 - 80 MiB\u2019s 4 / 10 Note: We do not officially endorse any of these providers, this list is simply illustrative of some of the options currently available* Try not to pick the first one off the list. Do some digging and see which one looks the best to you, what your budget is, and what the latency is like for you based on the server location that you choose. When selecting your VPS\u2019 operating system, choose Ubuntu 18.04 64 bit or Ubuntu 19.04 64 bit if you want to follow this guide. If you feel more confident or wish to run your server on another distribution or operating system, the Loki commands in this guide will still apply.","title":"Step 1 - Get a Server"},{"location":"ServiceNodes/SNFullGuide/#step-2-prepare-your-server","text":"Every provider has a slightly different way of issuing you access to your new VPS. Most will send an email with the IP address, root username, and a root password of the VPS. To access your server, you will need a SSH client for your operating system. Because we\u2019re on Windows today, we\u2019ll download PuTTY, Mac users can also use PuTTY. If you\u2019re a Linux user, you probably don\u2019t want us telling you where to get a SSH client from. To connect to our VPS we will need to paste the IP address into the SSH client\u2019s \u201cHost Name (or IP address)\u201d input box and click the \u201cOpen\u201d button. The Port number can usually just be left as 22 . A terminal window will now appear prompting for your log-in details, username(root) and password, which were provided by your VPS provider. When entering your password, nothing will visually appear in the terminal. This is normal. Hit enter when it\u2019s typed or pasted, and you should be logged in to your VPS.","title":"Step 2 - Prepare your Server"},{"location":"ServiceNodes/SNFullGuide/#21-create-a-non-root-user","text":"Best practice when running a public server is to not run your software as the root user. Although it is possible to do everything as root, it is strongly recommended that you create a non-root user on our VPS by running the following command: adduser <username> Replacing <username> with a name you will log-in with. For this user-guide we will use snode as our username. adduser snode The terminal will prompt you for a new password for our newly created user. Use a secure password that is different password from the root password. Once the password has been set, the terminal will prompt for a few details about the individual running the user. You can just hit enter through each of the inputs as the details are not important for the purposes of running a Service Node. Once that\u2019s done, run the following two commands to give our new account admin privileges and to change to such account. usermod -aG sudo snode sudo su - snode Before we proceed further, it is advised to close your terminal and reopen PuTTY to set up a saved session with our snode user. Your SSH client will have a load and save session function. For PuTTY we will need to type in our VPS IP address again, on the same screen type snode under \u201cSaved Session\u201d. Click on \u201cData\u201d under the drop-down menu \u201cConnection\u201d, and type in snode (or your username defined before) into the input box \u201cAuto-login username\u201d. Go back to your session screen, where we entered the IP address, and click \u201cSave\u201d. You can load this session whenever you want to check on your Service Node.","title":"2.1 Create a non-root User"},{"location":"ServiceNodes/SNFullGuide/#22-hot-tips-for-using-the-console","text":"Consoles don't work like the rest of your computer. Here are some basic tips for navigating your way around the command line! Don't try copying something by using the usual Ctrl + C hotkey! If you want to copy something, do so by highlighting text and then right clicking it. Pasting works by right clicking a blank area in the console. If you want to kill a process or stop something from running, press Ctrl + C. (This is why you shouldn't try copying something with this hotkey.) You can always check the directory you are in by typing pwd and list its contents by typing ls . You can always return to your home directory by typing cd . You can move into a given directory by typing cd <name> or move back up one level by typing cd .. . PuTTY allows you to easily duplicate or restart a session by right clicking the top of the window. Handy if you\u2019re trying to do a few things at once. Once we have logged in correctly to the VPS for the first time, the VPS may be configured to prompt for a new password for the root account. The terminal will require you to enter the new password twice before we can start running commands. If you aren't prompted for a new root password but want to change it anyway, type sudo passwd . Choose something very secure!","title":"2.2 Hot Tips for using the Console"},{"location":"ServiceNodes/SNFullGuide/#23-server-preparation-continued","text":"We should update our package lists, the below command downloads the package lists from the repositories and \"updates\" them to get information on the newest versions of packages and their dependencies. It will do this for all repositories and PPAs. sudo apt update You will notice a bunch of package lists were downloaded, once this is complete run the below command to fetch new versions of any packages we currently have installed on the system. sudo apt upgrade You will be prompted to authorise the use of disk space, type y and enter to authorise. If you are prompted during the upgrade that a new version of any file is available then click the up and down arrows until you are hovering over install the package maintainer\u2019s version and click enter. Alright, good to go. Our server is now set up, up to date, and is not running as root. On to the fun part!","title":"2.3 Server Preparation Continued"},{"location":"ServiceNodes/SNFullGuide/#step-3-loki-launcher","text":"","title":"Step 3 - Loki Launcher"},{"location":"ServiceNodes/SNFullGuide/#31-install-nodejs-and-loki-launcher","text":"In order to use the Loki Launcher we first need to install NodeJS. Run the following command to download the package: curl -sL https://deb.nodesource.com/setup_10.x | sudo bash - Then run the following command to install nodejs: sudo apt-get install -y nodejs Next we need to install the launcher with the following command: sudo npm install -g loki-launcher","title":"3.1 - Install NodeJS and Loki Launcher"},{"location":"ServiceNodes/SNFullGuide/#32-setting-up-your-loki-launcher-for-service-node","text":"We now need to prequalify our server to be ready to run as a service node. To do so run the following command: loki-launcher prequal If all checks have passed you will receive an output similar to the following: Starting open port check on configured blockchain p2p port: 22022 OpenP2pPort: Success ! Starting open port check on configured storage server port: 8080 OpenStoragePort: Success ! Starting disk space check on blockchain partition /home/snode/.loki Creating /home/snode/.loki/storage Starting disk space check on storage server partition /home/snode/.loki/storage DiskSpace_blockchain: Success ! DiskSpace_storage: Success ! Your node successfully passed all tests","title":"3.2 - Setting up your Loki-launcher for Service Node"},{"location":"ServiceNodes/SNFullGuide/#33-download-lokid-binaries","text":"We will download the Loki binaries by running the following command: sudo loki-launcher download-binaries","title":"3.3 - Download Lokid Binaries"},{"location":"ServiceNodes/SNFullGuide/#34-start-the-loki-launcher","text":"To start the loki launcher run the following command: sudo loki-launcher start At this moment the launcher will output a table showing if everything is working properly: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 (index) \u2502 Values \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 launcher \u2502 'running as 26525' \u2502 \u2502 blockchain \u2502 'running as 26537' \u2502 \u2502 socket \u2502 'running at /opt/loki-launcher/var' \u2502 \u2502 blockchain_rpc \u2502 'running on 127.0.0.1:22023' \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Now the Loki launcher is running we can access the launcher by running the following command: sudo loki-launcher client To exit out of the client click CTRL + C . Note: Loki-launcher will run in the background now and continue to sync with the blockchain. The only problem is if the system reboots we will need to relaunch the loki-launcher software. We can fix this by configuring the Launcher as a system service which makes it automatically start up if the server reboots, and restarts it if the software crashes for some reason.","title":"3.4 - Start the Loki Launcher"},{"location":"ServiceNodes/SNFullGuide/#step-4-loki-launcher-as-a-system-service","text":"","title":"Step 4 - Loki-Launcher as a System Service"},{"location":"ServiceNodes/SNFullGuide/#41-user-permissions","text":"We are going to need to fix our user \"snode\"s permissions with the loki-launcher. Next run the following command to fix permissions: sudo loki-launcher fix-perms <USER> Replacing <USER> with snode or the username that you created. The terminal should show the following: 3.x series blockchain binary detected, disabling storage server by default running fix-perms requesting launcher stop setting permissions to snode user snode uid is 1000 homedir is /home/snode remember to restart your launcher fixing blockchain.data_dir file /home/snode/.loki/key fixing blockchain.data_dir file /home/snode/.loki/loki.log fixing blockchain.data_dir file /home/snode/.loki/p2pstate.bin fixing blockchain.data_dir file /home/snode/.loki/lmdb/data.mdb fixing blockchain.data_dir file /home/snode/.loki/lmdb/lock.mdb fixing blockchain.data_dir file /home/snode/.loki/lmdb fixing blockchain.data_dir file /home/snode/.loki/storage/storage.logs fixing blockchain.data_dir file /home/snode/.loki/storage fixing blockchain.data_dir file /home/snode/.loki","title":"4.1 - User permissions"},{"location":"ServiceNodes/SNFullGuide/#42-creating-the-service-file","text":"To create our lokid.service file run the following command: sudo nano /etc/systemd/system/lokid.service Next copy the text below and paste it into your new file. To paste in putty you can right mouse click the terminal screen. [Unit] Description=lokilauncher After=network-online.target [Service] Type=simple User=snode ExecStart=/usr/lib/node_modules/loki-launcher/index.js systemd-start Restart=always RestartSec=30s [Install] WantedBy=multi-user.target If you chose a username other than snode then change snode in the User= line to the alternative username. Once completed, save the file and quit nano: CTRL+X -> Y -> ENTER .","title":"4.2 - Creating the Service File"},{"location":"ServiceNodes/SNFullGuide/#43-enabling-the-service-file","text":"Enable lokid.service so that it starts automatically upon boot: sudo systemctl enable lokid.service Start lokid.service: sudo systemctl start lokid.service Then reboot your system to check if the service file is working correctly. sudo reboot Log back into your server and run the following command: loki-launcher status The terminal should output something similar to: launcher status: running on 818 blockchain status: running on 891 Well done! You're loki-launcher is now setup.","title":"4.3 - Enabling the Service File"},{"location":"ServiceNodes/SNFullGuide/#step-5-wallet","text":"While we wait for the daemon to sync, we can now get a wallet going. You do not have to run this wallet on the server and you should not! Download the software and run it from elsewhere for security reasons! If you need help with installing the loki-wallet-cli on another machine check out our Wallets Overview section.","title":"Step 5 - Wallet"},{"location":"ServiceNodes/SNFullGuide/#51-run-wallet","text":"To open our wallet we are going to change into the directory which we installed loki-wallet-cli and run the following command: ./loki-wallet-cli If you are on testnet run the command with the --testnet flag: ~/loki/loki-wallet-cli --testnet When loki-wallet-cli first runs, it will request for you to specify a wallet name. Assuming we haven't created one yet, we will use the e.g. name MyWallet Because this is the first time we have used the name MyWallet the client will prompt us to create a new wallet. Type y and click return to continue. The loki-wallet-cli has generated us a wallet called MyWallet and is now prompting us for a password. Note : When typing the password, the characters will not appear. It will seem as if you are typing and no text is appearing however the terminal is logging every character you type including if it is capitalised or lowercase. Write down your wallet name and password on a piece of paper as this information will be required every time we want to enter our wallet. Use a password with uppercase letters, lowercase letters, numbers, symbols and make the password at least 9 characters long. Once we have chosen our password for the wallet we must choose our language. For the purposes of this user guide I suggest you use English by typing in 1 and clicking return. The CLI will generate and spit out several lines of text. The first two lines of text show your wallet public address. This address can be shared, will be used to receive Loki to your wallet, and will be used during the preparation and registration of our Service Node. All Mainnet Loki public addresses start with an L and are followed with a string of characters, Testnet Public addresses start with a T. The public address shown will be your primary address, however multiple public addresses can be generated from this primary address.","title":"5.1 - Run Wallet"},{"location":"ServiceNodes/SNFullGuide/#52-save-seed-phrase","text":"Line 13 to 17 show your 25-word mnemonic (\u201cnew-monic\u201d) seed. The seed is used to easily backup and restore your wallet without needing any other information. At this stage, grab a pen and paper, and write down your 25 words in order. Store the piece of paper in a safe and secure place, if your words are stored in a text file on your computer or stored online, you increase your risk of someone else getting control of your wallet.","title":"5.2 - Save Seed Phrase"},{"location":"ServiceNodes/SNFullGuide/#53-store-enough-loki-in-your-wallet-for-staking","text":"It is at this point that we should get some Loki in the wallet. The amount of Loki required to run a node is derived from the function shown in Lokis Cryptoeconomic paper . Don't worry if you cant work out the formula, you can use this community created tool or, the daemon will display the amount of Loki required to run the node. If you do not have enough you will have the option to join in or run your own Service Node pool. If you are running a Service Node on the testnet you will only ever require 100 testnet Loki to run the Node. You can ask the Telegram @LokiSNBot for some testnet loki or ask someone in the Loki Discord Community for some.","title":"5.3 - Store enough $loki in your wallet for staking"},{"location":"ServiceNodes/SNFullGuide/#54-information-required-for-the-service-node","text":"If you are staking please do not use Subaddresses. They are currently unsupported by the Loki wallet. We will need our address to register our Service Node later, to get your primary address type the following command: address Highlight the string of characters that were outputted and save this in a notepad for later use, your public address should look similar to: T6TCCyDgjjbddtzwNGryRJ5HntgGYvqZTagBb2mtHhn7WWz7i5JDeqhFiHqu7ret56411ZJS7Thfeis718bVteBZ2UA6Y7G2d (Note that this is an example testnet wallet address; your address will start with L if it is a mainnet wallet) NOTE: Do not use CTRL + C to copy your address, it will close the wallet down. Simply highlight the address and this will automatically save the portion you highlighted into your clipboard. Once you have enough Loki in this wallet, just leave it open, we\u2019ll come back to it in a minute.","title":"5.4 - Information required for the Service Node"},{"location":"ServiceNodes/SNFullGuide/#step-6-service-node-registration","text":"The next part of the guide will split into two sections: If you are an individual staker and do not require any other contributors to run your Service Node jump into 6.1 - individual Staking . If you want to run a pooled Service Node or contribute towards a pool jump into 6.2 - Pool Staking","title":"Step 6 - Service Node Registration"},{"location":"ServiceNodes/SNFullGuide/#61-individual-staking","text":"If you want to run the Service Node as an individual you will require the following things. A loki-launcher initialised with loki-launcher prequal . See Step 3.2 A fully synchronized, up-to-date Loki daemon running through the loki-launcher. A loki-wallet-cli primary address with enough Loki in your account to meet the Service Node Staking Requirement. See Step 5 Now if we have the three above items we can proceed to our daemon to register our Service Node. Log in (if not already connected) as the snode user on the VPS running the service node, then connect to the loki-launcher client: loki-launcher client Start the registration process by running the following interactive command: prepare_registration The daemon will output the current staking requirement and prompt you with an input to clarify whether you are an individual staker or you will be running a pool. Type y and click enter as we will be the sole staker. The daemon will now prompt us for the Loki address of the operator. If you followed step 5 you should have this address saved in a notepad, if not run through step 5 again to find your Loki Address. Once we have the Loki Address copied to our clipboard we can then right click the terminal screen to paste the address. Double check the address matches the one of your wallet then click enter if it is the same. The daemon will now ask for a final confirmation, if you agree to the information provided type y and click enter. The daemon will output a command for us to run looking similar to: register_service_node 4294967292 T6TCCyDgjjbddtzwNGryRJ5HntgGYvqZTagBb2mtHhn7WWz7i5JDeqhFiHqu7ret56411ZJS7Thfeis718bVteBZ2UA6Y7G2d 4294967292 100.000000000 1535677391 ec3895ea70a4a91b5ec4b5e1df96a45e07046f1fb0123c754d98fb2d70f4529d 5bb35d7b8ab1acb943bc47913ada8f9d2e6d6e22264e57484a04c1bbfd461f0ee2e5435454cd9b7059b221eb506ce9ea4537ddd9faf1f1757e0ef611a41c0609 NOTE: You must run the command outputed by your daemon and not the command shown above. Copy the whole line of text and paste it into your notepad as we will need to run this command in our loki-wallet-cli . If registering multiple nodes, it will likely be necessary to wait at least 10 blocks between Service Nodes before running the register Service Node command in the wallet. You have 2 weeks from the moment of preparing the registration command on the Service Node to actually run the register_service_node command in the wallet, however it is advised to do it as soon as possible. Run through step 5 once more to open our Loki wallet (if you don't already have it open). Once we are in our wallet run the command the daemon outputted for us when we prepared our Service Node registration. The wallet will prompt us to confirm our password, then the amount of Loki to stake. Confirm this by typing y and clicking enter. Note: At this point you now have locked stakes! To unlock your stake run the following Well done! Let's continue to the next step \" Step 7 - Service Node Check \" to check if our Service Node is running.","title":"6.1 - Individual Staking"},{"location":"ServiceNodes/SNFullGuide/#62-pool-staking","text":"","title":"6.2 - Pool Staking"},{"location":"ServiceNodes/SNFullGuide/#minimum-contribution-rules","text":"Infinite Staking introduces new limitations on the number of transactions that can be contributed to a Service Node, changing the minimum contribution rules for participating in the Service Node. Service Nodes accept at most 4 contributions, meaning the minimum contribution to a Service Node becomes: In a pooled Service Node with reserved spots, the Minimum Contribution must be either the Reserved Amount or the Contribution determined by the above equation, whichever is larger. A simplistic example being, if the staking requirement is 24,000 Loki then if, Operator contributes 50% of the requirement (12,000 Loki) The next contributor must contribute at least (\u2153 * 12,000) Loki i.e. 4000 Loki to become a participant. If this contributor had reserved a spot for more than 4000 Loki, their Minimum Contribution would be that amount. There are rules in the client software in place to stop users from irreversibly funding a Service Node into an invalid state. Depending on the individual and their circumstance they will need to: Jump into section 6.2.1 - Operator if they are running the daemon and hosting the pool; Jump into section 6.2.2 - Pool Contributor if they are contributing to someone's Service Node. NOTE: It is advised to read both sections of \" 6.2 - Pool Staking \" to have a better understanding of the process.","title":"Minimum Contribution Rules"},{"location":"ServiceNodes/SNFullGuide/#621-operator","text":"The Operator is the individual who will be hosting the pool and running the Service Node daemon, thus incurring the operating expenses encompassed by running a node. The Operator will need to have: A loki-launcher initialised with loki-launcher prequal . See Step 3.2 . A fully synchronized, up-to-date Loki daemon running through the loki-launcher. A loki-wallet-cli primary address with enough Loki in your account to meet the Service Node Staking Requirement. See Step 5 1-3 other contributors who also have a wallet ( loki-wallet-cli or the desktop GUI wallet) with enough Loki in their accounts to meet 25% of the staking requirement. If the operator wants to reserve contribution spots for specific contributors: The address and contribution amounts the 1-3 contributors will stake. NOTE: The other contributors addresses are optional to have as you can create your pool to be open to anyone to contribute to, however they are recommended to have to avoid any issues of other individuals stealing their spots. On the other hand, a reserved contribution spot can only be filled by that contributor: if they change their mind before submitting a stake your service node will be stuck inactive, so it is recommended to use reserved contribution spots only with contributors you trust. Now if we have the three/four above items we can proceed to our daemon to register our Service Node. Log in (if not already connected) as the snode user on the VPS running the service node, then connect to the loki-launcher client: loki-launcher client Start the registration process by running the following interactive command: prepare_registration The terminal will prompt the operator to specify if they will contribute the entire stake, because we are running this as a pooled Service Node we will type n and click enter. Next the terminal will request the input for the operator cut. This value is between 0-100 and represents the percentage of the reward the operator will receive before the reward is distributor to the share holders. If you have agreed to a 10% operator cut with the other contributors you would type 10 and click return. The terminal will now display the minimum reserve the operator can contribute and request the operator to input the amount in Loki they wish to contribute. Type your desired <operator contribution> and click return. Once we have set the operators desired stake amount we have the option to either leave the pool open for anyone to contribute or lock a reserve for individuals that have agreed with us to stake within our Service Node.","title":"6.2.1 - Operator"},{"location":"ServiceNodes/SNFullGuide/#reserved-pool","text":"If the operator wishes to reserve spots for specific contributors they should type y and click return. The terminal will now prompt the operator for the number of additional contributors they have organised to be apart of this Service Node. Type in the number of reserved contributors, not including themselves, and click return. The daemon will now prompt us for the Loki address of the operator. If you followed step 5 you should have this address saved in a notepad, if not run through step 5 again to find your address. Once we have the Loki Address copied to our clipboard we can then right click the terminal screen to paste the address then click return to confirm your address. Next the operator must input the amount of Loki each contributor will contribute and the contributor's address. NOTE: It is possible to reserve only some of the required stakes for specific contributors while leaving the remaining stake open. You will now be asked to confirm the information above is correct.","title":"Reserved Pool"},{"location":"ServiceNodes/SNFullGuide/#open-pool","text":"If the operator wishes to leave their pool complete open to contributions they should type n and click return. The terminal will prompt the operator to input their address. Once the address has been inputted the terminal will display the remaining portion that needs to be contributed by others. If you agree click y and hit return. The daemon will display a summary of the information we entered. This is our chance for a final check over to make sure we entered in the right information. If you confirm the information is correct type y and click return. The daemon will output a command for us to run within our wallet, looking similar to: register_service_node 214748364 T6UCEoWvJHCJq5biK3LMQZ4CRXAaqiPda2kCRRYYYEMFfxYoqnUo7Nx88RL3wmENwN4kfjDSp2jMN1g6PSErKrSu2EEp8UMy5 1073741823 T6TCCyDgjjbddtzwNGryRJ5HntgGYvqZTagBb2mtHhn7WWz7i5JDeqhFiHqu7ret56411ZJS7Thfeis718bVteBZ2UA6Y7G2d 3221225469 25.000000000 1535692249 5dac247e90ced2dcd9e51faec8792acb0c11b4c700640d9104b17c868ea167e3 cc11eef804c11d3e93cf8c488c10d97b8cec9ee2b38e6666ff07749c2911aa06ce310edc926a4d2f50a588e9c15afcc20e935a0f188aa7caa764a62058dec80d NOTE: You must run the command outputed by your daemon and not the command shown above. Copy the whole line of text in your daemon and paste it into your notepad as we will need to run this command in our loki-wallet-cli . You have 2 weeks from the moment of registering the Service Node to run the register_service_node command, however it is advised to do it as soon as possible. Before you disconnect from your VPS connect to the loki-launcher client : loki-launcher client and run the following command to get your <Service Node Public Key> and save it in your notepad (your contributors will need it): print_sn_key Run through step 5 once more to open our Loki wallet. Once we are in our wallet run the command the daemon outputted for us when we prepared our Service Node. The wallet will prompt us to confirm our password, then the amount of Loki to stake. Confirm this by typing y and clicking enter. Once this command completes your staking transaction will be sent to be included on the blockchain. It may take a few minutes for the transaction to be mined into a block; you can check the status using the loki-launcher and running the command: print_sn_status or by looking for your <Service Node Public Key> in the \"Service Nodes Awaiting\" section on lokiblocks.com (or lokitestnet.com for a testnet service node). Once the service node registration is received you can send the <Service Node Public Key> to your contributors with the amount of Loki they are required to stake. NOTE: the final amount will typically be slightly lower than what you entered in the prepare_registration command. This is expected: the required amounts are based on the registration block height which has usually advanced by a couple blocks between the time you prepared the registration and the time it gets mined into the blockchain. At this point we will need to wait until all contributors have staked before the service node activates and becomes eligible to receive rewards.","title":"Open Pool"},{"location":"ServiceNodes/SNFullGuide/#622-pool-contributor","text":"The pool contributor must first receive the Service Node Pubkey and the requirements (amount of loki to send) from the Service Node Operator. If you are staking please do not use Subaddresses. They are currently unsupported by the Loki wallet The pool contributor must have downloaded the necessary binaries, is running a daemon or is connected to a remote node, has generated a wallet through either the loki-wallet-cli or the desktop GUI wallet, and has enough Loki to stake. They can then run the following command in their loki-wallet-cli . stake <Service Node Pubkey> <contribution amount> Where the <Service Node Pubkey> is the Pubkey provided from the Service Node operator and <contribution amount> is the amount of Loki they are going to stake which they agreed to with the Service Node Operator. If using the desktop GUI wallet, the Stake command can be found under the Advanced - Service Node menu. Enter the service <Service Node Pubkey> and <contribution amount> and hit the Stake button. At this stage you will need to wait for the other contributors to provide their collateral. Once everyone has staked you can refer to \u201cStep 7 - Service Node Check\u201d to see where your Service Node Operator\u2019s node is in the list. Congratulations, you are now staking.","title":"6.2.2 - Pool Contributor"},{"location":"ServiceNodes/SNFullGuide/#step-7-service-node-check","text":"After we have locked our collateral we will need to check if our Service Node Pubkey is sitting in the list with the other Service Node\u2019s on the network. This will prove our Service Node is running, recognised and will receive a reward if it keeps running. Connect to the VPS where the service node is running and run the following command in our loki-launcher client to see our Service Node Public Key: print_sn_key The Service Node Public Key is used to identify our Service Node within the list of Service Nodes currently on the network. If you want more detailed Service Node status you can use the follow command: print_sn_status You can jump onto https://lokiblocks.com/ to see if your Service Node is in the list or we can continue in the terminal to output the same information. If you are running your Service Node on testnet go to https://lokitestnet.com/ instead. To check this information directly with the service node itself, first get the current block height by running status into the terminal with loki-launcher client launched.. Once we have the block height we can then check the current Service Nodes on the network at our specified block height. Run the following command in the loki-launcher : print_quorum_state <block height> Replacing <block height> with the number minus 1 that was outputted when running status command. If your <Service Node Pubkey> is sitting in the list you know you are now staking.","title":"Step 7 - Service Node Check"},{"location":"ServiceNodes/SNFullGuide/#step-8-unlock-stake","text":"Service Nodes will continually receive block rewards indefinitely until a stake is unlocked or the Service Node becomes deregistered. Unlocking is available via the following command which needs to be run in the command line wallet: request_stake_unlock <service node key> Once the unlock is requested and the request is included in a block in the blockchain, the Service Node will then expire in 15 days (10800 blocks) and the funds will become unlocked after expiry. In pooled nodes, any contributor that requests the stake to unlock will schedule the Service Node for expiration. All locked stakes in that Service Node will be unlocked in 15 days (10800 blocks). Once the unlock is requested, this process can not be undone or prolonged. Service Node participants will continue receiving rewards until expiration. Deregistrations can be issued at any point during the active lifecycle of the Service Node. This is inclusive of the time period during which the Service Node is scheduled for expiry. Getting deregistered removes your Service Node from the network and your stakes are placed into a list of blacklisted transactions. Blacklisted transactions are locked and unspendable for 30 days (21600 blocks) from the block in which the Service Node was deregistered. Receiving a deregistration after participants have already requested the stake to unlock overrides the 15 day (10800 blocks) unlock time, and resets the unlock time to 30 days (21600 blocks).","title":"Step 8 - Unlock Stake"},{"location":"ServiceNodes/SNFullGuide/#optional","text":"","title":"Optional"},{"location":"ServiceNodes/SNFullGuide/#see-locked-stake-amount-and-duration","text":"We can also view our locked stake by running the following command from our loki-wallet-cli we staked from: print_locked_stakes","title":"See Locked Stake Amount and Duration"},{"location":"ServiceNodes/SNFullGuide/#updating-your-binaries","text":"IMPORTANT: Please check the important changes section at the top of this page to see the changes before running your updates. When new binaries are out we need to log into our server as the which we initially set up our loki-launcher on. Run the following command to update our loki-launcher: sudo npm install -g loki-launcher Stop our lokid.service file: sudo systemctl stop lokid.service Then run the following command to download the new binaries: sudo loki-launcher download-binaries Next we'll need to run check-systemd now to upgrade your nofile (file descriptor limit): sudo loki-launcher check-systemd This next command is optional, try it if you run into issues. Fix permissions for Lokinet if you aren't running as root, <USER> should be replaced with the username your Service Node runs under - if you followed this guide it will be snode: sudo loki-launcher fix-perms <USER> Start lokid.service again: sudo systemctl start lokid.service If you are running loki-launcher as a service you can now reboot your computer and the new binaries will be used. sudo reboot","title":"Updating your Binaries"},{"location":"ServiceNodes/SNFullGuide/#default-directories-for-loki-files","text":"Name Directory Blockchain Data /home/<user>/.loki/ Lokid Binaries /opt/loki-launcher/bin Launcher Config File /etc/loki-launcher/launcher.ini Lokid Logs /home/<user>/.loki/","title":"Default Directories for Loki Files"},{"location":"ServiceNodes/SNFullGuide/#express-setup-guide","text":"Step 1: Get a Server Step 2: Prepare your server adduser snode usermod -aG sudo snode sudo su - snode sudo apt update sudo apt upgrade Step 3: Loki-Launcher curl -sL https://deb.nodesource.com/setup_10.x | sudo bash - sudo apt-get install -y nodejs sudo npm install -g loki-launcher loki-launcher prequal sudo loki-launcher download-binaries sudo loki-launcher start sudo loki-launcher client To exit out of the client click CTRL + C . Step 4: Loki-Launcher as a System Service su - root loki-launcher fix-perms snode su - snode sudo loki-launcher start sudo nano /etc/systemd/system/lokid.service Paste the following into your terminal: [Unit] Description=lokilauncher After=network-online.target [Service] Type=simple User=snode ExecStart=/usr/lib/node_modules/loki-launcher/index.js systemd-start Restart=always RestartSec=30s [Install] WantedBy=multi-user.target Save and exit the file by typing CTRL + X -> Y -> Enter . sudo systemctl daemon-reload sudo systemctl enable lokid.service sudo systemctl start lokid.service sudo reboot Log back into your server and check your launcher: loki-launcher status Step 5: Wallet ./loki-wallet-cli Save the address that comes from running: address Step 6: Service Node Registration loki-launcher client prepare_registration Run the register-service-node command in our loki-wallet-cli register_service_node 4294967292 T6TCCyDgjjbddtzwNGryRJ5HntgGYvqZTagBb2mtHhn7WWz7i5JDeqhFiHqu7ret56411ZJS7Thfeis718bVteBZ2UA6Y7G2d 4294967292 100.000000000 1535677391 ec3895ea70a4a91b5ec4b5e1df96a45e07046f1fb0123c754d98fb2d70f4529d 5bb35d7b8ab1acb943bc47913ada8f9d2e6d6e22264e57484a04c1bbfd461f0ee2e5435454cd9b7059b221eb506ce9ea4537ddd9faf1f1757e0ef611a41c0609 NOTE: You must run the command outputed by your daemon and not the command shown above.","title":"Express Setup Guide"},{"location":"ServiceNodes/SNFullGuide/#conclusion","text":"Well done! You will receive a block reward when your Service Node has been active for some time and the network chooses you within the list. Bonus : Use the community-run telegram bot @LokiSNBot to receive on-the-fly updates about your service node. Props to @jagerman42 for building this. Bonus 2 : View https://imaginary.stream/sn/ for more details on Loki Service Node staking requirements. This guide will be regularly updated when new features are added to Snodes. Join the discord for more discussion. If you can improve this guide, please submit a pull request.","title":"Conclusion"},{"location":"ServiceNodes/SNFullGuideLegacy/","text":"Full Guide on Service Nodes \u00b6 This document will tell you exactly how to set up and operate a Service Node for the Loki Project. This document was written with non-developers in mind, so people new to linux or command line operations should be able to follow along without any trouble. If you feel confident around servers and the CLI, then skip to the Express Setup Guide You can of course run the Loki software on any operating system that you can get it to build on, but for the purposes of this document, the instructions apply to running a Service Node on a remote Ubuntu 16.04 server. If that isn\u2019t what you want to do, syntax and server set up will of course differ according to whatever OS you choose to run your Service Node from. Summary of Loki Service Node Requirements \u00b6 Full summary of Loki Service Node Requirements. This may change depending on Service Node functionality, so you should check here regularly, or follow our Telegram / Discord announcements channel. Spec Note Latest Binary Hefty Heimdall Software Ubuntu 16.04, Ubuntu 18.04 Storage 30-50gb Ram 2-4 gb Table of Contents \u00b6 Overview of Service Nodes New User Guide Step 1 Server Step 2 Server Prep Step 3 Download Binaries Step 4 Service Node as a Service Step 5 Open a Loki Wallet Step 6 Register Node Step 7 Check Registration Express Setup Guide Overview \u00b6 To understand what a Service Node is, you can refer to the whitepaper to get an in depth understanding. For now, all you need to know is that: Service Nodes are full nodes on the Loki network Full nodes become Service Nodes when the owner locks the required amount of Loki and submits a registration transaction. Once accepted by the network, the Service Node is eligible to win block rewards. Multiple participants can be involved in one Service Node and can have the reward automatically distributed It is also worth noting that Service Nodes are quite basic at the moment, and operators will need to stay up to date with new updates to keep in line with software and hardware requirements. Once all of the updates are out, Service Nodes will also: Route end user\u2019s internet traffic, either as an exit node or relay. Receive, store and forward encrypted user messages. Monitor other Service Nodes and vote on their performance. Be called into quorums which give them authority over instant transactions ( Blink ). Act as remote nodes for users. Once these features come out, Service Node operation will require better servers, particularly when it comes to bandwidth. For the purposes of this guide, however, we will only consider the current requirements. New User Guide \u00b6 This section of this guide is for new users to servers and the CLI interface. Step 1 - Get a Server \u00b6 Righto! Let\u2019s get started. Choosing where to set up a Service Node is the biggest choice you will make when running a Service Node. There are a number of things to consider. Because you will be locking up funds for 30 days (2 days for testnet) at a time, you will want to ensure that your server has: A stable, relatively fast connection to be able to respond to ping requests to avoid being booted off the network. We recommend 2GB of RAM to cope with running the software reliably ( Note: This requirement may be much greater once services are live ). 1GB is fine for testing. At Least a 20GB SSD or Hard disk drive, this will be used to store the blockchain ( Note: to future proof yourself against blockchain growth and message storage we recommend a 30 - 40 GB drive ). A stable power supply. If your server goes down during the staking period, you may get kicked off the network, and not receive rewards while your funds are still locked for the remainder of the staking period. For most users, we assume that your home internet connection is relatively slow (< 4MB/s down and up) and probably lacks support for external connections. If this is the case, you will probably not want to run a Service Node from your home in the long term, as this could cost you if and when you get booted off. Since we\u2019re just testing at the moment, you could run it from home anyway, but for this guide we\u2019ll avoid it. Typically, the easiest and cheapest way to host a server outside of your home is to use a Virtual Private Server (VPS). There are thousands of options when it comes to VPS providers, but for now, just about any one will do. In the future, selection will be made more difficult because most providers will not allow exit node traffic, so we have compiled a list of exit node friendly providers to choose from if you want to stay with your provider for more than a few months. Hosting Provider Product Name Cost Per Month $USD Bandwidth Provided Exit Friendliness Rating Netcup VPS 1000 G8 10.50 30 - 35 MiB\u2019s 5 / 10 Online.net Start-2-S-SSD 13.99 15 - 17 MiB\u2019s 9 / 10 Scaleway START1-M 9.33 20 - 25 MiB\u2019s 7 / 10 OVH VPS SSD 2 7.61 9 - 1 MiB\u2019s 9 / 10 Leaseweb Virtual Server XL 34.45 30 - 35 MiB\u2019s 5 / 10 Digital Ocean 2 GB, 2 vCPUs 15 9 - 11 MiB\u2019s 8 / 10 Feral Hosting Neon Capability 19.68 9 - 11 MiB\u2019s 9 / 10 Trabia VDS-8G 38.54 9 - 11 MiB\u2019s 8 / 10 Hetzner EX41-SSD (30 TB) 39.71 40 - 80 MiB\u2019s 4 / 10 Note: We do not officially endorse any of these providers, this list is simply illustrative of some of the options currently available* Try not to pick the first one off the list. Do some digging and see which one looks the best to you, what your budget is, and what the latency is like for you based on the server location that you choose. When selecting your VPS\u2019 operating system, choose Ubuntu 16.04 64 bit or Ubuntu 18.04 64 bit if you want to follow this guide. If you feel more confident or wish to run your server on another distribution or operating system, the Loki commands in this guide will still apply. Step 2 - Prepare your Server \u00b6 Every provider has a slightly different way of issuing you access to your new VPS. Most will send an email with the IP address, root username, and a root password of the VPS. To access your server, you will need a SSH client for your operating system. Because we\u2019re on Windows today, we\u2019ll download PuTTY, Mac users can also use PuTTY. If you\u2019re a Linux user, you probably don\u2019t want us telling you where to get a SSH client from. To connect to our VPS we will need to paste the IP address into the SSH client\u2019s \u201cHost Name (or IP address)\u201d input box and click the \u201cOpen\u201d button. The Port number can usually just be left as 22 . A terminal window will now appear prompting for your log-in details, username(root) and password, which were provided by your VPS provider. When entering your password, nothing will visually appear in the terminal. This is normal. Hit enter when it\u2019s typed or pasted, and you should be logged in to your VPS. Create a non-root User \u00b6 Best practice when running a public server is to not run your software as the root user. Although it is possible to do everything as root, it is strongly recommended that you create a non-root user on our VPS by running the following command: adduser <username> Replacing <username> with a name you will log-in with. For this user-guide we will use snode as our username. adduser snode The terminal will prompt you for a new password for our newly created user. Use a secure password that is different password from the root password. Once the password has been set, the terminal will prompt for a few details about the individual running the user. You can just hit enter through each of the inputs as the details are not important for the purposes of running a Service Node. Once that\u2019s done, run the following two commands to give our new account admin privileges and to change to such account. usermod -aG sudo snode su - snode Before we proceed further, it is advised to close your terminal and reopen PuTTY to set up a saved session with our snode user. Your SSH client will have a load and save session function. For PuTTY we will need to type in our VPS IP address again, on the same screen type snode under \u201cSaved Session\u201d. Click on \u201cData\u201d under the drop-down menu \u201cConnection\u201d, and type in snode (or your username defined before) into the input box \u201cAuto-login username\u201d. Go back to your session screen, where we entered the IP address, and click \u201cSave\u201d. You can load this session whenever you want to check on your Service Node. Hot Tips for using the Console \u00b6 Consoles don't work like the rest of your computer. Here are some basic tips for navigating your way around the command line! Don't try copying something by using the usual Ctrl + C hotkey! If you want to copy something, do so by highlighting text and then right clicking it. Pasting works by right clicking a blank area in the console. If you want to kill a process or stop something from running, press Ctrl + C. (This is why you shouldn't try copying something with this hotkey.) You can always check the directory you are in by typing pwd and list its contents by typing ls . You can always return to your home directory by typing cd . You can move into a given directory by typing cd <name> or move back up one level by typing cd .. . PuTTY allows you to easily duplicate or restart a session by right clicking the top of the window. Handy if you\u2019re trying to do a few things at once. Once we have logged in correctly to the VPS for the first time, the VPS may be configured to prompt for a new password for the root account. The terminal will require you to enter the new password twice before we can start running commands. If you aren't prompted for a new root password but want to change it anyway, type sudo passwd . Choose something very secure! Server Preparation Continued \u00b6 We should update our package lists, the below command downloads the package lists from the repositories and \"updates\" them to get information on the newest versions of packages and their dependencies. It will do this for all repositories and PPAs. sudo apt update You will notice a bunch of package lists were downloaded, once this is complete run the below command to fetch new versions of any packages we currently have installed on the system. sudo apt upgrade You will be prompted to authorise the use of disk space, type y and enter to authorise. If you are prompted during the upgrade that a new version of any file is available then click the up and down arrows until you are hovering over install the package maintainer\u2019s version and click enter. Alright, good to go. Our server is now set up, up to date, and is not running as root. On to the fun part! Step 3 - Download the Loki Binaries \u00b6 In order to download and extract the Linux binaries, we need to make sure a couple tools are installed: sudo apt install wget unzip Now download the Linux binaries by running the following command: wget <link> Where <link> is the download link of the latest linux release. To find the link go to https://github.com/loki-project/loki/releases/latest , right click the latest linux release and click Copy Link Location . 3.1 - Lokid Binaries \u00b6 To download the lokid binaries run the following command: wget https://github.com/loki-project/loki/releases/download/vX.X.X/loki-linux-x64-vX.X.X.tar.xz Replacing X.X.X with the latest binary version number from https://github.com/loki-project/loki/releases/latest . 3.2 - Storage Server Binaries \u00b6 To download the loki storage server binaries run the following command: wget https://github.com/loki-project/loki-storage-server/releases/download/vX.X.X/loki-storage-linux-x64-vX.X.X.tar.xz Replacing X.X.X with the latest binary version number from https://github.com/loki-project/loki-storage-server/releases . 3.3 - Untar Binaries \u00b6 To untar the downloaded files run the following command: tar -xvf <filename> Replacing <filename> with the the filename we downloaded. For this example we would run 2 commands: tar -xvf loki-linux-x64-vX.X.X.tar.xz tar -xvf loki-storage-linux-x64-vX.X.X.tar.xz 3.4 - Create Symlink \u00b6 Note you need to replace the vX.X.X with the version you downloaded previous otherwise the symlink will not work. We now want to create a \"symlink\" to the extracted loki-linux-x64-vX.X.X folder: ln -snf loki-linux-x64-vX.X.X loki and a \"symlink\" to the extracted loki-storage-linux-x64-vX.X.X folder: ln -snf loki-storage-linux-x64-vX.X.X loki-ss This creates a virtual folder that points to the binary folders. This isn't strictly necessary, but will help with upgrades in the future: when you want to upgrade you can just repeat everything in this step again with the new binaries. Excellent! We now have all of the necessary files to get this show on the road! NOTE: If you\u2019re nervous about trusting the binaries or the download link, you should build it from source yourself. Instructions for that can be found in the README of https://github.com/loki-project/loki Step 4 - Service Node as a Service \u00b6 At this point you can run the Loki binaries directly in your terminal, but this is not a viable approach to running it as a service node: when you close PuTTY the program running inside it will also shut down, which is no good for a service node. Instead we will configure the Loki daemons as a system service which makes it automatically start up if the server reboots, and restarts it automatically if it crashes for some reason. 4.1 lokid.service file \u00b6 Create the lokid.service file: sudo nano /etc/systemd/system/lokid.service Copy the text below and paste it into your new file: [Unit] Description=lokid service node After=network-online.target [Service] Type=simple User=snode ExecStart=/home/snode/loki/lokid --non-interactive --service-node --service-node-public-ip SERVERIP --storage-server-port 23023 Restart=always RestartSec=30s [Install] WantedBy=multi-user.target Replacing SERVERIP in the line ExecStart= with your servers IP. To find your SERVERIP run the command curl ifconfig.me If you chose a username other than snode then change snode in the User= and ExecStart= lines to the alternative username. (If you want to run a testnet service node, append --testnet to the end of the ExecStart line. Alternatively, if you want to be able to run both a testnet and mainnet service node simultaneously you can use two service files: lokid.service and lokid-testnet.service and add --testnet to the ExecStart= line in the latter. You would then use lokid-testnet.service instead of lokid.service in the commands below when you want to control the testnet service node.) Once completed, save the file and quit nano: CTRL+X -> Y -> ENTER. 4.2 loki-ss.service file \u00b6 Create the loki-ss.service file: sudo nano /etc/systemd/system/loki-ss.service Copy the text below and paste it into your new file: [Unit] Description=Loki storage server After=network-online.target Requires=lokid.service [Service] User=snode Type=simple WorkingDirectory=/home/snode Restart=always RestartSec=5s ExecStart=/home/snode/loki-storage 0.0.0.0 23023 --lokid-rpc-port 22023 --lokid-key /home/snode/.loki/key [Install] WantedBy=multi-user.target If you chose a username other than snode then change snode in the User= and ExecStart= lines to the alternative username. Once completed, save the file and quit nano: CTRL+X -> Y -> ENTER. 4.3 Enabling Service Files \u00b6 Reload systemd manager configuration (to make it re-read the new service file): sudo systemctl daemon-reload Enable lokid.service so that it starts automatically upon boot: sudo systemctl enable lokid.service loki-ss.service Start lokid.service: sudo systemctl start lokid.service loki-ss.service The daemon will now start syncing. You won\u2019t be able to do much if it hasn\u2019t synced. To see the progress of your lokid service file you can run the following command: sudo journalctl -u lokid.service -af You should see it syncing the blockchain. To see the progress of your loki-ss service file you can run the following command: sudo journalctl -u loki-ss.service -af Step 5 - Get/Open A Wallet \u00b6 While we wait for the daemon to sync, we can now get a wallet going. You do not have to run this wallet on the server and you should not! Download the software and run it from elsewhere for security reasons! You can run the CLI wallet (Command Line Interface wallet) on any other computer, including your home computer to avoid leaving your wallet on the server. However, if you do want to run the CLI wallet on another computer, you will either need to run another daemon on that local machine or use a remote node (uk.loki.cash:22020, for example). There is also a list of trusted remote nodes in the Loki Project Discord channel under #links-and-resources. ./loki-wallet-cli --daemon-address <insert address here> Or on windows: loki-wallet-cli.exe --daemon-address <insert address here> If you are made of money and are willing to take the small risk of losing all of your funds, you can continue running the wallet inside the Service Node VPS. So we don't have to talk about a myriad of other operating systems or potential user cases, the rest of this guide will assume you are running the wallet in the same VPS. As such, it\u2019ll probably save us time to open a second PuTTY session. You can do this by right clicking the window of the current PuTTY session and clicking \u201cDuplicate Session.\u201d Log in as the non-root user that we set up before, in our case snode , and launch the wallet using: ~/loki/loki-wallet-cli If you are on testnet run the command with the --testnet flag: ~/loki/loki-wallet-cli --testnet When loki-wallet-cli first runs, it will request for you to specify a wallet name. Assuming we haven't created one yet, we will use the e.g. name MyWallet Because this is the first time we have used the name MyWallet the client will prompt us to create a new wallet. Type y and click return to continue. The loki-wallet-cli has generated us a wallet called MyWallet and is now prompting us for a password. Note: When typing the password, the characters will not appear. It will seem as if you are typing and no text is appearing however the terminal is logging every character you type including if it is capitalised or lowercase. Write down your wallet name and password on a piece of paper as this information will be required every time we want to enter our wallet. Use a password with uppercase letters, lowercase letters, numbers, symbols and make the password at least 9 characters long. Once we have chosen our password for the wallet we must choose our language. For the purposes of this user guide I suggest you use English by typing in 1 and clicking return. The CLI will generate and spit out several lines of text. The first two lines of text show your wallet public address. This address can be shared, will be used to receive Loki to your wallet, and will be used during the preparation and registration of our Service Node. All Mainnet Loki public addresses start with an L and are followed with a string of characters, Testnet Public addresses start with a T. The public address shown will be your primary address, however multiple public addresses can be generated from this primary address. Line 13 to 17 show your 25-word mnemonic (\u201cnew-monic\u201d) seed. The seed is used to easily backup and restore your wallet without needing any other information. At this stage, grab a pen and paper, and write down your 25 words in order. Store the piece of paper in a safe and secure place, if your words are stored in a text file on your computer or stored online, you increase your risk of someone else getting control of your wallet. It is at this point that we should get some Loki in the wallet. The amount of Loki required to run a node is derived from the function shown in Lokis Cryptoeconomic paper . Don't worry if you cant work out the formula, you can use this community created tool or, the daemon will display the amount of Loki required to run the node. If you do not have enough you will have the option to join in or run your own Service Node pool. If you are running a Service Node on the testnet you will only ever require 100 testnet Loki to run the Node. You can ask the Telegram @LokiSNBot for some testnet loki or ask someone in the Loki Discord Community for some. If you are staking please do not use Subaddresses. They are currently unsupported by the Loki wallet. We will need our address to register our Service Node later, to get your primary address type the following command: address Highlight the string of characters that were outputted and save this in a notepad for later use, your public address should look similar to: T6TCCyDgjjbddtzwNGryRJ5HntgGYvqZTagBb2mtHhn7WWz7i5JDeqhFiHqu7ret56411ZJS7Thfeis718bVteBZ2UA6Y7G2d (Note that this is an example testnet wallet address; your address will start with L if it is a mainnet wallet) NOTE: Do not use CTRL + C to copy your address, it will close the wallet down. Simply highlight the address and this will automatically save the portion you highlighted into your clipboard. Once you have enough Loki in this wallet, just leave it open, we\u2019ll come back to it in a minute. Step 6 - Service Node Registration \u00b6 The next part of the guide will split into two sections: If you are an individual staker and do not require any other contributors to run your Service Node jump into 6.1 - individual Staking . If you want to run a pooled Service Node or contribute towards a pool jump into 6.2 - Pool Staking 6.1 - Individual Staking \u00b6 If you want to run the Service Node as an individual you will require the following things. A fully synchronized, up-to-date Loki daemon running with the --service-node flag (see step 4). A loki-wallet-cli primary address with enough Loki in your account to meet the Service Node Staking Requirement (see step 5). Now if we have the two above items we can proceed to our daemon to register our Service Node. Log in (if not already connected) as the snode user on the VPS running the service node, then start the registration process by running the following interactive command: ~/loki/lokid prepare_registration The daemon will output the current staking requirement and prompt you with an input to clarify whether you are an individual staker or you will be running a pool. Type y and click enter as we will be the sole staker. The daemon will now prompt us for the Loki address of the operator. If you followed step 5 you should have this address saved in a notepad, if not run through step 5 again to find your Loki Address. Once we have the Loki Address copied to our clipboard we can then right click the terminal screen to paste the address. Double check the address matches the one of your wallet then click enter if it is the same. The daemon will now ask for a final confirmation, if you agree to the information provided type y and click enter. The daemon will output a command for us to run looking similar to: register_service_node 4294967292 T6TCCyDgjjbddtzwNGryRJ5HntgGYvqZTagBb2mtHhn7WWz7i5JDeqhFiHqu7ret56411ZJS7Thfeis718bVteBZ2UA6Y7G2d 4294967292 100.000000000 1535677391 ec3895ea70a4a91b5ec4b5e1df96a45e07046f1fb0123c754d98fb2d70f4529d 5bb35d7b8ab1acb943bc47913ada8f9d2e6d6e22264e57484a04c1bbfd461f0ee2e5435454cd9b7059b221eb506ce9ea4537ddd9faf1f1757e0ef611a41c0609 NOTE: You must run the command outputed by your daemon and not the command shown above. Copy the whole line of text and paste it into your notepad as we will need to run this command in our loki-wallet-cli . If registering multiple nodes, it will likely be necessary to wait at least 10 blocks between Service Nodes before running the register Service Node command in the wallet. You have 2 weeks from the moment of preparing the registration command on the Service Node to actually run the register_service_node command in the wallet, however it is advised to do it as soon as possible. Run through step 5 once more to open our Loki wallet (if you don't already have it open). Once we are in our wallet run the command the daemon outputted for us when we prepared our Service Node registration. The wallet will prompt us to confirm our password, then the amount of Loki to stake. Confirm this by typing y and clicking enter. Note: At this point you now have locked stakes! To unlock your stake run the following Well done! Let's continue to the next step \"Step 7 - Service Node Check\" to check if our Service Node is running. 6.2 - Pool Staking \u00b6 Minimum Contribution Rules \u00b6 Infinite Staking introduces new limitations on the number of transactions that can be contributed to a Service Node, changing the minimum contribution rules for participating in the Service Node. Service Nodes accept at most 4 contributions, meaning the minimum contribution to a Service Node becomes: In a pooled Service Node with reserved spots, the Minimum Contribution must be either the Reserved Amount or the Contribution determined by the above equation, whichever is larger. A simplistic example being, if the staking requirement is 24,000 Loki then if, Operator contributes 50% of the requirement (12,000 Loki) The next contributor must contribute at least (\u2153 * 12,000) Loki i.e. 4000 Loki to become a participant. If this contributor had reserved a spot for more than 4000 Loki, their Minimum Contribution would be that amount. There are rules in the client software in place to stop users from irreversibly funding a Service Node into an invalid state. Depending on the individual and their circumstance they will need to: Jump into section 6.2.1 - Operator if they are running the daemon and hosting the pool; Jump into section 6.2.2 - Pool Contributor if they are contributing to someone's Service Node. NOTE: It is advised to read both sections of \"6.2 - Pool Staking\" to have a better understanding of the process. 6.2.1 - Operator \u00b6 The Operator is the individual who will be hosting the pool and running the Service Node daemon, thus incurring the operating expenses encompassed by running a node. The Operator will need to have: A fully synchronized, up-to-date Loki daemon running with the --service-node flag (see step 4) at all times. A loki-wallet-cli primary address with enough Loki in their account to meet 25% of the Staking Requirement. 1-3 other contributors who also have a wallet ( loki-wallet-cli or the desktop GUI wallet) with enough Loki in their accounts to meet 25% of the staking requirement. If the operator wants to reserve contribution spots for specific contributors: The address and contribution amounts the 1-3 contributors will stake. NOTE: The other contributors addresses are optional to have as you can create your pool to be open to anyone to contribute to, however they are recommended to have to avoid any issues of other individuals stealing their spots. On the other hand, a reserved contribution spot can only be filled by that contributor: if they change their mind before submitting a stake your service node will be stuck inactive, so it is recommended to use reserved contribution spots only with contributors you trust. Now if we have the three/four above items we can proceed to our daemon to register our Service Node. Log in (if not already connected) as the snode user on the VPS running the service node, then start the registration process by running the following interactive command: ~/loki/lokid prepare_registration The terminal will prompt the operator to specify if they will contribute the entire stake, because we are running this as a pooled Service Node we will type n and click enter. Next the terminal will request the input for the operator cut. This value is between 0-100 and represents the percentage of the reward the operator will receive before the reward is distributor to the share holders. If you have agreed to a 10% operator cut with the other contributors you would type 10 and click return. The terminal will now display the minimum reserve the operator can contribute and request the operator to input the amount in Loki they wish to contribute. Type your desired <operator contribution> and click return. Once we have set the operators desired stake amount we have the option to either leave the pool open for anyone to contribute or lock a reserve for individuals that have agreed with us to stake within our Service Node. Reserved Pool \u00b6 If the operator wishes to reserve spots for specific contributors they should type y and click return. The terminal will now prompt the operator for the number of additional contributors they have organised to be apart of this Service Node. Type in the number of reserved contributors, not including themselves, and click return. The daemon will now prompt us for the Loki address of the operator. If you followed step 5 you should have this address saved in a notepad, if not run through step 5 again to find your address. Once we have the Loki Address copied to our clipboard we can then right click the terminal screen to paste the address then click return to confirm your address. Next the operator must input the amount of Loki each contributor will contribute and the contributor's address. NOTE: It is possible to reserve only some of the required stakes for specific contributors while leaving the remaining stake open. You will now be asked to confirm the information above is correct. Open Pool \u00b6 If the operator wishes to leave their pool complete open to contributions they should type n and click return. The terminal will prompt the operator to input their address. Once the address has been inputted the terminal will display the remaining portion that needs to be contributed by others. If you agree click y and hit return. The daemon will display a summary of the information we entered. This is our chance for a final check over to make sure we entered in the right information. If you confirm the information is correct type y and click return. The daemon will output a command for us to run within our wallet, looking similar to: register_service_node 214748364 T6UCEoWvJHCJq5biK3LMQZ4CRXAaqiPda2kCRRYYYEMFfxYoqnUo7Nx88RL3wmENwN4kfjDSp2jMN1g6PSErKrSu2EEp8UMy5 1073741823 T6TCCyDgjjbddtzwNGryRJ5HntgGYvqZTagBb2mtHhn7WWz7i5JDeqhFiHqu7ret56411ZJS7Thfeis718bVteBZ2UA6Y7G2d 3221225469 25.000000000 1535692249 5dac247e90ced2dcd9e51faec8792acb0c11b4c700640d9104b17c868ea167e3 cc11eef804c11d3e93cf8c488c10d97b8cec9ee2b38e6666ff07749c2911aa06ce310edc926a4d2f50a588e9c15afcc20e935a0f188aa7caa764a62058dec80d NOTE: You must run the command outputed by your daemon and not the command shown above. Copy the whole line of text in your daemon and paste it into your notepad as we will need to run this command in our loki-wallet-cli . You have 2 weeks from the moment of registering the Service Node to run the register_service_node command, however it is advised to do it as soon as possible. Before you disconnect from your VPS run the following command to get your <Service Node Public Key> and save it in your notepad (your contributors will need it): ~/loki/lokid print_sn_key Run through step 5 once more to open our Loki wallet. Once we are in our wallet run the command the daemon outputted for us when we prepared our Service Node. The wallet will prompt us to confirm our password, then the amount of Loki to stake. Confirm this by typing y and clicking enter. Once this command completes your staking transaction will be sent to be included on the blockchain. It may take a few minutes for the transaction to be mined into a block; you can check the status using ~/loki/lokid print_sn_status or by looking for your <Service Node Public Key> in the \"Service Nodes Awaiting\" section on lokiblocks.com (or lokitestnet.com for a testnet service node). Once the service node registration is received you can send the <Service Node Public Key> to your contributors with the amount of Loki they are required to stake. NOTE: the final amount will typically be slightly lower than what you entered in the prepare_registration command. This is expected: the required amounts are based on the registration block height which has usually advanced by a couple blocks between the time you prepared the registration and the time it gets mined into the blockchain. At this point we will need to wait until all contributors have staked before the service node activates and becomes eligible to receive rewards. 6.2.2 - Pool Contributor \u00b6 The pool contributor must first receive the Service Node Pubkey and the requirements (amount of loki to send) from the Service Node Operator. If you are staking please do not use Subaddresses. They are currently unsupported by the Loki wallet The pool contributor must have downloaded the necessary binaries, is running a daemon or is connected to a remote node, has generated a wallet through either the loki-wallet-cli or the desktop GUI wallet, and has enough Loki to stake. They can then run the following command in their loki-wallet-cli . stake <Service Node Pubkey> <contribution amount> Where the <Service Node Pubkey> is the Pubkey provided from the Service Node operator and <contribution amount> is the amount of Loki they are going to stake which they agreed to with the Service Node Operator. If using the desktop GUI wallet, the Stake command can be found under the Advanced - Service Node menu. Enter the service <Service Node Pubkey> and <contribution amount> and hit the Stake button. At this stage you will need to wait for the other contributors to provide their collateral. Once everyone has staked you can refer to \u201cStep 7 - Service Node Check\u201d to see where your Service Node Operator\u2019s node is in the list. Congratulations, you are now staking. Step 7 - Service Node Check \u00b6 After we have locked our collateral we will need to check if our Service Node Pubkey is sitting in the list with the other Service Node\u2019s on the network. This will prove our Service Node is running, recognised and will receive a reward if it keeps running. Connect to the VPS where the service node is running and run the following command to see our Service Node Public Key: ~/loki/lokid print_sn_key The Service Node Public Key is used to identify our Service Node within the list of Service Nodes currently on the network. If you want more detailed Service Node status you can use the follow command: ~/loki/lokid print_sn_status You can jump onto https://lokiblocks.com/ to see if your Service Node is in the list or we can continue in the terminal to output the same information. If you are running your Service Node on testnet go to https://lokitestnet.com/ instead. To check this information directly with the service node itself, first get the current block height by running ~/loki/lokid status into the terminal: it will output this information. Once we have the block height we can then check the current Service Nodes on the network at our specified block height. Run the command ~/loki/lokid print_quorum_state <block height> replacing <block height> with the number minus 1 that was outputted when running status command. If your <Service Node Pubkey> is sitting in the list you know you are now staking. Step 8 - Unlock Stake \u00b6 Service Nodes will continually receive block rewards indefinitely until a stake is unlocked or the Service Node becomes deregistered. Unlocking is available via the following command which needs to be run in the command line wallet: request_stake_unlock <service node key> Once the unlock is requested and the request is included in a block in the blockchain, the Service Node will then expire in 15 days (10800 blocks) and the funds will become unlocked after expiry. In pooled nodes, any contributor that requests the stake to unlock will schedule the Service Node for expiration. All locked stakes in that Service Node will be unlocked in 15 days (10800 blocks). Once the unlock is requested, this process can not be undone or prolonged. Service Node participants will continue receiving rewards until expiration. Deregistrations can be issued at any point during the active lifecycle of the Service Node. This is inclusive of the time period during which the Service Node is scheduled for expiry. Getting deregistered removes your Service Node from the network and your stakes are placed into a list of blacklisted transactions. Blacklisted transactions are locked and unspendable for 30 days (21600 blocks) from the block in which the Service Node was deregistered. Receiving a deregistration after participants have already requested the stake to unlock overrides the 15 day (10800 blocks) unlock time, and resets the unlock time to 30 days (21600 blocks). Optional \u00b6 See Locked Stake Amount and Duration \u00b6 We can also view our locked stake by running the following command from our loki-wallet-cli we staked from: print_locked_stakes Express Setup Guide \u00b6 This section is for power users who are more familiar with servers and the CLI interface. There's a couple of things your going to want to do before you commence. 1. Get a Server that meets requirements 2. Run the Daemon on a server from a non-root user account, then stake from a local wallet (or a wallet on a separate server). Where <VERSION> is mentioned replace with the latest version for lokid and Storage Server , example v3.0.6 . 3. Connect via SSH to your server 4. add new user sudo adduser snode usermod -aG sudo snode 5. login to your new user account via SSH snode@<ipaddress> 6. Update necessary security patches and system utilities sudo apt update sudo apt upgrade 7. Download & unzip Loki sudo apt install wget unzip wget https://github.com/loki-project/loki/releases/download/v<VERSION>/loki-linux-x64-v<VERSION>.zip wget https://github.com/loki-project/loki-storage-server/releases/download/v<VERSION>-release/loki-storage-linux-x64-v<VERSION>.tar.xz tar -xvf loki-linux-x64-v<VERSION>.tar.xz tar -xvf loki-storage-linux-x64-v<VERSION>.tar.xz ln -snf loki-linux-x64-<VERSION> loki ln -snf loki-storage-linux-x64-v<VERSION> loki-ss 8. Set up Loki to run as a service sudo nano /etc/systemd/system/lokid.service Paste the following: [Unit] Description=lokid service node After=network-online.target [Service] Type=simple User=snode ExecStart=/home/snode/loki/lokid --non-interactive --service-node --service-node-public-ip SERVERIP --storage-server-port 22023 Restart=always RestartSec=30s [Install] WantedBy=multi-user.target Replacing SERVERIP in the line ExecStart= with your servers IP. Save and exit: CTRL+X -> Y -> ENTER sudo nano /etc/systemd/system/loki-ss.service Paste the following: [Unit] Description=Loki storage server After=network-online.target Requires=lokid.service [Service] User=snode Type=simple WorkingDirectory=/home/snode Restart=always RestartSec=5s ExecStart=/home/snode/loki-storage 0.0.0.0 23023 --lokid-rpc-port 22023 --lokid-key /home/snode/.loki/key [Install] WantedBy=multi-user.target Enable and start the service: sudo systemctl daemon-reload sudo systemctl enable lokid.service loki-ss.service sudo systemctl start lokid.service loki-ss.service Wait for the Loki Daemon sync the blockchain (1 - 8 Hours depending on internet speed). You can watch the progress using: sudo journalctl -u lokid.service -af Hit Ctrl-C when you are tired of watching. 9. Open a Wallet This wallet can be in a screen session on the Service Node machine, or a wallet on your local computer (assuming you have downloaded the binaries locally). cd loki-linux-x64-<VERSION> Linux/MAC - ./loki-wallet-cli Windows - loki-wallet-cli Enter Name: Name your wallet Enter password Language: 1 (for English) Securely store: Address Seed Phrase Pass-phrase Send enough Loki to fund a node, wait for Balance to be unlocked (20 mins, 10 confirmations) 10. Register your Service Node Connect via SSH to your VPS with the Service Node running ( snode@<ipaddress> ). ~/loki/lokid prepare_registration Contribute entire Stake: Y/N Enter Loki Address Enable Restaking: Y/N Confirm: Y Copy green registration message Ctrl +AD 11. Reattach to Service Node or local wallet Paste in registration message <enter> 12 Connect back to Service Node VPS account ~/loki/lokid print_sn_key Copy service node key, and search for it on: https://lokiblocks.com/service_nodes . or check the detailed status using: ~/loki/lokid print_sn_key Conclusion \u00b6 Well done! You will receive a block reward when your Service Node has been active for some time and the network chooses you within the list. Bonus : Use the community-run telegram bot @LokiSNBot to receive on-the-fly updates about your service node. Props to @jagerman42 for building this. Bonus 2 : View https://imaginary.stream/sn/ for more details on Loki Service Node staking requirements. This guide will be regularly updated when new features are added to Snodes. Join the discord for more discussion. If you can improve this guide, please submit a pull request.","title":"Service Node Legacy Guide"},{"location":"ServiceNodes/SNFullGuideLegacy/#full-guide-on-service-nodes","text":"This document will tell you exactly how to set up and operate a Service Node for the Loki Project. This document was written with non-developers in mind, so people new to linux or command line operations should be able to follow along without any trouble. If you feel confident around servers and the CLI, then skip to the Express Setup Guide You can of course run the Loki software on any operating system that you can get it to build on, but for the purposes of this document, the instructions apply to running a Service Node on a remote Ubuntu 16.04 server. If that isn\u2019t what you want to do, syntax and server set up will of course differ according to whatever OS you choose to run your Service Node from.","title":"Full Guide on Service Nodes"},{"location":"ServiceNodes/SNFullGuideLegacy/#summary-of-loki-service-node-requirements","text":"Full summary of Loki Service Node Requirements. This may change depending on Service Node functionality, so you should check here regularly, or follow our Telegram / Discord announcements channel. Spec Note Latest Binary Hefty Heimdall Software Ubuntu 16.04, Ubuntu 18.04 Storage 30-50gb Ram 2-4 gb","title":"Summary of Loki Service Node Requirements"},{"location":"ServiceNodes/SNFullGuideLegacy/#table-of-contents","text":"Overview of Service Nodes New User Guide Step 1 Server Step 2 Server Prep Step 3 Download Binaries Step 4 Service Node as a Service Step 5 Open a Loki Wallet Step 6 Register Node Step 7 Check Registration Express Setup Guide","title":"Table of Contents"},{"location":"ServiceNodes/SNFullGuideLegacy/#overview","text":"To understand what a Service Node is, you can refer to the whitepaper to get an in depth understanding. For now, all you need to know is that: Service Nodes are full nodes on the Loki network Full nodes become Service Nodes when the owner locks the required amount of Loki and submits a registration transaction. Once accepted by the network, the Service Node is eligible to win block rewards. Multiple participants can be involved in one Service Node and can have the reward automatically distributed It is also worth noting that Service Nodes are quite basic at the moment, and operators will need to stay up to date with new updates to keep in line with software and hardware requirements. Once all of the updates are out, Service Nodes will also: Route end user\u2019s internet traffic, either as an exit node or relay. Receive, store and forward encrypted user messages. Monitor other Service Nodes and vote on their performance. Be called into quorums which give them authority over instant transactions ( Blink ). Act as remote nodes for users. Once these features come out, Service Node operation will require better servers, particularly when it comes to bandwidth. For the purposes of this guide, however, we will only consider the current requirements.","title":"Overview"},{"location":"ServiceNodes/SNFullGuideLegacy/#new-user-guide","text":"This section of this guide is for new users to servers and the CLI interface.","title":"New User Guide"},{"location":"ServiceNodes/SNFullGuideLegacy/#step-1-get-a-server","text":"Righto! Let\u2019s get started. Choosing where to set up a Service Node is the biggest choice you will make when running a Service Node. There are a number of things to consider. Because you will be locking up funds for 30 days (2 days for testnet) at a time, you will want to ensure that your server has: A stable, relatively fast connection to be able to respond to ping requests to avoid being booted off the network. We recommend 2GB of RAM to cope with running the software reliably ( Note: This requirement may be much greater once services are live ). 1GB is fine for testing. At Least a 20GB SSD or Hard disk drive, this will be used to store the blockchain ( Note: to future proof yourself against blockchain growth and message storage we recommend a 30 - 40 GB drive ). A stable power supply. If your server goes down during the staking period, you may get kicked off the network, and not receive rewards while your funds are still locked for the remainder of the staking period. For most users, we assume that your home internet connection is relatively slow (< 4MB/s down and up) and probably lacks support for external connections. If this is the case, you will probably not want to run a Service Node from your home in the long term, as this could cost you if and when you get booted off. Since we\u2019re just testing at the moment, you could run it from home anyway, but for this guide we\u2019ll avoid it. Typically, the easiest and cheapest way to host a server outside of your home is to use a Virtual Private Server (VPS). There are thousands of options when it comes to VPS providers, but for now, just about any one will do. In the future, selection will be made more difficult because most providers will not allow exit node traffic, so we have compiled a list of exit node friendly providers to choose from if you want to stay with your provider for more than a few months. Hosting Provider Product Name Cost Per Month $USD Bandwidth Provided Exit Friendliness Rating Netcup VPS 1000 G8 10.50 30 - 35 MiB\u2019s 5 / 10 Online.net Start-2-S-SSD 13.99 15 - 17 MiB\u2019s 9 / 10 Scaleway START1-M 9.33 20 - 25 MiB\u2019s 7 / 10 OVH VPS SSD 2 7.61 9 - 1 MiB\u2019s 9 / 10 Leaseweb Virtual Server XL 34.45 30 - 35 MiB\u2019s 5 / 10 Digital Ocean 2 GB, 2 vCPUs 15 9 - 11 MiB\u2019s 8 / 10 Feral Hosting Neon Capability 19.68 9 - 11 MiB\u2019s 9 / 10 Trabia VDS-8G 38.54 9 - 11 MiB\u2019s 8 / 10 Hetzner EX41-SSD (30 TB) 39.71 40 - 80 MiB\u2019s 4 / 10 Note: We do not officially endorse any of these providers, this list is simply illustrative of some of the options currently available* Try not to pick the first one off the list. Do some digging and see which one looks the best to you, what your budget is, and what the latency is like for you based on the server location that you choose. When selecting your VPS\u2019 operating system, choose Ubuntu 16.04 64 bit or Ubuntu 18.04 64 bit if you want to follow this guide. If you feel more confident or wish to run your server on another distribution or operating system, the Loki commands in this guide will still apply.","title":"Step 1 - Get a Server"},{"location":"ServiceNodes/SNFullGuideLegacy/#step-2-prepare-your-server","text":"Every provider has a slightly different way of issuing you access to your new VPS. Most will send an email with the IP address, root username, and a root password of the VPS. To access your server, you will need a SSH client for your operating system. Because we\u2019re on Windows today, we\u2019ll download PuTTY, Mac users can also use PuTTY. If you\u2019re a Linux user, you probably don\u2019t want us telling you where to get a SSH client from. To connect to our VPS we will need to paste the IP address into the SSH client\u2019s \u201cHost Name (or IP address)\u201d input box and click the \u201cOpen\u201d button. The Port number can usually just be left as 22 . A terminal window will now appear prompting for your log-in details, username(root) and password, which were provided by your VPS provider. When entering your password, nothing will visually appear in the terminal. This is normal. Hit enter when it\u2019s typed or pasted, and you should be logged in to your VPS.","title":"Step 2 - Prepare your Server"},{"location":"ServiceNodes/SNFullGuideLegacy/#create-a-non-root-user","text":"Best practice when running a public server is to not run your software as the root user. Although it is possible to do everything as root, it is strongly recommended that you create a non-root user on our VPS by running the following command: adduser <username> Replacing <username> with a name you will log-in with. For this user-guide we will use snode as our username. adduser snode The terminal will prompt you for a new password for our newly created user. Use a secure password that is different password from the root password. Once the password has been set, the terminal will prompt for a few details about the individual running the user. You can just hit enter through each of the inputs as the details are not important for the purposes of running a Service Node. Once that\u2019s done, run the following two commands to give our new account admin privileges and to change to such account. usermod -aG sudo snode su - snode Before we proceed further, it is advised to close your terminal and reopen PuTTY to set up a saved session with our snode user. Your SSH client will have a load and save session function. For PuTTY we will need to type in our VPS IP address again, on the same screen type snode under \u201cSaved Session\u201d. Click on \u201cData\u201d under the drop-down menu \u201cConnection\u201d, and type in snode (or your username defined before) into the input box \u201cAuto-login username\u201d. Go back to your session screen, where we entered the IP address, and click \u201cSave\u201d. You can load this session whenever you want to check on your Service Node.","title":"Create a non-root User"},{"location":"ServiceNodes/SNFullGuideLegacy/#hot-tips-for-using-the-console","text":"Consoles don't work like the rest of your computer. Here are some basic tips for navigating your way around the command line! Don't try copying something by using the usual Ctrl + C hotkey! If you want to copy something, do so by highlighting text and then right clicking it. Pasting works by right clicking a blank area in the console. If you want to kill a process or stop something from running, press Ctrl + C. (This is why you shouldn't try copying something with this hotkey.) You can always check the directory you are in by typing pwd and list its contents by typing ls . You can always return to your home directory by typing cd . You can move into a given directory by typing cd <name> or move back up one level by typing cd .. . PuTTY allows you to easily duplicate or restart a session by right clicking the top of the window. Handy if you\u2019re trying to do a few things at once. Once we have logged in correctly to the VPS for the first time, the VPS may be configured to prompt for a new password for the root account. The terminal will require you to enter the new password twice before we can start running commands. If you aren't prompted for a new root password but want to change it anyway, type sudo passwd . Choose something very secure!","title":"Hot Tips for using the Console"},{"location":"ServiceNodes/SNFullGuideLegacy/#server-preparation-continued","text":"We should update our package lists, the below command downloads the package lists from the repositories and \"updates\" them to get information on the newest versions of packages and their dependencies. It will do this for all repositories and PPAs. sudo apt update You will notice a bunch of package lists were downloaded, once this is complete run the below command to fetch new versions of any packages we currently have installed on the system. sudo apt upgrade You will be prompted to authorise the use of disk space, type y and enter to authorise. If you are prompted during the upgrade that a new version of any file is available then click the up and down arrows until you are hovering over install the package maintainer\u2019s version and click enter. Alright, good to go. Our server is now set up, up to date, and is not running as root. On to the fun part!","title":"Server Preparation Continued"},{"location":"ServiceNodes/SNFullGuideLegacy/#step-3-download-the-loki-binaries","text":"In order to download and extract the Linux binaries, we need to make sure a couple tools are installed: sudo apt install wget unzip Now download the Linux binaries by running the following command: wget <link> Where <link> is the download link of the latest linux release. To find the link go to https://github.com/loki-project/loki/releases/latest , right click the latest linux release and click Copy Link Location .","title":"Step 3 - Download the Loki Binaries"},{"location":"ServiceNodes/SNFullGuideLegacy/#31-lokid-binaries","text":"To download the lokid binaries run the following command: wget https://github.com/loki-project/loki/releases/download/vX.X.X/loki-linux-x64-vX.X.X.tar.xz Replacing X.X.X with the latest binary version number from https://github.com/loki-project/loki/releases/latest .","title":"3.1 - Lokid Binaries"},{"location":"ServiceNodes/SNFullGuideLegacy/#32-storage-server-binaries","text":"To download the loki storage server binaries run the following command: wget https://github.com/loki-project/loki-storage-server/releases/download/vX.X.X/loki-storage-linux-x64-vX.X.X.tar.xz Replacing X.X.X with the latest binary version number from https://github.com/loki-project/loki-storage-server/releases .","title":"3.2 - Storage Server Binaries"},{"location":"ServiceNodes/SNFullGuideLegacy/#33-untar-binaries","text":"To untar the downloaded files run the following command: tar -xvf <filename> Replacing <filename> with the the filename we downloaded. For this example we would run 2 commands: tar -xvf loki-linux-x64-vX.X.X.tar.xz tar -xvf loki-storage-linux-x64-vX.X.X.tar.xz","title":"3.3 - Untar Binaries"},{"location":"ServiceNodes/SNFullGuideLegacy/#34-create-symlink","text":"Note you need to replace the vX.X.X with the version you downloaded previous otherwise the symlink will not work. We now want to create a \"symlink\" to the extracted loki-linux-x64-vX.X.X folder: ln -snf loki-linux-x64-vX.X.X loki and a \"symlink\" to the extracted loki-storage-linux-x64-vX.X.X folder: ln -snf loki-storage-linux-x64-vX.X.X loki-ss This creates a virtual folder that points to the binary folders. This isn't strictly necessary, but will help with upgrades in the future: when you want to upgrade you can just repeat everything in this step again with the new binaries. Excellent! We now have all of the necessary files to get this show on the road! NOTE: If you\u2019re nervous about trusting the binaries or the download link, you should build it from source yourself. Instructions for that can be found in the README of https://github.com/loki-project/loki","title":"3.4 - Create Symlink"},{"location":"ServiceNodes/SNFullGuideLegacy/#step-4-service-node-as-a-service","text":"At this point you can run the Loki binaries directly in your terminal, but this is not a viable approach to running it as a service node: when you close PuTTY the program running inside it will also shut down, which is no good for a service node. Instead we will configure the Loki daemons as a system service which makes it automatically start up if the server reboots, and restarts it automatically if it crashes for some reason.","title":"Step 4 - Service Node as a Service"},{"location":"ServiceNodes/SNFullGuideLegacy/#41-lokidservice-file","text":"Create the lokid.service file: sudo nano /etc/systemd/system/lokid.service Copy the text below and paste it into your new file: [Unit] Description=lokid service node After=network-online.target [Service] Type=simple User=snode ExecStart=/home/snode/loki/lokid --non-interactive --service-node --service-node-public-ip SERVERIP --storage-server-port 23023 Restart=always RestartSec=30s [Install] WantedBy=multi-user.target Replacing SERVERIP in the line ExecStart= with your servers IP. To find your SERVERIP run the command curl ifconfig.me If you chose a username other than snode then change snode in the User= and ExecStart= lines to the alternative username. (If you want to run a testnet service node, append --testnet to the end of the ExecStart line. Alternatively, if you want to be able to run both a testnet and mainnet service node simultaneously you can use two service files: lokid.service and lokid-testnet.service and add --testnet to the ExecStart= line in the latter. You would then use lokid-testnet.service instead of lokid.service in the commands below when you want to control the testnet service node.) Once completed, save the file and quit nano: CTRL+X -> Y -> ENTER.","title":"4.1 lokid.service file"},{"location":"ServiceNodes/SNFullGuideLegacy/#42-loki-ssservice-file","text":"Create the loki-ss.service file: sudo nano /etc/systemd/system/loki-ss.service Copy the text below and paste it into your new file: [Unit] Description=Loki storage server After=network-online.target Requires=lokid.service [Service] User=snode Type=simple WorkingDirectory=/home/snode Restart=always RestartSec=5s ExecStart=/home/snode/loki-storage 0.0.0.0 23023 --lokid-rpc-port 22023 --lokid-key /home/snode/.loki/key [Install] WantedBy=multi-user.target If you chose a username other than snode then change snode in the User= and ExecStart= lines to the alternative username. Once completed, save the file and quit nano: CTRL+X -> Y -> ENTER.","title":"4.2 loki-ss.service file"},{"location":"ServiceNodes/SNFullGuideLegacy/#43-enabling-service-files","text":"Reload systemd manager configuration (to make it re-read the new service file): sudo systemctl daemon-reload Enable lokid.service so that it starts automatically upon boot: sudo systemctl enable lokid.service loki-ss.service Start lokid.service: sudo systemctl start lokid.service loki-ss.service The daemon will now start syncing. You won\u2019t be able to do much if it hasn\u2019t synced. To see the progress of your lokid service file you can run the following command: sudo journalctl -u lokid.service -af You should see it syncing the blockchain. To see the progress of your loki-ss service file you can run the following command: sudo journalctl -u loki-ss.service -af","title":"4.3 Enabling Service Files"},{"location":"ServiceNodes/SNFullGuideLegacy/#step-5-getopen-a-wallet","text":"While we wait for the daemon to sync, we can now get a wallet going. You do not have to run this wallet on the server and you should not! Download the software and run it from elsewhere for security reasons! You can run the CLI wallet (Command Line Interface wallet) on any other computer, including your home computer to avoid leaving your wallet on the server. However, if you do want to run the CLI wallet on another computer, you will either need to run another daemon on that local machine or use a remote node (uk.loki.cash:22020, for example). There is also a list of trusted remote nodes in the Loki Project Discord channel under #links-and-resources. ./loki-wallet-cli --daemon-address <insert address here> Or on windows: loki-wallet-cli.exe --daemon-address <insert address here> If you are made of money and are willing to take the small risk of losing all of your funds, you can continue running the wallet inside the Service Node VPS. So we don't have to talk about a myriad of other operating systems or potential user cases, the rest of this guide will assume you are running the wallet in the same VPS. As such, it\u2019ll probably save us time to open a second PuTTY session. You can do this by right clicking the window of the current PuTTY session and clicking \u201cDuplicate Session.\u201d Log in as the non-root user that we set up before, in our case snode , and launch the wallet using: ~/loki/loki-wallet-cli If you are on testnet run the command with the --testnet flag: ~/loki/loki-wallet-cli --testnet When loki-wallet-cli first runs, it will request for you to specify a wallet name. Assuming we haven't created one yet, we will use the e.g. name MyWallet Because this is the first time we have used the name MyWallet the client will prompt us to create a new wallet. Type y and click return to continue. The loki-wallet-cli has generated us a wallet called MyWallet and is now prompting us for a password. Note: When typing the password, the characters will not appear. It will seem as if you are typing and no text is appearing however the terminal is logging every character you type including if it is capitalised or lowercase. Write down your wallet name and password on a piece of paper as this information will be required every time we want to enter our wallet. Use a password with uppercase letters, lowercase letters, numbers, symbols and make the password at least 9 characters long. Once we have chosen our password for the wallet we must choose our language. For the purposes of this user guide I suggest you use English by typing in 1 and clicking return. The CLI will generate and spit out several lines of text. The first two lines of text show your wallet public address. This address can be shared, will be used to receive Loki to your wallet, and will be used during the preparation and registration of our Service Node. All Mainnet Loki public addresses start with an L and are followed with a string of characters, Testnet Public addresses start with a T. The public address shown will be your primary address, however multiple public addresses can be generated from this primary address. Line 13 to 17 show your 25-word mnemonic (\u201cnew-monic\u201d) seed. The seed is used to easily backup and restore your wallet without needing any other information. At this stage, grab a pen and paper, and write down your 25 words in order. Store the piece of paper in a safe and secure place, if your words are stored in a text file on your computer or stored online, you increase your risk of someone else getting control of your wallet. It is at this point that we should get some Loki in the wallet. The amount of Loki required to run a node is derived from the function shown in Lokis Cryptoeconomic paper . Don't worry if you cant work out the formula, you can use this community created tool or, the daemon will display the amount of Loki required to run the node. If you do not have enough you will have the option to join in or run your own Service Node pool. If you are running a Service Node on the testnet you will only ever require 100 testnet Loki to run the Node. You can ask the Telegram @LokiSNBot for some testnet loki or ask someone in the Loki Discord Community for some. If you are staking please do not use Subaddresses. They are currently unsupported by the Loki wallet. We will need our address to register our Service Node later, to get your primary address type the following command: address Highlight the string of characters that were outputted and save this in a notepad for later use, your public address should look similar to: T6TCCyDgjjbddtzwNGryRJ5HntgGYvqZTagBb2mtHhn7WWz7i5JDeqhFiHqu7ret56411ZJS7Thfeis718bVteBZ2UA6Y7G2d (Note that this is an example testnet wallet address; your address will start with L if it is a mainnet wallet) NOTE: Do not use CTRL + C to copy your address, it will close the wallet down. Simply highlight the address and this will automatically save the portion you highlighted into your clipboard. Once you have enough Loki in this wallet, just leave it open, we\u2019ll come back to it in a minute.","title":"Step 5 - Get/Open A Wallet"},{"location":"ServiceNodes/SNFullGuideLegacy/#step-6-service-node-registration","text":"The next part of the guide will split into two sections: If you are an individual staker and do not require any other contributors to run your Service Node jump into 6.1 - individual Staking . If you want to run a pooled Service Node or contribute towards a pool jump into 6.2 - Pool Staking","title":"Step 6 - Service Node Registration"},{"location":"ServiceNodes/SNFullGuideLegacy/#61-individual-staking","text":"If you want to run the Service Node as an individual you will require the following things. A fully synchronized, up-to-date Loki daemon running with the --service-node flag (see step 4). A loki-wallet-cli primary address with enough Loki in your account to meet the Service Node Staking Requirement (see step 5). Now if we have the two above items we can proceed to our daemon to register our Service Node. Log in (if not already connected) as the snode user on the VPS running the service node, then start the registration process by running the following interactive command: ~/loki/lokid prepare_registration The daemon will output the current staking requirement and prompt you with an input to clarify whether you are an individual staker or you will be running a pool. Type y and click enter as we will be the sole staker. The daemon will now prompt us for the Loki address of the operator. If you followed step 5 you should have this address saved in a notepad, if not run through step 5 again to find your Loki Address. Once we have the Loki Address copied to our clipboard we can then right click the terminal screen to paste the address. Double check the address matches the one of your wallet then click enter if it is the same. The daemon will now ask for a final confirmation, if you agree to the information provided type y and click enter. The daemon will output a command for us to run looking similar to: register_service_node 4294967292 T6TCCyDgjjbddtzwNGryRJ5HntgGYvqZTagBb2mtHhn7WWz7i5JDeqhFiHqu7ret56411ZJS7Thfeis718bVteBZ2UA6Y7G2d 4294967292 100.000000000 1535677391 ec3895ea70a4a91b5ec4b5e1df96a45e07046f1fb0123c754d98fb2d70f4529d 5bb35d7b8ab1acb943bc47913ada8f9d2e6d6e22264e57484a04c1bbfd461f0ee2e5435454cd9b7059b221eb506ce9ea4537ddd9faf1f1757e0ef611a41c0609 NOTE: You must run the command outputed by your daemon and not the command shown above. Copy the whole line of text and paste it into your notepad as we will need to run this command in our loki-wallet-cli . If registering multiple nodes, it will likely be necessary to wait at least 10 blocks between Service Nodes before running the register Service Node command in the wallet. You have 2 weeks from the moment of preparing the registration command on the Service Node to actually run the register_service_node command in the wallet, however it is advised to do it as soon as possible. Run through step 5 once more to open our Loki wallet (if you don't already have it open). Once we are in our wallet run the command the daemon outputted for us when we prepared our Service Node registration. The wallet will prompt us to confirm our password, then the amount of Loki to stake. Confirm this by typing y and clicking enter. Note: At this point you now have locked stakes! To unlock your stake run the following Well done! Let's continue to the next step \"Step 7 - Service Node Check\" to check if our Service Node is running.","title":"6.1 - Individual Staking"},{"location":"ServiceNodes/SNFullGuideLegacy/#62-pool-staking","text":"","title":"6.2 - Pool Staking"},{"location":"ServiceNodes/SNFullGuideLegacy/#minimum-contribution-rules","text":"Infinite Staking introduces new limitations on the number of transactions that can be contributed to a Service Node, changing the minimum contribution rules for participating in the Service Node. Service Nodes accept at most 4 contributions, meaning the minimum contribution to a Service Node becomes: In a pooled Service Node with reserved spots, the Minimum Contribution must be either the Reserved Amount or the Contribution determined by the above equation, whichever is larger. A simplistic example being, if the staking requirement is 24,000 Loki then if, Operator contributes 50% of the requirement (12,000 Loki) The next contributor must contribute at least (\u2153 * 12,000) Loki i.e. 4000 Loki to become a participant. If this contributor had reserved a spot for more than 4000 Loki, their Minimum Contribution would be that amount. There are rules in the client software in place to stop users from irreversibly funding a Service Node into an invalid state. Depending on the individual and their circumstance they will need to: Jump into section 6.2.1 - Operator if they are running the daemon and hosting the pool; Jump into section 6.2.2 - Pool Contributor if they are contributing to someone's Service Node. NOTE: It is advised to read both sections of \"6.2 - Pool Staking\" to have a better understanding of the process.","title":"Minimum Contribution Rules"},{"location":"ServiceNodes/SNFullGuideLegacy/#621-operator","text":"The Operator is the individual who will be hosting the pool and running the Service Node daemon, thus incurring the operating expenses encompassed by running a node. The Operator will need to have: A fully synchronized, up-to-date Loki daemon running with the --service-node flag (see step 4) at all times. A loki-wallet-cli primary address with enough Loki in their account to meet 25% of the Staking Requirement. 1-3 other contributors who also have a wallet ( loki-wallet-cli or the desktop GUI wallet) with enough Loki in their accounts to meet 25% of the staking requirement. If the operator wants to reserve contribution spots for specific contributors: The address and contribution amounts the 1-3 contributors will stake. NOTE: The other contributors addresses are optional to have as you can create your pool to be open to anyone to contribute to, however they are recommended to have to avoid any issues of other individuals stealing their spots. On the other hand, a reserved contribution spot can only be filled by that contributor: if they change their mind before submitting a stake your service node will be stuck inactive, so it is recommended to use reserved contribution spots only with contributors you trust. Now if we have the three/four above items we can proceed to our daemon to register our Service Node. Log in (if not already connected) as the snode user on the VPS running the service node, then start the registration process by running the following interactive command: ~/loki/lokid prepare_registration The terminal will prompt the operator to specify if they will contribute the entire stake, because we are running this as a pooled Service Node we will type n and click enter. Next the terminal will request the input for the operator cut. This value is between 0-100 and represents the percentage of the reward the operator will receive before the reward is distributor to the share holders. If you have agreed to a 10% operator cut with the other contributors you would type 10 and click return. The terminal will now display the minimum reserve the operator can contribute and request the operator to input the amount in Loki they wish to contribute. Type your desired <operator contribution> and click return. Once we have set the operators desired stake amount we have the option to either leave the pool open for anyone to contribute or lock a reserve for individuals that have agreed with us to stake within our Service Node.","title":"6.2.1 - Operator"},{"location":"ServiceNodes/SNFullGuideLegacy/#reserved-pool","text":"If the operator wishes to reserve spots for specific contributors they should type y and click return. The terminal will now prompt the operator for the number of additional contributors they have organised to be apart of this Service Node. Type in the number of reserved contributors, not including themselves, and click return. The daemon will now prompt us for the Loki address of the operator. If you followed step 5 you should have this address saved in a notepad, if not run through step 5 again to find your address. Once we have the Loki Address copied to our clipboard we can then right click the terminal screen to paste the address then click return to confirm your address. Next the operator must input the amount of Loki each contributor will contribute and the contributor's address. NOTE: It is possible to reserve only some of the required stakes for specific contributors while leaving the remaining stake open. You will now be asked to confirm the information above is correct.","title":"Reserved Pool"},{"location":"ServiceNodes/SNFullGuideLegacy/#open-pool","text":"If the operator wishes to leave their pool complete open to contributions they should type n and click return. The terminal will prompt the operator to input their address. Once the address has been inputted the terminal will display the remaining portion that needs to be contributed by others. If you agree click y and hit return. The daemon will display a summary of the information we entered. This is our chance for a final check over to make sure we entered in the right information. If you confirm the information is correct type y and click return. The daemon will output a command for us to run within our wallet, looking similar to: register_service_node 214748364 T6UCEoWvJHCJq5biK3LMQZ4CRXAaqiPda2kCRRYYYEMFfxYoqnUo7Nx88RL3wmENwN4kfjDSp2jMN1g6PSErKrSu2EEp8UMy5 1073741823 T6TCCyDgjjbddtzwNGryRJ5HntgGYvqZTagBb2mtHhn7WWz7i5JDeqhFiHqu7ret56411ZJS7Thfeis718bVteBZ2UA6Y7G2d 3221225469 25.000000000 1535692249 5dac247e90ced2dcd9e51faec8792acb0c11b4c700640d9104b17c868ea167e3 cc11eef804c11d3e93cf8c488c10d97b8cec9ee2b38e6666ff07749c2911aa06ce310edc926a4d2f50a588e9c15afcc20e935a0f188aa7caa764a62058dec80d NOTE: You must run the command outputed by your daemon and not the command shown above. Copy the whole line of text in your daemon and paste it into your notepad as we will need to run this command in our loki-wallet-cli . You have 2 weeks from the moment of registering the Service Node to run the register_service_node command, however it is advised to do it as soon as possible. Before you disconnect from your VPS run the following command to get your <Service Node Public Key> and save it in your notepad (your contributors will need it): ~/loki/lokid print_sn_key Run through step 5 once more to open our Loki wallet. Once we are in our wallet run the command the daemon outputted for us when we prepared our Service Node. The wallet will prompt us to confirm our password, then the amount of Loki to stake. Confirm this by typing y and clicking enter. Once this command completes your staking transaction will be sent to be included on the blockchain. It may take a few minutes for the transaction to be mined into a block; you can check the status using ~/loki/lokid print_sn_status or by looking for your <Service Node Public Key> in the \"Service Nodes Awaiting\" section on lokiblocks.com (or lokitestnet.com for a testnet service node). Once the service node registration is received you can send the <Service Node Public Key> to your contributors with the amount of Loki they are required to stake. NOTE: the final amount will typically be slightly lower than what you entered in the prepare_registration command. This is expected: the required amounts are based on the registration block height which has usually advanced by a couple blocks between the time you prepared the registration and the time it gets mined into the blockchain. At this point we will need to wait until all contributors have staked before the service node activates and becomes eligible to receive rewards.","title":"Open Pool"},{"location":"ServiceNodes/SNFullGuideLegacy/#622-pool-contributor","text":"The pool contributor must first receive the Service Node Pubkey and the requirements (amount of loki to send) from the Service Node Operator. If you are staking please do not use Subaddresses. They are currently unsupported by the Loki wallet The pool contributor must have downloaded the necessary binaries, is running a daemon or is connected to a remote node, has generated a wallet through either the loki-wallet-cli or the desktop GUI wallet, and has enough Loki to stake. They can then run the following command in their loki-wallet-cli . stake <Service Node Pubkey> <contribution amount> Where the <Service Node Pubkey> is the Pubkey provided from the Service Node operator and <contribution amount> is the amount of Loki they are going to stake which they agreed to with the Service Node Operator. If using the desktop GUI wallet, the Stake command can be found under the Advanced - Service Node menu. Enter the service <Service Node Pubkey> and <contribution amount> and hit the Stake button. At this stage you will need to wait for the other contributors to provide their collateral. Once everyone has staked you can refer to \u201cStep 7 - Service Node Check\u201d to see where your Service Node Operator\u2019s node is in the list. Congratulations, you are now staking.","title":"6.2.2 - Pool Contributor"},{"location":"ServiceNodes/SNFullGuideLegacy/#step-7-service-node-check","text":"After we have locked our collateral we will need to check if our Service Node Pubkey is sitting in the list with the other Service Node\u2019s on the network. This will prove our Service Node is running, recognised and will receive a reward if it keeps running. Connect to the VPS where the service node is running and run the following command to see our Service Node Public Key: ~/loki/lokid print_sn_key The Service Node Public Key is used to identify our Service Node within the list of Service Nodes currently on the network. If you want more detailed Service Node status you can use the follow command: ~/loki/lokid print_sn_status You can jump onto https://lokiblocks.com/ to see if your Service Node is in the list or we can continue in the terminal to output the same information. If you are running your Service Node on testnet go to https://lokitestnet.com/ instead. To check this information directly with the service node itself, first get the current block height by running ~/loki/lokid status into the terminal: it will output this information. Once we have the block height we can then check the current Service Nodes on the network at our specified block height. Run the command ~/loki/lokid print_quorum_state <block height> replacing <block height> with the number minus 1 that was outputted when running status command. If your <Service Node Pubkey> is sitting in the list you know you are now staking.","title":"Step 7 - Service Node Check"},{"location":"ServiceNodes/SNFullGuideLegacy/#step-8-unlock-stake","text":"Service Nodes will continually receive block rewards indefinitely until a stake is unlocked or the Service Node becomes deregistered. Unlocking is available via the following command which needs to be run in the command line wallet: request_stake_unlock <service node key> Once the unlock is requested and the request is included in a block in the blockchain, the Service Node will then expire in 15 days (10800 blocks) and the funds will become unlocked after expiry. In pooled nodes, any contributor that requests the stake to unlock will schedule the Service Node for expiration. All locked stakes in that Service Node will be unlocked in 15 days (10800 blocks). Once the unlock is requested, this process can not be undone or prolonged. Service Node participants will continue receiving rewards until expiration. Deregistrations can be issued at any point during the active lifecycle of the Service Node. This is inclusive of the time period during which the Service Node is scheduled for expiry. Getting deregistered removes your Service Node from the network and your stakes are placed into a list of blacklisted transactions. Blacklisted transactions are locked and unspendable for 30 days (21600 blocks) from the block in which the Service Node was deregistered. Receiving a deregistration after participants have already requested the stake to unlock overrides the 15 day (10800 blocks) unlock time, and resets the unlock time to 30 days (21600 blocks).","title":"Step 8 - Unlock Stake"},{"location":"ServiceNodes/SNFullGuideLegacy/#optional","text":"","title":"Optional"},{"location":"ServiceNodes/SNFullGuideLegacy/#see-locked-stake-amount-and-duration","text":"We can also view our locked stake by running the following command from our loki-wallet-cli we staked from: print_locked_stakes","title":"See Locked Stake Amount and Duration"},{"location":"ServiceNodes/SNFullGuideLegacy/#express-setup-guide","text":"This section is for power users who are more familiar with servers and the CLI interface. There's a couple of things your going to want to do before you commence. 1. Get a Server that meets requirements 2. Run the Daemon on a server from a non-root user account, then stake from a local wallet (or a wallet on a separate server). Where <VERSION> is mentioned replace with the latest version for lokid and Storage Server , example v3.0.6 . 3. Connect via SSH to your server 4. add new user sudo adduser snode usermod -aG sudo snode 5. login to your new user account via SSH snode@<ipaddress> 6. Update necessary security patches and system utilities sudo apt update sudo apt upgrade 7. Download & unzip Loki sudo apt install wget unzip wget https://github.com/loki-project/loki/releases/download/v<VERSION>/loki-linux-x64-v<VERSION>.zip wget https://github.com/loki-project/loki-storage-server/releases/download/v<VERSION>-release/loki-storage-linux-x64-v<VERSION>.tar.xz tar -xvf loki-linux-x64-v<VERSION>.tar.xz tar -xvf loki-storage-linux-x64-v<VERSION>.tar.xz ln -snf loki-linux-x64-<VERSION> loki ln -snf loki-storage-linux-x64-v<VERSION> loki-ss 8. Set up Loki to run as a service sudo nano /etc/systemd/system/lokid.service Paste the following: [Unit] Description=lokid service node After=network-online.target [Service] Type=simple User=snode ExecStart=/home/snode/loki/lokid --non-interactive --service-node --service-node-public-ip SERVERIP --storage-server-port 22023 Restart=always RestartSec=30s [Install] WantedBy=multi-user.target Replacing SERVERIP in the line ExecStart= with your servers IP. Save and exit: CTRL+X -> Y -> ENTER sudo nano /etc/systemd/system/loki-ss.service Paste the following: [Unit] Description=Loki storage server After=network-online.target Requires=lokid.service [Service] User=snode Type=simple WorkingDirectory=/home/snode Restart=always RestartSec=5s ExecStart=/home/snode/loki-storage 0.0.0.0 23023 --lokid-rpc-port 22023 --lokid-key /home/snode/.loki/key [Install] WantedBy=multi-user.target Enable and start the service: sudo systemctl daemon-reload sudo systemctl enable lokid.service loki-ss.service sudo systemctl start lokid.service loki-ss.service Wait for the Loki Daemon sync the blockchain (1 - 8 Hours depending on internet speed). You can watch the progress using: sudo journalctl -u lokid.service -af Hit Ctrl-C when you are tired of watching. 9. Open a Wallet This wallet can be in a screen session on the Service Node machine, or a wallet on your local computer (assuming you have downloaded the binaries locally). cd loki-linux-x64-<VERSION> Linux/MAC - ./loki-wallet-cli Windows - loki-wallet-cli Enter Name: Name your wallet Enter password Language: 1 (for English) Securely store: Address Seed Phrase Pass-phrase Send enough Loki to fund a node, wait for Balance to be unlocked (20 mins, 10 confirmations) 10. Register your Service Node Connect via SSH to your VPS with the Service Node running ( snode@<ipaddress> ). ~/loki/lokid prepare_registration Contribute entire Stake: Y/N Enter Loki Address Enable Restaking: Y/N Confirm: Y Copy green registration message Ctrl +AD 11. Reattach to Service Node or local wallet Paste in registration message <enter> 12 Connect back to Service Node VPS account ~/loki/lokid print_sn_key Copy service node key, and search for it on: https://lokiblocks.com/service_nodes . or check the detailed status using: ~/loki/lokid print_sn_key","title":"Express Setup Guide"},{"location":"ServiceNodes/SNFullGuideLegacy/#conclusion","text":"Well done! You will receive a block reward when your Service Node has been active for some time and the network chooses you within the list. Bonus : Use the community-run telegram bot @LokiSNBot to receive on-the-fly updates about your service node. Props to @jagerman42 for building this. Bonus 2 : View https://imaginary.stream/sn/ for more details on Loki Service Node staking requirements. This guide will be regularly updated when new features are added to Snodes. Join the discord for more discussion. If you can improve this guide, please submit a pull request.","title":"Conclusion"},{"location":"ServiceNodes/SNOverview/","text":"Loki Service Nodes \u00b6 Quick Navigation \u00b6 Service Node Setup Staking to Open Pool Service Node Updating Your Binaries How to setup a Service Node. GUI Staking Update your Service Node Set up a Service Node with debs via an apt repository by following this guide. Want to stake without operating a Service Node, or want to stake to an open pool Service Node? Need to download the latest releases for your Service Node and run the Loki Launcher? Service Nodes Overview \u00b6 Much of Loki\u2019s networking functionality and scalability is enabled by a set of incentivised nodes called Service Nodes. To operate a Service Node, an operator time-locks a significant amount of Loki and provides a minimum level of bandwidth and storage to the network. In return for their services, Loki Service Node operators receive a portion of the block reward from each block. Market-based Resistance To Sybil Attack \u00b6 The resulting network provides market-based resistance to Sybil attacks , addressing a range of problems with existing onion routers and privacy-centric services. This resistance is based on supply and demand interactions which help prevent single actors from having a large enough stake in Loki to have a significant negative impact on the second-layer privacy services Loki provides. As an attacker accumulates Loki, the circulating supply decreases, in turn applying demand-side pressure, driving the price of Loki up. As this continues, it becomes increasingly costly for additional Loki to be purchased, making the attack prohibitively expensive. Suppression of Circulating Supply \u00b6 To achieve this economic protection, Loki encourages the active suppression of the circulating supply. In particular, the emissions curve and collateral requirements must be designed to ensure enough circulating supply is locked and reasonable returns are provided for operators to ensure Sybil attack resistance . Express Guide \u00b6 Start a new service node by running these four commands on your server: curl -s https://deb.imaginary.stream/public.gpg | sudo apt-key add - echo \"deb https://deb.imaginary.stream $(lsb_release -sc) main\" | sudo tee /etc/apt/sources.list.d/imaginary.stream.list apt update apt install loki-service-node The services will run via systemd as loki-node.service , loki-storage-server.service , and lokinet-router.service . To see the full guide click here . Service Node Activities \u00b6 Full nodes become Service Nodes when the owner locks the required amount of $Loki and submits a registration transaction. Once accepted by the network, the Service Node is eligible to win block rewards . Multiple participants can be involved in one Service Node and can have the reward automatically distributed. It is also worth noting that Service Nodes operators will need to stay up to date with new updates to keep in line with software and hardware requirements. Service Nodes are required to: Route end user\u2019s internet traffic, either as an exit node or relay Receive, store and forward encrypted user messages Monitor other Service Nodes and vote on their performance Be called into quorums which give them authority over instant transactions ( Blink ) Create new blocks ( Pulse , coming soon ) Guides & Resources \u00b6 Guide/Resource Description Service Node Setup How to host and maintain a Service Node using a Debian Package and CLI wallet . Service Node Setup - Advanced How to host and maintain a Service Node using the CLI wallet . Staking to a Service Node as a Contributor How to Stake to a Service Node when you are not operating one but contributing. Updating your Service Node How to update your Service Node. Loki Dashboard See statistics, data, maps and other information on the Loki Service Nodes. Service Node RPC How to use JSON 2.0 RPC Calls with Service Nodes. Active Service Node List Loki Block explorer showing the current Service Node Pubkeys. Staking Requirement Calculator WEB Webpage showing Staking Requirement at current Block Height.","title":"Overview"},{"location":"ServiceNodes/SNOverview/#loki-service-nodes","text":"","title":"Loki Service Nodes"},{"location":"ServiceNodes/SNOverview/#quick-navigation","text":"Service Node Setup Staking to Open Pool Service Node Updating Your Binaries How to setup a Service Node. GUI Staking Update your Service Node Set up a Service Node with debs via an apt repository by following this guide. Want to stake without operating a Service Node, or want to stake to an open pool Service Node? Need to download the latest releases for your Service Node and run the Loki Launcher?","title":"Quick Navigation"},{"location":"ServiceNodes/SNOverview/#service-nodes-overview","text":"Much of Loki\u2019s networking functionality and scalability is enabled by a set of incentivised nodes called Service Nodes. To operate a Service Node, an operator time-locks a significant amount of Loki and provides a minimum level of bandwidth and storage to the network. In return for their services, Loki Service Node operators receive a portion of the block reward from each block.","title":"Service Nodes Overview"},{"location":"ServiceNodes/SNOverview/#market-based-resistance-to-sybil-attack","text":"The resulting network provides market-based resistance to Sybil attacks , addressing a range of problems with existing onion routers and privacy-centric services. This resistance is based on supply and demand interactions which help prevent single actors from having a large enough stake in Loki to have a significant negative impact on the second-layer privacy services Loki provides. As an attacker accumulates Loki, the circulating supply decreases, in turn applying demand-side pressure, driving the price of Loki up. As this continues, it becomes increasingly costly for additional Loki to be purchased, making the attack prohibitively expensive.","title":"Market-based Resistance To Sybil Attack"},{"location":"ServiceNodes/SNOverview/#suppression-of-circulating-supply","text":"To achieve this economic protection, Loki encourages the active suppression of the circulating supply. In particular, the emissions curve and collateral requirements must be designed to ensure enough circulating supply is locked and reasonable returns are provided for operators to ensure Sybil attack resistance .","title":"Suppression of Circulating Supply"},{"location":"ServiceNodes/SNOverview/#express-guide","text":"Start a new service node by running these four commands on your server: curl -s https://deb.imaginary.stream/public.gpg | sudo apt-key add - echo \"deb https://deb.imaginary.stream $(lsb_release -sc) main\" | sudo tee /etc/apt/sources.list.d/imaginary.stream.list apt update apt install loki-service-node The services will run via systemd as loki-node.service , loki-storage-server.service , and lokinet-router.service . To see the full guide click here .","title":"Express Guide"},{"location":"ServiceNodes/SNOverview/#service-node-activities","text":"Full nodes become Service Nodes when the owner locks the required amount of $Loki and submits a registration transaction. Once accepted by the network, the Service Node is eligible to win block rewards . Multiple participants can be involved in one Service Node and can have the reward automatically distributed. It is also worth noting that Service Nodes operators will need to stay up to date with new updates to keep in line with software and hardware requirements. Service Nodes are required to: Route end user\u2019s internet traffic, either as an exit node or relay Receive, store and forward encrypted user messages Monitor other Service Nodes and vote on their performance Be called into quorums which give them authority over instant transactions ( Blink ) Create new blocks ( Pulse , coming soon )","title":"Service Node Activities"},{"location":"ServiceNodes/SNOverview/#guides-resources","text":"Guide/Resource Description Service Node Setup How to host and maintain a Service Node using a Debian Package and CLI wallet . Service Node Setup - Advanced How to host and maintain a Service Node using the CLI wallet . Staking to a Service Node as a Contributor How to Stake to a Service Node when you are not operating one but contributing. Updating your Service Node How to update your Service Node. Loki Dashboard See statistics, data, maps and other information on the Loki Service Nodes. Service Node RPC How to use JSON 2.0 RPC Calls with Service Nodes. Active Service Node List Loki Block explorer showing the current Service Node Pubkeys. Staking Requirement Calculator WEB Webpage showing Staking Requirement at current Block Height.","title":"Guides &amp; Resources"},{"location":"ServiceNodes/ServiceNodeFunctions/","text":"Service Node Functions \u00b6 Remote Nodes \u00b6 On any given cryptocurrency network, storing a full copy of the blockchain is not possible or practical for many users. In Bitcoin and Ethereum, users can choose to connect to a public full node that holds a copy of the blockchain and can query and submit transactions to the network. This works because Bitcoin and Ethereum full nodes can efficiently search the blockchain for transactions that have the users public key as the target. Due to the construction of CryptoNote currencies, public full nodes (called remote nodes) are put under much more stress. When a user connects to a remote node, they must temporarily download every block (upon wallet creation or since last checked block) to their local machine and check each transaction for a public transaction key which can be generated from the users private view key. This process can cause a significant performance impact on remote nodes. Considering that there is no reward for this service, it can dissuade users from operating syncing services for light clients. CryptoNote mobile wallets are often unreliable and sometimes have to switch between remote nodes multiple times before establishing a reliable connection to either scan the blockchain or to submit a transaction. Additionally, malicious remote node operators running one of the few popular nodes can record the IP address of users as they broadcast specific transactions. Although no information about the actual transaction is revealed by this attack, specific IP addresses can be linked with transactions which can then be used to establish a link to a real-world identity, compromising privacy. Loki circumvents these issues by requiring each Service Node to act as a remote node that can be used by general users. Service Nodes naturally lend themselves to this work as they already hold a full copy of the blockchain and form a widely distributed network of high bandwidth nodes. By using Service Nodes as remote nodes, there is an inherent financial limitation as to how much of the remote node network any given party can own, and therefore, how much data a malicious node operator can collect. Future Service Node Functions \u00b6 Exit Nodes \u00b6 Exit nodes allow users to make requests to the wider internet and return those requests through an onion routing protocol . If used correctly, exit nodes allow users to browse the internet privately and without the users IP address being exposed to the server. Although the operation of exit nodes is essential to Loki\u2019s extended utility, forcing all Service Node operators to act as exit nodes could be detrimental. Acting as an exit node may expose the operator to legal risks, as users of the exit node may perform malicious activity whilst using it as a proxy. As exit nodes simply relay traffic from the internet to the end user, exit nodes often receive Digital Millennium Copyright Act (DMCA) requests or are often assumed to be the source of hacking attempts. Although in most jurisdictions safe harboring laws may protect exit node operators, internet service providers that carry Service Node traffic on their servers may fear legal risks and often cut off service to the exit node. Upon startup, a Service Node is assigned a relay flag and is restricted to routing packets within Lokinet, but never makes requests to the wider internet. An operator must opt-in if they wish to become an exit node, in doing so they demonstrate an understanding of the additional risks while also submitting to additional Swarm tests . Opting-in as an exit node affords an operator double the reward of a normal relay when selected for a block reward . This incentive is provided to ensure that exit node operators have sufficient financial incentives to operate exit nodes, helping to protect against Sybil attacks specifically targeted to take over the exit node network. This is a vulnerability which Tor suffers from due to its low ratio of exit nodes to relays.","title":"Loki Documentation | Loki Service Node Functions."},{"location":"ServiceNodes/ServiceNodeFunctions/#service-node-functions","text":"","title":"Service Node Functions"},{"location":"ServiceNodes/ServiceNodeFunctions/#remote-nodes","text":"On any given cryptocurrency network, storing a full copy of the blockchain is not possible or practical for many users. In Bitcoin and Ethereum, users can choose to connect to a public full node that holds a copy of the blockchain and can query and submit transactions to the network. This works because Bitcoin and Ethereum full nodes can efficiently search the blockchain for transactions that have the users public key as the target. Due to the construction of CryptoNote currencies, public full nodes (called remote nodes) are put under much more stress. When a user connects to a remote node, they must temporarily download every block (upon wallet creation or since last checked block) to their local machine and check each transaction for a public transaction key which can be generated from the users private view key. This process can cause a significant performance impact on remote nodes. Considering that there is no reward for this service, it can dissuade users from operating syncing services for light clients. CryptoNote mobile wallets are often unreliable and sometimes have to switch between remote nodes multiple times before establishing a reliable connection to either scan the blockchain or to submit a transaction. Additionally, malicious remote node operators running one of the few popular nodes can record the IP address of users as they broadcast specific transactions. Although no information about the actual transaction is revealed by this attack, specific IP addresses can be linked with transactions which can then be used to establish a link to a real-world identity, compromising privacy. Loki circumvents these issues by requiring each Service Node to act as a remote node that can be used by general users. Service Nodes naturally lend themselves to this work as they already hold a full copy of the blockchain and form a widely distributed network of high bandwidth nodes. By using Service Nodes as remote nodes, there is an inherent financial limitation as to how much of the remote node network any given party can own, and therefore, how much data a malicious node operator can collect.","title":"Remote Nodes"},{"location":"ServiceNodes/ServiceNodeFunctions/#future-service-node-functions","text":"","title":"Future Service Node Functions"},{"location":"ServiceNodes/ServiceNodeFunctions/#exit-nodes","text":"Exit nodes allow users to make requests to the wider internet and return those requests through an onion routing protocol . If used correctly, exit nodes allow users to browse the internet privately and without the users IP address being exposed to the server. Although the operation of exit nodes is essential to Loki\u2019s extended utility, forcing all Service Node operators to act as exit nodes could be detrimental. Acting as an exit node may expose the operator to legal risks, as users of the exit node may perform malicious activity whilst using it as a proxy. As exit nodes simply relay traffic from the internet to the end user, exit nodes often receive Digital Millennium Copyright Act (DMCA) requests or are often assumed to be the source of hacking attempts. Although in most jurisdictions safe harboring laws may protect exit node operators, internet service providers that carry Service Node traffic on their servers may fear legal risks and often cut off service to the exit node. Upon startup, a Service Node is assigned a relay flag and is restricted to routing packets within Lokinet, but never makes requests to the wider internet. An operator must opt-in if they wish to become an exit node, in doing so they demonstrate an understanding of the additional risks while also submitting to additional Swarm tests . Opting-in as an exit node affords an operator double the reward of a normal relay when selected for a block reward . This incentive is provided to ensure that exit node operators have sufficient financial incentives to operate exit nodes, helping to protect against Sybil attacks specifically targeted to take over the exit node network. This is a vulnerability which Tor suffers from due to its low ratio of exit nodes to relays.","title":"Exit Nodes"},{"location":"ServiceNodes/StakingRequirement/","text":"Staking Requirement \u00b6 A stake involves holding a specific cryptocoin in a wallet for a particular period of time. A staking requirement is the minimum amount of said cryptocoin that is required to stake. Service Node Staking Requirement \u00b6 A Loki staking Requirement is the collateral requirement an operator stakes through a time-locked output, which can be unlocked as per the contributor's request. Upon a request to unlock the funds they will stay locked for an additional 15 days where the contributor will still receive rewards. In the extra field of the transaction, the Service Node operator includes the Loki address which may receive Service Node rewards. This address will also be used as the public key for Service Node operations such as swarm voting. Before each node joins the Service Node network, other nodes must individually validate that the said nodes collateral outlay matches the required amount, as per the decreasing collateralisation requirement. If the node is offline for a reasonable time, its uptime proof will not be sent to the other nodes resulting in a deregister of the node. Deregistered nodes will have their collateral requirement locked for 30 days. The staking requirement started at 45,000 during Service Node launch (block height 101250), and was to descend non-linearly to ~10,000 by year 4 (block height 1036800). A change was made at block height 230704 to have the LSR descend non-linearly to ~15000. An aproximation of the formula is as follows: Where LSR is the Loki Staking Requirement and h is the block height. To find out the loki staking requirement click here .","title":"Staking Requirement"},{"location":"ServiceNodes/StakingRequirement/#staking-requirement","text":"A stake involves holding a specific cryptocoin in a wallet for a particular period of time. A staking requirement is the minimum amount of said cryptocoin that is required to stake.","title":"Staking Requirement"},{"location":"ServiceNodes/StakingRequirement/#service-node-staking-requirement","text":"A Loki staking Requirement is the collateral requirement an operator stakes through a time-locked output, which can be unlocked as per the contributor's request. Upon a request to unlock the funds they will stay locked for an additional 15 days where the contributor will still receive rewards. In the extra field of the transaction, the Service Node operator includes the Loki address which may receive Service Node rewards. This address will also be used as the public key for Service Node operations such as swarm voting. Before each node joins the Service Node network, other nodes must individually validate that the said nodes collateral outlay matches the required amount, as per the decreasing collateralisation requirement. If the node is offline for a reasonable time, its uptime proof will not be sent to the other nodes resulting in a deregister of the node. Deregistered nodes will have their collateral requirement locked for 30 days. The staking requirement started at 45,000 during Service Node launch (block height 101250), and was to descend non-linearly to ~10,000 by year 4 (block height 1036800). A change was made at block height 230704 to have the LSR descend non-linearly to ~15000. An aproximation of the formula is as follows: Where LSR is the Loki Staking Requirement and h is the block height. To find out the loki staking requirement click here .","title":"Service Node Staking Requirement"},{"location":"ServiceNodes/StorageServerGuide-Testnet/","text":"Storage Server Testnet Guide \u00b6 Overview \u00b6 This guide will tell you how to set up a staked node on testnet that handles lokid and storage-server functions. Step 1 - Server Preparation \u00b6 1.1 Add new User \u00b6 adduser <username> Replacing <username> with a name you will log-in with. For this user-guide we will use snode as our username. adduser snode Once that\u2019s done, run the following two commands to give our new account admin privileges and to change to such account. usermod -aG sudo snode sudo su - snode 1.2 Update and Upgrade Server \u00b6 Run the two following commands to update and upgrade your server. sudo apt update sudo apt upgrade Step 2 - Loki Launcher \u00b6 2.1 - Install NodeJS and Loki Launcher \u00b6 In order to use the Loki Launcher we first need to install NodeJS. Run the following command: curl -sL https://deb.nodesource.com/setup_10.x | sudo bash - then run: sudo apt-get install -y nodejs Next we need to install the launcher with the following command: sudo npm install -g loki-launcher 2.2 - Setting up your loki-launcher for Service Node \u00b6 We now need to prequalify our server to be ready to run as a service node. To do so run the following command: loki-launcher prequal 2.2 - Configuring Launcher.ini \u00b6 Next let's set our config file to enable the storage server and to set our network to testnet. Create a folder for our launcher.ini file: sudo mkdir /etc/loki-launcher Next create the launcher.ini file: sudo nano /etc/loki-launcher/launcher.ini Paste the following into the launcher.ini file and save. [blockchain] network=test [storage] enabled=true 2.3 - Download Lokid binaries \u00b6 We will download the Loki binaries by running the following command: sudo loki-launcher download-binaries 2.4 - Start the Loki Launcher \u00b6 To start the loki launcher run the following command: sudo loki-launcher start At this moment the launcher will output a table showing if everything is working properly: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 (index) \u2502 Values \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 launcher \u2502 'running as 16196' \u2502 \u2502 blockchain \u2502 'running as 16207' \u2502 \u2502 lokiKey \u2502 'found at /home/snode/.loki/testnet/key' \u2502 \u2502 storageServer \u2502 'running as 16208' \u2502 \u2502 socket \u2502 'running at /opt/loki-launcher/var' \u2502 \u2502 blockchain_rpc \u2502 'waiting...' \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Now the Loki-launcher is running we can access the launcher by running the following command: sudo loki-launcher client To exit out of the client click CTRL + C . Note: Loki-launcher will run in the background now and continue to sync with the blockchain. The only problem is if the system reboots we will need to relaunch the loki-launcher software. We can fix this by configuring the Launcher as a system service which makes it automatically start up if the server reboots, and restarts it if the software crashes for some reason. Step 3 - Loki-Launcher as a System Service \u00b6 3.1 User permissions \u00b6 We are going to need to fix our user \"snode\"s permissions with the loki-launcher. To do: Skip for people running as root To do this we need to swap back to root: su - root Next run the following command: loki-launcher fix-perms <USER> Replacing <USER> with snode or the username that you created. The terminal should show the following: setting permissions to snode user snode uid is 1000 Once the permissions have been set let's change back to our other user snode by running the following command: su - snode 3.2 Creating the Service File \u00b6 To create our lokid.service file run the following command: sudo nano /etc/systemd/system/lokid.service Next copy the text below and paste it into your new file. To paste in putty you can right mouse click the terminal screen. [Unit] Description=lokilauncher After=network-online.target [Service] Type=simple User=snode ExecStart=/usr/lib/node_modules/loki-launcher/index.js systemd-start Restart=always RestartSec=30s [Install] WantedBy=multi-user.target If you chose a username other than snode then change snode in the User= line to the alternative username. 3.3 Enabling the Service File \u00b6 Reload systemd manager configuration (to make it re-read the new service file): sudo systemctl daemon-reload Enable lokid.service so that it starts automatically upon boot: sudo systemctl enable lokid.service Start lokid.service: sudo systemctl start lokid.service and reboot your system to check if the service file is working correctly. sudo reboot Log back into your server and run the following command: loki-launcher status The terminal should output something similar to: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 (index) \u2502 Values \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 launcher \u2502 'running as 1118' \u2502 \u2502 blockchain \u2502 'running as 1129' \u2502 \u2502 lokiKey \u2502 'offline' \u2502 \u2502 storageServer \u2502 'running as 1130' \u2502 \u2502 socket \u2502 'running at /opt/loki-launcher/var' \u2502 \u2502 blockchain_rpc \u2502 'running on 127.0.0.1:38157' \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Note: There is a known bug that lokiKey shows as offline . Do not worry about this as you can run loki-launcher config-view to see where your lokid_key is stored. Well done! You're loki-launcher is now setup. Step 4 - Service Node Registration \u00b6 4.1 - Staking \u00b6 Log in (if not already connected) as the snode user on the VPS running the service node, then connect to the loki-launcher client: loki-launcher client Start the registration process by running the following interactive command: prepare_registration The daemon will output the current staking requirement and prompt you with an input to clarify whether you are an individual staker or you will be running a pool. Type y and click enter as we will be the sole staker. The daemon will now prompt us for the Loki address of the operator. The daemon will now ask for a final confirmation, if you agree to the information provided type y and click enter. The daemon will output a command for us to run looking similar to: register_service_node 4294967292 T6TCCyDgjjbddtzwNGryRJ5HntgGYvqZTagBb2mtHhn7WWz7i5JDeqhFiHqu7ret56411ZJS7Thfeis718bVteBZ2UA6Y7G2d 4294967292 100.000000000 1535677391 ec3895ea70a4a91b5ec4b5e1df96a45e07046f1fb0123c754d98fb2d70f4529d 5bb35d7b8ab1acb943bc47913ada8f9d2e6d6e22264e57484a04c1bbfd461f0ee2e5435454cd9b7059b221eb506ce9ea4537ddd9faf1f1757e0ef611a41c0609 NOTE: You must run the command outputed by your daemon and not the command shown above. Copy the whole line of text and paste it into your notepad as we will need to run this command in our loki-wallet-cli . Congratulations, You are now running a Service Node that handles both lokid and storage server functions.","title":"Service Node TESTNET Guide"},{"location":"ServiceNodes/StorageServerGuide-Testnet/#storage-server-testnet-guide","text":"","title":"Storage Server Testnet Guide"},{"location":"ServiceNodes/StorageServerGuide-Testnet/#overview","text":"This guide will tell you how to set up a staked node on testnet that handles lokid and storage-server functions.","title":"Overview"},{"location":"ServiceNodes/StorageServerGuide-Testnet/#step-1-server-preparation","text":"","title":"Step 1 - Server Preparation"},{"location":"ServiceNodes/StorageServerGuide-Testnet/#11-add-new-user","text":"adduser <username> Replacing <username> with a name you will log-in with. For this user-guide we will use snode as our username. adduser snode Once that\u2019s done, run the following two commands to give our new account admin privileges and to change to such account. usermod -aG sudo snode sudo su - snode","title":"1.1 Add new User"},{"location":"ServiceNodes/StorageServerGuide-Testnet/#12-update-and-upgrade-server","text":"Run the two following commands to update and upgrade your server. sudo apt update sudo apt upgrade","title":"1.2 Update and Upgrade Server"},{"location":"ServiceNodes/StorageServerGuide-Testnet/#step-2-loki-launcher","text":"","title":"Step 2 - Loki Launcher"},{"location":"ServiceNodes/StorageServerGuide-Testnet/#21-install-nodejs-and-loki-launcher","text":"In order to use the Loki Launcher we first need to install NodeJS. Run the following command: curl -sL https://deb.nodesource.com/setup_10.x | sudo bash - then run: sudo apt-get install -y nodejs Next we need to install the launcher with the following command: sudo npm install -g loki-launcher","title":"2.1 - Install NodeJS and Loki Launcher"},{"location":"ServiceNodes/StorageServerGuide-Testnet/#22-setting-up-your-loki-launcher-for-service-node","text":"We now need to prequalify our server to be ready to run as a service node. To do so run the following command: loki-launcher prequal","title":"2.2 - Setting up your loki-launcher for Service Node"},{"location":"ServiceNodes/StorageServerGuide-Testnet/#22-configuring-launcherini","text":"Next let's set our config file to enable the storage server and to set our network to testnet. Create a folder for our launcher.ini file: sudo mkdir /etc/loki-launcher Next create the launcher.ini file: sudo nano /etc/loki-launcher/launcher.ini Paste the following into the launcher.ini file and save. [blockchain] network=test [storage] enabled=true","title":"2.2 - Configuring Launcher.ini"},{"location":"ServiceNodes/StorageServerGuide-Testnet/#23-download-lokid-binaries","text":"We will download the Loki binaries by running the following command: sudo loki-launcher download-binaries","title":"2.3 - Download Lokid binaries"},{"location":"ServiceNodes/StorageServerGuide-Testnet/#24-start-the-loki-launcher","text":"To start the loki launcher run the following command: sudo loki-launcher start At this moment the launcher will output a table showing if everything is working properly: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 (index) \u2502 Values \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 launcher \u2502 'running as 16196' \u2502 \u2502 blockchain \u2502 'running as 16207' \u2502 \u2502 lokiKey \u2502 'found at /home/snode/.loki/testnet/key' \u2502 \u2502 storageServer \u2502 'running as 16208' \u2502 \u2502 socket \u2502 'running at /opt/loki-launcher/var' \u2502 \u2502 blockchain_rpc \u2502 'waiting...' \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Now the Loki-launcher is running we can access the launcher by running the following command: sudo loki-launcher client To exit out of the client click CTRL + C . Note: Loki-launcher will run in the background now and continue to sync with the blockchain. The only problem is if the system reboots we will need to relaunch the loki-launcher software. We can fix this by configuring the Launcher as a system service which makes it automatically start up if the server reboots, and restarts it if the software crashes for some reason.","title":"2.4 - Start the Loki Launcher"},{"location":"ServiceNodes/StorageServerGuide-Testnet/#step-3-loki-launcher-as-a-system-service","text":"","title":"Step 3 - Loki-Launcher as a System Service"},{"location":"ServiceNodes/StorageServerGuide-Testnet/#31-user-permissions","text":"We are going to need to fix our user \"snode\"s permissions with the loki-launcher. To do: Skip for people running as root To do this we need to swap back to root: su - root Next run the following command: loki-launcher fix-perms <USER> Replacing <USER> with snode or the username that you created. The terminal should show the following: setting permissions to snode user snode uid is 1000 Once the permissions have been set let's change back to our other user snode by running the following command: su - snode","title":"3.1 User permissions"},{"location":"ServiceNodes/StorageServerGuide-Testnet/#32-creating-the-service-file","text":"To create our lokid.service file run the following command: sudo nano /etc/systemd/system/lokid.service Next copy the text below and paste it into your new file. To paste in putty you can right mouse click the terminal screen. [Unit] Description=lokilauncher After=network-online.target [Service] Type=simple User=snode ExecStart=/usr/lib/node_modules/loki-launcher/index.js systemd-start Restart=always RestartSec=30s [Install] WantedBy=multi-user.target If you chose a username other than snode then change snode in the User= line to the alternative username.","title":"3.2 Creating the Service File"},{"location":"ServiceNodes/StorageServerGuide-Testnet/#33-enabling-the-service-file","text":"Reload systemd manager configuration (to make it re-read the new service file): sudo systemctl daemon-reload Enable lokid.service so that it starts automatically upon boot: sudo systemctl enable lokid.service Start lokid.service: sudo systemctl start lokid.service and reboot your system to check if the service file is working correctly. sudo reboot Log back into your server and run the following command: loki-launcher status The terminal should output something similar to: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 (index) \u2502 Values \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 launcher \u2502 'running as 1118' \u2502 \u2502 blockchain \u2502 'running as 1129' \u2502 \u2502 lokiKey \u2502 'offline' \u2502 \u2502 storageServer \u2502 'running as 1130' \u2502 \u2502 socket \u2502 'running at /opt/loki-launcher/var' \u2502 \u2502 blockchain_rpc \u2502 'running on 127.0.0.1:38157' \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Note: There is a known bug that lokiKey shows as offline . Do not worry about this as you can run loki-launcher config-view to see where your lokid_key is stored. Well done! You're loki-launcher is now setup.","title":"3.3 Enabling the Service File"},{"location":"ServiceNodes/StorageServerGuide-Testnet/#step-4-service-node-registration","text":"","title":"Step 4 - Service Node Registration"},{"location":"ServiceNodes/StorageServerGuide-Testnet/#41-staking","text":"Log in (if not already connected) as the snode user on the VPS running the service node, then connect to the loki-launcher client: loki-launcher client Start the registration process by running the following interactive command: prepare_registration The daemon will output the current staking requirement and prompt you with an input to clarify whether you are an individual staker or you will be running a pool. Type y and click enter as we will be the sole staker. The daemon will now prompt us for the Loki address of the operator. The daemon will now ask for a final confirmation, if you agree to the information provided type y and click enter. The daemon will output a command for us to run looking similar to: register_service_node 4294967292 T6TCCyDgjjbddtzwNGryRJ5HntgGYvqZTagBb2mtHhn7WWz7i5JDeqhFiHqu7ret56411ZJS7Thfeis718bVteBZ2UA6Y7G2d 4294967292 100.000000000 1535677391 ec3895ea70a4a91b5ec4b5e1df96a45e07046f1fb0123c754d98fb2d70f4529d 5bb35d7b8ab1acb943bc47913ada8f9d2e6d6e22264e57484a04c1bbfd461f0ee2e5435454cd9b7059b221eb506ce9ea4537ddd9faf1f1757e0ef611a41c0609 NOTE: You must run the command outputed by your daemon and not the command shown above. Copy the whole line of text and paste it into your notepad as we will need to run this command in our loki-wallet-cli . Congratulations, You are now running a Service Node that handles both lokid and storage server functions.","title":"4.1 - Staking"},{"location":"ServiceNodes/UpdateGuide/","text":"Update Guide \u00b6 This document is for Service Node Operators who have used the previous Service Node Full Guide and wish to update to the Loki-launcher. Note: This Guide is to help update a running lokid 3.0.6 Service Node to the loki-launcher. If you are using any screen's you will need kill the screens and go back to the Service Node Full Guide and follow it once more. Step 1: Load and Update your VPS. \u00b6 If you are updating your Service Node you would by now have a good understanding of how to log in to your server. If you don't check out how you prepared your server in this guide here . Once we have logged in to our VPS we should update our package lists, the below command downloads the package lists from the repositories and \"updates\" them to get information on the newest versions of packages and their dependencies. It will do this for all repositories and PPAs. sudo apt update You will notice a bunch of package lists were downloaded, once this is complete run the below command to fetch new versions of any packages we currently have installed on the system. sudo apt upgrade You will be prompted to authorise the use of disk space, type y and enter to authorise. If you are prompted during the upgrade that a new version of any file is available then click the up and down arrows until you are hovering over install the package maintainer\u2019s version and click enter. Alright, good to go. Our server is now up to date. On to the fun part! Step 2: Install Node JS \u00b6 In order to use the Loki Launcher we first need to install NodeJS. Run the following command: curl -sL https://deb.nodesource.com/setup_10.x | sudo bash - then sudo apt-get install -y nodejs Step 3: Loki Launcher \u00b6 3.1 Install \u00b6 Run the following command to install loki-launcher sudo npm install -g loki-launcher 3.2 Download lokid binaries \u00b6 Now loki-launcher is installed we should download the lokid binary: sudo loki-launcher download-binaries 3.3 Fix loki-launcher permissions \u00b6 Let's change to root to make these changes: su - root Now while in root let's give our user snode the required permissions to run the loki-launcher. sudo loki-launcher fix-perms snode Now let's change back to user snode. su - snode Step 4: lokid.service file \u00b6 Next we're going to have to stop our lokid.service file and update it to launch the launcher instead of lokid. 4.1: Stop existing lokid.service file \u00b6 Stop your existing service node: sudo systemctl stop lokid.service 4.2 - Setting up your loki-launcher for Service Node \u00b6 We now need to prequalify our server to be ready to run as a service node. To do so run the following command: loki-launcher prequal In most cases this will let us know we are good to deploy our Service Node. Troubleshooting will be required at this point if an error message pops up. 4.3: Check-systemd \u00b6 Run the check-systemd to make systemd now launch the launcher instead of lokid: sudo loki-launcher check-systemd 4.4 Update Service file \u00b6 Make sure the service is up to date: sudo systemctl daemon-reload 4.5 Start the new lokid.service file \u00b6 sudo systemctl start lokid.service At this point it is wise to restart your system with the following command: sudo reboot Once the system has restarted it will reboot the new version of lokid.service . Log back in to your VPS and double check the new version of lokid.service is running smoothly by running the following command: sudo journalctl -u lokid.service -af You can now access your lokid daemon by running the following command: loki-launcher client This will allow you to parse commands into your daemon, for example: print_sn_key e.t.c. NOTE: If you\u2019re nervous about trusting the binaries or the download link, you should build it from source yourself. Instructions for that can be found in the README of https://github.com/loki-project/loki Excellent! You have now updated your Service Node. Additional Information \u00b6 Default Directories for Loki Files \u00b6 Name Directory Blockchain Data /home/<user>/.loki/ Lokid Binaries /opt/loki-launcher/bin Launcher Config File /etc/loki-launcher/launcher.ini Lokid Logs /home/<user>/.loki/","title":"Loki Documentation | Service Node upgrade from Legacy to Launcher"},{"location":"ServiceNodes/UpdateGuide/#update-guide","text":"This document is for Service Node Operators who have used the previous Service Node Full Guide and wish to update to the Loki-launcher. Note: This Guide is to help update a running lokid 3.0.6 Service Node to the loki-launcher. If you are using any screen's you will need kill the screens and go back to the Service Node Full Guide and follow it once more.","title":"Update Guide"},{"location":"ServiceNodes/UpdateGuide/#step-1-load-and-update-your-vps","text":"If you are updating your Service Node you would by now have a good understanding of how to log in to your server. If you don't check out how you prepared your server in this guide here . Once we have logged in to our VPS we should update our package lists, the below command downloads the package lists from the repositories and \"updates\" them to get information on the newest versions of packages and their dependencies. It will do this for all repositories and PPAs. sudo apt update You will notice a bunch of package lists were downloaded, once this is complete run the below command to fetch new versions of any packages we currently have installed on the system. sudo apt upgrade You will be prompted to authorise the use of disk space, type y and enter to authorise. If you are prompted during the upgrade that a new version of any file is available then click the up and down arrows until you are hovering over install the package maintainer\u2019s version and click enter. Alright, good to go. Our server is now up to date. On to the fun part!","title":"Step 1: Load and Update your VPS."},{"location":"ServiceNodes/UpdateGuide/#step-2-install-node-js","text":"In order to use the Loki Launcher we first need to install NodeJS. Run the following command: curl -sL https://deb.nodesource.com/setup_10.x | sudo bash - then sudo apt-get install -y nodejs","title":"Step 2: Install Node JS"},{"location":"ServiceNodes/UpdateGuide/#step-3-loki-launcher","text":"","title":"Step 3: Loki Launcher"},{"location":"ServiceNodes/UpdateGuide/#31-install","text":"Run the following command to install loki-launcher sudo npm install -g loki-launcher","title":"3.1 Install"},{"location":"ServiceNodes/UpdateGuide/#32-download-lokid-binaries","text":"Now loki-launcher is installed we should download the lokid binary: sudo loki-launcher download-binaries","title":"3.2 Download lokid binaries"},{"location":"ServiceNodes/UpdateGuide/#33-fix-loki-launcher-permissions","text":"Let's change to root to make these changes: su - root Now while in root let's give our user snode the required permissions to run the loki-launcher. sudo loki-launcher fix-perms snode Now let's change back to user snode. su - snode","title":"3.3 Fix loki-launcher permissions"},{"location":"ServiceNodes/UpdateGuide/#step-4-lokidservice-file","text":"Next we're going to have to stop our lokid.service file and update it to launch the launcher instead of lokid.","title":"Step 4: lokid.service file"},{"location":"ServiceNodes/UpdateGuide/#41-stop-existing-lokidservice-file","text":"Stop your existing service node: sudo systemctl stop lokid.service","title":"4.1: Stop existing lokid.service file"},{"location":"ServiceNodes/UpdateGuide/#42-setting-up-your-loki-launcher-for-service-node","text":"We now need to prequalify our server to be ready to run as a service node. To do so run the following command: loki-launcher prequal In most cases this will let us know we are good to deploy our Service Node. Troubleshooting will be required at this point if an error message pops up.","title":"4.2 - Setting up your loki-launcher for Service Node"},{"location":"ServiceNodes/UpdateGuide/#43-check-systemd","text":"Run the check-systemd to make systemd now launch the launcher instead of lokid: sudo loki-launcher check-systemd","title":"4.3: Check-systemd"},{"location":"ServiceNodes/UpdateGuide/#44-update-service-file","text":"Make sure the service is up to date: sudo systemctl daemon-reload","title":"4.4 Update Service file"},{"location":"ServiceNodes/UpdateGuide/#45-start-the-new-lokidservice-file","text":"sudo systemctl start lokid.service At this point it is wise to restart your system with the following command: sudo reboot Once the system has restarted it will reboot the new version of lokid.service . Log back in to your VPS and double check the new version of lokid.service is running smoothly by running the following command: sudo journalctl -u lokid.service -af You can now access your lokid daemon by running the following command: loki-launcher client This will allow you to parse commands into your daemon, for example: print_sn_key e.t.c. NOTE: If you\u2019re nervous about trusting the binaries or the download link, you should build it from source yourself. Instructions for that can be found in the README of https://github.com/loki-project/loki Excellent! You have now updated your Service Node.","title":"4.5 Start the new lokid.service file"},{"location":"ServiceNodes/UpdateGuide/#additional-information","text":"","title":"Additional Information"},{"location":"ServiceNodes/UpdateGuide/#default-directories-for-loki-files","text":"Name Directory Blockchain Data /home/<user>/.loki/ Lokid Binaries /opt/loki-launcher/bin Launcher Config File /etc/loki-launcher/launcher.ini Lokid Logs /home/<user>/.loki/","title":"Default Directories for Loki Files"},{"location":"ServiceNodes/UpdateGuideOld/","text":"Update Guide \u00b6 This document is for Service Node Operators who have used the previous Service Node Full Guide and wish to update the version of their Service Node. Note that this update guide is for individuals running their Service Node as a Service on linux. If you are using any screen 's you will need kill the screens and go back to the Service Node Full Guide and follow it once more. It is highly recommended running your Service Node as a Service due to the ease of updating. Step 1: Load and Update your VPS. \u00b6 If you are updating your VPS you would by now have a good understanding of how to log in to your server. If you don't check out how you prepared your server in this guide here . Once we have logged in to our VPS we should update our package lists, the below command downloads the package lists from the repositories and \"updates\" them to get information on the newest versions of packages and their dependencies. It will do this for all repositories and PPAs. sudo apt update You will notice a bunch of package lists were downloaded, once this is complete run the below command to fetch new versions of any packages we currently have installed on the system. sudo apt upgrade You will be prompted to authorise the use of disk space, type y and enter to authorise. If you are prompted during the upgrade that a new version of any file is available then click the up and down arrows until you are hovering over install the package maintainer\u2019s version and click enter. Alright, good to go. Our server is now up to date. On to the fun part! Step 2: Download the new Loki Binaries \u00b6 To download the Linux binaries use the following command: wget <link> Where <link> is the download link of the latest linux release. To find the link go to https://github.com/loki-project/loki/releases/latest , right click the latest linux release and click Copy Link Location . Your command should look something like: wget https://github.com/loki-project/loki/releases/download/v3.0.6/loki-linux-x64-v3.0.6.zip To unzip the downloaded zip file run the following command (changing 3.0.6 to whatever version you downloaded above): unzip loki-linux-x64-v3.0.6.zip You will see something like this: Archive: loki-linux-x64-v3.0.6.zip creating: loki-linux-x64-v3.0.6/ inflating: loki-linux-x64-v3.0.6/loki-blockchain-ancestry inflating: loki-linux-x64-v3.0.6/loki-blockchain-depth inflating: loki-linux-x64-v3.0.6/loki-blockchain-export inflating: loki-linux-x64-v3.0.6/loki-blockchain-import inflating: loki-linux-x64-v3.0.6/loki-blockchain-mark-spent-outputs inflating: loki-linux-x64-v3.0.6/loki-blockchain-stats inflating: loki-linux-x64-v3.0.6/loki-blockchain-usage inflating: loki-linux-x64-v3.0.6/loki-gen-trusted-multisig inflating: loki-linux-x64-v3.0.6/loki-wallet-cli inflating: loki-linux-x64-v3.0.6/loki-wallet-rpc inflating: loki-linux-x64-v3.0.6/lokid Note that they are unzipped into the loki-linux-x64-v3.0.6 folder; you can check they are unzipped by running the following to change into the folder and then listing the files: cd loki-linux-x64-v3.0.6 ls We now want to replace our \"symlink\" to the new extracted loki-linux-x64-v3.0.6 folder. If you are unfamiliar with what the \"symlink\" was doing previously have a look at the Service Node Full Guide where you first set it up. Otherwise, run the following command.: cd ln -snf <folder_name> loki Where <folder_name> is the new folder we created when unziping the release. In this case if we were to update to v3.0.6 the commands we would use would be: cd ln -snf loki-linux-x64-v3.0.6 loki This replaces our virtual loki folder that pointed to an old folder to the loki-linux-x64-v3.0.6 folder we created. At this point it is wise to restart your system with the following command: sudo reboot Once the system has restarted it will reboot the new version of lokid . Log back in to your VPS and double check the new version of lokid is running smoothly by running the following command: sudo journalctl -u lokid.service -af NOTE: If you\u2019re nervous about trusting the binaries or the download link, you should build it from source yourself. Instructions for that can be found in the README of https://github.com/loki-project/loki Excellent! You have now updated your Service Node.","title":"Update Guide"},{"location":"ServiceNodes/UpdateGuideOld/#update-guide","text":"This document is for Service Node Operators who have used the previous Service Node Full Guide and wish to update the version of their Service Node. Note that this update guide is for individuals running their Service Node as a Service on linux. If you are using any screen 's you will need kill the screens and go back to the Service Node Full Guide and follow it once more. It is highly recommended running your Service Node as a Service due to the ease of updating.","title":"Update Guide"},{"location":"ServiceNodes/UpdateGuideOld/#step-1-load-and-update-your-vps","text":"If you are updating your VPS you would by now have a good understanding of how to log in to your server. If you don't check out how you prepared your server in this guide here . Once we have logged in to our VPS we should update our package lists, the below command downloads the package lists from the repositories and \"updates\" them to get information on the newest versions of packages and their dependencies. It will do this for all repositories and PPAs. sudo apt update You will notice a bunch of package lists were downloaded, once this is complete run the below command to fetch new versions of any packages we currently have installed on the system. sudo apt upgrade You will be prompted to authorise the use of disk space, type y and enter to authorise. If you are prompted during the upgrade that a new version of any file is available then click the up and down arrows until you are hovering over install the package maintainer\u2019s version and click enter. Alright, good to go. Our server is now up to date. On to the fun part!","title":"Step 1: Load and Update your VPS."},{"location":"ServiceNodes/UpdateGuideOld/#step-2-download-the-new-loki-binaries","text":"To download the Linux binaries use the following command: wget <link> Where <link> is the download link of the latest linux release. To find the link go to https://github.com/loki-project/loki/releases/latest , right click the latest linux release and click Copy Link Location . Your command should look something like: wget https://github.com/loki-project/loki/releases/download/v3.0.6/loki-linux-x64-v3.0.6.zip To unzip the downloaded zip file run the following command (changing 3.0.6 to whatever version you downloaded above): unzip loki-linux-x64-v3.0.6.zip You will see something like this: Archive: loki-linux-x64-v3.0.6.zip creating: loki-linux-x64-v3.0.6/ inflating: loki-linux-x64-v3.0.6/loki-blockchain-ancestry inflating: loki-linux-x64-v3.0.6/loki-blockchain-depth inflating: loki-linux-x64-v3.0.6/loki-blockchain-export inflating: loki-linux-x64-v3.0.6/loki-blockchain-import inflating: loki-linux-x64-v3.0.6/loki-blockchain-mark-spent-outputs inflating: loki-linux-x64-v3.0.6/loki-blockchain-stats inflating: loki-linux-x64-v3.0.6/loki-blockchain-usage inflating: loki-linux-x64-v3.0.6/loki-gen-trusted-multisig inflating: loki-linux-x64-v3.0.6/loki-wallet-cli inflating: loki-linux-x64-v3.0.6/loki-wallet-rpc inflating: loki-linux-x64-v3.0.6/lokid Note that they are unzipped into the loki-linux-x64-v3.0.6 folder; you can check they are unzipped by running the following to change into the folder and then listing the files: cd loki-linux-x64-v3.0.6 ls We now want to replace our \"symlink\" to the new extracted loki-linux-x64-v3.0.6 folder. If you are unfamiliar with what the \"symlink\" was doing previously have a look at the Service Node Full Guide where you first set it up. Otherwise, run the following command.: cd ln -snf <folder_name> loki Where <folder_name> is the new folder we created when unziping the release. In this case if we were to update to v3.0.6 the commands we would use would be: cd ln -snf loki-linux-x64-v3.0.6 loki This replaces our virtual loki folder that pointed to an old folder to the loki-linux-x64-v3.0.6 folder we created. At this point it is wise to restart your system with the following command: sudo reboot Once the system has restarted it will reboot the new version of lokid . Log back in to your VPS and double check the new version of lokid is running smoothly by running the following command: sudo journalctl -u lokid.service -af NOTE: If you\u2019re nervous about trusting the binaries or the download link, you should build it from source yourself. Instructions for that can be found in the README of https://github.com/loki-project/loki Excellent! You have now updated your Service Node.","title":"Step 2: Download the new Loki Binaries"},{"location":"ServiceNodes/launcherconfig/","text":"Launcher config files \u00b6 This guide shows the different config files and their associated sections, keys and values. First we check if there's a launcher.ini in the same directory as the loki-launcher script called (for non-global installations) Then we check for /etc/loki-launcher/launcher.ini (for global installations) Table of contents: \u00b6 launcher.ini [launcher] [blockchain] [network] [storage] launcher.ini \u00b6 [launcher] \u00b6 Key Default value Type Required? Auto-detectable? Description interactive false boolean no no special debug mode docker false boolean no no special docker mode [blockchain] \u00b6 Key Default value Type Sample Value Required? Auto-detectable? binary_path false file path src/loki/build/release/bin/lokid no no restart main boolean true no no network 127.0.0.1 string main, test, demo or staging no no rpc_ip 22023,38154,38157 ip yes no rpc_port user port 0 no no rpc_user pass string yes no rpc_pass 22024,38154,38158 string yes no zmq_port 22022,38153,38156 port 0 no no p2p_port ~/.loki[/testnet] port 0 no no data_dir string loki_data no no [network] \u00b6 Key Sample Value Type Required? Auto-detectable? enabled false boolean no no binary_path src/loki-network/lokinet file path yes no bootstrap_url http://206.81.100.174/n-st-1.signed url no no bootstrap_path ~/.lokinet/bootstrap.signed file path no yes rpc_ip 127.0.0.1 ip no no rpc_port 28082 port no no public_ip 206.81.100.174 ip no yes public_port 1090 port no no internal_port 1090 port no no dns_ip 127.0.0.1 ip no yes dns_port 53 port no yes ifname lokinet0 string up to 16 characters no yes ifaddr 10.0.0.1/8 network no yes netid service string up to 8 characters no yes nickname ldl string no no verbose true boolean no no auto_config_test_host www.google.com string no no auto_config_test_port 80 port no no testnet true boolean no yes data_dir /root/lokinet path no no netdb /usr/src/app path no no [storage] \u00b6 Key Sample value Type Required? Auto-detectable? enabled false boolean no no binary_path src/loki-storage-server/build/httpserver file path yes no port 8080 port no no log_level debug string no no identity_path ./identity.private file path no no output_log logs path no no db_location . file path no no","title":"Loki Documentation | Loki Service Node Launcher Config Files"},{"location":"ServiceNodes/launcherconfig/#launcher-config-files","text":"This guide shows the different config files and their associated sections, keys and values. First we check if there's a launcher.ini in the same directory as the loki-launcher script called (for non-global installations) Then we check for /etc/loki-launcher/launcher.ini (for global installations)","title":"Launcher config files"},{"location":"ServiceNodes/launcherconfig/#table-of-contents","text":"launcher.ini [launcher] [blockchain] [network] [storage]","title":"Table of contents:"},{"location":"ServiceNodes/launcherconfig/#launcherini","text":"","title":"launcher.ini"},{"location":"ServiceNodes/launcherconfig/#launcher","text":"Key Default value Type Required? Auto-detectable? Description interactive false boolean no no special debug mode docker false boolean no no special docker mode","title":"[launcher]"},{"location":"ServiceNodes/launcherconfig/#blockchain","text":"Key Default value Type Sample Value Required? Auto-detectable? binary_path false file path src/loki/build/release/bin/lokid no no restart main boolean true no no network 127.0.0.1 string main, test, demo or staging no no rpc_ip 22023,38154,38157 ip yes no rpc_port user port 0 no no rpc_user pass string yes no rpc_pass 22024,38154,38158 string yes no zmq_port 22022,38153,38156 port 0 no no p2p_port ~/.loki[/testnet] port 0 no no data_dir string loki_data no no","title":"[blockchain]"},{"location":"ServiceNodes/launcherconfig/#network","text":"Key Sample Value Type Required? Auto-detectable? enabled false boolean no no binary_path src/loki-network/lokinet file path yes no bootstrap_url http://206.81.100.174/n-st-1.signed url no no bootstrap_path ~/.lokinet/bootstrap.signed file path no yes rpc_ip 127.0.0.1 ip no no rpc_port 28082 port no no public_ip 206.81.100.174 ip no yes public_port 1090 port no no internal_port 1090 port no no dns_ip 127.0.0.1 ip no yes dns_port 53 port no yes ifname lokinet0 string up to 16 characters no yes ifaddr 10.0.0.1/8 network no yes netid service string up to 8 characters no yes nickname ldl string no no verbose true boolean no no auto_config_test_host www.google.com string no no auto_config_test_port 80 port no no testnet true boolean no yes data_dir /root/lokinet path no no netdb /usr/src/app path no no","title":"[network]"},{"location":"ServiceNodes/launcherconfig/#storage","text":"Key Sample value Type Required? Auto-detectable? enabled false boolean no no binary_path src/loki-storage-server/build/httpserver file path yes no port 8080 port no no log_level debug string no no identity_path ./identity.private file path no no output_log logs path no no db_location . file path no no","title":"[storage]"},{"location":"Wallets/Multisignature/","text":"Multisignature \u00b6 In cryptocurrencies, multisig feature allows you to sign a transaction with more than one private key. Funds protected with multisig can only be spent by signing with M-of-N keys. Use Case Scheme Example Shared Account (1-of-2) Both husband and wife individually have full access to their funds. Consensus Account (2-of-2) Both husband and wife must agree to spend their funds. Threshold account (2-of-3) An escrow service is involved as an independent 3rd party, to co-sign with either the seller, or with the buyer, if seller and buyer do not agree. Secure account (2-of-3) A single owner controls all 3 keys but secures them via a different means to diversify risks. Arbitrary threshold account (M-of-N) Some cryptocurrencies provide full flexibility on the number of signers. Loki Multisignature \u00b6 Loki doesn't directly implement multisignatures (at least not in a classical sense). Monero emulates the feature by secret splitting and Loki has brought this code from Moneros code base. Transactions are still signed with a single spend key. The spend key is a sum of all N private keys. The rationale for such design is to decouple multisig from ring signatures. Let's consider the 2-of-3 scheme. We have 3 participants. Each participant is granted exactly 2 private keys in a way that pairs do not repeat between participants. This way any 2 participants together have all 3 private keys required to create the private spend key. Multi-signing is a wallet-level feature. There is no way to learn from the blockchain which transactions were created using multiple signatures. It is also worth noting in Loki there is no multisig addresses as such. The Address structure does not care how the underlying private spend key got created. In Loki, multisignature is supported for M of N participants making any combination of signers possible. After multisig wallet setup every participant ends up knowing the public address and private view key. This is necessary for participants to recognize and decipher transactions they are supposed to co-sign. Guides \u00b6 Guide Description 2-of-2 Multisigniture Wallet Setup Setup Guide for a 2 of 2 Multsig Wallet. 2-of-3 Multisigniture Wallet Setup Setup Guide for a 2 of 3 Multsig Wallet. M-of-N Multisig Setup Guide Setup Guide for a M of N Multisig Wallet.","title":"Multsignature"},{"location":"Wallets/Multisignature/#multisignature","text":"In cryptocurrencies, multisig feature allows you to sign a transaction with more than one private key. Funds protected with multisig can only be spent by signing with M-of-N keys. Use Case Scheme Example Shared Account (1-of-2) Both husband and wife individually have full access to their funds. Consensus Account (2-of-2) Both husband and wife must agree to spend their funds. Threshold account (2-of-3) An escrow service is involved as an independent 3rd party, to co-sign with either the seller, or with the buyer, if seller and buyer do not agree. Secure account (2-of-3) A single owner controls all 3 keys but secures them via a different means to diversify risks. Arbitrary threshold account (M-of-N) Some cryptocurrencies provide full flexibility on the number of signers.","title":"Multisignature"},{"location":"Wallets/Multisignature/#loki-multisignature","text":"Loki doesn't directly implement multisignatures (at least not in a classical sense). Monero emulates the feature by secret splitting and Loki has brought this code from Moneros code base. Transactions are still signed with a single spend key. The spend key is a sum of all N private keys. The rationale for such design is to decouple multisig from ring signatures. Let's consider the 2-of-3 scheme. We have 3 participants. Each participant is granted exactly 2 private keys in a way that pairs do not repeat between participants. This way any 2 participants together have all 3 private keys required to create the private spend key. Multi-signing is a wallet-level feature. There is no way to learn from the blockchain which transactions were created using multiple signatures. It is also worth noting in Loki there is no multisig addresses as such. The Address structure does not care how the underlying private spend key got created. In Loki, multisignature is supported for M of N participants making any combination of signers possible. After multisig wallet setup every participant ends up knowing the public address and private view key. This is necessary for participants to recognize and decipher transactions they are supposed to co-sign.","title":"Loki Multisignature"},{"location":"Wallets/Multisignature/#guides","text":"Guide Description 2-of-2 Multisigniture Wallet Setup Setup Guide for a 2 of 2 Multsig Wallet. 2-of-3 Multisigniture Wallet Setup Setup Guide for a 2 of 3 Multsig Wallet. M-of-N Multisig Setup Guide Setup Guide for a M of N Multisig Wallet.","title":"Guides"},{"location":"Wallets/WalletsOverview/","text":"Loki Wallets \u00b6 The Loki wallets are a gateway into private decentralised transactions and communications. They allow you to hold private keys, secure or mine Loki, and trade peer-to-peer. Loki wallets store a collection of public and private keys which can be used to receive, view, or spend Loki. The wallet uses the private keys through a daemon which synchronises with the Loki Network to scan for incoming transactions and to send outgoing transactions. Graphical User Interface Wallet (GUI) \u00b6 The Gui Wallet is the easiest wallets to use. It has a graphical user friendly interface which is perfect for beginners. The Loki Electron wallet: Download here . GUI Guides \u00b6 Guide Description GUI Setup How to set up the GUI wallet for the first time. GUI Staking How to stake to a Service Node from your GUI Wallet. Command Line Interface Wallet (CLI) \u00b6 The Cli Wallet is for more advanced users and offers the most tools when interacting with the Loki Blockchain. Download Loki CLI Wallet Github Link CLI Guides \u00b6 Guide Description Restore CLI Wallet from Keys How to restore your wallet with spend and view keys. Restore CLI Wallet from Seed How to restore your wallet with a seed phrase (25 word mnemonic seed). CLI Commands Details on different commands within the loki-wallet-cli . 2 of 2 - Multisignature Setup Multisig feature allows you to sign a transaction with more than one private key. Funds protected with multisig can only be spent by signing with 2-of-2 keys. 2 of 3 - Multisignature Setup Multisig feature allows you to sign a transaction with more than one private key. Funds protected with multisig can only be spent by signing with 2-of-3 keys. M of N - Multisignature Setup Multisig feature allows you to sign a transaction with more than one private key. Funds protected with multisig can only be spent by signing with M-of-N keys. CLI Setup - Mac How to setup the loki-wallet-cli for the first time on Mac OS.","title":"Overview"},{"location":"Wallets/WalletsOverview/#loki-wallets","text":"The Loki wallets are a gateway into private decentralised transactions and communications. They allow you to hold private keys, secure or mine Loki, and trade peer-to-peer. Loki wallets store a collection of public and private keys which can be used to receive, view, or spend Loki. The wallet uses the private keys through a daemon which synchronises with the Loki Network to scan for incoming transactions and to send outgoing transactions.","title":"Loki Wallets"},{"location":"Wallets/WalletsOverview/#graphical-user-interface-wallet-gui","text":"The Gui Wallet is the easiest wallets to use. It has a graphical user friendly interface which is perfect for beginners. The Loki Electron wallet: Download here .","title":"Graphical User Interface Wallet (GUI)"},{"location":"Wallets/WalletsOverview/#gui-guides","text":"Guide Description GUI Setup How to set up the GUI wallet for the first time. GUI Staking How to stake to a Service Node from your GUI Wallet.","title":"GUI Guides"},{"location":"Wallets/WalletsOverview/#command-line-interface-wallet-cli","text":"The Cli Wallet is for more advanced users and offers the most tools when interacting with the Loki Blockchain. Download Loki CLI Wallet Github Link","title":"Command Line Interface Wallet (CLI)"},{"location":"Wallets/WalletsOverview/#cli-guides","text":"Guide Description Restore CLI Wallet from Keys How to restore your wallet with spend and view keys. Restore CLI Wallet from Seed How to restore your wallet with a seed phrase (25 word mnemonic seed). CLI Commands Details on different commands within the loki-wallet-cli . 2 of 2 - Multisignature Setup Multisig feature allows you to sign a transaction with more than one private key. Funds protected with multisig can only be spent by signing with 2-of-2 keys. 2 of 3 - Multisignature Setup Multisig feature allows you to sign a transaction with more than one private key. Funds protected with multisig can only be spent by signing with 2-of-3 keys. M of N - Multisignature Setup Multisig feature allows you to sign a transaction with more than one private key. Funds protected with multisig can only be spent by signing with M-of-N keys. CLI Setup - Mac How to setup the loki-wallet-cli for the first time on Mac OS.","title":"CLI Guides"},{"location":"Wallets/WhatWalletToUse/","text":"Which wallet should I use? \u00b6 Loki wallets are a gateway into private decentralised transactions and communications. They allow you to hold private keys and secure, mine, stake or trade Loki. Each wallet is designed for specific groups of users, depending on their goal and level of expertise. The different wallets currently available are: Graphical user interface wallet (GUI) Command-line interface wallet (CLI) Mobile wallet Web wallet Use cases \u00b6 Before deciding which wallet you want to use, you must first know what you want the wallet for. Receiving and sending Loki \u00b6 All Loki wallets can receive and send Loki; however, some are much easier to use than others for this specific purpose. The easiest wallets to use for sending and receiving Loki are: Graphical user interface wallet (GUI) Mobile wallet The GUI wallet can be downloaded here , while the mobile wallet can be downloaded from the Google Play Store. Hosting a Service Node as an operator \u00b6 If your goal is to host and operate a Loki Service Node, there is only one wallet that offers the ability to register a Service Node: the command-line interface wallet (CLI) which can be downloaded here . To better understand how to prepare, register and maintain a Service Node, check out this guide here . Staking to a Service Node as a contributor \u00b6 Do you have at least 25% of the staking requirement for a Loki Service Node, and want to contribute to a Service Node pool? If so, you will want to either use the: Graphical user interface wallet (GUI), or the Command-line interface wallet (CLI) If you rarely use the terminal or command line, it is recommended that you perform your stake through the GUI wallet which can be downloaded here . Alternatively, if you would like to perform the stake on the CLI wallet, you can download it here .","title":"Which wallet should I use?"},{"location":"Wallets/WhatWalletToUse/#which-wallet-should-i-use","text":"Loki wallets are a gateway into private decentralised transactions and communications. They allow you to hold private keys and secure, mine, stake or trade Loki. Each wallet is designed for specific groups of users, depending on their goal and level of expertise. The different wallets currently available are: Graphical user interface wallet (GUI) Command-line interface wallet (CLI) Mobile wallet Web wallet","title":"Which wallet should I use?"},{"location":"Wallets/WhatWalletToUse/#use-cases","text":"Before deciding which wallet you want to use, you must first know what you want the wallet for.","title":"Use cases"},{"location":"Wallets/WhatWalletToUse/#receiving-and-sending-loki","text":"All Loki wallets can receive and send Loki; however, some are much easier to use than others for this specific purpose. The easiest wallets to use for sending and receiving Loki are: Graphical user interface wallet (GUI) Mobile wallet The GUI wallet can be downloaded here , while the mobile wallet can be downloaded from the Google Play Store.","title":"Receiving and sending Loki"},{"location":"Wallets/WhatWalletToUse/#hosting-a-service-node-as-an-operator","text":"If your goal is to host and operate a Loki Service Node, there is only one wallet that offers the ability to register a Service Node: the command-line interface wallet (CLI) which can be downloaded here . To better understand how to prepare, register and maintain a Service Node, check out this guide here .","title":"Hosting a Service Node as an operator"},{"location":"Wallets/WhatWalletToUse/#staking-to-a-service-node-as-a-contributor","text":"Do you have at least 25% of the staking requirement for a Loki Service Node, and want to contribute to a Service Node pool? If so, you will want to either use the: Graphical user interface wallet (GUI), or the Command-line interface wallet (CLI) If you rarely use the terminal or command line, it is recommended that you perform your stake through the GUI wallet which can be downloaded here . Alternatively, if you would like to perform the stake on the CLI wallet, you can download it here .","title":"Staking to a Service Node as a contributor"},{"location":"Wallets/Addresses/IntegratedAddress/","text":"Integrated Address \u00b6 Integrated addresses are ideal for accepting Loki in an automated fashion - like in online stores and exchanges. Loki integrated address embeds a payment ID. This allows you to learn for what you are being paid. Please note these are Loki technical payment IDs and must not be confused with business identifiers like order number or invoice number. The transaction to integrated address will not reveal the payment ID publicly. Payment ID in a transaction will be encrypted with a shared secret (one-time random key known only to sender and recipient). Only the recipient will be able to match the transaction against payment ID. Loki integrated address obsoletes the former practice of using full 32-bytes payment ID in a transaction extra field (where it was not encrypted). Data structure ( src ): Index Size in bytes Description 0 1 identifies the network and address type; 115 - main chain; 157 - test chain; 25 - stage chain 1 32 public spend key 33 32 public view key 65 8 compact payment ID - 8 bytes randomly generated by the recipient; note that it does not need encryption in the address itself but it is hidden in a transaction paying to integrated address to prevent linking payment with the address by external observers 73 4 checksum ( Keccak-f[1600] hash of the previous 73 bytes, trimmed to first 4 bytes) It totals to 77 bytes. The bytes are then encoded ( src ) in Loki specific Base58 format, resulting in a 106 chars long string. Example integrated address: LLhSDqBZdjLQWajr4pBcFkdjL8oGY7MDvfJkKfrQVaokfDMxU6bDVb6h8tsD1jpKpSXbbB1p8RxPbA7fmjvLGjicKLBdQvDMbHA7TWVCUQ Integrated addresses vs subaddresses \u00b6 Both types allow you to learn for what you are being paid. Individuals should prefer subaddresses to receive payments. This is to improve privacy in certain scenarios. See article on subaddresses for details. Businesses accepting payments in an automated way should prefer integrated addresses . The rationale is as follows: Scenario where subaddresses improve privacy is not applicable to businesses b/c businesses have the same identity over time. Consequently, subaddresses provide no benefits over integrated addresses. No private key is necessary to generate integrated address. This provides a strong security advantage because services that generate integrated addresses need no access to wallet. In contrast, to generate a subaddress, one needs a private view key. No shared counter is necessary to generate integrated address. This allows individual services to independently generate integrated addresses w/o synchronizing on a common sequence. In contrast, subaddresses are generated sequentially, and so the sequence (the counter or index) is a coupling point between the wallet and all services that need to generate the address. Back to integrated addresses, note that embedded payment IDs are 64-bit. This means the space is large enough that one can simply generate them randomly and reliably assume uniqueness. In very specific scenarios, preparation effort to monitor a very huge number of subaddresses, could became an issue. See this reddit thread for details. Caveats \u00b6 There are some caveats: Single transaction cannot pay to multiple integrated addresses. As individual running a wallet you should generally prefer subaddresses. However, if you happen to use integrated addresses, you should allow Loki software to generate integrated addresses for you (instead of forcing your own payment IDs). Reference \u00b6 question on StackExchange","title":"Integrated Address"},{"location":"Wallets/Addresses/IntegratedAddress/#integrated-address","text":"Integrated addresses are ideal for accepting Loki in an automated fashion - like in online stores and exchanges. Loki integrated address embeds a payment ID. This allows you to learn for what you are being paid. Please note these are Loki technical payment IDs and must not be confused with business identifiers like order number or invoice number. The transaction to integrated address will not reveal the payment ID publicly. Payment ID in a transaction will be encrypted with a shared secret (one-time random key known only to sender and recipient). Only the recipient will be able to match the transaction against payment ID. Loki integrated address obsoletes the former practice of using full 32-bytes payment ID in a transaction extra field (where it was not encrypted). Data structure ( src ): Index Size in bytes Description 0 1 identifies the network and address type; 115 - main chain; 157 - test chain; 25 - stage chain 1 32 public spend key 33 32 public view key 65 8 compact payment ID - 8 bytes randomly generated by the recipient; note that it does not need encryption in the address itself but it is hidden in a transaction paying to integrated address to prevent linking payment with the address by external observers 73 4 checksum ( Keccak-f[1600] hash of the previous 73 bytes, trimmed to first 4 bytes) It totals to 77 bytes. The bytes are then encoded ( src ) in Loki specific Base58 format, resulting in a 106 chars long string. Example integrated address: LLhSDqBZdjLQWajr4pBcFkdjL8oGY7MDvfJkKfrQVaokfDMxU6bDVb6h8tsD1jpKpSXbbB1p8RxPbA7fmjvLGjicKLBdQvDMbHA7TWVCUQ","title":"Integrated Address"},{"location":"Wallets/Addresses/IntegratedAddress/#integrated-addresses-vs-subaddresses","text":"Both types allow you to learn for what you are being paid. Individuals should prefer subaddresses to receive payments. This is to improve privacy in certain scenarios. See article on subaddresses for details. Businesses accepting payments in an automated way should prefer integrated addresses . The rationale is as follows: Scenario where subaddresses improve privacy is not applicable to businesses b/c businesses have the same identity over time. Consequently, subaddresses provide no benefits over integrated addresses. No private key is necessary to generate integrated address. This provides a strong security advantage because services that generate integrated addresses need no access to wallet. In contrast, to generate a subaddress, one needs a private view key. No shared counter is necessary to generate integrated address. This allows individual services to independently generate integrated addresses w/o synchronizing on a common sequence. In contrast, subaddresses are generated sequentially, and so the sequence (the counter or index) is a coupling point between the wallet and all services that need to generate the address. Back to integrated addresses, note that embedded payment IDs are 64-bit. This means the space is large enough that one can simply generate them randomly and reliably assume uniqueness. In very specific scenarios, preparation effort to monitor a very huge number of subaddresses, could became an issue. See this reddit thread for details.","title":"Integrated addresses vs subaddresses"},{"location":"Wallets/Addresses/IntegratedAddress/#caveats","text":"There are some caveats: Single transaction cannot pay to multiple integrated addresses. As individual running a wallet you should generally prefer subaddresses. However, if you happen to use integrated addresses, you should allow Loki software to generate integrated addresses for you (instead of forcing your own payment IDs).","title":"Caveats"},{"location":"Wallets/Addresses/IntegratedAddress/#reference","text":"question on StackExchange","title":"Reference"},{"location":"Wallets/Addresses/MainAddress/","text":"Address \u00b6 A Loki public address is what you publish to get paid. An address can be generated offline and for free. It boils down to generating a large random number representing your private spending key. Publishing your Loki address does not endanger your privacy. That's because in Loki transactions go to stealth addresses which are decoupled from your public address. There are a few types of public addresses in Loki: Main address - basic type of an address, also refered to as raw address Subaddress - what you should be using by default Integrated address - relevant for exchanges, merchants, and other businesses accepting Loki in a fully automated way Main address \u00b6 Historicaly, raw address was the only available option. For that reason it is the most widely adopted and supported address type. Its strength is simplicity. However, these days users should prefer receiving to subaddresses instead. Technically, raw address is also a basis for creating subaddresses and integrated addresses. Raw address is still useful for : accepting block reward in a solo-mining scenario as other addresses are not supported accepting from senders who batch payouts (like mining pools); in this scenario the sender is paying multiple parties using a single transaction; such transaction has multiple outputs; subaddresses do not work in this scenario accepting from senders who use legacy wallets (can't send to subaddress) Loki raw address is composed of two public keys: public spend key public view key It also contains a checksum and a \"network byte\" which actually identifies both the network and the address type. Data structure \u00b6 Index Size in bytes Description 0 1 identifies the network and address type; 114 - main chain; 156 - test chain; 24 - stagenet chain 1 32 public spend key 33 32 public view key 65 4 checksum ( Keccak-f[1600] hash of the previous 65 bytes, trimmed to first 4 bytes) It totals to 69 bytes. The bytes are then encoded ( src ) in Loki specific Base58 format, resulting in a 95 chars long string. Example main address: LAXk6eS3Ng98QxDTdC47eNdfCXttJycKraXxfsw9cMVngGUqP3kiSE6cwXoApU6gjzSXVX1ASAPAi1MSXA935XUs1MWEcv9 See the source code . Generating \u00b6 Main address is derived from the root private key. Reference \u00b6 StackExchenge answer https://xmr.llcoins.net/addresstests.html","title":"Main Address"},{"location":"Wallets/Addresses/MainAddress/#address","text":"A Loki public address is what you publish to get paid. An address can be generated offline and for free. It boils down to generating a large random number representing your private spending key. Publishing your Loki address does not endanger your privacy. That's because in Loki transactions go to stealth addresses which are decoupled from your public address. There are a few types of public addresses in Loki: Main address - basic type of an address, also refered to as raw address Subaddress - what you should be using by default Integrated address - relevant for exchanges, merchants, and other businesses accepting Loki in a fully automated way","title":"Address"},{"location":"Wallets/Addresses/MainAddress/#main-address","text":"Historicaly, raw address was the only available option. For that reason it is the most widely adopted and supported address type. Its strength is simplicity. However, these days users should prefer receiving to subaddresses instead. Technically, raw address is also a basis for creating subaddresses and integrated addresses. Raw address is still useful for : accepting block reward in a solo-mining scenario as other addresses are not supported accepting from senders who batch payouts (like mining pools); in this scenario the sender is paying multiple parties using a single transaction; such transaction has multiple outputs; subaddresses do not work in this scenario accepting from senders who use legacy wallets (can't send to subaddress) Loki raw address is composed of two public keys: public spend key public view key It also contains a checksum and a \"network byte\" which actually identifies both the network and the address type.","title":"Main address"},{"location":"Wallets/Addresses/MainAddress/#data-structure","text":"Index Size in bytes Description 0 1 identifies the network and address type; 114 - main chain; 156 - test chain; 24 - stagenet chain 1 32 public spend key 33 32 public view key 65 4 checksum ( Keccak-f[1600] hash of the previous 65 bytes, trimmed to first 4 bytes) It totals to 69 bytes. The bytes are then encoded ( src ) in Loki specific Base58 format, resulting in a 95 chars long string. Example main address: LAXk6eS3Ng98QxDTdC47eNdfCXttJycKraXxfsw9cMVngGUqP3kiSE6cwXoApU6gjzSXVX1ASAPAi1MSXA935XUs1MWEcv9 See the source code .","title":"Data structure"},{"location":"Wallets/Addresses/MainAddress/#generating","text":"Main address is derived from the root private key.","title":"Generating"},{"location":"Wallets/Addresses/MainAddress/#reference","text":"StackExchenge answer https://xmr.llcoins.net/addresstests.html","title":"Reference"},{"location":"Wallets/Addresses/SubAddress/","text":"Subaddress \u00b6 Subaddress is what you should be using by default to receive Loki. Learn for what you are being paid \u00b6 By providing a unique subaddress for each anticipated payment you will know for what you are being paid. This use case overlaps with integrated addresses. Subaddresses are generally prefered for reasons outlined below. Prevent payer from linking your payouts together \u00b6 To prevent the payer from linking your payouts together simply generate a new subaddress for each payout. This way services like Shapeshift wouldn't know it is you again receving Loki. Note it won't help if you have an account with the service. Then your payouts are already linked in the service database, regardless of Loki. Group funds into accounts \u00b6 Note Feel free to skip this if your are new to Loki. Accounts are not essential and currently not supported by the GUI. Accounts are a convenience wallet-level feature to group subaddresses under one label and balance. You may want to organize your funds into accounts like \"cash\", \"work\", \"trading\", \"mining\", \"donations\", etc. As accounts are only groupings of subaddresses, they themselves do not have an address. Accounts are deterministically derived from the root private key along with subaddresses. As of September 2018 accounts are only supported by the CLI wallet and missing from GUI wallet. Accounts are similar to subaccounts in your classic bank account. There is a very important difference though. In Loki funds don't really sit on accounts or public addresses. Public addresses are conceptually a gateway or a routing mechanism. Funds sit on transactions' unspent outputs. Thus, a single transaction can - in principle - aggregate and spend outputs from multiple addresses (and by extension from multiple accounts). The CLI or GUI wallet may not directly support creating such transactions for simplicity. In short, think of accounts as a soft grouping of your funds. Why not multiple wallets? \u00b6 The advantage over creating multiple wallets is that you only have a single seed to manage. All subaddresses can be derived from the wallet seed. Additionally, you conveniently manage your subaddresses within a single user interface. Wallet level feature \u00b6 Subaddresses and accounts are a wallet-level feature to construct and interpret transactions. They do not affect the consensus. Data structure \u00b6 Subaddress has a dedicated \"network byte\": Index Size in bytes Description 0 1 identifies the network and address type; 116 - mainnet; 36 - stagenet; 158 - testnet Otherwise the data structure is the same as for the main address . Generating \u00b6 Each subaddress conceptually has: account index (also known as \"major\" index) subaddress index within the account (also known as \"minor\" index) The indexes are 0-based. By default wallets use account index 0. The indexes are not directly included in the subaddress data structure. Instead, they are used as input to generating subaddress keys. Private view key \u00b6 The subaddress private view key m is derived as follows: m = Hs(\"SubAddr\" || a || account_index || subaddress_index_within_account) Where: Hs is a Keccak-256 hash function interpreted as integer and modulo l (maximum edwards25519 scalar) || is a byte array concatenation operator SubAddr is a 0-terminated fixed string (8 bytes total) a is a private view key of the main address (a 32 byte little endian unsigned integer) account_index is index of an account (a 32 bit little endian unsigned integer) subaddress_index_within_account is index of the subaddress within the account (a 32 bit little endian unsigned integer) Deriving \"sub view keys\" from the main view key allows for creating a view only wallet that monitors the entire wallet including subaddresses. Public spend key \u00b6 The subaddress public spend key D is derived as follows: D = B + m*G Where: B is main address public spend key m is subaddress private view key G is the \"base point\"; this is simply a constant specific to edwards25519 Public view key \u00b6 The subaddress public view key C is derived as follows: C = a*D Where: a is a private view key of the main address D is a public spend key of the subaddress Special case for (0, 0) \u00b6 The subaddress #0 on the account #0 is the main address . As main address has different generation rules, this is simply implemented via an if statement. Building the address string \u00b6 The procedure is the same as for the main address . Caveats \u00b6 It is not recommended to sweep all the balances of subaddress to main address in a single transaction. That links the subaddresses together on the blockchain. However, this only concerns privacy against specific sender and the situation will never get worse than not using subaddresses in the first place. If you need to join funds while preserving maximum privacy do it with individual transactions (one per subaddress). Convenience labels are not preserved when recreating from seed. Reference \u00b6 monero-python - the easiest to follow implementation by Micha\u0142 Sa\u0142aban get_subaddress_spend_public_key() - Monero reference implementation historical discussion on Github - gives context but is not up to date with all details StackExchange answer - excellent summary by knaccc","title":"Sub Address"},{"location":"Wallets/Addresses/SubAddress/#subaddress","text":"Subaddress is what you should be using by default to receive Loki.","title":"Subaddress"},{"location":"Wallets/Addresses/SubAddress/#learn-for-what-you-are-being-paid","text":"By providing a unique subaddress for each anticipated payment you will know for what you are being paid. This use case overlaps with integrated addresses. Subaddresses are generally prefered for reasons outlined below.","title":"Learn for what you are being paid"},{"location":"Wallets/Addresses/SubAddress/#prevent-payer-from-linking-your-payouts-together","text":"To prevent the payer from linking your payouts together simply generate a new subaddress for each payout. This way services like Shapeshift wouldn't know it is you again receving Loki. Note it won't help if you have an account with the service. Then your payouts are already linked in the service database, regardless of Loki.","title":"Prevent payer from linking your payouts together"},{"location":"Wallets/Addresses/SubAddress/#group-funds-into-accounts","text":"Note Feel free to skip this if your are new to Loki. Accounts are not essential and currently not supported by the GUI. Accounts are a convenience wallet-level feature to group subaddresses under one label and balance. You may want to organize your funds into accounts like \"cash\", \"work\", \"trading\", \"mining\", \"donations\", etc. As accounts are only groupings of subaddresses, they themselves do not have an address. Accounts are deterministically derived from the root private key along with subaddresses. As of September 2018 accounts are only supported by the CLI wallet and missing from GUI wallet. Accounts are similar to subaccounts in your classic bank account. There is a very important difference though. In Loki funds don't really sit on accounts or public addresses. Public addresses are conceptually a gateway or a routing mechanism. Funds sit on transactions' unspent outputs. Thus, a single transaction can - in principle - aggregate and spend outputs from multiple addresses (and by extension from multiple accounts). The CLI or GUI wallet may not directly support creating such transactions for simplicity. In short, think of accounts as a soft grouping of your funds.","title":"Group funds into accounts"},{"location":"Wallets/Addresses/SubAddress/#why-not-multiple-wallets","text":"The advantage over creating multiple wallets is that you only have a single seed to manage. All subaddresses can be derived from the wallet seed. Additionally, you conveniently manage your subaddresses within a single user interface.","title":"Why not multiple wallets?"},{"location":"Wallets/Addresses/SubAddress/#wallet-level-feature","text":"Subaddresses and accounts are a wallet-level feature to construct and interpret transactions. They do not affect the consensus.","title":"Wallet level feature"},{"location":"Wallets/Addresses/SubAddress/#data-structure","text":"Subaddress has a dedicated \"network byte\": Index Size in bytes Description 0 1 identifies the network and address type; 116 - mainnet; 36 - stagenet; 158 - testnet Otherwise the data structure is the same as for the main address .","title":"Data structure"},{"location":"Wallets/Addresses/SubAddress/#generating","text":"Each subaddress conceptually has: account index (also known as \"major\" index) subaddress index within the account (also known as \"minor\" index) The indexes are 0-based. By default wallets use account index 0. The indexes are not directly included in the subaddress data structure. Instead, they are used as input to generating subaddress keys.","title":"Generating"},{"location":"Wallets/Addresses/SubAddress/#private-view-key","text":"The subaddress private view key m is derived as follows: m = Hs(\"SubAddr\" || a || account_index || subaddress_index_within_account) Where: Hs is a Keccak-256 hash function interpreted as integer and modulo l (maximum edwards25519 scalar) || is a byte array concatenation operator SubAddr is a 0-terminated fixed string (8 bytes total) a is a private view key of the main address (a 32 byte little endian unsigned integer) account_index is index of an account (a 32 bit little endian unsigned integer) subaddress_index_within_account is index of the subaddress within the account (a 32 bit little endian unsigned integer) Deriving \"sub view keys\" from the main view key allows for creating a view only wallet that monitors the entire wallet including subaddresses.","title":"Private view key"},{"location":"Wallets/Addresses/SubAddress/#public-spend-key","text":"The subaddress public spend key D is derived as follows: D = B + m*G Where: B is main address public spend key m is subaddress private view key G is the \"base point\"; this is simply a constant specific to edwards25519","title":"Public spend key"},{"location":"Wallets/Addresses/SubAddress/#public-view-key","text":"The subaddress public view key C is derived as follows: C = a*D Where: a is a private view key of the main address D is a public spend key of the subaddress","title":"Public view key"},{"location":"Wallets/Addresses/SubAddress/#special-case-for-0-0","text":"The subaddress #0 on the account #0 is the main address . As main address has different generation rules, this is simply implemented via an if statement.","title":"Special case for (0, 0)"},{"location":"Wallets/Addresses/SubAddress/#building-the-address-string","text":"The procedure is the same as for the main address .","title":"Building the address string"},{"location":"Wallets/Addresses/SubAddress/#caveats","text":"It is not recommended to sweep all the balances of subaddress to main address in a single transaction. That links the subaddresses together on the blockchain. However, this only concerns privacy against specific sender and the situation will never get worse than not using subaddresses in the first place. If you need to join funds while preserving maximum privacy do it with individual transactions (one per subaddress). Convenience labels are not preserved when recreating from seed.","title":"Caveats"},{"location":"Wallets/Addresses/SubAddress/#reference","text":"monero-python - the easiest to follow implementation by Micha\u0142 Sa\u0142aban get_subaddress_spend_public_key() - Monero reference implementation historical discussion on Github - gives context but is not up to date with all details StackExchange answer - excellent summary by knaccc","title":"Reference"},{"location":"Wallets/CliWallet/2of2Multisig/","text":"Loki 2/2 Multisig \u00b6 First, the wallet to be converted to multisig must be empty. It is best to use a brand-new wallet for the purpose, although not required. It is strongly advised to make a copy of the wallet files first, just in case something goes wrong. Overview \u00b6 In short, the process is: Set-up Both parties prepare loki-wallet-cli files Both parties command prepare_multisig and send data to each other Both parties command make_multisig Receiving All parties can type address to see the created multisig wallet address. The address will, of course, be the same for all parties since they're all watching the same wallet. Preparation for Sending To prepare for sending both parties command export_multisig_info <filename> and send the file to the other party To complete preparation, all parties command import_multisig_info <filename1> <filename2> and import files from other parties Sending To send, any party can use the usual transfer command, but the result will be a file named multisig_loki_tx which must be sent to any 1 other signer The other party commands sign_multisig multisig_loki_tx and the file is updated with the signature. The completely signed file is pushed to the network with use of submit_multisig multisig_loki_tx Below is a step-by-step walkthrough. Set-up \u00b6 Step 1 Initiate Creation of Multisig Wallet and Exchange Data \u00b6 Requirements: 2 empty loki-wallet-cli wallets Both wallets connected to lokid Private communication channel Person A must run the command in their loki-wallet-cli : prepare_multisig Person A will receive the output: MultisigV1cYuTGuf8FSiCYnMtLU4sZzeKZgeMy51qf4CcG2EQ2BPqKTii6YanpNLJDTM9rVRNfBPNFnJHoCWwGT9d8kB2UEDNHDxjgaAZX6DAWtj9VBFq9Q5qHjduozaYzgYpbVfHKHUQR2UrJjyX7tCSyd8gFEHUSocDRejRZBrFrKNifri5ozpN Send this multisig info to all other participants, then use make_multisig <threshold> <info1> [<info2>...] with others' multisig info This includes the PRIVATE view key, so needs to be disclosed only to that multisig wallet's participants Copy the entire line Multisig...5ozpN and be sure to capture the whole thing when copying. Send this line to person B through a private communication channel. Person B does the same and sends his output to person A. Person B must run the command in their loki-wallet-cli : prepare_multisig Person B will receive the output: MultisigV1BU9w9mysQMhNTYcNFQgD82VQiKFGpkwy8Jmu13iWWBmoeRbqyuYmEh22bJRk945ntuDeazTsYwUCYZcCL1cxuf4xDzwUJCLkiYhPCvF7gv3xrCGkAiozirNUG6CxRa53mHqp4Cvdj3yxcQcYbXNYC1ecybbQMW1gs5BBQiruVGeJi4FS Send this multisig info to all other participants, then use make_multisig <threshold> <info1> [<info2>...] with others' multisig info This includes the PRIVATE view key, so needs to be disclosed only to that multisig wallet's participants Person B will copy the Multisig\u2026...eJi4FS and send it to person A through a private communication channel. Step 2 Create Multisig Wallets \u00b6 Both person A and person B now have the Multisig...arg text from the other one. With that, each of them can create their part of the multisig wallet. Before you proceed, note that the wallet will lose access to the underlying account when converted to multisig. This is not really a problem, since we started with an empty one, and if all goes ok with this step, you won't ever need it unless you want to go through the process again for whatever reason (like HDD died, but you have the seed mnemonic of the underlying account and want to reconstruct the multisig wallet). Person A will use the output Person B sent and will run the command: make_multisig 2 MultisigV1BU9w9mysQMhNTYcNFQgD82VQiKFGpkwy8Jmu13iWWBmoeRbqyuYmEh22bJRk945ntuDeazTsYwUCYZcCL1cxuf4xDzwUJCLkiYhPCvF7gv3xrCGkAiozirNUG6CxRa53mHqp4Cvdj3yxcQcYbXNYC1ecybbQMW1gs5BBQiruVGeJi4FS The wallet will output something similar to: 2/2 multisig address: T6ScXhWpAG2aUHmFemwvn4HddHA5GQ4u6MvYsW2hVteJSwLJXCEhk2aVp4XzyqGmvyUqc3w8fwWwg6szGEytUSx51C6WQ3er8 Person B will use the output Person A sent and run the command: make_multisig 2 MultisigV1cYuTGuf8FSiCYnMtLU4sZzeKZgeMy51qf4CcG2EQ2BPqKTii6YanpNLJDTM9rVRNfBPNFnJHoCWwGT9d8kB2UEDNHDxjgaAZX6DAWtj9VBFq9Q5qHjduozaYzgYpbVfHKHUQR2UrJjyX7tCSyd8gFEHUSocDRejRZBrFrKNifri5ozpN The wallet will output something similar to: 2/2 multisig address: T6ScXhWpAG2aUHmFemwvn4HddHA5GQ4u6MvYsW2hVteJSwLJXCEhk2aVp4XzyqGmvyUqc3w8fwWwg6szGEytUSx51C6WQ3er8 Now each person involved should exchange addresses and compare, they must be the same. Receiving \u00b6 Step 1 Fund The Multisig Account \u00b6 This is simple. Just send to the shared address. You can send multiple times, this is the same as a normal wallet. You can use payment ID\u2019s as well, or generate an integrated address to receive funds. Best part, whomever is sending the funds won't be able to tell that the address belongs to a multisig wallet since it looks like any other. Step 2 Check Multisig Account Balance \u00b6 Just open the wallet and command refresh. Once completed, both persons can verify that the funds arrived. Person A commands: show_transfers Person A outputs: 1357156 in 07:50:35 PM 0.100000000000 88ba687dc79a0b39e6de6d0763eda8363d33d9f58ec9a096171bd9a7f1dae873 0000000000000000 - 1357161 in 08:00:18 PM 0.100000000000 d6ac845b9400759525519cdc5d514eb8f5b1d265b24d1c016e75b20ed3b4b7da 0000000000000000 - Person B can do the same: show_tranfers Person B has the same outputs: 1357156 in 07:50:35 PM 0.100000000000 88ba687dc79a0b39e6de6d0763eda8363d33d9f58ec9a096171bd9a7f1dae873 0000000000000000 - 1357161 in 08:00:18 PM 0.100000000000 d6ac845b9400759525519cdc5d514eb8f5b1d265b24d1c016e75b20ed3b4b7da 0000000000000000 - Spending \u00b6 Step 1 Synchronizing Key Images \u00b6 1.1 Exporting Multisig Info \u00b6 Without this step, it will not be possible to create a spending transaction. Both persons need to run the following command to sync their key images: export_multisig_info <filename> Where <filename> can be any filename. Person A will run the command: export_multisig_info mi1 Person A will receive the output: Multisig info exported to mi1 The file mi1 will be located in the shell working folder* Person A sends that file to Person B. They can send the file in many ways, preferably through by handing a usb drive with the file on it, however If you would like to send the file through terminal use https://transfer.sh/ , an optional step has been added if you choose to use this method. Person B does the same, but changing the filename and runs the command: export_multisig_info mi2 Person B will receive the output: Multisig info exported to mi2 The file mi2 will be located in the shell working folder* Person B sends that file to person A. Now, they must both import each other's file. Optional: Step 1.2 Sending Multisig Info File with terminal - transfer.sh \u00b6 It is optional to use the terminal to send each person the multisig info files. Uploading Multisig Info file \u00b6 Person A will open up a new terminal and change to the directory \u201cmi1\u201d has been saved.* Person A will run the following command: curl --upload-file ./mi1 https://transfer.sh/mi1 Person A will receive the link to the file as an output, looking similar to: https://transfer.sh/Ehl5q/mi1 Person A will need to send this link to Person B. Person B will run a similar command: curl --upload-file ./mi1 https://transfer.sh/mi2 Person B will receive the link to the file as an output, looking similar to: https://transfer.sh/Iedv9/mi2 Person B will need to send this link to Person A. Downloading Multisig Info file \u00b6 Person A should change to the directory of their loki-wallet-cli and use Person B\u2019s download link to run the command: curl <Person B link> -o <filename> Replacing <Person B link> with the link Person B shared with Person A and <filename> with the filename of the Multisig info file that Person A generated, for example Person A will run the command: curl https://transfer.sh/Iedv9/mi2 -o mi2 Likewise, Person B should do the same, changing directories to their loki-wallet-cli and downloading with Person A\u2019s download link, and filename. curl https://transfer.sh/Ehl5q/mi1 -o mi1 Step 1.3 Importing Multisig Info \u00b6 Person A will run the command: import_multisig_info mi2 Depending on the transactions made in to the multsig wallet the output will look similar to: 2 outputs found in mi2 Height 1357156, transaction <88ba687dc79a0b39e6de6d0763eda8363d33d9f58ec9a096171bd9a7f1dae873>, received 0.100000000000 Height 1357161, transaction <d6ac845b9400759525519cdc5d514eb8f5b1d265b24d1c016e75b20ed3b4b7da>, received 0.100000000000 Person B will run a similar command: import_multisig_info mi1 and the output will look like: 2 outputs found in mi1 Height 1357156, transaction <88ba687dc79a0b39e6de6d0763eda8363d33d9f58ec9a096171bd9a7f1dae873>, received 0.100000000000 Height 1357161, transaction <d6ac845b9400759525519cdc5d514eb8f5b1d265b24d1c016e75b20ed3b4b7da>, received 0.100000000000 Step 2 Preparing Spending Transaction \u00b6 Either person A or person B can do this, it doesn't matter. To avoid weird things from happening only do it for 1 transaction at a time. Person A performs the usual transfer command: transfer T6TmZX8EzZVjS9zNg7zAsrEQFDgcVC2qV2ZMyoWsbyK4SNB2SwMHZtMhPSsFyTmRBQUaGVF5k3qy5CMFM6Lvj7gi3AeszDag7 50 The output will look like: Unsigned transaction(s) successfully written to file: multisig_loki_tx Check in the folder where you started loki-wallet-cli from. There should be a file named multisig_loki_tx . Person A will send the file multisig_loki_tx to the Person B. Person A can send this file through email or alternatively use the transfer.sh commands outside of the wallet: curl --upload-file ./multisig_loki_tx https://transfer.sh/multisig_loki_tx If Person A chooses to use transfer.sh command to send the file to Person B they will receive a <link> to pass to Person B. Person B must finish the signature. Person B copies/downloads the file to the same folder from where he started (or will start) loki-wallet-cli . Person B can run the command to download the file to the loki-wallet-cli directory. curl https://transfer.sh/CJqnM/multisig_loki_tx -o multisig_loki_tx Replacing https://transfer.sh/CJqnM/multisig_loki_tx with the link provided by Person A. Then, Person B runs the command: sign_multisig multisig_loki_tx A prompt will be displayed to allow person B to check the transaction before signing: Loaded 1 transactions, for 108.082287779, fee 0.061108880, sending 50.000000000 to T6TmZX8EzZVjS9zNg7zAsrEQFDgcVC2qV2ZMyoWsbyK4SNB2SwMHZtMhPSsFyTmRBQUaGVF5k3qy5CMFM6Lvj7gi3AeszDag7, 58.021178899 change to T6ScXhWpAG2aUHmFemwvn4HddHA5GQ4u6MvYsW2hVteJSwLJXCEhk2aVp4XzyqGmvyUqc3w8fwWwg6szGEytUSx51C6WQ3er8, with min ring size 10, no payment ID. Is this okay? (Y/Yes/N/No): If ok, answer Y , and the output will look like: Transaction successfully signed to file multisig_loki_tx, txid 3b03b16c79eaa5564171ae88242c4cdb1f9e0b41fc3de949c6524c5026a3f3bb It may be relayed to the network with submit_multisig Finally, person B submits the transaction to the network by commanding: submit_multisig multisig_loki_tx There will be a confirmation prompt: Loaded 1 transactions, for 108.082287779, fee 0.061108880, sending 50.000000000 to T6TmZX8EzZVjS9zNg7zAsrEQFDgcVC2qV2ZMyoWsbyK4SNB2SwMHZtMhPSsFyTmRBQUaGVF5k3qy5CMFM6Lvj7gi3AeszDag7, 58.021178899 change to T6ScXhWpAG2aUHmFemwvn4HddHA5GQ4u6MvYsW2hVteJSwLJXCEhk2aVp4XzyqGmvyUqc3w8fwWwg6szGEytUSx51C6WQ3er8, with min ring size 10, no payment ID. Is this okay? (Y/Yes/N/No): If ok, answer Y , and the transaction will be sent. The output will look like: Transaction successfully submitted, transaction <3b03b16c79eaa5564171ae88242c4cdb1f9e0b41fc3de949c6524c5026a3f3bb> The person B could also send the signed TX to person A, who could then submit it to the network himself. If you want to make another one, you have to go back to step 1 of spending (sync the key images again). Note on folders and file locations, as it could create some confusions. The wallet will look for the files and export them to the folder from where it was started, ie where your command prompt / shell was when you called loki-wallet-cli . It may or may not be the same folder as your actual wallet files or loki-wallet-cli , depending on how you go about it. For example, your wallet could be on some USB drive like f:\\temp\\ , and your wallet software on c:\\loki-windows-x64\\ and your shell working folder could be c:\\ . If you remain in c:\\ with the shell, you could start the wallet by its full path and specify the wallet file location: c:\\loki-windows-x64\\loki-wallet-cli.exe --wallet-file f:\\temp\\mywallet . In this case, all the import/export stuff would be read/written to c:\\ because that's still your shell's working folder. It would be probably feel more natural to cd into the wallet folder. Do f: to change drive and then cd f:\\temp\\ . Then, simply start the wallet from that location by its full path again: c:\\loki-windows-x64\\loki-wallet-cli.exe --wallet-file mywallet . Notice how you don't have to write the full wallet path now as you're already there with your shell. In this case, all the files mentioned above would be written or read from the same folder as the wallet files. Source: Monero Stackexchange: How to use Monero Multisigniture Wallets","title":"2/2 Multisig"},{"location":"Wallets/CliWallet/2of2Multisig/#loki-22-multisig","text":"First, the wallet to be converted to multisig must be empty. It is best to use a brand-new wallet for the purpose, although not required. It is strongly advised to make a copy of the wallet files first, just in case something goes wrong.","title":"Loki 2/2 Multisig"},{"location":"Wallets/CliWallet/2of2Multisig/#overview","text":"In short, the process is: Set-up Both parties prepare loki-wallet-cli files Both parties command prepare_multisig and send data to each other Both parties command make_multisig Receiving All parties can type address to see the created multisig wallet address. The address will, of course, be the same for all parties since they're all watching the same wallet. Preparation for Sending To prepare for sending both parties command export_multisig_info <filename> and send the file to the other party To complete preparation, all parties command import_multisig_info <filename1> <filename2> and import files from other parties Sending To send, any party can use the usual transfer command, but the result will be a file named multisig_loki_tx which must be sent to any 1 other signer The other party commands sign_multisig multisig_loki_tx and the file is updated with the signature. The completely signed file is pushed to the network with use of submit_multisig multisig_loki_tx Below is a step-by-step walkthrough.","title":"Overview"},{"location":"Wallets/CliWallet/2of2Multisig/#set-up","text":"","title":"Set-up"},{"location":"Wallets/CliWallet/2of2Multisig/#step-1-initiate-creation-of-multisig-wallet-and-exchange-data","text":"Requirements: 2 empty loki-wallet-cli wallets Both wallets connected to lokid Private communication channel Person A must run the command in their loki-wallet-cli : prepare_multisig Person A will receive the output: MultisigV1cYuTGuf8FSiCYnMtLU4sZzeKZgeMy51qf4CcG2EQ2BPqKTii6YanpNLJDTM9rVRNfBPNFnJHoCWwGT9d8kB2UEDNHDxjgaAZX6DAWtj9VBFq9Q5qHjduozaYzgYpbVfHKHUQR2UrJjyX7tCSyd8gFEHUSocDRejRZBrFrKNifri5ozpN Send this multisig info to all other participants, then use make_multisig <threshold> <info1> [<info2>...] with others' multisig info This includes the PRIVATE view key, so needs to be disclosed only to that multisig wallet's participants Copy the entire line Multisig...5ozpN and be sure to capture the whole thing when copying. Send this line to person B through a private communication channel. Person B does the same and sends his output to person A. Person B must run the command in their loki-wallet-cli : prepare_multisig Person B will receive the output: MultisigV1BU9w9mysQMhNTYcNFQgD82VQiKFGpkwy8Jmu13iWWBmoeRbqyuYmEh22bJRk945ntuDeazTsYwUCYZcCL1cxuf4xDzwUJCLkiYhPCvF7gv3xrCGkAiozirNUG6CxRa53mHqp4Cvdj3yxcQcYbXNYC1ecybbQMW1gs5BBQiruVGeJi4FS Send this multisig info to all other participants, then use make_multisig <threshold> <info1> [<info2>...] with others' multisig info This includes the PRIVATE view key, so needs to be disclosed only to that multisig wallet's participants Person B will copy the Multisig\u2026...eJi4FS and send it to person A through a private communication channel.","title":"Step 1 Initiate Creation of Multisig Wallet and Exchange Data"},{"location":"Wallets/CliWallet/2of2Multisig/#step-2-create-multisig-wallets","text":"Both person A and person B now have the Multisig...arg text from the other one. With that, each of them can create their part of the multisig wallet. Before you proceed, note that the wallet will lose access to the underlying account when converted to multisig. This is not really a problem, since we started with an empty one, and if all goes ok with this step, you won't ever need it unless you want to go through the process again for whatever reason (like HDD died, but you have the seed mnemonic of the underlying account and want to reconstruct the multisig wallet). Person A will use the output Person B sent and will run the command: make_multisig 2 MultisigV1BU9w9mysQMhNTYcNFQgD82VQiKFGpkwy8Jmu13iWWBmoeRbqyuYmEh22bJRk945ntuDeazTsYwUCYZcCL1cxuf4xDzwUJCLkiYhPCvF7gv3xrCGkAiozirNUG6CxRa53mHqp4Cvdj3yxcQcYbXNYC1ecybbQMW1gs5BBQiruVGeJi4FS The wallet will output something similar to: 2/2 multisig address: T6ScXhWpAG2aUHmFemwvn4HddHA5GQ4u6MvYsW2hVteJSwLJXCEhk2aVp4XzyqGmvyUqc3w8fwWwg6szGEytUSx51C6WQ3er8 Person B will use the output Person A sent and run the command: make_multisig 2 MultisigV1cYuTGuf8FSiCYnMtLU4sZzeKZgeMy51qf4CcG2EQ2BPqKTii6YanpNLJDTM9rVRNfBPNFnJHoCWwGT9d8kB2UEDNHDxjgaAZX6DAWtj9VBFq9Q5qHjduozaYzgYpbVfHKHUQR2UrJjyX7tCSyd8gFEHUSocDRejRZBrFrKNifri5ozpN The wallet will output something similar to: 2/2 multisig address: T6ScXhWpAG2aUHmFemwvn4HddHA5GQ4u6MvYsW2hVteJSwLJXCEhk2aVp4XzyqGmvyUqc3w8fwWwg6szGEytUSx51C6WQ3er8 Now each person involved should exchange addresses and compare, they must be the same.","title":"Step 2 Create Multisig Wallets"},{"location":"Wallets/CliWallet/2of2Multisig/#receiving","text":"","title":"Receiving"},{"location":"Wallets/CliWallet/2of2Multisig/#step-1-fund-the-multisig-account","text":"This is simple. Just send to the shared address. You can send multiple times, this is the same as a normal wallet. You can use payment ID\u2019s as well, or generate an integrated address to receive funds. Best part, whomever is sending the funds won't be able to tell that the address belongs to a multisig wallet since it looks like any other.","title":"Step 1 Fund The Multisig Account"},{"location":"Wallets/CliWallet/2of2Multisig/#step-2-check-multisig-account-balance","text":"Just open the wallet and command refresh. Once completed, both persons can verify that the funds arrived. Person A commands: show_transfers Person A outputs: 1357156 in 07:50:35 PM 0.100000000000 88ba687dc79a0b39e6de6d0763eda8363d33d9f58ec9a096171bd9a7f1dae873 0000000000000000 - 1357161 in 08:00:18 PM 0.100000000000 d6ac845b9400759525519cdc5d514eb8f5b1d265b24d1c016e75b20ed3b4b7da 0000000000000000 - Person B can do the same: show_tranfers Person B has the same outputs: 1357156 in 07:50:35 PM 0.100000000000 88ba687dc79a0b39e6de6d0763eda8363d33d9f58ec9a096171bd9a7f1dae873 0000000000000000 - 1357161 in 08:00:18 PM 0.100000000000 d6ac845b9400759525519cdc5d514eb8f5b1d265b24d1c016e75b20ed3b4b7da 0000000000000000 -","title":"Step 2 Check Multisig Account Balance"},{"location":"Wallets/CliWallet/2of2Multisig/#spending","text":"","title":"Spending"},{"location":"Wallets/CliWallet/2of2Multisig/#step-1-synchronizing-key-images","text":"","title":"Step 1 Synchronizing Key Images"},{"location":"Wallets/CliWallet/2of2Multisig/#11-exporting-multisig-info","text":"Without this step, it will not be possible to create a spending transaction. Both persons need to run the following command to sync their key images: export_multisig_info <filename> Where <filename> can be any filename. Person A will run the command: export_multisig_info mi1 Person A will receive the output: Multisig info exported to mi1 The file mi1 will be located in the shell working folder* Person A sends that file to Person B. They can send the file in many ways, preferably through by handing a usb drive with the file on it, however If you would like to send the file through terminal use https://transfer.sh/ , an optional step has been added if you choose to use this method. Person B does the same, but changing the filename and runs the command: export_multisig_info mi2 Person B will receive the output: Multisig info exported to mi2 The file mi2 will be located in the shell working folder* Person B sends that file to person A. Now, they must both import each other's file.","title":"1.1 Exporting Multisig Info"},{"location":"Wallets/CliWallet/2of2Multisig/#optional-step-12-sending-multisig-info-file-with-terminal-transfersh","text":"It is optional to use the terminal to send each person the multisig info files.","title":"Optional: Step 1.2 Sending Multisig Info File with terminal - transfer.sh"},{"location":"Wallets/CliWallet/2of2Multisig/#uploading-multisig-info-file","text":"Person A will open up a new terminal and change to the directory \u201cmi1\u201d has been saved.* Person A will run the following command: curl --upload-file ./mi1 https://transfer.sh/mi1 Person A will receive the link to the file as an output, looking similar to: https://transfer.sh/Ehl5q/mi1 Person A will need to send this link to Person B. Person B will run a similar command: curl --upload-file ./mi1 https://transfer.sh/mi2 Person B will receive the link to the file as an output, looking similar to: https://transfer.sh/Iedv9/mi2 Person B will need to send this link to Person A.","title":"Uploading Multisig Info file"},{"location":"Wallets/CliWallet/2of2Multisig/#downloading-multisig-info-file","text":"Person A should change to the directory of their loki-wallet-cli and use Person B\u2019s download link to run the command: curl <Person B link> -o <filename> Replacing <Person B link> with the link Person B shared with Person A and <filename> with the filename of the Multisig info file that Person A generated, for example Person A will run the command: curl https://transfer.sh/Iedv9/mi2 -o mi2 Likewise, Person B should do the same, changing directories to their loki-wallet-cli and downloading with Person A\u2019s download link, and filename. curl https://transfer.sh/Ehl5q/mi1 -o mi1","title":"Downloading Multisig Info file"},{"location":"Wallets/CliWallet/2of2Multisig/#step-13-importing-multisig-info","text":"Person A will run the command: import_multisig_info mi2 Depending on the transactions made in to the multsig wallet the output will look similar to: 2 outputs found in mi2 Height 1357156, transaction <88ba687dc79a0b39e6de6d0763eda8363d33d9f58ec9a096171bd9a7f1dae873>, received 0.100000000000 Height 1357161, transaction <d6ac845b9400759525519cdc5d514eb8f5b1d265b24d1c016e75b20ed3b4b7da>, received 0.100000000000 Person B will run a similar command: import_multisig_info mi1 and the output will look like: 2 outputs found in mi1 Height 1357156, transaction <88ba687dc79a0b39e6de6d0763eda8363d33d9f58ec9a096171bd9a7f1dae873>, received 0.100000000000 Height 1357161, transaction <d6ac845b9400759525519cdc5d514eb8f5b1d265b24d1c016e75b20ed3b4b7da>, received 0.100000000000","title":"Step 1.3 Importing Multisig Info"},{"location":"Wallets/CliWallet/2of2Multisig/#step-2-preparing-spending-transaction","text":"Either person A or person B can do this, it doesn't matter. To avoid weird things from happening only do it for 1 transaction at a time. Person A performs the usual transfer command: transfer T6TmZX8EzZVjS9zNg7zAsrEQFDgcVC2qV2ZMyoWsbyK4SNB2SwMHZtMhPSsFyTmRBQUaGVF5k3qy5CMFM6Lvj7gi3AeszDag7 50 The output will look like: Unsigned transaction(s) successfully written to file: multisig_loki_tx Check in the folder where you started loki-wallet-cli from. There should be a file named multisig_loki_tx . Person A will send the file multisig_loki_tx to the Person B. Person A can send this file through email or alternatively use the transfer.sh commands outside of the wallet: curl --upload-file ./multisig_loki_tx https://transfer.sh/multisig_loki_tx If Person A chooses to use transfer.sh command to send the file to Person B they will receive a <link> to pass to Person B. Person B must finish the signature. Person B copies/downloads the file to the same folder from where he started (or will start) loki-wallet-cli . Person B can run the command to download the file to the loki-wallet-cli directory. curl https://transfer.sh/CJqnM/multisig_loki_tx -o multisig_loki_tx Replacing https://transfer.sh/CJqnM/multisig_loki_tx with the link provided by Person A. Then, Person B runs the command: sign_multisig multisig_loki_tx A prompt will be displayed to allow person B to check the transaction before signing: Loaded 1 transactions, for 108.082287779, fee 0.061108880, sending 50.000000000 to T6TmZX8EzZVjS9zNg7zAsrEQFDgcVC2qV2ZMyoWsbyK4SNB2SwMHZtMhPSsFyTmRBQUaGVF5k3qy5CMFM6Lvj7gi3AeszDag7, 58.021178899 change to T6ScXhWpAG2aUHmFemwvn4HddHA5GQ4u6MvYsW2hVteJSwLJXCEhk2aVp4XzyqGmvyUqc3w8fwWwg6szGEytUSx51C6WQ3er8, with min ring size 10, no payment ID. Is this okay? (Y/Yes/N/No): If ok, answer Y , and the output will look like: Transaction successfully signed to file multisig_loki_tx, txid 3b03b16c79eaa5564171ae88242c4cdb1f9e0b41fc3de949c6524c5026a3f3bb It may be relayed to the network with submit_multisig Finally, person B submits the transaction to the network by commanding: submit_multisig multisig_loki_tx There will be a confirmation prompt: Loaded 1 transactions, for 108.082287779, fee 0.061108880, sending 50.000000000 to T6TmZX8EzZVjS9zNg7zAsrEQFDgcVC2qV2ZMyoWsbyK4SNB2SwMHZtMhPSsFyTmRBQUaGVF5k3qy5CMFM6Lvj7gi3AeszDag7, 58.021178899 change to T6ScXhWpAG2aUHmFemwvn4HddHA5GQ4u6MvYsW2hVteJSwLJXCEhk2aVp4XzyqGmvyUqc3w8fwWwg6szGEytUSx51C6WQ3er8, with min ring size 10, no payment ID. Is this okay? (Y/Yes/N/No): If ok, answer Y , and the transaction will be sent. The output will look like: Transaction successfully submitted, transaction <3b03b16c79eaa5564171ae88242c4cdb1f9e0b41fc3de949c6524c5026a3f3bb> The person B could also send the signed TX to person A, who could then submit it to the network himself. If you want to make another one, you have to go back to step 1 of spending (sync the key images again). Note on folders and file locations, as it could create some confusions. The wallet will look for the files and export them to the folder from where it was started, ie where your command prompt / shell was when you called loki-wallet-cli . It may or may not be the same folder as your actual wallet files or loki-wallet-cli , depending on how you go about it. For example, your wallet could be on some USB drive like f:\\temp\\ , and your wallet software on c:\\loki-windows-x64\\ and your shell working folder could be c:\\ . If you remain in c:\\ with the shell, you could start the wallet by its full path and specify the wallet file location: c:\\loki-windows-x64\\loki-wallet-cli.exe --wallet-file f:\\temp\\mywallet . In this case, all the import/export stuff would be read/written to c:\\ because that's still your shell's working folder. It would be probably feel more natural to cd into the wallet folder. Do f: to change drive and then cd f:\\temp\\ . Then, simply start the wallet from that location by its full path again: c:\\loki-windows-x64\\loki-wallet-cli.exe --wallet-file mywallet . Notice how you don't have to write the full wallet path now as you're already there with your shell. In this case, all the files mentioned above would be written or read from the same folder as the wallet files. Source: Monero Stackexchange: How to use Monero Multisigniture Wallets","title":"Step 2 Preparing Spending Transaction"},{"location":"Wallets/CliWallet/2of3Multisig/","text":"Loki 2/3 Multisig \u00b6 First, the wallet to be converted to multisig must be empty. It is best to use a brand-new wallet for the purpose, although not required. It is strongly advised to make a copy of the wallet files first, just in case something goes wrong. Overview \u00b6 In short, the process is: Wallet Creation All parties command prepare_multisig and send data to ALL other parties All parties command make_multisig <threshold> <data1> <data2> and send 2nd batch of data to ALL other parties All parties command finalize_multisig <data1> <data2> with the data from ALL other parties. Receiving All parties can type address to see the created multisig wallet address. The address will, of course, be the same for all parties since they're all watching the same wallet. Preparation for Sending To prepare for sending all parties command export_multisig_info <filename> and send the file to all other parties To complete preparation, all parties command import_multisig_info <filename1> <filename2> and import files from other parties Sending To send, any party can use the usual transfer command, but the result will be a file named multisig_loki_tx which must be sent to any 1 other signer The other party commands sign_multisig multisig_loki_tx and the file is updated with the signature. The completely signed file is pushed to the network with use of submit_multisig multisig_loki_tx . Below is a step-by-step walkthrough. Wallet Creation \u00b6 Requirements: 3 empty loki-wallet-cli wallets All parties wallets connected to a lokid Private communication channel Step 1 - Prepare Multisig \u00b6 All 3 people should open up their loki-wallet-cli and generate a new wallet. Make sure you do not have any $loki within your wallet. Person 1, 2 and 3 runs the following command within their loki-wallet-cli : prepare_multisig The output will be something like: MultisigV1cR7X7ZAfa5ncRmQv1hpt4P1DmmnhinhokhDMqsmuWXmHFrb6xUr3FtBGygCfMScxnKJvXK1vvPNahXNWfYWVquieBErr98sFtgs24c2YuYrQT78uxV8oYx1A9bKeHSUfYzCniN5kMznEfvKCw3FiomjLvw364gg98ZWp16zA7pUVozid Send this multisig info to all other participants, then use make_multisig <threshold> <info1> [<info2>...] with others' multisig info This includes the PRIVATE view key, so needs to be disclosed only to that multisig wallet's participants Copy the entire line Multisig\u2026...Vozid and be sure to capture the whole thing when copying. Person 1 to send the Multsig...arg to Person 2 and 3, Person 2 to send their output to Person 1 and 3 and Person 3 to send their output to Person 1 and 2. Step 2 - Make Multisig \u00b6 All 3 persons now have the Multisig...arg text from the other 2. With that, each of them can create their part of the multisig wallet. Before you proceed, note that the wallet will lose access to the underlying wallet when converted to multisig. This is not really a problem, since we started with an empty wallet, and if all goes OK with this step, you won't ever need it unless you want to go through the process again for whatever reason (like HDD died, but you have the seed mnemonic of the underlying wallet and want to reconstruct the multisig wallet). Person 1 commands: make_multisig <threshold> <data person 2> <data person 3> Where <threshold> is the number of signers required out of the 3 people, <data person 2> is the output provided by Person 2, and <data person 3> is the output provided by Person 3. This should look similar to: make_multisig 2 MultisigV12EHtuvxFyAYDNcDsbDqWHDfkRr4JZchSdf8eZQSFwiMKDk15CYEJeQyEwtSnqUZdRr2BsEaT9z2biUdDTEQM4T3N625owvKMDoyhbRj3bwkBtceLKimap8DBAiUmSABpdf62HnPYiRtLW4JdVFmfqjndhWjYBypx1duvpi3qwfSrBY9a MultisigV1TqQ8Gt5Sb3GYtVJa1fQrK7e7hPm59XbooNvLxPSBR4856bW9jtD1hEyWy4yULKrX7reZZ6vrKdBCdSdk4nfApCGYJAA2WP4pKNwHDyKTuLEeuoDhqno8keEVeEF9AZsWXvng1avUTRREmy11h8wu8pdjopC4AguQKiHCJCN7aT9W6b8C Notice how there are 2 strings starting with Multisig....arg . One is from person 2 and other from person 3. The number at the beginning is the minimum required number of signatures. Since it's a 2/3 scheme - it's 2. The output from the make_multisig command will be similar to: Another step is needed MultisigxV1PKCwmVrucV8bXi18VnHFqRXcnAq4osFL3ahzPHCiN48zhs28u6jmEhy7ktZbUEGfRtTuFjjKzJYb61fnFwnysBBnNXsUtCgFMXPa7FyNKVy2AnUg3ePEnKqWkgKVvA81axTS8r9EX1DmVPXgFKkFzw4Yj4ZtMcJVo77b5ayuMzjFtsaijko9X2bjd9AVfFVGBFMCSLa4xXhNVNz19CTUJx5gpoPG Send this multisig info to all other participants, then use finalize_multisig <info1> [<info2>...] with others' multisig info With 2/3 there's an additional step to be done here. The new Multisig...arg info must be passed to ALL other participants (persons 2 & 3). Persons 2 & 3 do the same as above and send the info to other 2 parties. Step 3 - Finalize Multisig \u00b6 Here we do one last command to make the wallet ready for receiving. It requires the 2nd batch of Multisig\u2026....arg strings received from other parties. Person 1 will run the command: finalize_multisig MultisigxV1Vg1tsRLurvAc5aSA9Hd9God3MQhijCFoE1rPDFzx7ufwhs28u6jmEhy7ktZbUEGfRtTuFjjKzJYb61fnFwnysBBnfYm4xJWcJ4qM4khSb2KkyAKDuT39pTvdmemhojNjeYCmgSQ1NZLyBj48R1tVpiGNxa7TDnGbSgLuKBq35AX6jfu5PECAcDDn22CFQbJZip7xnBbn89Szzh27xeozfxcLiqqm MultisigxV14xDZBGACz3iUh2aVKGE5q5VzcvJdg2qCvZECgUWCdy5QNXsUtCgFMXPa7FyNKVy2AnUg3ePEnKqWkgKVvA81axTSfYm4xJWcJ4qM4khSb2KkyAKDuT39pTvdmemhojNjeYCmCNaRSsDEcemLLL8wCvzsy5R6hhkhWLYkD9vhZwprSFFKMZ7tfRko2VfMBoKQhB7PKXbf1npk2xceVKu2y7kExywb Unfortunately the wallet will not display an output at this point. There's no indication that the process was successfully completed (for now). All 3 persons do the same, and all 3 wallets will show the same address after this step. Now each person run the command: address And each 3 parties of the multisig wallet should be shown the same address in their wallet. Receiving \u00b6 Step 1 Fund The Multisig Account \u00b6 This is simple. Just send to the shared address. You can send multiple times, just like a normal wallet. You can use payment ID\u2019s as well, or generate an integrated address to receive funds. Best part, whomever is sending the funds won't be able to tell that the address belongs to a multisig wallet since it looks like any other Loki address. Step 2 Check Multisig Account Balance \u00b6 Just open the wallet and run the refresh command . Once completed, all persons can verify that the funds arrived. Person 1, 2 & 3 can run the command: show_transfers To see incoming transfers or the following command to see the balance of the wallet: balance Preparation for Spending \u00b6 Step 1 - Export Multisig \u00b6 Without this step, it will not be possible to create a transaction that spends Loki. As a minimum, the sender needs to get a partial key image from the same person who will sign the transaction with him later. He could get from both parties immediately and then later decide with whom to sign. Person 1 commands: export_multisig_info mi1 Where mi1 can be any filename. The output will be: Multisig info exported to mi1 The file mi1 will be located in the shell working folder* Person 1 sends that file to other persons. Persons 2 & 3 do the same. Optional: Step 1.2 Sending Multisig Info File with terminal - transfer.sh \u00b6 It is optional to use the terminal to send each person the multisig info files. Uploading Multisig Info file \u00b6 Person 1 will open up a new terminal and change to the directory mi1 has been saved.* Person 1 will run the following command: curl --upload-file ./mi1 https://transfer.sh/mi1 Person 1 will receive the link to the file as an output, looking similar to: https://transfer.sh/Ehl5q/mi1 Person 1 will need to send this link to Person 2 and Person 3. Person 2 will need to do the same and send the link to Person 1 and 3. Person 3 will need to do the same and send the link to Person 1 and 2. Downloading Multisig Info file \u00b6 Person 1 should change to the directory of their loki-wallet-cli and use Person 2 and 3\u2019s download link to run the commands: curl <link> -o <filename> Replacing <link> with the link Person 2 and 3 shared with Person 1 and <filename> with the filename of the Multisig info file that Person 2 or 3 generated, for example Person 1 will run the command: curl https://transfer.sh/Iedv9/mi2 -o mi2 And the command: curl https://transfer.sh/dfvr3/mi3 -o mi3 Likewise, Person 2 and 3 should do the same, changing directories to their loki-wallet-cli and downloading with the alternative Persons download link, and filename. curl https://transfer.sh/Ehl5q/mi1 -o mi1 Step 2 - Import Multisig \u00b6 Now, they must all import each other's file so they can be ready to make a TX later. For example, Person 2 commands: import_multisig_info mi1 The wallet will look for files in the shell working folder and if the files are found the output will look like: 2 outputs found in mi1 Height 1357156, transaction <88ba687dc79a0b39e6de6d0763eda8363d33d9f58ec9a096171bd9a7f1dae873>, received 0.100000000000 Height 1357161, transaction <d6ac845b9400759525519cdc5d514eb8f5b1d265b24d1c016e75b20ed3b4b7da>, received 0.100000000000 Persons 1 & 3 do the same. Spending \u00b6 Step 1 - Transfer (Preparing Unsigned Transaction) \u00b6 Any of the 3 persons can start a transaction, it doesn't matter. To avoid weird things from happening only do it for 1 transaction at a time. If anything weird happens, do the step 1 & 2 again to fix. For example, let's say that Person 3 will make the TX. Person 3 performs the usual transfer command: transfer T6TmZX8EzZVjS9zNg7zAsrEQFDgcVC2qV2ZMyoWsbyK4SNB2SwMHZtMhPSsFyTmRBQUaGVF5k3qy5CMFM6Lvj7gi3AeszDag7 50 The output will look like: Unsigned transaction(s) successfully written to file: multisig_loki_tx Check in the folder where you started loki-wallet-cli from. There should be a file named multisig_loki_tx . Send the file multisig_loki_tx to either person 1 or 2. Person 3 will send the file multisig_loki_tx to the Person 1 or 2. Person 3 can send this file through email or alternatively use the transfer.sh commands outside of the wallet: curl --upload-file ./multisig_loki_tx https://transfer.sh/multisig_loki_tx If Person 3 chooses to use transfer.sh command to send the file to Person 1 or 2 they will receive a <link> . Person 1 or 2 must finish the signature. Person 1 or 2 copies/downloads the file to the same folder from where he started (or will start) loki-wallet-cli . Person 1 or 2 can run the command to download the file to the loki-wallet-cli directory. curl https://transfer.sh/CJqnM/multisig_loki_tx -o multisig_loki_tx Replacing https://transfer.sh/CJqnM/multisig_loki_tx with the link provided by Person 3. Step 2 - Sign Multisig \u00b6 Let's say Person 2 was picked as the partner. He must finish the signature. Person 2 copies the file to the same folder from where he started (or will start) loki-wallet-cli . Then, Person 2 commands: sign_multisig multisig_loki_tx and they will be prompted to check it first: Loaded 1 transactions, for 108.082287779, fee 0.061108880, sending 50.000000000 to T6TmZX8EzZVjS9zNg7zAsrEQFDgcVC2qV2ZMyoWsbyK4SNB2SwMHZtMhPSsFyTmRBQUaGVF5k3qy5CMFM6Lvj7gi3AeszDag7, 58.021178899 change to T6ScXhWpAG2aUHmFemwvn4HddHA5GQ4u6MvYsW2hVteJSwLJXCEhk2aVp4XzyqGmvyUqc3w8fwWwg6szGEytUSx51C6WQ3er8, with min ring size 10, no payment ID. Is this okay? (Y/Yes/N/No): If ok, answer Y , and the output will look like: Transaction successfully submitted, transaction <3b03b16c79eaa5564171ae88242c4cdb1f9e0b41fc3de949c6524c5026a3f3bb> Step 3 - Submit Multisig \u00b6 Finally, person with the signed file submits the transaction to the network by commanding: submit_multisig multisig_loki_tx There will be a confirmation prompt: Loaded 1 transactions, for 108.082287779, fee 0.061108880, sending 50.000000000 to T6TmZX8EzZVjS9zNg7zAsrEQFDgcVC2qV2ZMyoWsbyK4SNB2SwMHZtMhPSsFyTmRBQUaGVF5k3qy5CMFM6Lvj7gi3AeszDag7, 58.021178899 change to T6ScXhWpAG2aUHmFemwvn4HddHA5GQ4u6MvYsW2hVteJSwLJXCEhk2aVp4XzyqGmvyUqc3w8fwWwg6szGEytUSx51C6WQ3er8, with min ring size 10, no payment ID. Is this okay? (Y/Yes/N/No): If ok, answer Y , and the transaction will be sent. The output will look like: Transaction successfully submitted, transaction <3b03b16c79eaa5564171ae88242c4cdb1f9e0b41fc3de949c6524c5026a3f3bb> You can check its status by using the show_transfers command. The person 2 could also send the signed TX to person 3, who could then submit it to the network himself. If you want to make another one, you have to go back to preparation for spending step (sync the key images again). The wallet will look for the files and export them to the folder from where it was started, ie where your command prompt / shell was when you called loki-wallet-cli . It may or may not be the same folder as your actual wallet files or loki-wallet-cli , depending on how you go about it. For example, your wallet could be on some USB drive like f:\\temp\\ , and your wallet software on c:\\loki\\ and your shell working folder could be c:\\ . If you remain in c:\\ with the shell, you could start the wallet by its full path and specify the wallet file location: c:\\loki\\loki-wallet-cli.exe --wallet-file f:\\temp\\mywallet . In this case, all the import/export stuff would be read/written to c:\\ because that's still your shell's working folder. It would be probably feel more natural to cd into the wallet folder. Do f: to change drive and then cd f:\\temp\\ . Then, simply start the wallet from that location by its full path again: c:\\loki\\loki-wallet-cli.exe --wallet-file mywallet . Notice how you don't have to write the full wallet path now as you're already there with your shell. In this case, all the files mentioned above would be written or read from the same folder as the wallet files. Source: Monero Stack Exchange: how to use monero multisigniture wallets","title":"2/3 Multisig"},{"location":"Wallets/CliWallet/2of3Multisig/#loki-23-multisig","text":"First, the wallet to be converted to multisig must be empty. It is best to use a brand-new wallet for the purpose, although not required. It is strongly advised to make a copy of the wallet files first, just in case something goes wrong.","title":"Loki 2/3 Multisig"},{"location":"Wallets/CliWallet/2of3Multisig/#overview","text":"In short, the process is: Wallet Creation All parties command prepare_multisig and send data to ALL other parties All parties command make_multisig <threshold> <data1> <data2> and send 2nd batch of data to ALL other parties All parties command finalize_multisig <data1> <data2> with the data from ALL other parties. Receiving All parties can type address to see the created multisig wallet address. The address will, of course, be the same for all parties since they're all watching the same wallet. Preparation for Sending To prepare for sending all parties command export_multisig_info <filename> and send the file to all other parties To complete preparation, all parties command import_multisig_info <filename1> <filename2> and import files from other parties Sending To send, any party can use the usual transfer command, but the result will be a file named multisig_loki_tx which must be sent to any 1 other signer The other party commands sign_multisig multisig_loki_tx and the file is updated with the signature. The completely signed file is pushed to the network with use of submit_multisig multisig_loki_tx . Below is a step-by-step walkthrough.","title":"Overview"},{"location":"Wallets/CliWallet/2of3Multisig/#wallet-creation","text":"Requirements: 3 empty loki-wallet-cli wallets All parties wallets connected to a lokid Private communication channel","title":"Wallet Creation"},{"location":"Wallets/CliWallet/2of3Multisig/#step-1-prepare-multisig","text":"All 3 people should open up their loki-wallet-cli and generate a new wallet. Make sure you do not have any $loki within your wallet. Person 1, 2 and 3 runs the following command within their loki-wallet-cli : prepare_multisig The output will be something like: MultisigV1cR7X7ZAfa5ncRmQv1hpt4P1DmmnhinhokhDMqsmuWXmHFrb6xUr3FtBGygCfMScxnKJvXK1vvPNahXNWfYWVquieBErr98sFtgs24c2YuYrQT78uxV8oYx1A9bKeHSUfYzCniN5kMznEfvKCw3FiomjLvw364gg98ZWp16zA7pUVozid Send this multisig info to all other participants, then use make_multisig <threshold> <info1> [<info2>...] with others' multisig info This includes the PRIVATE view key, so needs to be disclosed only to that multisig wallet's participants Copy the entire line Multisig\u2026...Vozid and be sure to capture the whole thing when copying. Person 1 to send the Multsig...arg to Person 2 and 3, Person 2 to send their output to Person 1 and 3 and Person 3 to send their output to Person 1 and 2.","title":"Step 1 - Prepare Multisig"},{"location":"Wallets/CliWallet/2of3Multisig/#step-2-make-multisig","text":"All 3 persons now have the Multisig...arg text from the other 2. With that, each of them can create their part of the multisig wallet. Before you proceed, note that the wallet will lose access to the underlying wallet when converted to multisig. This is not really a problem, since we started with an empty wallet, and if all goes OK with this step, you won't ever need it unless you want to go through the process again for whatever reason (like HDD died, but you have the seed mnemonic of the underlying wallet and want to reconstruct the multisig wallet). Person 1 commands: make_multisig <threshold> <data person 2> <data person 3> Where <threshold> is the number of signers required out of the 3 people, <data person 2> is the output provided by Person 2, and <data person 3> is the output provided by Person 3. This should look similar to: make_multisig 2 MultisigV12EHtuvxFyAYDNcDsbDqWHDfkRr4JZchSdf8eZQSFwiMKDk15CYEJeQyEwtSnqUZdRr2BsEaT9z2biUdDTEQM4T3N625owvKMDoyhbRj3bwkBtceLKimap8DBAiUmSABpdf62HnPYiRtLW4JdVFmfqjndhWjYBypx1duvpi3qwfSrBY9a MultisigV1TqQ8Gt5Sb3GYtVJa1fQrK7e7hPm59XbooNvLxPSBR4856bW9jtD1hEyWy4yULKrX7reZZ6vrKdBCdSdk4nfApCGYJAA2WP4pKNwHDyKTuLEeuoDhqno8keEVeEF9AZsWXvng1avUTRREmy11h8wu8pdjopC4AguQKiHCJCN7aT9W6b8C Notice how there are 2 strings starting with Multisig....arg . One is from person 2 and other from person 3. The number at the beginning is the minimum required number of signatures. Since it's a 2/3 scheme - it's 2. The output from the make_multisig command will be similar to: Another step is needed MultisigxV1PKCwmVrucV8bXi18VnHFqRXcnAq4osFL3ahzPHCiN48zhs28u6jmEhy7ktZbUEGfRtTuFjjKzJYb61fnFwnysBBnNXsUtCgFMXPa7FyNKVy2AnUg3ePEnKqWkgKVvA81axTS8r9EX1DmVPXgFKkFzw4Yj4ZtMcJVo77b5ayuMzjFtsaijko9X2bjd9AVfFVGBFMCSLa4xXhNVNz19CTUJx5gpoPG Send this multisig info to all other participants, then use finalize_multisig <info1> [<info2>...] with others' multisig info With 2/3 there's an additional step to be done here. The new Multisig...arg info must be passed to ALL other participants (persons 2 & 3). Persons 2 & 3 do the same as above and send the info to other 2 parties.","title":"Step 2 - Make Multisig"},{"location":"Wallets/CliWallet/2of3Multisig/#step-3-finalize-multisig","text":"Here we do one last command to make the wallet ready for receiving. It requires the 2nd batch of Multisig\u2026....arg strings received from other parties. Person 1 will run the command: finalize_multisig MultisigxV1Vg1tsRLurvAc5aSA9Hd9God3MQhijCFoE1rPDFzx7ufwhs28u6jmEhy7ktZbUEGfRtTuFjjKzJYb61fnFwnysBBnfYm4xJWcJ4qM4khSb2KkyAKDuT39pTvdmemhojNjeYCmgSQ1NZLyBj48R1tVpiGNxa7TDnGbSgLuKBq35AX6jfu5PECAcDDn22CFQbJZip7xnBbn89Szzh27xeozfxcLiqqm MultisigxV14xDZBGACz3iUh2aVKGE5q5VzcvJdg2qCvZECgUWCdy5QNXsUtCgFMXPa7FyNKVy2AnUg3ePEnKqWkgKVvA81axTSfYm4xJWcJ4qM4khSb2KkyAKDuT39pTvdmemhojNjeYCmCNaRSsDEcemLLL8wCvzsy5R6hhkhWLYkD9vhZwprSFFKMZ7tfRko2VfMBoKQhB7PKXbf1npk2xceVKu2y7kExywb Unfortunately the wallet will not display an output at this point. There's no indication that the process was successfully completed (for now). All 3 persons do the same, and all 3 wallets will show the same address after this step. Now each person run the command: address And each 3 parties of the multisig wallet should be shown the same address in their wallet.","title":"Step 3 - Finalize Multisig"},{"location":"Wallets/CliWallet/2of3Multisig/#receiving","text":"","title":"Receiving"},{"location":"Wallets/CliWallet/2of3Multisig/#step-1-fund-the-multisig-account","text":"This is simple. Just send to the shared address. You can send multiple times, just like a normal wallet. You can use payment ID\u2019s as well, or generate an integrated address to receive funds. Best part, whomever is sending the funds won't be able to tell that the address belongs to a multisig wallet since it looks like any other Loki address.","title":"Step 1 Fund The Multisig Account"},{"location":"Wallets/CliWallet/2of3Multisig/#step-2-check-multisig-account-balance","text":"Just open the wallet and run the refresh command . Once completed, all persons can verify that the funds arrived. Person 1, 2 & 3 can run the command: show_transfers To see incoming transfers or the following command to see the balance of the wallet: balance","title":"Step 2 Check Multisig Account Balance"},{"location":"Wallets/CliWallet/2of3Multisig/#preparation-for-spending","text":"","title":"Preparation for Spending"},{"location":"Wallets/CliWallet/2of3Multisig/#step-1-export-multisig","text":"Without this step, it will not be possible to create a transaction that spends Loki. As a minimum, the sender needs to get a partial key image from the same person who will sign the transaction with him later. He could get from both parties immediately and then later decide with whom to sign. Person 1 commands: export_multisig_info mi1 Where mi1 can be any filename. The output will be: Multisig info exported to mi1 The file mi1 will be located in the shell working folder* Person 1 sends that file to other persons. Persons 2 & 3 do the same.","title":"Step 1 - Export Multisig"},{"location":"Wallets/CliWallet/2of3Multisig/#optional-step-12-sending-multisig-info-file-with-terminal-transfersh","text":"It is optional to use the terminal to send each person the multisig info files.","title":"Optional: Step 1.2 Sending Multisig Info File with terminal - transfer.sh"},{"location":"Wallets/CliWallet/2of3Multisig/#uploading-multisig-info-file","text":"Person 1 will open up a new terminal and change to the directory mi1 has been saved.* Person 1 will run the following command: curl --upload-file ./mi1 https://transfer.sh/mi1 Person 1 will receive the link to the file as an output, looking similar to: https://transfer.sh/Ehl5q/mi1 Person 1 will need to send this link to Person 2 and Person 3. Person 2 will need to do the same and send the link to Person 1 and 3. Person 3 will need to do the same and send the link to Person 1 and 2.","title":"Uploading Multisig Info file"},{"location":"Wallets/CliWallet/2of3Multisig/#downloading-multisig-info-file","text":"Person 1 should change to the directory of their loki-wallet-cli and use Person 2 and 3\u2019s download link to run the commands: curl <link> -o <filename> Replacing <link> with the link Person 2 and 3 shared with Person 1 and <filename> with the filename of the Multisig info file that Person 2 or 3 generated, for example Person 1 will run the command: curl https://transfer.sh/Iedv9/mi2 -o mi2 And the command: curl https://transfer.sh/dfvr3/mi3 -o mi3 Likewise, Person 2 and 3 should do the same, changing directories to their loki-wallet-cli and downloading with the alternative Persons download link, and filename. curl https://transfer.sh/Ehl5q/mi1 -o mi1","title":"Downloading Multisig Info file"},{"location":"Wallets/CliWallet/2of3Multisig/#step-2-import-multisig","text":"Now, they must all import each other's file so they can be ready to make a TX later. For example, Person 2 commands: import_multisig_info mi1 The wallet will look for files in the shell working folder and if the files are found the output will look like: 2 outputs found in mi1 Height 1357156, transaction <88ba687dc79a0b39e6de6d0763eda8363d33d9f58ec9a096171bd9a7f1dae873>, received 0.100000000000 Height 1357161, transaction <d6ac845b9400759525519cdc5d514eb8f5b1d265b24d1c016e75b20ed3b4b7da>, received 0.100000000000 Persons 1 & 3 do the same.","title":"Step 2 - Import Multisig"},{"location":"Wallets/CliWallet/2of3Multisig/#spending","text":"","title":"Spending"},{"location":"Wallets/CliWallet/2of3Multisig/#step-1-transfer-preparing-unsigned-transaction","text":"Any of the 3 persons can start a transaction, it doesn't matter. To avoid weird things from happening only do it for 1 transaction at a time. If anything weird happens, do the step 1 & 2 again to fix. For example, let's say that Person 3 will make the TX. Person 3 performs the usual transfer command: transfer T6TmZX8EzZVjS9zNg7zAsrEQFDgcVC2qV2ZMyoWsbyK4SNB2SwMHZtMhPSsFyTmRBQUaGVF5k3qy5CMFM6Lvj7gi3AeszDag7 50 The output will look like: Unsigned transaction(s) successfully written to file: multisig_loki_tx Check in the folder where you started loki-wallet-cli from. There should be a file named multisig_loki_tx . Send the file multisig_loki_tx to either person 1 or 2. Person 3 will send the file multisig_loki_tx to the Person 1 or 2. Person 3 can send this file through email or alternatively use the transfer.sh commands outside of the wallet: curl --upload-file ./multisig_loki_tx https://transfer.sh/multisig_loki_tx If Person 3 chooses to use transfer.sh command to send the file to Person 1 or 2 they will receive a <link> . Person 1 or 2 must finish the signature. Person 1 or 2 copies/downloads the file to the same folder from where he started (or will start) loki-wallet-cli . Person 1 or 2 can run the command to download the file to the loki-wallet-cli directory. curl https://transfer.sh/CJqnM/multisig_loki_tx -o multisig_loki_tx Replacing https://transfer.sh/CJqnM/multisig_loki_tx with the link provided by Person 3.","title":"Step 1 - Transfer (Preparing Unsigned Transaction)"},{"location":"Wallets/CliWallet/2of3Multisig/#step-2-sign-multisig","text":"Let's say Person 2 was picked as the partner. He must finish the signature. Person 2 copies the file to the same folder from where he started (or will start) loki-wallet-cli . Then, Person 2 commands: sign_multisig multisig_loki_tx and they will be prompted to check it first: Loaded 1 transactions, for 108.082287779, fee 0.061108880, sending 50.000000000 to T6TmZX8EzZVjS9zNg7zAsrEQFDgcVC2qV2ZMyoWsbyK4SNB2SwMHZtMhPSsFyTmRBQUaGVF5k3qy5CMFM6Lvj7gi3AeszDag7, 58.021178899 change to T6ScXhWpAG2aUHmFemwvn4HddHA5GQ4u6MvYsW2hVteJSwLJXCEhk2aVp4XzyqGmvyUqc3w8fwWwg6szGEytUSx51C6WQ3er8, with min ring size 10, no payment ID. Is this okay? (Y/Yes/N/No): If ok, answer Y , and the output will look like: Transaction successfully submitted, transaction <3b03b16c79eaa5564171ae88242c4cdb1f9e0b41fc3de949c6524c5026a3f3bb>","title":"Step 2 - Sign Multisig"},{"location":"Wallets/CliWallet/2of3Multisig/#step-3-submit-multisig","text":"Finally, person with the signed file submits the transaction to the network by commanding: submit_multisig multisig_loki_tx There will be a confirmation prompt: Loaded 1 transactions, for 108.082287779, fee 0.061108880, sending 50.000000000 to T6TmZX8EzZVjS9zNg7zAsrEQFDgcVC2qV2ZMyoWsbyK4SNB2SwMHZtMhPSsFyTmRBQUaGVF5k3qy5CMFM6Lvj7gi3AeszDag7, 58.021178899 change to T6ScXhWpAG2aUHmFemwvn4HddHA5GQ4u6MvYsW2hVteJSwLJXCEhk2aVp4XzyqGmvyUqc3w8fwWwg6szGEytUSx51C6WQ3er8, with min ring size 10, no payment ID. Is this okay? (Y/Yes/N/No): If ok, answer Y , and the transaction will be sent. The output will look like: Transaction successfully submitted, transaction <3b03b16c79eaa5564171ae88242c4cdb1f9e0b41fc3de949c6524c5026a3f3bb> You can check its status by using the show_transfers command. The person 2 could also send the signed TX to person 3, who could then submit it to the network himself. If you want to make another one, you have to go back to preparation for spending step (sync the key images again). The wallet will look for the files and export them to the folder from where it was started, ie where your command prompt / shell was when you called loki-wallet-cli . It may or may not be the same folder as your actual wallet files or loki-wallet-cli , depending on how you go about it. For example, your wallet could be on some USB drive like f:\\temp\\ , and your wallet software on c:\\loki\\ and your shell working folder could be c:\\ . If you remain in c:\\ with the shell, you could start the wallet by its full path and specify the wallet file location: c:\\loki\\loki-wallet-cli.exe --wallet-file f:\\temp\\mywallet . In this case, all the import/export stuff would be read/written to c:\\ because that's still your shell's working folder. It would be probably feel more natural to cd into the wallet folder. Do f: to change drive and then cd f:\\temp\\ . Then, simply start the wallet from that location by its full path again: c:\\loki\\loki-wallet-cli.exe --wallet-file mywallet . Notice how you don't have to write the full wallet path now as you're already there with your shell. In this case, all the files mentioned above would be written or read from the same folder as the wallet files. Source: Monero Stack Exchange: how to use monero multisigniture wallets","title":"Step 3 - Submit Multisig"},{"location":"Wallets/CliWallet/MofNMultisig/","text":"Loki M/N Multisig \u00b6 First, the wallet to be converted to multisig must be empty. It is best to use a brand-new wallet for the purpose, although not required. It is strongly advised to make a copy of the wallet files first, just in case something goes wrong. Overview \u00b6 In short, the process is: Wallet Creation All parties command prepare_multisig and send data to ALL other parties All parties command make_multisig <threshold> <data1> <data2> .... <dataN> and send 2nd batch of data to ALL other parties All parties command finalize_multisig <data1> <data2> ...... <DataM> with the data from ALL other parties. Receiving All parties can type address to see the created multisig wallet address. The address will, of course, be the same for all parties since they're all watching the same wallet. Preparation for Sending To prepare for sending all parties command export_multisig_info <filename> and send the file to all other parties To complete preparation, all parties command import_multisig_info <filename1> <filename2> ..... <filenameM> and import files from other parties Sending To send, any party can use the usual transfer command, but the result will be a file named multisig_loki_tx which must be sent to any 1 other signer The other party commands sign_multisig multisig_loki_tx and the file is updated with the signature. The completely signed file is pushed to the network with use of submit_multisig multisig_loki_tx . Below is a step-by-step walkthrough. Wallet Creation \u00b6 Requirements: N empty loki-wallet-cli wallets. All parties wallets connected to a lokid . Private communication channel. Step 1 - Prepare Multisig \u00b6 All N people should open up their loki-wallet-cli and generate a new wallet. Make sure you do not have any $loki within your wallet. The 1st, 2nd, 3rd , and so on, up to the N th person commands in their loki-wallet-cli : prepare_multisig The output will be something like: MultisigV1cR7X7ZAfa5ncRmQv1hpt4P1DmmnhinhokhDMqsmuWXmHFrb6xUr3FtBGygCfMScxnKJvXK1vvPNahXNWfYWVquieBErr98sFtgs24c2YuYrQT78uxV8oYx1A9bKeHSUfYzCniN5kMznEfvKCw3FiomjLvw364gg98ZWp16zA7pUVozid Send this multisig info to all other participants, then use make_multisig <threshold> <info1> [<info2>...] with others' multisig info This includes the PRIVATE view key, so needs to be disclosed only to that multisig wallet's participants Copy the entire line Multisig\u2026...Vozid and be sure to capture the whole thing when copying. Each person must send their Multisig\u2026...arg to each other person, it is suggested to send this information through a private comunication channel. Step 2 - Make Multisig \u00b6 All N people now have the Multisig...arg text from the other N-1 people. With that, each of them can create their part of the multisig wallet. Before you proceed, note that the wallet will lose access to the underlying wallet when converted to multisig. This is not really a problem, since we started with an empty wallet, and if all goes OK with this step, you won't ever need it unless you want to go through the process again for whatever reason (like HDD died, but you have the seed mnemonic of the underlying wallet and want to reconstruct the multisig wallet). Person 1 commands: make_multisig <threshold> <data person 2> <data person 3> ..... <data person N> Where <threshold> is the number of signers required out of the N people, <data person 2> is the output provided by Person 2, and <data person 3> is the output provided by Person 3, and <data person N> is the output provided by the N th person. This is the process for M of N multisig wallets, For the below example we will show a 2 of 3 multisig wallet. This should look similar to: make_multisig 2 MultisigV12EHtuvxFyAYDNcDsbDqWHDfkRr4JZchSdf8eZQSFwiMKDk15CYEJeQyEwtSnqUZdRr2BsEaT9z2biUdDTEQM4T3N625owvKMDoyhbRj3bwkBtceLKimap8DBAiUmSABpdf62HnPYiRtLW4JdVFmfqjndhWjYBypx1duvpi3qwfSrBY9a MultisigV1TqQ8Gt5Sb3GYtVJa1fQrK7e7hPm59XbooNvLxPSBR4856bW9jtD1hEyWy4yULKrX7reZZ6vrKdBCdSdk4nfApCGYJAA2WP4pKNwHDyKTuLEeuoDhqno8keEVeEF9AZsWXvng1avUTRREmy11h8wu8pdjopC4AguQKiHCJCN7aT9W6b8C Notice how there are 2 strings starting with Multisig....arg . One is from person 2 and other from person 3, if their is 5 different people their would be 4 different strings of Multisig....arg . The number at the beginning is the minimum required number of signatures. Since it's a 2/3 scheme - it's 2. To reiterate, for a 5/8 scheme which means there are 8 people who can sign and 5 people must sign to authorise a transaction out of the Multi signature wallet. In this circumstance, the command each person would run has a <threshold> that equals 5 and 7 strings of multisig...arg . The output from the make_multisig command will be similar to: Another step is needed MultisigxV1PKCwmVrucV8bXi18VnHFqRXcnAq4osFL3ahzPHCiN48zhs28u6jmEhy7ktZbUEGfRtTuFjjKzJYb61fnFwnysBBnNXsUtCgFMXPa7FyNKVy2AnUg3ePEnKqWkgKVvA81axTS8r9EX1DmVPXgFKkFzw4Yj4ZtMcJVo77b5ayuMzjFtsaijko9X2bjd9AVfFVGBFMCSLa4xXhNVNz19CTUJx5gpoPG Send this multisig info to all other participants, then use finalize_multisig <info1> [<info2>...] with others' multisig info With any M of N schemes there's an additional step to be done here. The new Multisig...arg info that was just outputted must be passed to ALL other participants (For person 1 they must send it to persons 2 & 3 ... all the way up to person N). Persons N sends the new output to all other persons. Step 3 - Finalize Multisig \u00b6 Here we do one last command to make the wallet ready for receiving. It requires the 2nd batch of Multisig\u2026....arg strings received from other parties. Person N will run the command: finalize_multisig MultisigxV1Vg1tsRLurvAc5aSA9Hd9God3MQhijCFoE1rPDFzx7ufwhs28u6jmEhy7ktZbUEGfRtTuFjjKzJYb61fnFwnysBBnfYm4xJWcJ4qM4khSb2KkyAKDuT39pTvdmemhojNjeYCmgSQ1NZLyBj48R1tVpiGNxa7TDnGbSgLuKBq35AX6jfu5PECAcDDn22CFQbJZip7xnBbn89Szzh27xeozfxcLiqqm MultisigxV14xDZBGACz3iUh2aVKGE5q5VzcvJdg2qCvZECgUWCdy5QNXsUtCgFMXPa7FyNKVy2AnUg3ePEnKqWkgKVvA81axTSfYm4xJWcJ4qM4khSb2KkyAKDuT39pTvdmemhojNjeYCmCNaRSsDEcemLLL8wCvzsy5R6hhkhWLYkD9vhZwprSFFKMZ7tfRko2VfMBoKQhB7PKXbf1npk2xceVKu2y7kExywb Unfortunately the wallet will not display an output at this point. There's no indication that the process was successfully completed (for now). All N persons do the same, and all N wallets will show the same address after this step. Now each person run the command: address And each N people of the multisig wallet should be shown the same address in their wallet. Receiving \u00b6 Step 1 Fund The Multisig Account \u00b6 This is simple, just send to the shared address. You can send multiple times, just like a normal wallet. You can use payment ID\u2019s as well, or generate an integrated address to receive funds. Best part, whomever is sending the funds won't be able to tell that the address belongs to a multisig wallet since it looks like any other Loki address. Step 2 Check Multisig Account Balance \u00b6 Just open the wallet and run the refresh command. Once completed, all persons can verify that the funds arrived. Person 1, 2 , 3 up to N can run the command: show_transfers To see incoming transfers or the following command to see the balance of the wallet: balance Preparation for Spending \u00b6 Step 1 - Export Multisig \u00b6 Without this step, it will not be possible to create a transaction that spends Loki. As a minimum, the sender needs to get a partial key image from all the people who will sign the transaction with them later. They could get it from the parties immediately and then later decide with whom to sign. Person N commands: export_multisig_info miN Where miN can be any filename. The output will be: Multisig info exported to miN The file miN will be located in the shell working folder* Person N sends that file to other people. Persons 2 & 3 up to N do the same. Optional: Step 1.2 Sending Multisig Info File with terminal - transfer.sh \u00b6 It is optional to use the terminal to send each person the multisig info files. Uploading Multisig Info file \u00b6 Person 1 will open up a new terminal and change to the directory mi1 has been saved.* Person 1 will run the following command: curl --upload-file ./mi1 https://transfer.sh/mi1 Person 1 will receive the link to the file as an output, looking similar to: https://transfer.sh/Ehl5q/mi1 Person 1 will need to send this link to Person 2, Person 3, .... Person N. Person 2 will need to do the same and send the link to Person 1, 3 ..... N. Person 3 will need to do the same and send the link to Person 1, 2 ..... N. Person N will need to do the same and send the link to Person 1, 2, 3, 4, 5 ...... N-1. Downloading Multisig Info file \u00b6 Person 1 should change to the directory of their loki-wallet-cli and use Person 2, 3, 4 ... N\u2019s download link to run the commands: curl <link> -o <filename> Replacing <link> with the link Person 2, 3 ... N shared with Person 1 and <filename> with the filename of the Multisig info file that Person 2, 3 or ... N generated, for example Person 1 will run the command: curl https://transfer.sh/Iedv9/mi2 -o mi2 And the command: curl https://transfer.sh/dfvr3/mi3 -o mi3 and all the way up to: curl https://transfer.sh/dfvr3/mi3 -o miN Likewise, Person 2, 3 .... and N should do the same, changing directories to their loki-wallet-cli and downloading with the alternative Persons download link, and filename. curl https://transfer.sh/Ehl5q/mi1 -o mi1 Step 2 - Import Multisig \u00b6 Now, they must all import each other's file so they can be ready to make a TX later. For example, Person 2 commands: import_multisig_info mi1 import_multisig_info mi3 import_multisig_info miN The wallet will look for files in the shell working folder* and if the files are found the output will look like: 2 outputs found in mi1 Height 1357156, transaction <88ba687dc79a0b39e6de6d0763eda8363d33d9f58ec9a096171bd9a7f1dae873>, received 0.100000000000 Height 1357161, transaction <d6ac845b9400759525519cdc5d514eb8f5b1d265b24d1c016e75b20ed3b4b7da>, received 0.100000000000 Persons 1 , 3 .... and N do the same. Spending \u00b6 Step 1 - Transfer (Preparing Unsigned Transaction) \u00b6 Any of the multisig wallets can start a transaction, it doesn't matter. To avoid weird things from happening only do it for 1 transaction at a time. If anything weird happens, do the step 1 & 2 again to fix. For example, let's say that Person 3 will make the TX. Person 3 performs the usual transfer command: transfer T6TmZX8EzZVjS9zNg7zAsrEQFDgcVC2qV2ZMyoWsbyK4SNB2SwMHZtMhPSsFyTmRBQUaGVF5k3qy5CMFM6Lvj7gi3AeszDag7 50 The output will look like: Unsigned transaction(s) successfully written to file: multisig_loki_tx Check in the folder where you started loki-wallet-cli from. There should be a file named multisig_loki_tx . Send the file multisig_loki_tx to one of the people who will sign the TX. Person 3 will send the file multisig_loki_tx to the Person 1, 2 or N. Person 3 can send this file through email or alternatively use the transfer.sh commands outside of the wallet: curl --upload-file ./multisig_loki_tx https://transfer.sh/multisig_loki_tx If Person 3 chooses to use transfer.sh command to send the file to Person 1 or 2 they will receive a <link> . Person 1 or 2 must finish the signature. Person 1 or 2 copies/downloads the file to the same folder from where he started (or will start) loki-wallet-cli . Person 1 or 2 can run the command to download the file to the loki-wallet-cli directory. curl https://transfer.sh/CJqnM/multisig_loki_tx -o multisig_loki_tx Replacing https://transfer.sh/CJqnM/multisig_loki_tx with the link provided by Person 3. Step 2 - Sign Multisig \u00b6 Let's say Person 2 was picked as the partner. They must finish the signature. Person 2 copies the file to the same folder from where he started (or will start) loki-wallet-cli . Then, Person 2 commands: sign_multisig multisig_loki_tx and they will be prompted to check it first: Loaded 1 transactions, for 108.082287779, fee 0.061108880, sending 50.000000000 to T6TmZX8EzZVjS9zNg7zAsrEQFDgcVC2qV2ZMyoWsbyK4SNB2SwMHZtMhPSsFyTmRBQUaGVF5k3qy5CMFM6Lvj7gi3AeszDag7, 58.021178899 change to T6ScXhWpAG2aUHmFemwvn4HddHA5GQ4u6MvYsW2hVteJSwLJXCEhk2aVp4XzyqGmvyUqc3w8fwWwg6szGEytUSx51C6WQ3er8, with min ring size 10, no payment ID. Is this okay? (Y/Yes/N/No): If ok, answer Y , and the output will look like: Transaction successfully submitted, transaction <3b03b16c79eaa5564171ae88242c4cdb1f9e0b41fc3de949c6524c5026a3f3bb> If the threshold is greater than 2 another multisig_loki_tx file will need to be signed by the amount of signers required. Step 3 - Submit Multisig \u00b6 Finally, person with the final signed file submits the transaction to the network by commanding: submit_multisig multisig_loki_tx There will be a confirmation prompt: Loaded 1 transactions, for 108.082287779, fee 0.061108880, sending 50.000000000 to T6TmZX8EzZVjS9zNg7zAsrEQFDgcVC2qV2ZMyoWsbyK4SNB2SwMHZtMhPSsFyTmRBQUaGVF5k3qy5CMFM6Lvj7gi3AeszDag7, 58.021178899 change to T6ScXhWpAG2aUHmFemwvn4HddHA5GQ4u6MvYsW2hVteJSwLJXCEhk2aVp4XzyqGmvyUqc3w8fwWwg6szGEytUSx51C6WQ3er8, with min ring size 10, no payment ID. Is this okay? (Y/Yes/N/No): If ok, answer Y , and the transaction will be sent. The output will look like: Transaction successfully submitted, transaction <3b03b16c79eaa5564171ae88242c4cdb1f9e0b41fc3de949c6524c5026a3f3bb> You can check its status by using the show_transfers command. The person 2 could also send the signed TX to person 3, who could then submit it to the network himself. If you want to make another one, you have to go back to preparation for spending step (sync the key images again). The wallet will look for the files and export them to the folder from where it was started, ie where your command prompt / shell was when you called loki-wallet-cli . It may or may not be the same folder as your actual wallet files or loki-wallet-cli , depending on how you go about it. For example, your wallet could be on some USB drive like f:\\temp\\ , and your wallet software on c:\\loki\\ and your shell working folder could be c:\\ . If you remain in c:\\ with the shell, you could start the wallet by its full path and specify the wallet file location: c:\\loki\\loki-wallet-cli.exe --wallet-file f:\\temp\\mywallet . In this case, all the import/export stuff would be read/written to c:\\ because that's still your shell's working folder. It would be probably feel more natural to cd into the wallet folder. Do f: to change drive and then cd f:\\temp\\ . Then, simply start the wallet from that location by its full path again: c:\\loki\\loki-wallet-cli.exe --wallet-file mywallet . Notice how you don't have to write the full wallet path now as you're already there with your shell. In this case, all the files mentioned above would be written or read from the same folder as the wallet files. Source: Monero Stack Exchange: how to use monero multisigniture wallets","title":"M/N Multsig"},{"location":"Wallets/CliWallet/MofNMultisig/#loki-mn-multisig","text":"First, the wallet to be converted to multisig must be empty. It is best to use a brand-new wallet for the purpose, although not required. It is strongly advised to make a copy of the wallet files first, just in case something goes wrong.","title":"Loki M/N Multisig"},{"location":"Wallets/CliWallet/MofNMultisig/#overview","text":"In short, the process is: Wallet Creation All parties command prepare_multisig and send data to ALL other parties All parties command make_multisig <threshold> <data1> <data2> .... <dataN> and send 2nd batch of data to ALL other parties All parties command finalize_multisig <data1> <data2> ...... <DataM> with the data from ALL other parties. Receiving All parties can type address to see the created multisig wallet address. The address will, of course, be the same for all parties since they're all watching the same wallet. Preparation for Sending To prepare for sending all parties command export_multisig_info <filename> and send the file to all other parties To complete preparation, all parties command import_multisig_info <filename1> <filename2> ..... <filenameM> and import files from other parties Sending To send, any party can use the usual transfer command, but the result will be a file named multisig_loki_tx which must be sent to any 1 other signer The other party commands sign_multisig multisig_loki_tx and the file is updated with the signature. The completely signed file is pushed to the network with use of submit_multisig multisig_loki_tx . Below is a step-by-step walkthrough.","title":"Overview"},{"location":"Wallets/CliWallet/MofNMultisig/#wallet-creation","text":"Requirements: N empty loki-wallet-cli wallets. All parties wallets connected to a lokid . Private communication channel.","title":"Wallet Creation"},{"location":"Wallets/CliWallet/MofNMultisig/#step-1-prepare-multisig","text":"All N people should open up their loki-wallet-cli and generate a new wallet. Make sure you do not have any $loki within your wallet. The 1st, 2nd, 3rd , and so on, up to the N th person commands in their loki-wallet-cli : prepare_multisig The output will be something like: MultisigV1cR7X7ZAfa5ncRmQv1hpt4P1DmmnhinhokhDMqsmuWXmHFrb6xUr3FtBGygCfMScxnKJvXK1vvPNahXNWfYWVquieBErr98sFtgs24c2YuYrQT78uxV8oYx1A9bKeHSUfYzCniN5kMznEfvKCw3FiomjLvw364gg98ZWp16zA7pUVozid Send this multisig info to all other participants, then use make_multisig <threshold> <info1> [<info2>...] with others' multisig info This includes the PRIVATE view key, so needs to be disclosed only to that multisig wallet's participants Copy the entire line Multisig\u2026...Vozid and be sure to capture the whole thing when copying. Each person must send their Multisig\u2026...arg to each other person, it is suggested to send this information through a private comunication channel.","title":"Step 1 - Prepare Multisig"},{"location":"Wallets/CliWallet/MofNMultisig/#step-2-make-multisig","text":"All N people now have the Multisig...arg text from the other N-1 people. With that, each of them can create their part of the multisig wallet. Before you proceed, note that the wallet will lose access to the underlying wallet when converted to multisig. This is not really a problem, since we started with an empty wallet, and if all goes OK with this step, you won't ever need it unless you want to go through the process again for whatever reason (like HDD died, but you have the seed mnemonic of the underlying wallet and want to reconstruct the multisig wallet). Person 1 commands: make_multisig <threshold> <data person 2> <data person 3> ..... <data person N> Where <threshold> is the number of signers required out of the N people, <data person 2> is the output provided by Person 2, and <data person 3> is the output provided by Person 3, and <data person N> is the output provided by the N th person. This is the process for M of N multisig wallets, For the below example we will show a 2 of 3 multisig wallet. This should look similar to: make_multisig 2 MultisigV12EHtuvxFyAYDNcDsbDqWHDfkRr4JZchSdf8eZQSFwiMKDk15CYEJeQyEwtSnqUZdRr2BsEaT9z2biUdDTEQM4T3N625owvKMDoyhbRj3bwkBtceLKimap8DBAiUmSABpdf62HnPYiRtLW4JdVFmfqjndhWjYBypx1duvpi3qwfSrBY9a MultisigV1TqQ8Gt5Sb3GYtVJa1fQrK7e7hPm59XbooNvLxPSBR4856bW9jtD1hEyWy4yULKrX7reZZ6vrKdBCdSdk4nfApCGYJAA2WP4pKNwHDyKTuLEeuoDhqno8keEVeEF9AZsWXvng1avUTRREmy11h8wu8pdjopC4AguQKiHCJCN7aT9W6b8C Notice how there are 2 strings starting with Multisig....arg . One is from person 2 and other from person 3, if their is 5 different people their would be 4 different strings of Multisig....arg . The number at the beginning is the minimum required number of signatures. Since it's a 2/3 scheme - it's 2. To reiterate, for a 5/8 scheme which means there are 8 people who can sign and 5 people must sign to authorise a transaction out of the Multi signature wallet. In this circumstance, the command each person would run has a <threshold> that equals 5 and 7 strings of multisig...arg . The output from the make_multisig command will be similar to: Another step is needed MultisigxV1PKCwmVrucV8bXi18VnHFqRXcnAq4osFL3ahzPHCiN48zhs28u6jmEhy7ktZbUEGfRtTuFjjKzJYb61fnFwnysBBnNXsUtCgFMXPa7FyNKVy2AnUg3ePEnKqWkgKVvA81axTS8r9EX1DmVPXgFKkFzw4Yj4ZtMcJVo77b5ayuMzjFtsaijko9X2bjd9AVfFVGBFMCSLa4xXhNVNz19CTUJx5gpoPG Send this multisig info to all other participants, then use finalize_multisig <info1> [<info2>...] with others' multisig info With any M of N schemes there's an additional step to be done here. The new Multisig...arg info that was just outputted must be passed to ALL other participants (For person 1 they must send it to persons 2 & 3 ... all the way up to person N). Persons N sends the new output to all other persons.","title":"Step 2 - Make Multisig"},{"location":"Wallets/CliWallet/MofNMultisig/#step-3-finalize-multisig","text":"Here we do one last command to make the wallet ready for receiving. It requires the 2nd batch of Multisig\u2026....arg strings received from other parties. Person N will run the command: finalize_multisig MultisigxV1Vg1tsRLurvAc5aSA9Hd9God3MQhijCFoE1rPDFzx7ufwhs28u6jmEhy7ktZbUEGfRtTuFjjKzJYb61fnFwnysBBnfYm4xJWcJ4qM4khSb2KkyAKDuT39pTvdmemhojNjeYCmgSQ1NZLyBj48R1tVpiGNxa7TDnGbSgLuKBq35AX6jfu5PECAcDDn22CFQbJZip7xnBbn89Szzh27xeozfxcLiqqm MultisigxV14xDZBGACz3iUh2aVKGE5q5VzcvJdg2qCvZECgUWCdy5QNXsUtCgFMXPa7FyNKVy2AnUg3ePEnKqWkgKVvA81axTSfYm4xJWcJ4qM4khSb2KkyAKDuT39pTvdmemhojNjeYCmCNaRSsDEcemLLL8wCvzsy5R6hhkhWLYkD9vhZwprSFFKMZ7tfRko2VfMBoKQhB7PKXbf1npk2xceVKu2y7kExywb Unfortunately the wallet will not display an output at this point. There's no indication that the process was successfully completed (for now). All N persons do the same, and all N wallets will show the same address after this step. Now each person run the command: address And each N people of the multisig wallet should be shown the same address in their wallet.","title":"Step 3 - Finalize Multisig"},{"location":"Wallets/CliWallet/MofNMultisig/#receiving","text":"","title":"Receiving"},{"location":"Wallets/CliWallet/MofNMultisig/#step-1-fund-the-multisig-account","text":"This is simple, just send to the shared address. You can send multiple times, just like a normal wallet. You can use payment ID\u2019s as well, or generate an integrated address to receive funds. Best part, whomever is sending the funds won't be able to tell that the address belongs to a multisig wallet since it looks like any other Loki address.","title":"Step 1 Fund The Multisig Account"},{"location":"Wallets/CliWallet/MofNMultisig/#step-2-check-multisig-account-balance","text":"Just open the wallet and run the refresh command. Once completed, all persons can verify that the funds arrived. Person 1, 2 , 3 up to N can run the command: show_transfers To see incoming transfers or the following command to see the balance of the wallet: balance","title":"Step 2 Check Multisig Account Balance"},{"location":"Wallets/CliWallet/MofNMultisig/#preparation-for-spending","text":"","title":"Preparation for Spending"},{"location":"Wallets/CliWallet/MofNMultisig/#step-1-export-multisig","text":"Without this step, it will not be possible to create a transaction that spends Loki. As a minimum, the sender needs to get a partial key image from all the people who will sign the transaction with them later. They could get it from the parties immediately and then later decide with whom to sign. Person N commands: export_multisig_info miN Where miN can be any filename. The output will be: Multisig info exported to miN The file miN will be located in the shell working folder* Person N sends that file to other people. Persons 2 & 3 up to N do the same.","title":"Step 1 - Export Multisig"},{"location":"Wallets/CliWallet/MofNMultisig/#optional-step-12-sending-multisig-info-file-with-terminal-transfersh","text":"It is optional to use the terminal to send each person the multisig info files.","title":"Optional: Step 1.2 Sending Multisig Info File with terminal - transfer.sh"},{"location":"Wallets/CliWallet/MofNMultisig/#uploading-multisig-info-file","text":"Person 1 will open up a new terminal and change to the directory mi1 has been saved.* Person 1 will run the following command: curl --upload-file ./mi1 https://transfer.sh/mi1 Person 1 will receive the link to the file as an output, looking similar to: https://transfer.sh/Ehl5q/mi1 Person 1 will need to send this link to Person 2, Person 3, .... Person N. Person 2 will need to do the same and send the link to Person 1, 3 ..... N. Person 3 will need to do the same and send the link to Person 1, 2 ..... N. Person N will need to do the same and send the link to Person 1, 2, 3, 4, 5 ...... N-1.","title":"Uploading Multisig Info file"},{"location":"Wallets/CliWallet/MofNMultisig/#downloading-multisig-info-file","text":"Person 1 should change to the directory of their loki-wallet-cli and use Person 2, 3, 4 ... N\u2019s download link to run the commands: curl <link> -o <filename> Replacing <link> with the link Person 2, 3 ... N shared with Person 1 and <filename> with the filename of the Multisig info file that Person 2, 3 or ... N generated, for example Person 1 will run the command: curl https://transfer.sh/Iedv9/mi2 -o mi2 And the command: curl https://transfer.sh/dfvr3/mi3 -o mi3 and all the way up to: curl https://transfer.sh/dfvr3/mi3 -o miN Likewise, Person 2, 3 .... and N should do the same, changing directories to their loki-wallet-cli and downloading with the alternative Persons download link, and filename. curl https://transfer.sh/Ehl5q/mi1 -o mi1","title":"Downloading Multisig Info file"},{"location":"Wallets/CliWallet/MofNMultisig/#step-2-import-multisig","text":"Now, they must all import each other's file so they can be ready to make a TX later. For example, Person 2 commands: import_multisig_info mi1 import_multisig_info mi3 import_multisig_info miN The wallet will look for files in the shell working folder* and if the files are found the output will look like: 2 outputs found in mi1 Height 1357156, transaction <88ba687dc79a0b39e6de6d0763eda8363d33d9f58ec9a096171bd9a7f1dae873>, received 0.100000000000 Height 1357161, transaction <d6ac845b9400759525519cdc5d514eb8f5b1d265b24d1c016e75b20ed3b4b7da>, received 0.100000000000 Persons 1 , 3 .... and N do the same.","title":"Step 2 - Import Multisig"},{"location":"Wallets/CliWallet/MofNMultisig/#spending","text":"","title":"Spending"},{"location":"Wallets/CliWallet/MofNMultisig/#step-1-transfer-preparing-unsigned-transaction","text":"Any of the multisig wallets can start a transaction, it doesn't matter. To avoid weird things from happening only do it for 1 transaction at a time. If anything weird happens, do the step 1 & 2 again to fix. For example, let's say that Person 3 will make the TX. Person 3 performs the usual transfer command: transfer T6TmZX8EzZVjS9zNg7zAsrEQFDgcVC2qV2ZMyoWsbyK4SNB2SwMHZtMhPSsFyTmRBQUaGVF5k3qy5CMFM6Lvj7gi3AeszDag7 50 The output will look like: Unsigned transaction(s) successfully written to file: multisig_loki_tx Check in the folder where you started loki-wallet-cli from. There should be a file named multisig_loki_tx . Send the file multisig_loki_tx to one of the people who will sign the TX. Person 3 will send the file multisig_loki_tx to the Person 1, 2 or N. Person 3 can send this file through email or alternatively use the transfer.sh commands outside of the wallet: curl --upload-file ./multisig_loki_tx https://transfer.sh/multisig_loki_tx If Person 3 chooses to use transfer.sh command to send the file to Person 1 or 2 they will receive a <link> . Person 1 or 2 must finish the signature. Person 1 or 2 copies/downloads the file to the same folder from where he started (or will start) loki-wallet-cli . Person 1 or 2 can run the command to download the file to the loki-wallet-cli directory. curl https://transfer.sh/CJqnM/multisig_loki_tx -o multisig_loki_tx Replacing https://transfer.sh/CJqnM/multisig_loki_tx with the link provided by Person 3.","title":"Step 1 - Transfer (Preparing Unsigned Transaction)"},{"location":"Wallets/CliWallet/MofNMultisig/#step-2-sign-multisig","text":"Let's say Person 2 was picked as the partner. They must finish the signature. Person 2 copies the file to the same folder from where he started (or will start) loki-wallet-cli . Then, Person 2 commands: sign_multisig multisig_loki_tx and they will be prompted to check it first: Loaded 1 transactions, for 108.082287779, fee 0.061108880, sending 50.000000000 to T6TmZX8EzZVjS9zNg7zAsrEQFDgcVC2qV2ZMyoWsbyK4SNB2SwMHZtMhPSsFyTmRBQUaGVF5k3qy5CMFM6Lvj7gi3AeszDag7, 58.021178899 change to T6ScXhWpAG2aUHmFemwvn4HddHA5GQ4u6MvYsW2hVteJSwLJXCEhk2aVp4XzyqGmvyUqc3w8fwWwg6szGEytUSx51C6WQ3er8, with min ring size 10, no payment ID. Is this okay? (Y/Yes/N/No): If ok, answer Y , and the output will look like: Transaction successfully submitted, transaction <3b03b16c79eaa5564171ae88242c4cdb1f9e0b41fc3de949c6524c5026a3f3bb> If the threshold is greater than 2 another multisig_loki_tx file will need to be signed by the amount of signers required.","title":"Step 2 - Sign Multisig"},{"location":"Wallets/CliWallet/MofNMultisig/#step-3-submit-multisig","text":"Finally, person with the final signed file submits the transaction to the network by commanding: submit_multisig multisig_loki_tx There will be a confirmation prompt: Loaded 1 transactions, for 108.082287779, fee 0.061108880, sending 50.000000000 to T6TmZX8EzZVjS9zNg7zAsrEQFDgcVC2qV2ZMyoWsbyK4SNB2SwMHZtMhPSsFyTmRBQUaGVF5k3qy5CMFM6Lvj7gi3AeszDag7, 58.021178899 change to T6ScXhWpAG2aUHmFemwvn4HddHA5GQ4u6MvYsW2hVteJSwLJXCEhk2aVp4XzyqGmvyUqc3w8fwWwg6szGEytUSx51C6WQ3er8, with min ring size 10, no payment ID. Is this okay? (Y/Yes/N/No): If ok, answer Y , and the transaction will be sent. The output will look like: Transaction successfully submitted, transaction <3b03b16c79eaa5564171ae88242c4cdb1f9e0b41fc3de949c6524c5026a3f3bb> You can check its status by using the show_transfers command. The person 2 could also send the signed TX to person 3, who could then submit it to the network himself. If you want to make another one, you have to go back to preparation for spending step (sync the key images again). The wallet will look for the files and export them to the folder from where it was started, ie where your command prompt / shell was when you called loki-wallet-cli . It may or may not be the same folder as your actual wallet files or loki-wallet-cli , depending on how you go about it. For example, your wallet could be on some USB drive like f:\\temp\\ , and your wallet software on c:\\loki\\ and your shell working folder could be c:\\ . If you remain in c:\\ with the shell, you could start the wallet by its full path and specify the wallet file location: c:\\loki\\loki-wallet-cli.exe --wallet-file f:\\temp\\mywallet . In this case, all the import/export stuff would be read/written to c:\\ because that's still your shell's working folder. It would be probably feel more natural to cd into the wallet folder. Do f: to change drive and then cd f:\\temp\\ . Then, simply start the wallet from that location by its full path again: c:\\loki\\loki-wallet-cli.exe --wallet-file mywallet . Notice how you don't have to write the full wallet path now as you're already there with your shell. In this case, all the files mentioned above would be written or read from the same folder as the wallet files. Source: Monero Stack Exchange: how to use monero multisigniture wallets","title":"Step 3 - Submit Multisig"},{"location":"Wallets/CliWallet/TroubleshootCli/","text":"TO DO","title":"TroubleshootCli"},{"location":"Wallets/CliWallet/WalletCommands/","text":"Loki CLI Guide \u00b6 The Loki CLI wallet is a wallet first developed by Monero. Loki has added additional commands ontop of the monero-wallet-cli and this document goes through all the Loki and Monero CLI commands available within the loki-wallet-cli . Displaying commands \u00b6 The loki-wallet-cli has multiple commands to conduct different operations on the Loki Blockchain. By typing help and clicking enter after loading your wallet will bring up the commands that can be used. 1 Accounts \u00b6 1.1 Creating new account \u00b6 When a wallet is generated it will automatically have an account labelled Primary account with index 0 . If at any time you wish to create an additional account use the command: account new <label text with white spaces allowed> This command will create a subaddress which is labelled with a tag and index number. This subaddress will share the same seed as your Primary address. To ensure this new account is displayed you must type exit to save your session. You will note that there is now an asterisk to the left of index 1. The asterisks show us the account in which the commands we run will apply to. Note: Restoring your wallet from your seed will not restore your accounts as the index of your subaddress data is stored on your computer within your wallet file. All the funds stored in your additional accounts will be shown in your Primary account if you need to restore your wallet from scratch. [wallet L9LnR2]: account new Secondary account [wallet L9LnR2]: Untagged accounts: [wallet L9LnR2]: Account Balance Unlocked balance Label [wallet L9LnR2]: 0 L9LnR2 0.000000000 0.000000000 Primary account [wallet L9LnR2]: * 1 LY5J5W 0.000000000 0.000000000 Secondary account [wallet L9LnR2]: ---------------------------------------------------------------------------------- [wallet L9LnR2]: Total 0.000000000 0.000000000 1.2 Switching account \u00b6 When transferring out or receiving to a specific account we need to make sure that the account we are performing the action is the one the CLI is currently connected to. An asterisk will show which account we are connected to. In the below example the asterisk is shown to the left of Secondary account so any operations will be associated with that account. Each of the accounts connected to your Primary address will have an index associated with them. The index number will be shown to the left of the Account column. By default, index \u201c0\u201d is your Primary account. [wallet L9LnR2]: account new Secondary account [wallet L9LnR2]: Untagged accounts: [wallet L9LnR2]: Account Balance Unlocked balance Label [wallet L9LnR2]: 0 L9LnR2 0.000000000 0.000000000 Primary account [wallet L9LnR2]: * 1 LY5J5W 0.000000000 0.000000000 Secondary account [wallet L9LnR2]: ---------------------------------------------------------------------------------- [wallet L9LnR2]: Total 0.000000000 0.000000000 To switch between the accounts you have created run the command: account switch <index> After running the command a similar output shown below will be on your terminal. [wallet L9LnR2]: account switch 0 [wallet L9LnR2]: Currently selected account: [0] Primary account [wallet L9LnR2]: Tag: (No tag assigned) [wallet L9LnR2]: Balance: 0.000000000, unlocked balance: 0.000000000 1.3 Changing account labels \u00b6 To change the label name connected to a specific Loki Primary or Sub-address use the command: account label <index> <label text with white spaces allowed> Replacing <index> with the index number associated with the account you wish to relabel, and replacing <label text with white spaces allowed> with the new label you would like to name the specified account. Below shows the current accounts and labels for a specific wallet. [wallet LCmjSH]: Untagged accounts: [wallet LCmjSH]: Account Balance Unlocked balance Label [wallet LCmjSH]: * 0 LCmjSH 0.000000000 0.000000000 Primary account [wallet LCmjSH]: 1 LTLgNy 0.000000000 0.000000000 Secondary [wallet LCmjSH]: ---------------------------------------------------------------------------------- [wallet LCmjSH]: Total 0.000000000 0.000000000 Using the command account label 0 My Account we have changed the label connected to our Primary address from \u201cPrimary account\u201d to \u201cMy Account\u201d. [wallet LCmjSH]: account label 0 My Account [wallet LCmjSH]: Untagged accounts: [wallet LCmjSH]: Account Balance Unlocked balance Label [wallet LCmjSH]: * 0 LCmjSH 0.000000000 0.000000000 My Account [wallet LCmjSH]: 1 LTLgNy 0.000000000 0.000000000 Secondary [wallet LCmjSH]: ---------------------------------------------------------------------------------- [wallet LCmjSH]: Total 0.000000000 0.000000000 1.4 Tagging and untagging accounts: \u00b6 The loki-wallet-cli allows you to group accounts by tagging or untagging them. Below shows a wallet with 4 accounts, Dog, Kid 1 and Kid 2. [wallet LVP3bv]: Untagged accounts: [wallet LVP3bv]: Account Balance Unlocked balance Label [wallet LVP3bv]: 0 LAXk6e 0.000000000 0.000000000 My Account [wallet LVP3bv]: 1 LRDvY6 0.000000000 0.000000000 Dog [wallet LVP3bv]: 2 LVJDwN 0.000000000 0.000000000 Kid 1 [wallet LVP3bv]: * 3 LVP3bv 0.000000000 0.000000000 Kid 2 [wallet LVP3bv]: ---------------------------------------------------------------------------------- [wallet LVP3bv]: Total 0.000000000 0.000000000 We can tag a single account with the following command: account tag <tag_name> <account_index> [wallet LVP3bv]: account tag Pets 1 [wallet LVP3bv]: Accounts with tag: Pets [wallet LVP3bv]: Tag's description: [wallet LVP3bv]: Account Balance Unlocked balance Label [wallet LVP3bv]: 1 LRDvY6 0.000000000 0.000000000 Dog [wallet LVP3bv]: ---------------------------------------------------------------------------------- [wallet LVP3bv]: Total 0.000000000 0.000000000 When needing to perform multiple tags we can do it through one command: account tag <tag_name> <account_index_1> [<account_index_2> ...] [wallet LVP3bv]: account tag Family 2 3 [wallet LVP3bv]: Accounts with tag: Family [wallet LVP3bv]: Tag's description: [wallet LVP3bv]: Account Balance Unlocked balance Label [wallet LVP3bv]: 2 LVJDwN 0.000000000 0.000000000 Kid 1 [wallet LVP3bv]: * 3 LVP3bv 0.000000000 0.000000000 Kid 2 [wallet LVP3bv]: ---------------------------------------------------------------------------------- [wallet LVP3bv]: Total 0.000000000 0.000000000 Similarly we can untag accounts by running the following command: account untag <account_index_1> [<account_index_2> ...] Using the above exampled wallet we will remove our \u201cDog\u201d account from \u201cPets\u201d. [wallet LVP3bv]: account untag 1 [wallet LVP3bv]: Accounts with tag: Family [wallet LVP3bv]: Tag's description: [wallet LVP3bv]: Account Balance Unlocked balance Label [wallet LVP3bv]: 2 LVJDwN 0.000000000 0.000000000 Kid 1 [wallet LVP3bv]: * 3 LVP3bv 0.000000000 0.000000000 Kid 2 [wallet LVP3bv]: ---------------------------------------------------------------------------------- [wallet LVP3bv]: Total 0.000000000 0.000000000 [wallet LVP3bv]: [wallet LVP3bv]: Untagged accounts: [wallet LVP3bv]: Account Balance Unlocked balance Label [wallet LVP3bv]: 0 LAXk6e 0.000000000 0.000000000 My Account [wallet LVP3bv]: 1 LRDvY6 0.000000000 0.000000000 Dog [wallet LVP3bv]: ---------------------------------------------------------------------------------- [wallet LVP3bv]: Total 0.000000000 0.000000000 1.5 Adding Tag descriptions \u00b6 If you require additional information attached to a specific tag you can add a description with the following command: account tag_description <tag_name> <description> For example: [wallet LVP3bv]: account tag_description Family This is my family. [wallet LVP3bv]: Accounts with tag: Family [wallet LVP3bv]: Tag's description: This is my family. [wallet LVP3bv]: Account Balance Unlocked balance Label [wallet LVP3bv]: 2 LVJDwN 0.000000000 0.000000000 Kid 1 [wallet LVP3bv]: * 3 LVP3bv 0.000000000 0.000000000 Kid 2 [wallet LVP3bv]: ---------------------------------------------------------------------------------- [wallet LVP3bv]: Total 0.000000000 0.000000000 2 Balance \u00b6 To check the balance of your wallet you can run one of two commands: balance or balance detail Running the command balance will generated a simple output showing your balance and unlocked balance of the specific account you are in. For example: [wallet T6TmZX]: balance Currently selected account: [0] Primary account Tag: (No tag assigned) Balance: 172286.035054991, unlocked balance: 172086.338373771 While running the command balance detail will generate a more detailed output, showing the account number, first few characters of the address, balance, unlocked balance, Outputs and the Label of the account. For example: [wallet T6TmZX]: balance detail Currently selected account: [0] Primary account Tag: (No tag assigned) Balance: 172286.035054991, unlocked balance: 172086.338373771 Balance per address: Address Balance Unlocked balance Outputs Label 0 T6TmZX 172286.035054991 172086.338373771 3347 Primary account There are other commands that will also output the balance which have been covered by this guide, such as the account command. 3 Getting the Block Height \u00b6 To show the blockchain height run the command: bc_height 4 Blackballing Transactions \u00b6 Blackballing transactions allows you to ignore others' outputs (containers of money) that are known to be spent in a certain transaction. For example let\u2019s imagine that txid: 4f4b371a0da8858bbeab8a40ff37de1f6ff33e64a616e5ced8239062570b7542 is known to be fake and if this txid is seen within a RingCT transaction the network can assume it is fake, therefore an actor has a better chance of deducing the real transaction within the RingCT. By blackballing the above txid we remove the chance of it being used within our RingCT. To do this we will use the following command: blackball <output public key> | <filename> [add] For example: [wallet LAXk6e]: blackball 4f4b371a0da8858bbeab8a40ff37de1f6ff33e64a616e5ced8239062570b7542 To check if the txid was added to our list of txids not to use we can use the following command: blackballed <output public key> If the txid is on our list the following will output: [wallet LAXk6e]: blackballed 4f4b371a0da8858bbeab8a40ff37de1f6ff33e64a616e5ced8239062570b7542 [wallet LAXk6e]: Blackballed: <4f4b371a0da8858bbeab8a40ff37de1f6ff33e64a616e5ced8239062570b7542> Alternatively if the txid is not on our list the following will output: [wallet LAXk6e]: blackballed 4f4b371a0da8858bbeab8a40ff37de1f6ff33e64a616e5ced8239062570b7542 [wallet LAXk6e]: not blackballed: <4f4b371a0da8858bbeab8a40ff37de1f6ff33e64a616e5ced8239062570b7542> To unblackball a txid use the following command: unblackball <output public key> For example: [wallet LAXk6e]: unblackball 4f4b371a0da8858bbeab8a40ff37de1f6ff33e64a616e5ced8239062570b7542 5 Reserve Proof \u00b6 Reserve Proofs are used to generate a signature proving that you own an amount of Loki, with the option to sign the reserve proof with a key. For example let\u2019s imagine you see a car for sale but they will accept Loki as payment, however they have advised in their online listing that they are only interested in serious buyers and require you to prove you have the Loki within your initial contact. Luckily we can use the Reserve Proof commands for this proof. 5.1 Generate Reserve Proof \u00b6 To begin we will need to run the get_reserve_proof command to generate our proof. get_reserve_proof (all|<amount>) [<message>] If the individual you are sending this proof to requires you to prove you have 1000 Loki you will need to replace the section (all|<amount>) with a 1000, otherwise replace it with the amount you need to prove you have reserved. If you want to put an extra layer of encryption over the file replace [<message>] with a password. Your command will similar to the below command: get_reserve_proof 1000 Car The Cli will request your wallet password and once your password is entered it will tell you it generated a signature file. [wallet T6TmZX]: get_reserve_proof 1000 Car Wallet password: signature file saved to: loki_reserve_proof This signature file loki_reserve_proof will be saved in your Loki folder, where your daemon and wallet keys are. Keep in mind every time you run the get_reserve_proof command it will overwrite your loki_reserve_proof file. You will want to send this file to the person who requires the proof. You can upload the loki_reserve_proof file through https://transfer.sh/ by running the command within the folder of your signature file: curl --upload-file ./loki_reserve_proof https://transfer.sh/loki_reserve_proof` The terminal will then print out a link to your signature file which you can then provide to the individual performing the check. https://transfer.sh/QhoC7/loki_reserve_proof Make sure you provide the following to the individual who will be checking your reserve proof: The loki_reserve_proof file through the transfer.sh link. The loki address you are proving has Loki in it. The <message> if you encrypted the file. 5.2 Checking Reserve Proof \u00b6 To check a reserve proof we need to first have the loki_reserve_proof file in our Loki folder. If you do not have the loki_reserve_proof file in your loki folder request the individual sending the file to you to use https://transfer.sh/ , once they send you the link to their loki_reserve_proof you can use the following command to download it. curl <link> -o loki_reserve_proof Replacing <link> with the link to download the loki_reserve_proof . Now that the loki_reserve_proof is in our folder we can run the following command: check_reserve_proof <address> <signature_file> [<message>] Where <address> is the address of the wallet where the command get_reserve_proof was ran. <signiture_file> is the file that was received from the individual sending you the reserve proof, normally generated as loki_reserve_proof and <message> is the key set by the individual who sent you the reserve proof. Therefor for the previous example where we created a reserve proof for 1000 loki and signed with \u201ccar\u201d, we would run the command: check_reserve_proof T6TmZX8EzZVjS9zNg7zAsrEQFDgcVC2qV2ZMyoWsbyK4SNB2SwMHZtMhPSsFyTmRBQUaGVF5k3qy5CMFM6Lvj7gi3AeszDag7 loki_reserve_proof Car If all goes well, the terminal will output the following: Good signature -- total: 1014.862440831, spent: 0.000000000, unspent: 1014.862440831 You may note that it shows a reserve proof which is greater than 1000, this is because the command is adding up all the transactions into the address specified until it is greater than the reserve proof set. 6 Spend Proof \u00b6 Spend Proofs are used to generate a signature proving that you generated a TXID, with the option to sign the spend proof with a key. For example let\u2019s imagine you have bought a car from a dealership with loki and have sent 1000 loki to the seller. Unfortunately the dealer does not know which transaction is yours as he has received 5 transactions of 1000 loki in the same block for 5 different cars. He knows the txid\u2019s but wants you to prove that you have generate one of the txid\u2019s in his list. Luckily we can prove we generated the txid by using the get_spend_proof command. 6.1 Generate Spend Proof \u00b6 To begin we will first need to find the txid associated with our transaction. To do this run the following command in our wallet: show_transfers The terminal will output a list of transactions in and out of your address. You should have a transaction in your list with the amount you spent to the dealership. Copy the txid(by highlighting) associated with this transaction and save it in a notepad for later. We can now run the get_spend_proof command to generate our proof. get_spend_proof <txid> [<message>] Replacing <txid> with the txid of our transfer out and replacing <message> if we want to add a password to the proof. If all went well the terminal will output the following text: signature file saved to: loki_spend_proof This signature file loki_spend_proof will be saved in your Loki folder, where your daemon and wallet keys are. Keep in mind every time you run the get_spend_proof command it will overwrite your loki_spend_proof file . You will want to send this file to the person who requires the proof. You can upload the loki_spend_proof file through https://transfer.sh/ by running the command within the folder of your signature file: curl --upload-file ./loki_spend_proof https://transfer.sh/loki_spend_proof The terminal will then print out a link to your signature file which you can then provide to the individual performing the check. For example: https://transfer.sh/QhoC7/loki_spend_proof Make sure you provide the following to the individual who will be checking your reserve proof: The loki_spend_proof file through the transfer.sh link. The loki transaction txid associated with the transaction you are proving you generated. The <message> if you encrypted the file. 6.2 Checking Spend Proof \u00b6 To check a spend proof we need to first have the loki_spend_proof file in our Loki folder and the txid associated with the transaction being proved. If you do not have the loki_spend_proof file in your loki folder request the individual sending the file to you to use https://transfer.sh/ , once they send you the link to their loki_spend_proof you can use the following command to download it. curl <link> -o loki_spend_proof Replacing <link> with the link to download the loki_spend_proof . Now that the loki_spend_proof is in our folder we can run the following command: check_spend_proof <txid> <signature_file> [<message>] Where <txid> is the txid associated with the transaction that is being proved. <signiture_file> is the file that was received from the individual sending you the spend proof, normally generated as loki_spend_proof and <message> is the key set by the individual who sent you the spend proof. An example would look like the following command check_spend_proof 20eb3b5545d6587e5a379feb2fc69b43d4f8b6b825bb7eff78e263d4e7e8eaa9 loki_spend_proof car If all goes well, the terminal will output the following: Good signature If you receive a Good signature message that should be a good proof that the txid you are checking was generated from the sender. Keep in mind however that this can potentially not always be the case, considering someone could get access to someone else's computer thus having access to this file. 7 TX Proof \u00b6 TX Proofs are used to generate a signature file proving that you generated a TXID, with the option to sign the spend proof with a key. TX proofs work similar to Reserve Proof\u2019s and Spend Proofs however they show more detailed information. For example let\u2019s imagine you have bought a car from a dealership with loki and have sent 1000 loki to the seller. Unfortunately the dealer does not know which transaction is yours as he has received 5 transactions of 1000 loki in the same block for 5 different cars. He knows the txid\u2019s but wants you to prove that you have generate one of the txid\u2019s in his list. Luckily we can prove we generated the txid by using the get_tx_proof command. 7.1 Generate Spend Proof \u00b6 To begin we will first need to find the txid associated with our transaction. To do this run the following command in our wallet: show_transfers The terminal will output a list of transactions in and out of your address. You should have a transaction in your list with the amount you spent to the dealership. Copy the txid(by highlighting) associated with this transaction and save it in a notepad for later. We can now run the get_tx_proof command to generate our proof. get_tx_proof <txid> <address> [<message>] Replacing <txid> with the txid of our transfer out, <address> with the receiver's address, and replacing <message> if we want to add a password to the proof. If all went well the terminal will output the following text: signature file saved to: loki_tx_proof This signature file loki_tx_proof will be saved in your Loki folder, where your daemon and wallet keys are. Keep in mind every time you run the get_tx_proof command it will overwrite your loki_tx_proof file. You will want to send this file to the person who requires the proof. You can upload the loki_tx_proof file through https://transfer.sh/ by running the command within the folder of your signature file: curl --upload-file ./loki_tx_proof https://transfer.sh/loki_tx_proof The terminal will then print out a link to your signature file which you can then provide to the individual performing the check. For example: https://transfer.sh/QhoC7/loki_tx_proof Make sure you provide the following to the individual who will be checking your reserve proof: The loki_tx_proof file through the transfer.sh link. The loki transaction txid associated with the transaction you are proving you generated. The receivers loki address. The <message> if you encrypted the file. 7.2 Checking tx Proof \u00b6 To check a tx proof we need to first have the loki_tx_proof file in our Loki folder, the receiver's address and the txid associated with the transaction being proved. If you do not have the loki_tx_proof file in your loki folder request the individual sending the file to you to use https://transfer.sh/ , once they send you the link to their loki_tx_proof you can use the following command to download it. curl <link> -o loki_tx_proof Replacing <link> with the link to download the loki_tx_proof . Now that the loki_tx_proof is in our folder we can run the following command: check_tx_proof <txid> <address> <signature_file> [<message>] Where <txid> is the txid associated with the transaction that is being proved, <address> is the receiver\u2019s address and <signiture_file> is the file that was received from the individual sending you the tx proof, normally generated as loki_tx_proof and <message> is the key set by the individual who sent you the tx proof. An example would look like the following command: check_tx_proof 3f8c62b4d83100ff4f89b44a96350e65aeaa83a9b4273c31f94b9aa12e713044 TRrEpWMLd3rRuirYqsjg1iaNsukAAojWjFDhJ2kK2o4uM6tkcjMerA4SZNat6QHEYe1SoGCFQddVPgRqmkA8kARX1ffU1Wcjc loki_tx_proof If all goes well, the terminal will output the following: Good signature TRrEpWMLd3rRuirYqsjg1iaNsukAAojWjFDhJ2kK2o4uM6tkcjMerA4SZNat6QHEYe1SoGCFQddVPgRqmkA8kARX1ffU1Wcjc received 40000.000000 in txid <3f8c62b4d83100ff4f89b44a96350e65aeaa83a9b4273c31f94b9aa12e713044> This transaction has 1 confirmations If you receive a Good signature message that should be a good proof that the txid you are checking was generated from the sender. Keep in mind however that this can potentially not always be the case, considering someone could get access to someone else's computer thus having access to this file. 8 TX key \u00b6 A TX key is a private key associated with a TXid. Only the wallet that has sent the transaction can generate a TX key from the TXID that both parties can see. A TX key can be used to validate a transaction on a case by case basis. In essence, you can provide the tx key, txid and the receiver address to someone to prove you had generate that transaction. 8.1 View TX key \u00b6 To view the TX key of a specific transaction you have generate you will need to run the command: get_tx_key <txid> Where <txid> is the transaction id associated with the transfer out you are proving is yours. The terminal will prompt the user for the wallets password and then print out the tx key, which will look similar to: [wallet T6TmZX]: get_tx_key d5fb415aad43f4e45bc72566d5ad4c8f12629db1f924d953efc2521c137a987f Wallet password: Tx key: 5dfc4d677e2707317f306219b6aa445feaab4c652927237c012f7e72cb41bf0e Provide the <tx key> with the <txid> and <receiving address> to the individual who will run the validation, thus this will prove you generated the transaction. 8.2 Validate transaction with TX key \u00b6 Once we have a <tx key> , <txid> and <receiving address> from a specific transaction we can use the following command to prove they are all associated: check_tx_key <txid> <txkey> <address> For the previous example we would run the following command from any loki wallet: check_tx_key d5fb415aad43f4e45bc72566d5ad4c8f12629db1f924d953efc2521c137a987f 5dfc4d677e2707317f306219b6aa445feaab4c652927237c012f7e72cb41bf0e T6TZ2VaG1p9PQkDgdVCYwnjoxYSU7ErXX56etGsqHLugAGqynFwBvP4dnN7wvYCcJfMa9LPgtYu8UEUqyc4xsxmx2ZTyMp4U3 The terminal will show text of how much Loki the address received. It will also show how many confirmations the transaction has received from the blockchain. For example: [wallet T6TZ2V]: check_tx_key d5fb415aad43f4e45bc72566d5ad4c8f12629db1f924d953efc2521c137a987f 5dfc4d677e2707317f306219b6aa445feaab4c652927237c012f7e72cb41bf0e T6TZ2VaG1p9PQkDgdVCYwnjoxYSU7ErXX56etGsqHLugAGqynFwBvP4dnN7wvYCcJfMa9LPgtYu8UEUqyc4xsxmx2ZTyMp4U3 T6TZ2VaG1p9PQkDgdVCYwnjoxYSU7ErXX56etGsqHLugAGqynFwBvP4dnN7wvYCcJfMa9LPgtYu8UEUqyc4xsxmx2ZTyMp4U3 received 10000.000000000 in txid <d5fb415aad43f4e45bc72566d5ad4c8f12629db1f924d953efc2521c137a987f> This transaction has 10 confirmations 9 Tx Notes \u00b6 The loki-wallet-cli allows you to add notes to specific txid\u2019s, however this note does not get stored on the blockchain, rather it is stored on client side, on the device that generates the tx_note . 9.1 Set tx note \u00b6 To set a tx note we will need a the <txid> and the <message> you want to add to the txid. For instance, if you want to add a note to a txid that is connected to your wallet run the following command to show your transactions in/out with their <txid> \u2019s: show_transfers To set the note to the <txid> run the following command: set_tx_note <txid> [free text note] Where <txid> is the transaction id associated to the transaction you are adding the [free text note] too. Your command will look similar to the following example: [wallet T6TmZX]: set_tx_note d5fb415aad43f4e45bc72566d5ad4c8f12629db1f924d953efc2521c137a987f This is a tx note example. 9.2 View tx note \u00b6 To view a note connected to a txid run the following command: get_tx_note <txid> Where <txid> is the transaction id that has the note connected to it. For example, if we run the command on the previous <txid> mentioned, the terminal will display the following text: [wallet T6TmZX]: get_tx_note d5fb415aad43f4e45bc72566d5ad4c8f12629db1f924d953efc2521c137a987f note found: This is a tx note example. You can also view a tx note by running the show_transfers command, each transaction that has a note connected to it will display the text to the right of each transfer. 10 Changing wallet password \u00b6 Changing the wallet password is only client side(locally), and if the password is forgotten the wallet can always be restored with the mnemonic seed. If you know the password to the wallet and want to change it you can run the following command: password Once the command has been run the terminal will prompt you for the current password and the new password twice. If entered correctly the terminal will go back to receiving inputs, otherwise the terminal will output an error such as Passwords do not match! Please try again or Error: invalid password . 11 Encrypting seed phrase \u00b6 Your seed passphrase is a 25 word phrase which is used to recover access to your wallet on a client or gui and is. The command encrypted_seed allows your to add an additional password, or encryption layer, to your 25 word mnemonic seed. Encrypting your seed will stop others from recovering access to your wallet if they somehow gain access to your 25 word mnemonic seed as they will not have the passphrase that decrypts them. This means, your passphrase should not be written or saved in the same location as your encrypted 25 word mnemonic seed phrase. To encrypt your seed run the following command: encrypted_seed Initially the cli wallet will prompt you to enter your wallet password. Next it will request for your seed encryption passphrase, enter in your desired password/passphrase once, click enter, then type the passphrase in again. The wallet will output your mnemonic seed which is a 25 word passphrase. It is generally best practice to write these 25 words down and store them somewhere safe and securely, write your passphrase down(which is the phrase you used to encrypt the 25 words) and store this somewhere else. Storing the 25 words with the passphrase in a file on your computer that is not encrypted is giving others easier access to your mnemonic seed.","title":"CLI Wallet Commands"},{"location":"Wallets/CliWallet/WalletCommands/#loki-cli-guide","text":"The Loki CLI wallet is a wallet first developed by Monero. Loki has added additional commands ontop of the monero-wallet-cli and this document goes through all the Loki and Monero CLI commands available within the loki-wallet-cli .","title":"Loki CLI Guide"},{"location":"Wallets/CliWallet/WalletCommands/#displaying-commands","text":"The loki-wallet-cli has multiple commands to conduct different operations on the Loki Blockchain. By typing help and clicking enter after loading your wallet will bring up the commands that can be used.","title":"Displaying commands"},{"location":"Wallets/CliWallet/WalletCommands/#1-accounts","text":"","title":"1 Accounts"},{"location":"Wallets/CliWallet/WalletCommands/#11-creating-new-account","text":"When a wallet is generated it will automatically have an account labelled Primary account with index 0 . If at any time you wish to create an additional account use the command: account new <label text with white spaces allowed> This command will create a subaddress which is labelled with a tag and index number. This subaddress will share the same seed as your Primary address. To ensure this new account is displayed you must type exit to save your session. You will note that there is now an asterisk to the left of index 1. The asterisks show us the account in which the commands we run will apply to. Note: Restoring your wallet from your seed will not restore your accounts as the index of your subaddress data is stored on your computer within your wallet file. All the funds stored in your additional accounts will be shown in your Primary account if you need to restore your wallet from scratch. [wallet L9LnR2]: account new Secondary account [wallet L9LnR2]: Untagged accounts: [wallet L9LnR2]: Account Balance Unlocked balance Label [wallet L9LnR2]: 0 L9LnR2 0.000000000 0.000000000 Primary account [wallet L9LnR2]: * 1 LY5J5W 0.000000000 0.000000000 Secondary account [wallet L9LnR2]: ---------------------------------------------------------------------------------- [wallet L9LnR2]: Total 0.000000000 0.000000000","title":"1.1 Creating new account"},{"location":"Wallets/CliWallet/WalletCommands/#12-switching-account","text":"When transferring out or receiving to a specific account we need to make sure that the account we are performing the action is the one the CLI is currently connected to. An asterisk will show which account we are connected to. In the below example the asterisk is shown to the left of Secondary account so any operations will be associated with that account. Each of the accounts connected to your Primary address will have an index associated with them. The index number will be shown to the left of the Account column. By default, index \u201c0\u201d is your Primary account. [wallet L9LnR2]: account new Secondary account [wallet L9LnR2]: Untagged accounts: [wallet L9LnR2]: Account Balance Unlocked balance Label [wallet L9LnR2]: 0 L9LnR2 0.000000000 0.000000000 Primary account [wallet L9LnR2]: * 1 LY5J5W 0.000000000 0.000000000 Secondary account [wallet L9LnR2]: ---------------------------------------------------------------------------------- [wallet L9LnR2]: Total 0.000000000 0.000000000 To switch between the accounts you have created run the command: account switch <index> After running the command a similar output shown below will be on your terminal. [wallet L9LnR2]: account switch 0 [wallet L9LnR2]: Currently selected account: [0] Primary account [wallet L9LnR2]: Tag: (No tag assigned) [wallet L9LnR2]: Balance: 0.000000000, unlocked balance: 0.000000000","title":"1.2 Switching account"},{"location":"Wallets/CliWallet/WalletCommands/#13-changing-account-labels","text":"To change the label name connected to a specific Loki Primary or Sub-address use the command: account label <index> <label text with white spaces allowed> Replacing <index> with the index number associated with the account you wish to relabel, and replacing <label text with white spaces allowed> with the new label you would like to name the specified account. Below shows the current accounts and labels for a specific wallet. [wallet LCmjSH]: Untagged accounts: [wallet LCmjSH]: Account Balance Unlocked balance Label [wallet LCmjSH]: * 0 LCmjSH 0.000000000 0.000000000 Primary account [wallet LCmjSH]: 1 LTLgNy 0.000000000 0.000000000 Secondary [wallet LCmjSH]: ---------------------------------------------------------------------------------- [wallet LCmjSH]: Total 0.000000000 0.000000000 Using the command account label 0 My Account we have changed the label connected to our Primary address from \u201cPrimary account\u201d to \u201cMy Account\u201d. [wallet LCmjSH]: account label 0 My Account [wallet LCmjSH]: Untagged accounts: [wallet LCmjSH]: Account Balance Unlocked balance Label [wallet LCmjSH]: * 0 LCmjSH 0.000000000 0.000000000 My Account [wallet LCmjSH]: 1 LTLgNy 0.000000000 0.000000000 Secondary [wallet LCmjSH]: ---------------------------------------------------------------------------------- [wallet LCmjSH]: Total 0.000000000 0.000000000","title":"1.3 Changing account labels"},{"location":"Wallets/CliWallet/WalletCommands/#14-tagging-and-untagging-accounts","text":"The loki-wallet-cli allows you to group accounts by tagging or untagging them. Below shows a wallet with 4 accounts, Dog, Kid 1 and Kid 2. [wallet LVP3bv]: Untagged accounts: [wallet LVP3bv]: Account Balance Unlocked balance Label [wallet LVP3bv]: 0 LAXk6e 0.000000000 0.000000000 My Account [wallet LVP3bv]: 1 LRDvY6 0.000000000 0.000000000 Dog [wallet LVP3bv]: 2 LVJDwN 0.000000000 0.000000000 Kid 1 [wallet LVP3bv]: * 3 LVP3bv 0.000000000 0.000000000 Kid 2 [wallet LVP3bv]: ---------------------------------------------------------------------------------- [wallet LVP3bv]: Total 0.000000000 0.000000000 We can tag a single account with the following command: account tag <tag_name> <account_index> [wallet LVP3bv]: account tag Pets 1 [wallet LVP3bv]: Accounts with tag: Pets [wallet LVP3bv]: Tag's description: [wallet LVP3bv]: Account Balance Unlocked balance Label [wallet LVP3bv]: 1 LRDvY6 0.000000000 0.000000000 Dog [wallet LVP3bv]: ---------------------------------------------------------------------------------- [wallet LVP3bv]: Total 0.000000000 0.000000000 When needing to perform multiple tags we can do it through one command: account tag <tag_name> <account_index_1> [<account_index_2> ...] [wallet LVP3bv]: account tag Family 2 3 [wallet LVP3bv]: Accounts with tag: Family [wallet LVP3bv]: Tag's description: [wallet LVP3bv]: Account Balance Unlocked balance Label [wallet LVP3bv]: 2 LVJDwN 0.000000000 0.000000000 Kid 1 [wallet LVP3bv]: * 3 LVP3bv 0.000000000 0.000000000 Kid 2 [wallet LVP3bv]: ---------------------------------------------------------------------------------- [wallet LVP3bv]: Total 0.000000000 0.000000000 Similarly we can untag accounts by running the following command: account untag <account_index_1> [<account_index_2> ...] Using the above exampled wallet we will remove our \u201cDog\u201d account from \u201cPets\u201d. [wallet LVP3bv]: account untag 1 [wallet LVP3bv]: Accounts with tag: Family [wallet LVP3bv]: Tag's description: [wallet LVP3bv]: Account Balance Unlocked balance Label [wallet LVP3bv]: 2 LVJDwN 0.000000000 0.000000000 Kid 1 [wallet LVP3bv]: * 3 LVP3bv 0.000000000 0.000000000 Kid 2 [wallet LVP3bv]: ---------------------------------------------------------------------------------- [wallet LVP3bv]: Total 0.000000000 0.000000000 [wallet LVP3bv]: [wallet LVP3bv]: Untagged accounts: [wallet LVP3bv]: Account Balance Unlocked balance Label [wallet LVP3bv]: 0 LAXk6e 0.000000000 0.000000000 My Account [wallet LVP3bv]: 1 LRDvY6 0.000000000 0.000000000 Dog [wallet LVP3bv]: ---------------------------------------------------------------------------------- [wallet LVP3bv]: Total 0.000000000 0.000000000","title":"1.4 Tagging and untagging accounts:"},{"location":"Wallets/CliWallet/WalletCommands/#15-adding-tag-descriptions","text":"If you require additional information attached to a specific tag you can add a description with the following command: account tag_description <tag_name> <description> For example: [wallet LVP3bv]: account tag_description Family This is my family. [wallet LVP3bv]: Accounts with tag: Family [wallet LVP3bv]: Tag's description: This is my family. [wallet LVP3bv]: Account Balance Unlocked balance Label [wallet LVP3bv]: 2 LVJDwN 0.000000000 0.000000000 Kid 1 [wallet LVP3bv]: * 3 LVP3bv 0.000000000 0.000000000 Kid 2 [wallet LVP3bv]: ---------------------------------------------------------------------------------- [wallet LVP3bv]: Total 0.000000000 0.000000000","title":"1.5 Adding Tag descriptions"},{"location":"Wallets/CliWallet/WalletCommands/#2-balance","text":"To check the balance of your wallet you can run one of two commands: balance or balance detail Running the command balance will generated a simple output showing your balance and unlocked balance of the specific account you are in. For example: [wallet T6TmZX]: balance Currently selected account: [0] Primary account Tag: (No tag assigned) Balance: 172286.035054991, unlocked balance: 172086.338373771 While running the command balance detail will generate a more detailed output, showing the account number, first few characters of the address, balance, unlocked balance, Outputs and the Label of the account. For example: [wallet T6TmZX]: balance detail Currently selected account: [0] Primary account Tag: (No tag assigned) Balance: 172286.035054991, unlocked balance: 172086.338373771 Balance per address: Address Balance Unlocked balance Outputs Label 0 T6TmZX 172286.035054991 172086.338373771 3347 Primary account There are other commands that will also output the balance which have been covered by this guide, such as the account command.","title":"2 Balance"},{"location":"Wallets/CliWallet/WalletCommands/#3-getting-the-block-height","text":"To show the blockchain height run the command: bc_height","title":"3 Getting the Block Height"},{"location":"Wallets/CliWallet/WalletCommands/#4-blackballing-transactions","text":"Blackballing transactions allows you to ignore others' outputs (containers of money) that are known to be spent in a certain transaction. For example let\u2019s imagine that txid: 4f4b371a0da8858bbeab8a40ff37de1f6ff33e64a616e5ced8239062570b7542 is known to be fake and if this txid is seen within a RingCT transaction the network can assume it is fake, therefore an actor has a better chance of deducing the real transaction within the RingCT. By blackballing the above txid we remove the chance of it being used within our RingCT. To do this we will use the following command: blackball <output public key> | <filename> [add] For example: [wallet LAXk6e]: blackball 4f4b371a0da8858bbeab8a40ff37de1f6ff33e64a616e5ced8239062570b7542 To check if the txid was added to our list of txids not to use we can use the following command: blackballed <output public key> If the txid is on our list the following will output: [wallet LAXk6e]: blackballed 4f4b371a0da8858bbeab8a40ff37de1f6ff33e64a616e5ced8239062570b7542 [wallet LAXk6e]: Blackballed: <4f4b371a0da8858bbeab8a40ff37de1f6ff33e64a616e5ced8239062570b7542> Alternatively if the txid is not on our list the following will output: [wallet LAXk6e]: blackballed 4f4b371a0da8858bbeab8a40ff37de1f6ff33e64a616e5ced8239062570b7542 [wallet LAXk6e]: not blackballed: <4f4b371a0da8858bbeab8a40ff37de1f6ff33e64a616e5ced8239062570b7542> To unblackball a txid use the following command: unblackball <output public key> For example: [wallet LAXk6e]: unblackball 4f4b371a0da8858bbeab8a40ff37de1f6ff33e64a616e5ced8239062570b7542","title":"4 Blackballing Transactions"},{"location":"Wallets/CliWallet/WalletCommands/#5-reserve-proof","text":"Reserve Proofs are used to generate a signature proving that you own an amount of Loki, with the option to sign the reserve proof with a key. For example let\u2019s imagine you see a car for sale but they will accept Loki as payment, however they have advised in their online listing that they are only interested in serious buyers and require you to prove you have the Loki within your initial contact. Luckily we can use the Reserve Proof commands for this proof.","title":"5 Reserve Proof"},{"location":"Wallets/CliWallet/WalletCommands/#51-generate-reserve-proof","text":"To begin we will need to run the get_reserve_proof command to generate our proof. get_reserve_proof (all|<amount>) [<message>] If the individual you are sending this proof to requires you to prove you have 1000 Loki you will need to replace the section (all|<amount>) with a 1000, otherwise replace it with the amount you need to prove you have reserved. If you want to put an extra layer of encryption over the file replace [<message>] with a password. Your command will similar to the below command: get_reserve_proof 1000 Car The Cli will request your wallet password and once your password is entered it will tell you it generated a signature file. [wallet T6TmZX]: get_reserve_proof 1000 Car Wallet password: signature file saved to: loki_reserve_proof This signature file loki_reserve_proof will be saved in your Loki folder, where your daemon and wallet keys are. Keep in mind every time you run the get_reserve_proof command it will overwrite your loki_reserve_proof file. You will want to send this file to the person who requires the proof. You can upload the loki_reserve_proof file through https://transfer.sh/ by running the command within the folder of your signature file: curl --upload-file ./loki_reserve_proof https://transfer.sh/loki_reserve_proof` The terminal will then print out a link to your signature file which you can then provide to the individual performing the check. https://transfer.sh/QhoC7/loki_reserve_proof Make sure you provide the following to the individual who will be checking your reserve proof: The loki_reserve_proof file through the transfer.sh link. The loki address you are proving has Loki in it. The <message> if you encrypted the file.","title":"5.1 Generate Reserve Proof"},{"location":"Wallets/CliWallet/WalletCommands/#52-checking-reserve-proof","text":"To check a reserve proof we need to first have the loki_reserve_proof file in our Loki folder. If you do not have the loki_reserve_proof file in your loki folder request the individual sending the file to you to use https://transfer.sh/ , once they send you the link to their loki_reserve_proof you can use the following command to download it. curl <link> -o loki_reserve_proof Replacing <link> with the link to download the loki_reserve_proof . Now that the loki_reserve_proof is in our folder we can run the following command: check_reserve_proof <address> <signature_file> [<message>] Where <address> is the address of the wallet where the command get_reserve_proof was ran. <signiture_file> is the file that was received from the individual sending you the reserve proof, normally generated as loki_reserve_proof and <message> is the key set by the individual who sent you the reserve proof. Therefor for the previous example where we created a reserve proof for 1000 loki and signed with \u201ccar\u201d, we would run the command: check_reserve_proof T6TmZX8EzZVjS9zNg7zAsrEQFDgcVC2qV2ZMyoWsbyK4SNB2SwMHZtMhPSsFyTmRBQUaGVF5k3qy5CMFM6Lvj7gi3AeszDag7 loki_reserve_proof Car If all goes well, the terminal will output the following: Good signature -- total: 1014.862440831, spent: 0.000000000, unspent: 1014.862440831 You may note that it shows a reserve proof which is greater than 1000, this is because the command is adding up all the transactions into the address specified until it is greater than the reserve proof set.","title":"5.2 Checking Reserve Proof"},{"location":"Wallets/CliWallet/WalletCommands/#6-spend-proof","text":"Spend Proofs are used to generate a signature proving that you generated a TXID, with the option to sign the spend proof with a key. For example let\u2019s imagine you have bought a car from a dealership with loki and have sent 1000 loki to the seller. Unfortunately the dealer does not know which transaction is yours as he has received 5 transactions of 1000 loki in the same block for 5 different cars. He knows the txid\u2019s but wants you to prove that you have generate one of the txid\u2019s in his list. Luckily we can prove we generated the txid by using the get_spend_proof command.","title":"6 Spend Proof"},{"location":"Wallets/CliWallet/WalletCommands/#61-generate-spend-proof","text":"To begin we will first need to find the txid associated with our transaction. To do this run the following command in our wallet: show_transfers The terminal will output a list of transactions in and out of your address. You should have a transaction in your list with the amount you spent to the dealership. Copy the txid(by highlighting) associated with this transaction and save it in a notepad for later. We can now run the get_spend_proof command to generate our proof. get_spend_proof <txid> [<message>] Replacing <txid> with the txid of our transfer out and replacing <message> if we want to add a password to the proof. If all went well the terminal will output the following text: signature file saved to: loki_spend_proof This signature file loki_spend_proof will be saved in your Loki folder, where your daemon and wallet keys are. Keep in mind every time you run the get_spend_proof command it will overwrite your loki_spend_proof file . You will want to send this file to the person who requires the proof. You can upload the loki_spend_proof file through https://transfer.sh/ by running the command within the folder of your signature file: curl --upload-file ./loki_spend_proof https://transfer.sh/loki_spend_proof The terminal will then print out a link to your signature file which you can then provide to the individual performing the check. For example: https://transfer.sh/QhoC7/loki_spend_proof Make sure you provide the following to the individual who will be checking your reserve proof: The loki_spend_proof file through the transfer.sh link. The loki transaction txid associated with the transaction you are proving you generated. The <message> if you encrypted the file.","title":"6.1 Generate Spend Proof"},{"location":"Wallets/CliWallet/WalletCommands/#62-checking-spend-proof","text":"To check a spend proof we need to first have the loki_spend_proof file in our Loki folder and the txid associated with the transaction being proved. If you do not have the loki_spend_proof file in your loki folder request the individual sending the file to you to use https://transfer.sh/ , once they send you the link to their loki_spend_proof you can use the following command to download it. curl <link> -o loki_spend_proof Replacing <link> with the link to download the loki_spend_proof . Now that the loki_spend_proof is in our folder we can run the following command: check_spend_proof <txid> <signature_file> [<message>] Where <txid> is the txid associated with the transaction that is being proved. <signiture_file> is the file that was received from the individual sending you the spend proof, normally generated as loki_spend_proof and <message> is the key set by the individual who sent you the spend proof. An example would look like the following command check_spend_proof 20eb3b5545d6587e5a379feb2fc69b43d4f8b6b825bb7eff78e263d4e7e8eaa9 loki_spend_proof car If all goes well, the terminal will output the following: Good signature If you receive a Good signature message that should be a good proof that the txid you are checking was generated from the sender. Keep in mind however that this can potentially not always be the case, considering someone could get access to someone else's computer thus having access to this file.","title":"6.2 Checking Spend Proof"},{"location":"Wallets/CliWallet/WalletCommands/#7-tx-proof","text":"TX Proofs are used to generate a signature file proving that you generated a TXID, with the option to sign the spend proof with a key. TX proofs work similar to Reserve Proof\u2019s and Spend Proofs however they show more detailed information. For example let\u2019s imagine you have bought a car from a dealership with loki and have sent 1000 loki to the seller. Unfortunately the dealer does not know which transaction is yours as he has received 5 transactions of 1000 loki in the same block for 5 different cars. He knows the txid\u2019s but wants you to prove that you have generate one of the txid\u2019s in his list. Luckily we can prove we generated the txid by using the get_tx_proof command.","title":"7 TX Proof"},{"location":"Wallets/CliWallet/WalletCommands/#71-generate-spend-proof","text":"To begin we will first need to find the txid associated with our transaction. To do this run the following command in our wallet: show_transfers The terminal will output a list of transactions in and out of your address. You should have a transaction in your list with the amount you spent to the dealership. Copy the txid(by highlighting) associated with this transaction and save it in a notepad for later. We can now run the get_tx_proof command to generate our proof. get_tx_proof <txid> <address> [<message>] Replacing <txid> with the txid of our transfer out, <address> with the receiver's address, and replacing <message> if we want to add a password to the proof. If all went well the terminal will output the following text: signature file saved to: loki_tx_proof This signature file loki_tx_proof will be saved in your Loki folder, where your daemon and wallet keys are. Keep in mind every time you run the get_tx_proof command it will overwrite your loki_tx_proof file. You will want to send this file to the person who requires the proof. You can upload the loki_tx_proof file through https://transfer.sh/ by running the command within the folder of your signature file: curl --upload-file ./loki_tx_proof https://transfer.sh/loki_tx_proof The terminal will then print out a link to your signature file which you can then provide to the individual performing the check. For example: https://transfer.sh/QhoC7/loki_tx_proof Make sure you provide the following to the individual who will be checking your reserve proof: The loki_tx_proof file through the transfer.sh link. The loki transaction txid associated with the transaction you are proving you generated. The receivers loki address. The <message> if you encrypted the file.","title":"7.1 Generate Spend Proof"},{"location":"Wallets/CliWallet/WalletCommands/#72-checking-tx-proof","text":"To check a tx proof we need to first have the loki_tx_proof file in our Loki folder, the receiver's address and the txid associated with the transaction being proved. If you do not have the loki_tx_proof file in your loki folder request the individual sending the file to you to use https://transfer.sh/ , once they send you the link to their loki_tx_proof you can use the following command to download it. curl <link> -o loki_tx_proof Replacing <link> with the link to download the loki_tx_proof . Now that the loki_tx_proof is in our folder we can run the following command: check_tx_proof <txid> <address> <signature_file> [<message>] Where <txid> is the txid associated with the transaction that is being proved, <address> is the receiver\u2019s address and <signiture_file> is the file that was received from the individual sending you the tx proof, normally generated as loki_tx_proof and <message> is the key set by the individual who sent you the tx proof. An example would look like the following command: check_tx_proof 3f8c62b4d83100ff4f89b44a96350e65aeaa83a9b4273c31f94b9aa12e713044 TRrEpWMLd3rRuirYqsjg1iaNsukAAojWjFDhJ2kK2o4uM6tkcjMerA4SZNat6QHEYe1SoGCFQddVPgRqmkA8kARX1ffU1Wcjc loki_tx_proof If all goes well, the terminal will output the following: Good signature TRrEpWMLd3rRuirYqsjg1iaNsukAAojWjFDhJ2kK2o4uM6tkcjMerA4SZNat6QHEYe1SoGCFQddVPgRqmkA8kARX1ffU1Wcjc received 40000.000000 in txid <3f8c62b4d83100ff4f89b44a96350e65aeaa83a9b4273c31f94b9aa12e713044> This transaction has 1 confirmations If you receive a Good signature message that should be a good proof that the txid you are checking was generated from the sender. Keep in mind however that this can potentially not always be the case, considering someone could get access to someone else's computer thus having access to this file.","title":"7.2 Checking tx Proof"},{"location":"Wallets/CliWallet/WalletCommands/#8-tx-key","text":"A TX key is a private key associated with a TXid. Only the wallet that has sent the transaction can generate a TX key from the TXID that both parties can see. A TX key can be used to validate a transaction on a case by case basis. In essence, you can provide the tx key, txid and the receiver address to someone to prove you had generate that transaction.","title":"8 TX key"},{"location":"Wallets/CliWallet/WalletCommands/#81-view-tx-key","text":"To view the TX key of a specific transaction you have generate you will need to run the command: get_tx_key <txid> Where <txid> is the transaction id associated with the transfer out you are proving is yours. The terminal will prompt the user for the wallets password and then print out the tx key, which will look similar to: [wallet T6TmZX]: get_tx_key d5fb415aad43f4e45bc72566d5ad4c8f12629db1f924d953efc2521c137a987f Wallet password: Tx key: 5dfc4d677e2707317f306219b6aa445feaab4c652927237c012f7e72cb41bf0e Provide the <tx key> with the <txid> and <receiving address> to the individual who will run the validation, thus this will prove you generated the transaction.","title":"8.1 View TX key"},{"location":"Wallets/CliWallet/WalletCommands/#82-validate-transaction-with-tx-key","text":"Once we have a <tx key> , <txid> and <receiving address> from a specific transaction we can use the following command to prove they are all associated: check_tx_key <txid> <txkey> <address> For the previous example we would run the following command from any loki wallet: check_tx_key d5fb415aad43f4e45bc72566d5ad4c8f12629db1f924d953efc2521c137a987f 5dfc4d677e2707317f306219b6aa445feaab4c652927237c012f7e72cb41bf0e T6TZ2VaG1p9PQkDgdVCYwnjoxYSU7ErXX56etGsqHLugAGqynFwBvP4dnN7wvYCcJfMa9LPgtYu8UEUqyc4xsxmx2ZTyMp4U3 The terminal will show text of how much Loki the address received. It will also show how many confirmations the transaction has received from the blockchain. For example: [wallet T6TZ2V]: check_tx_key d5fb415aad43f4e45bc72566d5ad4c8f12629db1f924d953efc2521c137a987f 5dfc4d677e2707317f306219b6aa445feaab4c652927237c012f7e72cb41bf0e T6TZ2VaG1p9PQkDgdVCYwnjoxYSU7ErXX56etGsqHLugAGqynFwBvP4dnN7wvYCcJfMa9LPgtYu8UEUqyc4xsxmx2ZTyMp4U3 T6TZ2VaG1p9PQkDgdVCYwnjoxYSU7ErXX56etGsqHLugAGqynFwBvP4dnN7wvYCcJfMa9LPgtYu8UEUqyc4xsxmx2ZTyMp4U3 received 10000.000000000 in txid <d5fb415aad43f4e45bc72566d5ad4c8f12629db1f924d953efc2521c137a987f> This transaction has 10 confirmations","title":"8.2 Validate transaction with TX key"},{"location":"Wallets/CliWallet/WalletCommands/#9-tx-notes","text":"The loki-wallet-cli allows you to add notes to specific txid\u2019s, however this note does not get stored on the blockchain, rather it is stored on client side, on the device that generates the tx_note .","title":"9 Tx Notes"},{"location":"Wallets/CliWallet/WalletCommands/#91-set-tx-note","text":"To set a tx note we will need a the <txid> and the <message> you want to add to the txid. For instance, if you want to add a note to a txid that is connected to your wallet run the following command to show your transactions in/out with their <txid> \u2019s: show_transfers To set the note to the <txid> run the following command: set_tx_note <txid> [free text note] Where <txid> is the transaction id associated to the transaction you are adding the [free text note] too. Your command will look similar to the following example: [wallet T6TmZX]: set_tx_note d5fb415aad43f4e45bc72566d5ad4c8f12629db1f924d953efc2521c137a987f This is a tx note example.","title":"9.1 Set tx note"},{"location":"Wallets/CliWallet/WalletCommands/#92-view-tx-note","text":"To view a note connected to a txid run the following command: get_tx_note <txid> Where <txid> is the transaction id that has the note connected to it. For example, if we run the command on the previous <txid> mentioned, the terminal will display the following text: [wallet T6TmZX]: get_tx_note d5fb415aad43f4e45bc72566d5ad4c8f12629db1f924d953efc2521c137a987f note found: This is a tx note example. You can also view a tx note by running the show_transfers command, each transaction that has a note connected to it will display the text to the right of each transfer.","title":"9.2 View tx note"},{"location":"Wallets/CliWallet/WalletCommands/#10-changing-wallet-password","text":"Changing the wallet password is only client side(locally), and if the password is forgotten the wallet can always be restored with the mnemonic seed. If you know the password to the wallet and want to change it you can run the following command: password Once the command has been run the terminal will prompt you for the current password and the new password twice. If entered correctly the terminal will go back to receiving inputs, otherwise the terminal will output an error such as Passwords do not match! Please try again or Error: invalid password .","title":"10 Changing wallet password"},{"location":"Wallets/CliWallet/WalletCommands/#11-encrypting-seed-phrase","text":"Your seed passphrase is a 25 word phrase which is used to recover access to your wallet on a client or gui and is. The command encrypted_seed allows your to add an additional password, or encryption layer, to your 25 word mnemonic seed. Encrypting your seed will stop others from recovering access to your wallet if they somehow gain access to your 25 word mnemonic seed as they will not have the passphrase that decrypts them. This means, your passphrase should not be written or saved in the same location as your encrypted 25 word mnemonic seed phrase. To encrypt your seed run the following command: encrypted_seed Initially the cli wallet will prompt you to enter your wallet password. Next it will request for your seed encryption passphrase, enter in your desired password/passphrase once, click enter, then type the passphrase in again. The wallet will output your mnemonic seed which is a 25 word passphrase. It is generally best practice to write these 25 words down and store them somewhere safe and securely, write your passphrase down(which is the phrase you used to encrypt the 25 words) and store this somewhere else. Storing the 25 words with the passphrase in a file on your computer that is not encrypted is giving others easier access to your mnemonic seed.","title":"11 Encrypting seed phrase"},{"location":"Wallets/CliWallet/WalletRestoreKeys/","text":"Restoring Your CLI Wallet from Keys \u00b6 If you have a Mnemonic Seed Phrase, restoring your wallet from it would probably be a good option. Otherwise, you can restore your wallet from private keys. You will need to have the following keys to proceed: Wallet public address Spend Key View Key Step 1: Download and unzip CLI wallet \u00b6 Download the latest release of wallet CLI software for your desired operating system: https://github.com/loki-project/loki/releases Unzip loki-[operating-system]-[platform]-[version].zip file Step 2: Run wallet in restore mode \u00b6 Open a Command Prompt (Windows) or Terminal (Linux / OSX) and navigate to the wallet folder Run wallet with --generate-from-keys argument: ./loki-wallet-cli --generate-from-keys [New Wallet Name] Where [New Wallet Name] is a new wallet name. You can enter any name here, use something rememberable and meaningful. Step 3: Enter wallet address, view and spend keys \u00b6 On the next step, specify all 3 wallet keys, one by one: Enter Standard address and press [Enter] Enter Secret spend key and press [Enter] Enter Secret view key and press [Enter] Step 4: Enter wallet password \u00b6 You will be prompted for a password. Enter a new password that follows the Password Policy and press [Enter]. Confirm password and press [Enter]. Step 5: Specify a blockchain height \u00b6 If you know the block height at which wallet was created or a first transaction was made, you can enter it here. Specifying a blockchain height will help to scan the wallet faster. If you don't know a specific blockchain height, press [Enter] for scanning from block height 0. Step 6: Wait for the refresh process to finish \u00b6 For refresh process to start, you need to have your daemon running. Another option would be to use a remote node. For that, use the following command, replacing and with the host and port number of the remote node you are connecting to: ./loki-wallet-cli --daemon-address <host>:<port> Once refresh is done, you can use your full functioning restored wallet. Your public wallet address will remain the same.","title":"CLI Restoring Wallet from Keys"},{"location":"Wallets/CliWallet/WalletRestoreKeys/#restoring-your-cli-wallet-from-keys","text":"If you have a Mnemonic Seed Phrase, restoring your wallet from it would probably be a good option. Otherwise, you can restore your wallet from private keys. You will need to have the following keys to proceed: Wallet public address Spend Key View Key","title":"Restoring Your CLI Wallet from Keys"},{"location":"Wallets/CliWallet/WalletRestoreKeys/#step-1-download-and-unzip-cli-wallet","text":"Download the latest release of wallet CLI software for your desired operating system: https://github.com/loki-project/loki/releases Unzip loki-[operating-system]-[platform]-[version].zip file","title":"Step 1: Download and unzip CLI wallet"},{"location":"Wallets/CliWallet/WalletRestoreKeys/#step-2-run-wallet-in-restore-mode","text":"Open a Command Prompt (Windows) or Terminal (Linux / OSX) and navigate to the wallet folder Run wallet with --generate-from-keys argument: ./loki-wallet-cli --generate-from-keys [New Wallet Name] Where [New Wallet Name] is a new wallet name. You can enter any name here, use something rememberable and meaningful.","title":"Step 2: Run wallet in restore mode"},{"location":"Wallets/CliWallet/WalletRestoreKeys/#step-3-enter-wallet-address-view-and-spend-keys","text":"On the next step, specify all 3 wallet keys, one by one: Enter Standard address and press [Enter] Enter Secret spend key and press [Enter] Enter Secret view key and press [Enter]","title":"Step 3: Enter wallet address, view and spend keys"},{"location":"Wallets/CliWallet/WalletRestoreKeys/#step-4-enter-wallet-password","text":"You will be prompted for a password. Enter a new password that follows the Password Policy and press [Enter]. Confirm password and press [Enter].","title":"Step 4: Enter wallet password"},{"location":"Wallets/CliWallet/WalletRestoreKeys/#step-5-specify-a-blockchain-height","text":"If you know the block height at which wallet was created or a first transaction was made, you can enter it here. Specifying a blockchain height will help to scan the wallet faster. If you don't know a specific blockchain height, press [Enter] for scanning from block height 0.","title":"Step 5: Specify a blockchain height"},{"location":"Wallets/CliWallet/WalletRestoreKeys/#step-6-wait-for-the-refresh-process-to-finish","text":"For refresh process to start, you need to have your daemon running. Another option would be to use a remote node. For that, use the following command, replacing and with the host and port number of the remote node you are connecting to: ./loki-wallet-cli --daemon-address <host>:<port> Once refresh is done, you can use your full functioning restored wallet. Your public wallet address will remain the same.","title":"Step 6: Wait for the refresh process to finish"},{"location":"Wallets/CliWallet/WalletRestoreSeed/","text":"Restoring Your CLI Wallet from Seed \u00b6 To fully restore your wallet and be able to view balance and make transactions, having your seed stored will be enough. You don't need your wallet password or other keys to restore the wallet once you have a seed phrase. Step 1: Download and unzip CLI wallet \u00b6 Download the latest release of wallet CLI software for your desired operating system: https://github.com/loki-project/loki/releases Unzip loki-[operating-system]-[platform]-[version].zip file Step 2: Run wallet in restore mode \u00b6 Open a Command Prompt (Windows) or Terminal (Linux / OSX) and navigate to the wallet folder Run wallet with --restore-deterministic-wallet argument: ./loki-wallet-cli --restore-deterministic-wallet Step 3: Enter wallet name \u00b6 You will be prompted to enter a wallet name and click [Enter]. You can enter any name here, use something rememberable and meaningful. Step 4: Enter your seed phrase \u00b6 You will be prompted to enter 25 word mnemonic seed you have stored. Paste it and press [Enter]. If you have a seed encryption passphrase, enter it on the next step. Otherwise, press [Enter]. Step 5: Enter wallet password \u00b6 You will be prompted for a password. Enter a new password that follows the Password Policy and press [Enter]. Confirm password and press [Enter]. Step 6: Specify a blockchain height \u00b6 If you know the block height at which wallet was created or a first transaction was made, you can enter it here. Specifying a blockchain height will help to scan the wallet faster. If you don't know a specific blockchain height, press [Enter] for scanning from block height 0. Step 7: Wait for the refresh process to finish \u00b6 For refresh process to start, you need to have your daemon running. Another option would be to use a remote node. For that, use the following command, replacing and with the host and port number of the remote node you are connecting to: ./loki-wallet-cli --daemon-address <host>:<port> Once refresh is done, you can use your full functioning restored wallet. Your public wallet address will remain the same.","title":"CLI Restoring Wallet from Seed"},{"location":"Wallets/CliWallet/WalletRestoreSeed/#restoring-your-cli-wallet-from-seed","text":"To fully restore your wallet and be able to view balance and make transactions, having your seed stored will be enough. You don't need your wallet password or other keys to restore the wallet once you have a seed phrase.","title":"Restoring Your CLI Wallet from Seed"},{"location":"Wallets/CliWallet/WalletRestoreSeed/#step-1-download-and-unzip-cli-wallet","text":"Download the latest release of wallet CLI software for your desired operating system: https://github.com/loki-project/loki/releases Unzip loki-[operating-system]-[platform]-[version].zip file","title":"Step 1: Download and unzip CLI wallet"},{"location":"Wallets/CliWallet/WalletRestoreSeed/#step-2-run-wallet-in-restore-mode","text":"Open a Command Prompt (Windows) or Terminal (Linux / OSX) and navigate to the wallet folder Run wallet with --restore-deterministic-wallet argument: ./loki-wallet-cli --restore-deterministic-wallet","title":"Step 2: Run wallet in restore mode"},{"location":"Wallets/CliWallet/WalletRestoreSeed/#step-3-enter-wallet-name","text":"You will be prompted to enter a wallet name and click [Enter]. You can enter any name here, use something rememberable and meaningful.","title":"Step 3: Enter wallet name"},{"location":"Wallets/CliWallet/WalletRestoreSeed/#step-4-enter-your-seed-phrase","text":"You will be prompted to enter 25 word mnemonic seed you have stored. Paste it and press [Enter]. If you have a seed encryption passphrase, enter it on the next step. Otherwise, press [Enter].","title":"Step 4: Enter your seed phrase"},{"location":"Wallets/CliWallet/WalletRestoreSeed/#step-5-enter-wallet-password","text":"You will be prompted for a password. Enter a new password that follows the Password Policy and press [Enter]. Confirm password and press [Enter].","title":"Step 5: Enter wallet password"},{"location":"Wallets/CliWallet/WalletRestoreSeed/#step-6-specify-a-blockchain-height","text":"If you know the block height at which wallet was created or a first transaction was made, you can enter it here. Specifying a blockchain height will help to scan the wallet faster. If you don't know a specific blockchain height, press [Enter] for scanning from block height 0.","title":"Step 6: Specify a blockchain height"},{"location":"Wallets/CliWallet/WalletRestoreSeed/#step-7-wait-for-the-refresh-process-to-finish","text":"For refresh process to start, you need to have your daemon running. Another option would be to use a remote node. For that, use the following command, replacing and with the host and port number of the remote node you are connecting to: ./loki-wallet-cli --daemon-address <host>:<port> Once refresh is done, you can use your full functioning restored wallet. Your public wallet address will remain the same.","title":"Step 7: Wait for the refresh process to finish"},{"location":"Wallets/CliWallet/loki-wallet-cliMacSetup/","text":"loki-wallet-cli Mac Setup \u00b6 The loki-wallet-cli is the \u201cCommand Line Interface\u201d wallet software that is used to run Loki accounts through command prompt or terminal. The CLI wallet only uses text to do operations, where the oki-wallet-gui wallet offers a graphical user interface with buttons to do most of the operations the loki-wallet-cli does. If you are new to console or terminal commands and/or would prefer a wallet with buttons and Loki branding we would suggest you download the latest loki-wallet-gui release from here and follow the guide found here to get started. Bear in mind that the CLI wallet, while harder to use, is generally faster and more reliable. If you are still interested in the 'Loki-wallet-cli' you can find it here . Download the latest release for your specified Operating System, for this user guide we are going to assume you are running the latest MAC OS and have XCode installed. Step 1: Opening loki-wallet-cli and lokid. \u00b6 To use the loki-wallet-cli we must first have the daemon, lokid , up and running. The lokid is your node which the loki-wallet-cli broadcasts through. Without the node running the loki-wallet-cli will not be able to operate. Open up the lokid file in the folder you extracted the release from. In most cases you will have the following security dialog box pop up. If the dialog box opens up you will need to allow the lokid to open by moving your cursor to the top-left of your screen, clicking the apple logo, and then clicking on system preferences. Once in system preferences click on the Security & Privacy button, check in this new screen that the lokid file was blocked, if it was you should be confident to click \u201cOpen Anyway\u201d. Keep clicking open and allow to give the software permission to run. Once the software has permission a terminal window should pop up and say the following text: ********************************************************************** The daemon will start synchronizing with the network. This may take a long time to complete. You can set the level of process detailization through \"set_log <level|categories>\" command, where <level> is between 0 (no details) and 4 (very verbose), or custom category based levels (eg, *:WARNING). Use the \"help\" command to see the list of available commands. Use \"help <command>\" to see a command's documentation. ********************************************************************** Let the daemon run until the node is completely synced, you will know the node is synced once the terminal outputs the following text: ********************************************************************** You are now synchronized with the network. You may now start loki-wallet-cli. Use the \"help\" command to see the list of available commands. ********************************************************************** Now the daemon is synced we can run the loki-wallet-cli file. Step 2: Setting up your loki-wallet-cli account. \u00b6 If this is your first time opening the loki-wallet-cli it will request for you to specify a wallet name. For the purposes of this user guide we will use the example name MyWallet Specify wallet file name (e.g., MyWallet). If the wallet doesn't exist, it will be created. Wallet file name (or Ctrl-C to quit): MyWallet Because this is the first time we have used the name MyWallet the following text will appear in our terminal. Type in Y or Yes to confirm your wallet name. No wallet found with that name. Confirm creation of new wallet named: MyWallet (Y/Yes/N/No): Yes The loki-wallet-cli has now generated us a wallet called MyWallet and is now prompting us for a password for our generated wallet. Please note: When typing the password, the characters will not appear. It will seem as if you are typing and no text is appearing however the terminal is logging every character your clicking including if it is capitalised or lowercase. Write down your wallet name and password on a piece of paper as this information will be required every time we want to enter our wallet. Use a password with uppercase letters, lowercase letters, numbers, symbols and make the password at least 9 characters long. Generating new wallet... Enter a new password for the wallet: Confirm password: Now once we have chosen our password for the wallet we must choose our language. For the purposes of this user guide I suggest you use English by typing 1 and clicking enter. List of available languages for your wallet's seed: If your display freezes, exit blind with ^C, then run again with --use-english-language-names 0 : Deutsch 1 : English 2 : Espa\u00f1ol 3 : Fran\u00e7ais 4 : Italiano 5 : Nederlands 6 : Portugu\u00eas 7 : \u0440\u0443\u0441\u0441\u043a\u0438\u0439 \u044f\u0437\u044b\u043a 8 : \u65e5\u672c\u8a9e 9 : \u7b80\u4f53\u4e2d\u6587 (\u4e2d\u56fd) 10 : Esperanto 11 : Lojban Enter the number corresponding to the language of your choice: 1 The loki-wallet-cli will generate and spit out several lines of text. Some of the information that was outputted will only ever show once, therefore it is very important to do this next section properly otherwise we may lose access to our account, thus losing access to our funds. Let\u2019s take a close look at each section of the newly generated wallet: The text after Generated new wallet shows your public address. This address can be shared and will be used to receive Loki to your wallet. All Loki public addresses start with an L.... and are followed with a string of characters. The public address shown will be your primary address however multiple public addresses can be generated from this primary address. You do not need to write down the public address, the command address will re-display it whenever required. Generated new wallet: LAXk6eS3Ng98QxDTdC47eNdfCXttJycKraXxfsw9cMVngGUqP3kiSE6cwXoApU6gjzSXVX1ASAPAi1MSXA935XUs1MWEcv9 The View key address is not to be shared unless you want to show the transactions received to the public address connected to this wallet. You do not need to write down the view key as it can be re-displayed with the command viewkey . View key: 97d3c27e20818e5e23a6548458b50d4f128a2709c55eb7f9518d0e957a5d2e0d The next few lines of text show how to navigate the loki-wallet-client . This user guide will look into more detail the commands that can be used within the loki-wallet-client further in the guide. Your wallet has been generated! To start synchronizing with the daemon, use the \"refresh\" command. Use the \"help\" command to see the list of available commands. Use \"help <command>\" to see a command's documentation. Always use the \"exit\" command when closing loki-wallet-cli to save your current session's state. Otherwise, you might need to synchronize your wallet again (your wallet keys are NOT at risk in any case). The next section with the random 25 words is your mnemonic seed. The seed is used to easily back-up and restore your wallet without needing any other information. At this stage, grab a pen and paper and write down your 25 words in order(having these words out of order will not restore your wallet) and store the piece of paper in a safe and secure place. If your words are stored in a text file on your computer or stored online, you increase your risk of someone else getting control of your account. NOTE: the following 25 words can be used to recover access to your wallet. Write them down and store them somewhere safe and secure. Please do not store them in your email or on file storage services outside of your immediate control. ponies innocent oyster whale autumn knapsack jostle elapse inroads joining doorway ticket drying obnoxious algebra tutor biplane sack alpine zinger huge duets refer rigid inroads The last of the outputs are the account balance, because your wallet does not have any Loki in it currently the balance is showing 0. Once we receive a transaction of Loki into our wallet the balance will appear as soon as the transaction is confirmed in one block (usually less than 2 minutes). Once the transaction has been confirmed over 10 blocks the balance will show in unlocked balance. The unlocked balance is the Loki available to be spent/sent to other addresses. Starting refresh... Refresh done, blocks received: 0 Untagged accounts: Account Balance Unlocked balance Label * 0 LAXk6e 0.000000000 0.000000000 Primary account ---------------------------------------------------------------------------------- Total 0.000000000 0.000000000 Currently selected account: [0] Primary account Tag: (No tag assigned) Balance: 0.000000000, unlocked balance: 0.000000000 Background refresh thread started\u201d","title":"CLI Mac Setup"},{"location":"Wallets/CliWallet/loki-wallet-cliMacSetup/#loki-wallet-cli-mac-setup","text":"The loki-wallet-cli is the \u201cCommand Line Interface\u201d wallet software that is used to run Loki accounts through command prompt or terminal. The CLI wallet only uses text to do operations, where the oki-wallet-gui wallet offers a graphical user interface with buttons to do most of the operations the loki-wallet-cli does. If you are new to console or terminal commands and/or would prefer a wallet with buttons and Loki branding we would suggest you download the latest loki-wallet-gui release from here and follow the guide found here to get started. Bear in mind that the CLI wallet, while harder to use, is generally faster and more reliable. If you are still interested in the 'Loki-wallet-cli' you can find it here . Download the latest release for your specified Operating System, for this user guide we are going to assume you are running the latest MAC OS and have XCode installed.","title":"loki-wallet-cli Mac Setup"},{"location":"Wallets/CliWallet/loki-wallet-cliMacSetup/#step-1-opening-loki-wallet-cli-and-lokid","text":"To use the loki-wallet-cli we must first have the daemon, lokid , up and running. The lokid is your node which the loki-wallet-cli broadcasts through. Without the node running the loki-wallet-cli will not be able to operate. Open up the lokid file in the folder you extracted the release from. In most cases you will have the following security dialog box pop up. If the dialog box opens up you will need to allow the lokid to open by moving your cursor to the top-left of your screen, clicking the apple logo, and then clicking on system preferences. Once in system preferences click on the Security & Privacy button, check in this new screen that the lokid file was blocked, if it was you should be confident to click \u201cOpen Anyway\u201d. Keep clicking open and allow to give the software permission to run. Once the software has permission a terminal window should pop up and say the following text: ********************************************************************** The daemon will start synchronizing with the network. This may take a long time to complete. You can set the level of process detailization through \"set_log <level|categories>\" command, where <level> is between 0 (no details) and 4 (very verbose), or custom category based levels (eg, *:WARNING). Use the \"help\" command to see the list of available commands. Use \"help <command>\" to see a command's documentation. ********************************************************************** Let the daemon run until the node is completely synced, you will know the node is synced once the terminal outputs the following text: ********************************************************************** You are now synchronized with the network. You may now start loki-wallet-cli. Use the \"help\" command to see the list of available commands. ********************************************************************** Now the daemon is synced we can run the loki-wallet-cli file.","title":"Step 1: Opening loki-wallet-cli and lokid."},{"location":"Wallets/CliWallet/loki-wallet-cliMacSetup/#step-2-setting-up-your-loki-wallet-cli-account","text":"If this is your first time opening the loki-wallet-cli it will request for you to specify a wallet name. For the purposes of this user guide we will use the example name MyWallet Specify wallet file name (e.g., MyWallet). If the wallet doesn't exist, it will be created. Wallet file name (or Ctrl-C to quit): MyWallet Because this is the first time we have used the name MyWallet the following text will appear in our terminal. Type in Y or Yes to confirm your wallet name. No wallet found with that name. Confirm creation of new wallet named: MyWallet (Y/Yes/N/No): Yes The loki-wallet-cli has now generated us a wallet called MyWallet and is now prompting us for a password for our generated wallet. Please note: When typing the password, the characters will not appear. It will seem as if you are typing and no text is appearing however the terminal is logging every character your clicking including if it is capitalised or lowercase. Write down your wallet name and password on a piece of paper as this information will be required every time we want to enter our wallet. Use a password with uppercase letters, lowercase letters, numbers, symbols and make the password at least 9 characters long. Generating new wallet... Enter a new password for the wallet: Confirm password: Now once we have chosen our password for the wallet we must choose our language. For the purposes of this user guide I suggest you use English by typing 1 and clicking enter. List of available languages for your wallet's seed: If your display freezes, exit blind with ^C, then run again with --use-english-language-names 0 : Deutsch 1 : English 2 : Espa\u00f1ol 3 : Fran\u00e7ais 4 : Italiano 5 : Nederlands 6 : Portugu\u00eas 7 : \u0440\u0443\u0441\u0441\u043a\u0438\u0439 \u044f\u0437\u044b\u043a 8 : \u65e5\u672c\u8a9e 9 : \u7b80\u4f53\u4e2d\u6587 (\u4e2d\u56fd) 10 : Esperanto 11 : Lojban Enter the number corresponding to the language of your choice: 1 The loki-wallet-cli will generate and spit out several lines of text. Some of the information that was outputted will only ever show once, therefore it is very important to do this next section properly otherwise we may lose access to our account, thus losing access to our funds. Let\u2019s take a close look at each section of the newly generated wallet: The text after Generated new wallet shows your public address. This address can be shared and will be used to receive Loki to your wallet. All Loki public addresses start with an L.... and are followed with a string of characters. The public address shown will be your primary address however multiple public addresses can be generated from this primary address. You do not need to write down the public address, the command address will re-display it whenever required. Generated new wallet: LAXk6eS3Ng98QxDTdC47eNdfCXttJycKraXxfsw9cMVngGUqP3kiSE6cwXoApU6gjzSXVX1ASAPAi1MSXA935XUs1MWEcv9 The View key address is not to be shared unless you want to show the transactions received to the public address connected to this wallet. You do not need to write down the view key as it can be re-displayed with the command viewkey . View key: 97d3c27e20818e5e23a6548458b50d4f128a2709c55eb7f9518d0e957a5d2e0d The next few lines of text show how to navigate the loki-wallet-client . This user guide will look into more detail the commands that can be used within the loki-wallet-client further in the guide. Your wallet has been generated! To start synchronizing with the daemon, use the \"refresh\" command. Use the \"help\" command to see the list of available commands. Use \"help <command>\" to see a command's documentation. Always use the \"exit\" command when closing loki-wallet-cli to save your current session's state. Otherwise, you might need to synchronize your wallet again (your wallet keys are NOT at risk in any case). The next section with the random 25 words is your mnemonic seed. The seed is used to easily back-up and restore your wallet without needing any other information. At this stage, grab a pen and paper and write down your 25 words in order(having these words out of order will not restore your wallet) and store the piece of paper in a safe and secure place. If your words are stored in a text file on your computer or stored online, you increase your risk of someone else getting control of your account. NOTE: the following 25 words can be used to recover access to your wallet. Write them down and store them somewhere safe and secure. Please do not store them in your email or on file storage services outside of your immediate control. ponies innocent oyster whale autumn knapsack jostle elapse inroads joining doorway ticket drying obnoxious algebra tutor biplane sack alpine zinger huge duets refer rigid inroads The last of the outputs are the account balance, because your wallet does not have any Loki in it currently the balance is showing 0. Once we receive a transaction of Loki into our wallet the balance will appear as soon as the transaction is confirmed in one block (usually less than 2 minutes). Once the transaction has been confirmed over 10 blocks the balance will show in unlocked balance. The unlocked balance is the Loki available to be spent/sent to other addresses. Starting refresh... Refresh done, blocks received: 0 Untagged accounts: Account Balance Unlocked balance Label * 0 LAXk6e 0.000000000 0.000000000 Primary account ---------------------------------------------------------------------------------- Total 0.000000000 0.000000000 Currently selected account: [0] Primary account Tag: (No tag assigned) Balance: 0.000000000, unlocked balance: 0.000000000 Background refresh thread started\u201d","title":"Step 2: Setting up your loki-wallet-cli account."},{"location":"Wallets/GuiWallet/TroubleshootGui/","text":"TO DO","title":"TroubleshootGui"},{"location":"Wallets/GuiWallet/loki-electron-guide/","text":"Setup Guide on the Loki GUI Wallet \u00b6 This document will tell you exactly how to set up and operate the Loki GUI wallet. The latest version of the wallet can be downloaded here . Windows \u00b6 Mac and Linux users skip to step 1 . Install Electron wallet and allow Defender permissions. \u00b6 Open the executable file we downloaded from the Loki Github Loki.Electron.Wallet.Setup.X.X.X-windows.exe to start installion. When installing the wallet the Windows Defender SmartScreen will prevent you from opening it unless you give the file permission. Click Run anyway to give the executable permission. Now run through the installion prompts and then click install. Once the installation has finalised open the Loki Wallet by clicking your \"Windows\" key or the start menu and searching for loki electron wallet . 1: Running the Wallet for the first time. \u00b6 Once the installation has finalised open the Loki Wallet by clicking your \"Windows\" key or the start menu and searching for loki electron wallet . Once opened the wallet will need to be configured. 1.1: Choose your language. \u00b6 1.2: Configure your settings. \u00b6 Default settings are fine to use. This is not required but if you would like to run your own node and broadcast your own transactions check the Local + Remote Daemon or the Local Daemon Only option. Click Next when ready. 2: Creating/importing Wallet. \u00b6 Once your settings have been configured if you do not already have a wallet generated yet then your screen will look like the following: 2.1: Creating new Wallet. \u00b6 To create a new wallet click the Create new wallet button. Next fill in the input fields that are required. It is recommended that you should consider encrypting your key with an optional password. Once input boxes are filled in click CREATE WALLET button. 2.2: Importing Wallet from seed. \u00b6 To import a wallet from seed click the Restore wallet from seed button. Next fill in the following input fields: Wallet Name: Enter a name for your wallet. Mnemonic Seed: Enter the seed phrase that was generated when intially creating your wallet. Restore from Date: Enter the date or blockheight in which you want to restore your wallet from. It is quicker to restore from the date in which you generated the wallet. Password: Enter an optional password. Confirm Password: Enter the same password to confirm spelling. Once input boxes are filled in click RESTORE WALLET button.","title":"Electron Gui Setup"},{"location":"Wallets/GuiWallet/loki-electron-guide/#setup-guide-on-the-loki-gui-wallet","text":"This document will tell you exactly how to set up and operate the Loki GUI wallet. The latest version of the wallet can be downloaded here .","title":"Setup Guide on the Loki GUI Wallet"},{"location":"Wallets/GuiWallet/loki-electron-guide/#windows","text":"Mac and Linux users skip to step 1 .","title":"Windows"},{"location":"Wallets/GuiWallet/loki-electron-guide/#install-electron-wallet-and-allow-defender-permissions","text":"Open the executable file we downloaded from the Loki Github Loki.Electron.Wallet.Setup.X.X.X-windows.exe to start installion. When installing the wallet the Windows Defender SmartScreen will prevent you from opening it unless you give the file permission. Click Run anyway to give the executable permission. Now run through the installion prompts and then click install. Once the installation has finalised open the Loki Wallet by clicking your \"Windows\" key or the start menu and searching for loki electron wallet .","title":"Install Electron wallet and allow Defender permissions."},{"location":"Wallets/GuiWallet/loki-electron-guide/#1-running-the-wallet-for-the-first-time","text":"Once the installation has finalised open the Loki Wallet by clicking your \"Windows\" key or the start menu and searching for loki electron wallet . Once opened the wallet will need to be configured.","title":"1: Running the Wallet for the first time."},{"location":"Wallets/GuiWallet/loki-electron-guide/#11-choose-your-language","text":"","title":"1.1: Choose your language."},{"location":"Wallets/GuiWallet/loki-electron-guide/#12-configure-your-settings","text":"Default settings are fine to use. This is not required but if you would like to run your own node and broadcast your own transactions check the Local + Remote Daemon or the Local Daemon Only option. Click Next when ready.","title":"1.2: Configure your settings."},{"location":"Wallets/GuiWallet/loki-electron-guide/#2-creatingimporting-wallet","text":"Once your settings have been configured if you do not already have a wallet generated yet then your screen will look like the following:","title":"2: Creating/importing Wallet."},{"location":"Wallets/GuiWallet/loki-electron-guide/#21-creating-new-wallet","text":"To create a new wallet click the Create new wallet button. Next fill in the input fields that are required. It is recommended that you should consider encrypting your key with an optional password. Once input boxes are filled in click CREATE WALLET button.","title":"2.1: Creating new Wallet."},{"location":"Wallets/GuiWallet/loki-electron-guide/#22-importing-wallet-from-seed","text":"To import a wallet from seed click the Restore wallet from seed button. Next fill in the following input fields: Wallet Name: Enter a name for your wallet. Mnemonic Seed: Enter the seed phrase that was generated when intially creating your wallet. Restore from Date: Enter the date or blockheight in which you want to restore your wallet from. It is quicker to restore from the date in which you generated the wallet. Password: Enter an optional password. Confirm Password: Enter the same password to confirm spelling. Once input boxes are filled in click RESTORE WALLET button.","title":"2.2: Importing Wallet from seed."},{"location":"Wallets/GuiWallet/loki-gui-guide/","text":"Setup Guide on the Loki GUI Wallet \u00b6 This document will tell you exactly how to set up and operate the Loki GUI wallet. The latest version of the wallet can be downloaded here . Windows \u00b6 Mac and Linux users skip to step 1 . Install Electron wallet and allow Defender permissions. \u00b6 Open the executable file we downloaded from the Loki Github Loki.Electron.Wallet.Setup.X.X.X-windows.exe to start installion. When installing the wallet the Windows Defender SmartScreen will prevent you from opening it unless you give the file permission. Click Run anyway to give the executable permission. Now run through the installion prompts and then click install. Once the installation has finalised open the Loki Wallet by clicking your \"Windows\" key or the start menu and searching for loki electron wallet . 1: Running the Wallet for the first time. \u00b6 Once the installation has finalised open the Loki Wallet by clicking your \"Windows\" key or the start menu and searching for loki electron wallet . Once opened the wallet will need to be configured. 1.1: Choose your language. \u00b6 1.2: Configure your settings. \u00b6 Default settings are fine to use. This is not required but if you would like to run your own node and broadcast your own transactions check the Local + Remote Daemon or the Local Daemon Only option. Click Next when ready. 2: Creating/importing Wallet. \u00b6 Once your settings have been configured if you do not already have a wallet generated yet your screen will look like the following: 2.1: Creating new Wallet. \u00b6 To create a new wallet click the Create new wallet button. Next fill in the input fields that are required. It is recommended but not required, however you should consider encrypting your key with an optional password. Once input boxes are filled in click CREATE WALLET button. 2.2: Importing Wallet from seed. \u00b6 To import a wallet from seed click the Restore wallet from seed button. Next fill in the following input fields: Wallet Name: Enter a name for your wallet. Mnemonic Seed: Enter the seed phrase that was generated when intially creating your wallet. Restore from Date: Enter the date or blockheight in which you want to restore your wallet from. It is quicker to restore from the date in which you generated the wallet. Password: Enter an optional password. Confirm Password: Enter the same password to confirm spelling. Once input boxes are filled in click RESTORE WALLET button.","title":"Loki Documentation | Setup a Loki Wallet on Desktop."},{"location":"Wallets/GuiWallet/loki-gui-guide/#setup-guide-on-the-loki-gui-wallet","text":"This document will tell you exactly how to set up and operate the Loki GUI wallet. The latest version of the wallet can be downloaded here .","title":"Setup Guide on the Loki GUI Wallet"},{"location":"Wallets/GuiWallet/loki-gui-guide/#windows","text":"Mac and Linux users skip to step 1 .","title":"Windows"},{"location":"Wallets/GuiWallet/loki-gui-guide/#install-electron-wallet-and-allow-defender-permissions","text":"Open the executable file we downloaded from the Loki Github Loki.Electron.Wallet.Setup.X.X.X-windows.exe to start installion. When installing the wallet the Windows Defender SmartScreen will prevent you from opening it unless you give the file permission. Click Run anyway to give the executable permission. Now run through the installion prompts and then click install. Once the installation has finalised open the Loki Wallet by clicking your \"Windows\" key or the start menu and searching for loki electron wallet .","title":"Install Electron wallet and allow Defender permissions."},{"location":"Wallets/GuiWallet/loki-gui-guide/#1-running-the-wallet-for-the-first-time","text":"Once the installation has finalised open the Loki Wallet by clicking your \"Windows\" key or the start menu and searching for loki electron wallet . Once opened the wallet will need to be configured.","title":"1: Running the Wallet for the first time."},{"location":"Wallets/GuiWallet/loki-gui-guide/#11-choose-your-language","text":"","title":"1.1: Choose your language."},{"location":"Wallets/GuiWallet/loki-gui-guide/#12-configure-your-settings","text":"Default settings are fine to use. This is not required but if you would like to run your own node and broadcast your own transactions check the Local + Remote Daemon or the Local Daemon Only option. Click Next when ready.","title":"1.2: Configure your settings."},{"location":"Wallets/GuiWallet/loki-gui-guide/#2-creatingimporting-wallet","text":"Once your settings have been configured if you do not already have a wallet generated yet your screen will look like the following:","title":"2: Creating/importing Wallet."},{"location":"Wallets/GuiWallet/loki-gui-guide/#21-creating-new-wallet","text":"To create a new wallet click the Create new wallet button. Next fill in the input fields that are required. It is recommended but not required, however you should consider encrypting your key with an optional password. Once input boxes are filled in click CREATE WALLET button.","title":"2.1: Creating new Wallet."},{"location":"Wallets/GuiWallet/loki-gui-guide/#22-importing-wallet-from-seed","text":"To import a wallet from seed click the Restore wallet from seed button. Next fill in the following input fields: Wallet Name: Enter a name for your wallet. Mnemonic Seed: Enter the seed phrase that was generated when intially creating your wallet. Restore from Date: Enter the date or blockheight in which you want to restore your wallet from. It is quicker to restore from the date in which you generated the wallet. Password: Enter an optional password. Confirm Password: Enter the same password to confirm spelling. Once input boxes are filled in click RESTORE WALLET button.","title":"2.2: Importing Wallet from seed."},{"location":"Wallets/GuiWallet/loki-gui-guideold/","text":"Setup Guide on the Loki GUI Wallet \u00b6 This document will tell you exactly how to set up and operate the Loki GUI wallet. The latest version of the wallet can be downloaded here . Windows users: ( Mac and Linux users skip to step 6 ) 1) Make sure Windows Defender (or other anti-virus software) is not flagging it. Add 'loki-gui-win...' folder (or saved name of download) to exclusions in Windows Defender. 2) After exclusion is added, check if lokid.exe is still in the folder. If it's not, unzip the archive file once again and put the files in the previously created folder. 3) Make sure that the path to your Loki folder doesn't contain non-latin characters. 4) Right click loki-wallet-gui.exe and select 'run as administrator'. 5) If it crashes after the steps above are performed, run the file named start-low-graphics-mode.bat in the Loki folder. 6) Select your language. 7) Select 'create a new wallet'. 8) This step is important! Please be careful to write down and save your seed exactly as you see it on the screen and store it in a safe location. 9) Enter a strong password. 10) If you have problems with syncing or connecting to the daemon, try to connect to a remote node (recommended): Go to settings > go to node > select a remote node and click 'load preset' > scroll down and click 'connect'.","title":"Loki gui guideold"},{"location":"Wallets/GuiWallet/loki-gui-guideold/#setup-guide-on-the-loki-gui-wallet","text":"This document will tell you exactly how to set up and operate the Loki GUI wallet. The latest version of the wallet can be downloaded here . Windows users: ( Mac and Linux users skip to step 6 ) 1) Make sure Windows Defender (or other anti-virus software) is not flagging it. Add 'loki-gui-win...' folder (or saved name of download) to exclusions in Windows Defender. 2) After exclusion is added, check if lokid.exe is still in the folder. If it's not, unzip the archive file once again and put the files in the previously created folder. 3) Make sure that the path to your Loki folder doesn't contain non-latin characters. 4) Right click loki-wallet-gui.exe and select 'run as administrator'. 5) If it crashes after the steps above are performed, run the file named start-low-graphics-mode.bat in the Loki folder. 6) Select your language. 7) Select 'create a new wallet'. 8) This step is important! Please be careful to write down and save your seed exactly as you see it on the screen and store it in a safe location. 9) Enter a strong password. 10) If you have problems with syncing or connecting to the daemon, try to connect to a remote node (recommended): Go to settings > go to node > select a remote node and click 'load preset' > scroll down and click 'connect'.","title":"Setup Guide on the Loki GUI Wallet"},{"location":"Wallets/MobileWallet/RestoreMobileWalletGuide/","text":"Restoring Your Loki Mobile Wallet (Android) \u00b6 Go to the Google Play Store and make sure you are signed in to your Google account. Search for the app [Loki Wallet](https://play.google.com/store/apps/details?id=network.loki.wallet) and install it. Open the app. Select one of the preset remote nodes. You can keep it to its default, `doopool.xyz:22020`. Click the green plus button on the lower right corner to restore your wallet. Restore your wallet using your private keys or using the 25 word seed. When restoring using private keys, you will be asked to enter the Wallet Name, Wallet Paraphrase, Public Address, View Key, Spend Key and Restore Height or Date. Set the Restore Height (a block number) or Date to a time **before** your wallet was created. Please do not enter the current block number or date. Once you have entered all the information and made sure everything is correct, click `Make me a Wallet Already`.","title":"Mobile Wallet Restore"},{"location":"Wallets/MobileWallet/RestoreMobileWalletGuide/#restoring-your-loki-mobile-wallet-android","text":"Go to the Google Play Store and make sure you are signed in to your Google account. Search for the app [Loki Wallet](https://play.google.com/store/apps/details?id=network.loki.wallet) and install it. Open the app. Select one of the preset remote nodes. You can keep it to its default, `doopool.xyz:22020`. Click the green plus button on the lower right corner to restore your wallet. Restore your wallet using your private keys or using the 25 word seed. When restoring using private keys, you will be asked to enter the Wallet Name, Wallet Paraphrase, Public Address, View Key, Spend Key and Restore Height or Date. Set the Restore Height (a block number) or Date to a time **before** your wallet was created. Please do not enter the current block number or date. Once you have entered all the information and made sure everything is correct, click `Make me a Wallet Already`.","title":"Restoring Your Loki Mobile Wallet (Android)"},{"location":"Wallets/MobileWallet/TroubleshootMobileWallet/","text":"TO DO","title":"TroubleshootMobileWallet"},{"location":"Wallets/WebWallet/TroubleshootWebWallet/","text":"TO DO","title":"TroubleshootWebWallet"},{"location":"Wallets/WebWallet/placeholder/","text":"placeholder file","title":"Placeholder"}]}